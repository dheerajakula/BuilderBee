{"version":3,"file":"renderer.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA,0BAA0B;AAC1B;AACA;AACA,GAAG;AACH;;AAE+B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACV/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEghB;;;;;;;;;;;;;;;;;;;;;;ACvBhhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEuE;;;;;;;;;;;;;;;ACvCvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;ACjCyB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,kBAAkB,2GAA2G;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;;ACrJ0B;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,2DAAY;AACd;AACA,EAAE;AACF,eAAe,2DAAY;AAC3B,KAAK,2DAAY;AACjB,MAAM,2DAAY;AAClB,OAAO,2DAAY;AACnB,OAAO,2DAAY;AACnB,WAAW,2DAAY;AACvB;;AAEkB;;;;;;;;;;;;;;;ACtBlB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEgB;;;;;;;;;;;;;;;;ACVhB;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;;AAEiC;;;;;;;;;;;;;;;AClBjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,IAAI;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;AChDvB;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;;;ACjBW;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0CAAI;AACrB;AACA;AACA;AACA;;AAEoC;;;;;;;;;;;;;;;;ACjCH;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0CAAI;AACf,IAAI;AACJ,WAAW,0CAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kIAAkI;AAChJ;AACA;AACA;AACA,aAAa,EAAE;AACf,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiB;;;;;;;;;;;;;;;;;;;;ACvGjB;AACA;AACA;AACA;AACA;AACA;;AAEmG;;;;;;;;;;;;;;;;;ACPsB;AACxF;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAU;AACzB;AACA,IAAI;AACJ;AACA,gBAAgB,uDAAY;AAC5B,aAAa,0CAAI;AACjB,KAAK,kBAAkB,2DAAgB;AACvC,aAAa,0CAAI;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wDAAa,yBAAyB,yDAAc,yBAAyB,uDAAY;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,2BAA2B,uDAAY;AACvC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,wCAAwC,wDAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;;;;ACpHwB;AACf;AACmB;;AAEtD;AACA;AACA;AACA,eAAe,2DAAgB;AAC/B;AACA,mBAAmB,sBAAsB;AACzC,yBAAyB,4CAAK;AAC9B;AACA,IAAI;AACJ;AACA,yBAAyB,4CAAK;AAC9B,KAAK;AACL;AACA;AACA,qBAAqB,SAAS;AAC9B,2BAA2B,4CAAK;AAChC;AACA,MAAM;AACN,qBAAqB,gBAAgB;AACrC,2BAA2B,4CAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC,kBAAkB,+DAAc;AAChC,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;;AAEoB;;;;;;;;;;;;;;;;;ACnF8B;AACI;;AAEtD;AACA;AACA;AACA,cAAc,2DAAgB;AAC9B;AACA,mBAAmB,+DAAc;AACjC;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,SAAS;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;;AAEiB;;;;;;;;;;;;;;;;ACnFgB;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,0CAAI;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;;ACxDS;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0CAAI;AAClB;AACA;AACA,cAAc,0CAAI;AAClB;AACA;AACA,cAAc,0CAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAAI;AACpC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgB;;;;;;;;;;;;;;;;;;;ACtMiB;AACA;AACA;AACA;;AAEjC;AACA,sBAAsB,0CAAI;AAC1B,cAAc,0CAAI;AAClB,cAAc,0CAAI;AAClB,cAAc,0CAAI;AAClB,kBAAkB,0CAAI;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0CAAI;AACnC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAAI;AACpC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,8BAA8B,0CAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0CAAI;AACf;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0CAAI;AAC5B;AACA;AACA,cAAc,0CAAI;AAClB;AACA;AACA,cAAc,0CAAI;AAClB;AACA;AACA,cAAc,0CAAI;AAClB;AACA;AACA,sBAAsB,0CAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0CAAI;AACZ,QAAQ,0CAAI;AACZ,QAAQ,0CAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0CAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,uCAAuC,0CAAI;AAC3C;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;;AAEgB;;;;;;;;;;;;;;;ACvqBhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;;AAEgB;;;;;;;;;;;;;;;;;AC/FiB;AACA;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,eAAe,0CAAI;AACnB;AACA,6BAA6B,0CAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,uCAAuC,0CAAI;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0CAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0CAAI;AACxB;AACA;AACA;AACA;AACA;AACA,0BAA0B,0CAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0CAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO,IAAI,OAAO,IAAI,OAAO,IAAI,OAAO;AACrD;AACA;AACA;AACA;AACA;;AAEgB;;;;;;;;;;;;;;;;ACjUiB;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,YAAY,0CAAI;AAChB;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkB;;;;;;;;;;;;;;;;ACpCe;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,0CAAI;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,0CAAI;AAC1C;AACA;AACA,wFAAwF,0CAAI;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO,IAAI,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgB;;;;;;;;;;;;;;;ACnMhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO,IAAI,OAAO,IAAI,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgB;;;;;;;;;;;;;;;ACjOhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO,IAAI,OAAO,IAAI,OAAO,IAAI,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgB;;;;;;;;;;;;;;;AC3NhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,UAAU;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;AC1BtB;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,cAAc,IAAI;AAClB;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,sBAAsB;AACvC,yCAAyC,SAAS;AAClD;AACA,MAAM;AACN,iBAAiB,sBAAsB;AACvC,yCAAyC,SAAS;AAClD;AACA,MAAM;AACN;AACA,iBAAiB,sBAAsB;AACvC,oBAAoB,SAAS;AAC7B;AACA;AACA,KAAK;AACL,gBAAgB,sBAAsB;AACtC,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;;AAEgB;;;;;;;;;;;;;;;ACjGhB;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoB;;;;;;;;;;;;;;;AC1CpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,4CAA4C,MAAM;AAClD;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,IAAI,gBAAgB,MAAM;AACvE,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,GAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,4CAA4C,WAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;AC3NxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;ACvEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;AC9B3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;;ACfW;;AAEvC,oBAAoB,+CAAI;AACxB,oBAAoB,+CAAI;AACxB,oBAAoB,+CAAI;AACxB,oBAAoB,+CAAI;AACxB,oBAAoB,+CAAI;AACxB;AACA,0BAA0B,+CAAI,sBAAsB,+CAAI;AACxD;AACA;AACA,kBAAkB,+CAAI;AACtB,kBAAkB,+CAAI;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;AC5QgB;;AAEvC,oBAAoB,+CAAI;AACxB,oBAAoB,+CAAI;AACxB;AACA,0BAA0B,+CAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;AC3C1B;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmB;;;;;;;;;;;;;;;;AC3GoB;;AAEvC;AACA,sBAAsB,+CAAI;AAC1B,oBAAoB,+CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiB;;;;;;;;;;;;;;;;AC/CsB;;AAEvC;AACA;AACA,oBAAoB,+CAAI;AACxB,mBAAmB,+CAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe;;;;;;;;;;;;;;;AC1Bf;AACA;;AAEwB;;;;;;;;;;;;;;;ACHxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;AC7D3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;ACfrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC,mBAAmB,EAAE,GAAG;AACxB;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkB;;;;;;;;;;;;;;;AC1IlB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sCAAsC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kCAAkC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;;ACrH6B;;AAElD,mBAAmB,2DAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgB;;;;;;;;;;;;;;;AC5IhB;;AAEe;;;;;;;;;;;;;;;ACFf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmB;;;;;;;;;;;;;;;;ACTnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe;AACzB;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wBAAwB,GAAG,gCAAgC;AACvE;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;AC3F1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,IAAI;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,mDAAmD,YAAY,QAAQ,IAAI;AAC3E;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;;ACrHtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEgF;;;;;;;;;;;;;;;ACbhF;AACA;AACA;AACA;AACA,gEAAgE,UAAU,cAAc,UAAU;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,kBAAkB,EAAE;AACpB;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8DAA8D,GAAG,UAAU,GAAG,oEAAoE;AAC9J;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;;;;AC5CwB;AACW;AAChB;;AAEzC;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,8CAAM;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA,yFAAyF,WAAW;AACpG;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA,mBAAmB,4BAA4B;AAC/C,0BAA0B,mBAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uDAAU;AAC/B,aAAa,iEAAU;AACvB;AACA;AACA,sBAAsB,uDAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6B;;;;;;;;;;;;;;;;;AC/M7B;AACA;AACA;;AAEyE;;;;;;;;;;;;;;;;;ACJvB;AACG;;AAErD,8BAA8B,8DAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,SAAS,oDAAI;AACnB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;;;;AC1CuB;AACA;AACG;;AAErD,uCAAuC,8DAAa;AACpD;AACA,sBAAsB,EAAE,EAAE,EAAE;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA,mBAAmB,oDAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oDAAI;AACtC,oCAAoC,oDAAI;;AAEJ;;;;;;;;;;;;;;;;;;AC/Cc;AACA;AACG;;AAErD,yCAAyC,8DAAa;AACtD;AACA,sBAAsB,EAAE,EAAE,EAAE;AAC5B;AACA,oCAAoC,oDAAI,0IAA0I,oDAAI;AACtL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA,4FAA4F,oDAAI;AAChG,mBAAmB,oDAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oDAAI;AACxC,sCAAsC,oDAAI;;AAEJ;;;;;;;;;;;;;;;;ACnDe;;AAErD,kCAAkC,8DAAa;AAC/C;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;;AChCW;;AAE1C,4BAA4B,mDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA,KAAK;AACL,4BAA4B,mDAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kCAAkC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;;;;;;;;AC7D+D;AACnC;AACA;AACT;AACF;AACY;AACqU;;AAE3X;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,iEAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC,sCAAsC,qDAAS;AAC/C;AACA;AACA;AACA,cAAc,+DAAc,CAAC,gFAAQ,GAAG;AACxC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uCAAuC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uCAAuC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2DAAgB,6BAA6B,yDAAc,6BAA6B,yDAAc;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG,2DAAY;AACf;AACA;AACA;AACA;AACA;AACA,+DAA+D,gBAAgB,IAAI,qBAAqB;AACxG;AACA;AACA;AACA,IAAI;AACJ,GAAG,2DAAY;AACf,8CAA8C,gBAAgB,IAAI,qBAAqB;AACvF;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA,SAAS,4DAAiB;AAC1B;AACA;AACA,SAAS,yDAAc;AACvB;AACA;AACA,SAAS,qEAA0B;AACnC;AACA;AACA,SAAS,kEAAuB;AAChC;AACA;AACA,SAAS,wDAAa;AACtB;AACA;AACA,SAAS,4DAAiB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,oEAAoE,yDAAc;AAClF,KAAK;AACL;AACA,UAAU,iEAAsB;AAChC;AACA,sEAAsE,yDAAc;AACpF;AACA,UAAU,iEAAsB;AAChC;AACA,sEAAsE,yDAAc;AACpF;AACA,UAAU,sEAA2B;AACrC;AACA;AACA,sEAAsE,yDAAc;AACpF;AACA,UAAU,sEAA2B;AACrC;AACA;AACA,sEAAsE,yDAAc;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,yBAAyB,yDAAc;AACvC,2DAA2D,2DAAgB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kCAAkC;AACpD;AACA;AACA,0BAA0B,iEAAsB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,mBAAmB,2CAA2C;AAC9D;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA,oBAAoB,6BAA6B;AACjD;AACA,4CAA4C,eAAe,YAAY,EAAE;AACzE;AACA;AACA,qBAAqB,eAAe,YAAY,EAAE;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mCAAmC;AACrD;AACA;AACA;AACA,eAAe,6DAAQ;AACvB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+DAAc;AAClC;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,8DAAmB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2CAA2C;AAC/D;AACA;AACA,qBAAqB,6BAA6B;AAClD;AACA,6CAA6C,eAAe,YAAY,EAAE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,mDAAmD,mDAAQ;AAC3D;AACA,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;;AC9dwB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAI;AACzB;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB,GAAG,WAAW;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoB;;;;;;;;;;;;;;;;;;;;;;ACjEmC;AACG;AACmB;AACI;AACf;AACxB;AACiG;;AAE3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,yBAAyB,mDAAQ;AACjC;AACA;AACA;AACA;AACA,QAAQ,wDAAa;AACrB,eAAe,mEAAe;AAC9B,QAAQ,kEAAuB;AAC/B,eAAe,sFAAwB;AACvC,QAAQ,oEAAyB;AACjC,eAAe,0FAA0B;AACzC,QAAQ,4DAAiB;AACzB,eAAe,2EAAmB;AAClC;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gJAAgJ,+DAAS;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,mDAAQ;AAClE;AACA;AACA;AACA,SAAS,8DAAmB;AAC5B;AACA;AACA;AACA,4BAA4B,UAAU,GAAG,kCAAkC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4BAA4B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4BAA4B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;;ACzHmC;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iEAAsB;AAC7C,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtD1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4iB;;;;;;;;;;;;;;;AC1B5iB;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA,IAAI;AACJ,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;;;AC5E6B;AAC8C;;AAEhG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6DAAkB;AAC1C,mBAAmB,UAAU;AAC7B;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,SAAS,+DAAoB;AAC7B,qBAAqB,UAAU;AAC/B,kBAAkB,oDAAI;AACtB;AACA;AACA,SAAS,8DAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;;;AC7GmE;AACtC;;AAElD;AACA;AACA;AACA;AACA,uBAAuB,2DAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2DAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gFAAQ;AACvD;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoB;;;;;;;;;;;;;;;AC1NpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;ACrBrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoB;;;;;;;;;;;;;;;;;ACbqC;AACb;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAe;AAC9B,SAAS;AACT,eAAe,kEAAe;AAC9B;AACA,+DAA+D,kEAAe;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE,qDAAS;AACX;AACA,GAAG;AACH,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA,KAAK,qDAAS;AACd;AACA;AACA,KAAK;AACL,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA,MAAM,qDAAS;AACf,OAAO;AACP,MAAM,qDAAS;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;ACrMzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;;ACVsB;;AAE5C;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD,wBAAwB,qDAAS;AACjC;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;;;;;ACzB0B;AACqC;AAC3C;AACM;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,SAAS,oDAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,0EAAoB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,qDAAS;AACZ;AACA,IAAI,qDAAS;AACb;AACA;AACA;AACA,sCAAsC,yEAAmB;AACzD;AACA;AACA;AACA;AACA;AACA,aAAa,oDAAI;AACjB;AACA;AACA;AACA;AACA;AACA,IAAI,qDAAS;AACb,KAAK;AACL;AACA;AACA;AACA,IAAI,qDAAS;AACb;AACA,IAAI;AACJ,GAAG,qDAAS;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAI;AAC7B,yBAAyB,oDAAI;AAC7B,yBAAyB,oDAAI;AAC7B;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;AClG3B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;;ACjCwB;;AAE9C;AACA;AACA,uEAAuE,uDAAU;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;ACtDrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6BAA6B;AACjD;AACA;AACA,oBAAoB,kCAAkC;AACtD;AACA;AACA;AACA;AACA,sBAAsB,0BAA0B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3DqB;AACT;AACC;AACiB;AACV;AACF;AACA;AACA;AACA;AACiF;AAC9E;AACqH;AACrF;AACP;AACA;AACnB;AACO;AAClB;AACmC;AACnC;AACgB;AACiB;AACC;AACnC;AACiB;AACG;AACM;AACd;AACC;AAChB;AACuB;AACxB;AACe;AACf;AACS;AACiE;AACjD;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAY;AAClC;AACA;AACA;AACA;AACA,EAAE,2DAAc;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,8CAAM;AAC/C;AACA,mBAAmB,+DAAoB;AACvC,yBAAyB,2DAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uDAAgB;AACnC;AACA,oBAAoB,+DAAc;AAClC;AACA,mBAAmB,kDAAK;AACxB;AACA,kBAAkB,8CAAM;AACxB;AACA,oBAAoB,mEAAa;AACjC;AACA,qBAAqB,sEAAc;AACnC;AACA;AACA,qBAAqB,uEAAc;AACnC,kBAAkB,gDAAI;AACtB,oBAAoB,8DAAa;AACjC,+BAA+B,mDAAK;AACpC;AACA,OAAO,+DAAa;AACpB,GAAG;AACH,+BAA+B,mDAAK;AACpC;AACA,OAAO,+DAAa;AACpB;AACA,mBAAmB,+DAAa;AAChC,GAAG;AACH,gCAAgC,mDAAK;AACrC;AACA,OAAO,gEAAc;AACrB,mBAAmB,+DAAa;AAChC,GAAG;AACH,4BAA4B,mDAAK;AACjC;AACA,OAAO,4DAAU;AACjB,wBAAwB,iEAAe;AACvC,GAAG;AACH,mCAAmC,mDAAK;AACxC;AACA,OAAO,mEAAiB;AACxB,mBAAmB,+DAAa;AAChC,GAAG;AACH,sCAAsC,sFAAgB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,qEAAa;AACf,sBAAsB,iFAAe;AACrC;AACA,wBAAwB,8DAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+DAAa;AACrD;AACA;AACA;AACA;AACA,GAAG;AACH,qBAAqB,6EAAuB;AAC5C;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2DAAc;AACxD;AACA;AACA,uBAAuB,oFAAgB;AACvC;AACA,0BAA0B,gEAAc;AACxC,EAAE,yFAAkB;AACpB;AACA;AACA,sBAAsB,iFAAc,0BAA0B,oFAAgB;AAC9E,EAAE,4FAAiB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,wDAAI;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,OAAO,8CAAM;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA,iBAAiB,gDAAI;AACrB;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sFAAgB;AAC3C;AACA;AACA;AACA;AACA,+BAA+B,+DAAa;AAC5C,sBAAsB,mDAAK;AAC3B;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA,WAAW,gDAAI;AACf;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,8CAAM;AACb,mBAAmB,8BAA8B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA,qBAAqB,mDAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4BAA4B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mDAAG;AACjB;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,8CAAM;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iFAAmB,uBAAuB,gFAAkB,2BAA2B,8EAAgB;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC,WAAW,iFAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+DAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI,4BAA4B,+DAAoB;AACpD;AACA;AACA;AACA,8CAA8C,MAAM;AACpD,+CAA+C,OAAO;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0DAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,6BAA6B,uBAAuB;AACpD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,qEAAa;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qBAAqB;AACjD,8BAA8B,qBAAqB;AACnD;AACA;AACA;AACA;AACA,2BAA2B,qBAAqB;AAChD,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uDAAK;AAC7C;AACA;AACA,gDAAgD,uDAAK;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qDAAI;AACzB,oBAAoB,qDAAI,aAAa,qDAAI,eAAe,qDAAI;AAC5D;AACA,kBAAkB,mEAAQ;AAC1B,mBAAmB,2EAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mEAAQ;AAC/B,kBAAkB,2EAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,8CAAM;AACR;AACA,MAAM,2DAAc;AACpB,GAAG,2DAAc;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,2DAAc;AAChB;AACA,kEAAkE,mDAAG;AACrE;AACA;AACA,OAAO,qDAAI;AACX;AACA;AACA;AACA;AACA,IAAI;AACJ,gCAAgC,wDAAQ,YAAY,wDAAQ;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAG;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;ACl9BxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpByB;AAC2C;AAC9B;AACD;AACO;AAC1B;AACM;AACT;AACuC;AACV;AACmB;AACJ;AACX;AACM;AACJ;AACJ;AACa;AACA;AACb;AACmB;AACjB;AACO;AACP;AACa;AACJ;AACH;AACR;AACE;AACJ;AACI;AACF;AACE;AACA;AACjB;AACM;AACD;AACa;AACpB;AACE;AACM;AACZ;AACQ;AACF;AACJ;AACI;AACM;AACV;AACA;AACQ;AACN;AACA;AACE;AACA;AACA;AACI;AACR;AACiB;AACX;AACR;;AAE/C,0BAA0B,iDAAO;AACjC,iCAAiC;AACjC;AACA;AACA,yBAAyB,uDAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oEAAY;AAC5C,2BAA2B,oEAAW;AACtC,4BAA4B,0EAAY;AACxC,kBAAkB,wDAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,uDAAQ;AACd;AACA;AACA;AACA,aAAa,kGAAmB;AAChC;AACA;AACA,iCAAiC,sFAAwB,EAAE,qFAAwB,EAAE,8EAAoB,EAAE,sFAAwB,EAAE,4EAAmB,EAAE,8EAAoB,EAAE,gFAAqB,EAAE,gFAAqB,EAAE,8EAAoB,EAAE,+CAAM,UAAU,6FAA2B,GAAG,gFAAqB,EAAE,2FAA0B,EAAE,8EAAoB,EAAE,+FAA4B,EAAE,iGAA6B,EAAE,gFAAqB,EAAE,kFAAsB,EAAE,gFAAqB,EAAE,yFAAyB,EAAE,sFAAwB,EAAE,gFAAqB,EAAE,2FAA0B,EAAE,2FAA0B,EAAE,4EAAmB,EAAE,gFAAqB;AAC5pB;AACA;AACA,iCAAiC,+DAAa,EAAE,qEAAgB,EAAE,oEAAe,EAAE,iFAAqB,EAAE,6DAAY,EAAE,mEAAe,EAAE,iEAAc,EAAE,2DAAW,EAAE,2DAAW,EAAE,6DAAY,EAAE,+DAAa,EAAE,6DAAY,EAAE,iEAAc,EAAE,2DAAW,EAAE,yDAAU,EAAE,+DAAa,EAAE,qEAAgB,EAAE,+DAAa,EAAE,2DAAW,EAAE,+DAAa,EAAE,4EAAmB,EAAE,+DAAa,EAAE,mEAAe,EAAE,qEAAgB,EAAE,+DAAa;AACva;AACA;;AAEuB;;;;;;;;;;;;;;;ACpGvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;;;ACdsC;AACxB;;AAEnC,6BAA6B,gEAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4CAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4CAAK;AACnC;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;ACtK1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,QAAQ;AAChF,uEAAuE,QAAQ;AAC/E,8EAA8E,QAAQ;AACtF,8EAA8E,QAAQ;AACtF;AACA;AACA,6EAA6E,SAAS;AACtF,4EAA4E,SAAS;AACrF,mFAAmF,SAAS;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;;;;;;;AC5FgB;AACiB;AACN;AACqD;AACpE;AACH;;AAEnC,4BAA4B,gEAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0DAAS;AAC5B;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,6BAA6B,SAAS;AACtC;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA,KAAK;AACL,SAAS,8CAAM;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4CAAK;AACpB;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,cAAc,+CAAI;AAClB;AACA,eAAe,+CAAI;AACnB,oBAAoB,+CAAI;AACxB,sBAAsB,+CAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,kBAAkB,4BAA4B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+GAAiC;AACrD,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;;;;;;;;;ACnViB;AACA;AACiB;AACJ;AACT;AACF;AACG;AACG;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAY;AAChC;AACA;AACA;AACA;AACA;AACA,kBAAkB,+CAAI;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iJAAiJ,2DAAc;AAC/J;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,uDAAY;AAC5D;AACA;AACA;AACA;AACA,aAAa,UAAU,IAAI,UAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAI;AACnB,SAAS,+CAAI;AACb;AACA;AACA,WAAW,mEAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ,GAAG,uDAAI;AACP;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnPjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8O;;;;;;;;;;;;;;;ACjB9O;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS;AAC1C,2BAA2B,SAAS;AACpC,4BAA4B,SAAS;AACrC;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,GAAG;AACpC,2BAA2B,GAAG;AAC9B,4BAA4B,GAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC,qCAAqC,EAAE;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,UAAU;AAC3C,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,iCAAiC,UAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,oBAAoB,UAAU,uBAAuB,IAAI;AACzD,KAAK;AACL;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,KAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,uBAAuB,WAAW,uBAAuB,IAAI;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;;AClNiC;;AAE3D,qBAAqB,gEAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkB;;;;;;;;;;;;;;;;;;;;;;;ACtC+C;AACY;AACf;AACV;AACF;AACA;AACA;AACA;;AAElD,eAAe,oDAAI;AACnB,eAAe,oDAAI;AACnB,eAAe,oDAAI;AACnB,cAAc,sDAAK;AACnB,cAAc,oDAAI;AAClB,kCAAkC,kFAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mEAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mEAAU;AAC3B;AACA;AACA;AACA;AACA;AACA,iBAAiB,mEAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mEAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kCAAkC,EAAE,iBAAiB;AACpF;AACA,gCAAgC,kCAAkC,EAAE,iBAAiB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,oDAAI,EAAE,oDAAI,EAAE,oDAAI,EAAE,sDAAK,EAAE,oDAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA,SAAS,oDAAI;AACb;AACA;AACA;AACA;AACA,SAAS,oDAAI;AACb;AACA;AACA;AACA;AACA,SAAS,oDAAI;AACb;AACA;AACA;AACA;AACA,SAAS,sDAAK;AACd;AACA;AACA;AACA;AACA,SAAS,oDAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sEAAU;AACxB;AACA;AACA,IAAI;AACJ;AACA,aAAa,sEAAU;AACvB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;;;;;ACxOmB;AACa;AACW;AACA;;AAE1E;AACA,kEAAkE,+EAAoB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oDAAI;AACtB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oEAAS;AACtC;AACA;AACA;AACA;AACA,0CAA0C,+EAAc;AACxD;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,UAAU,GAAG,UAAU;AACnE;AACA;AACA,iDAAiD,+EAAc;AAC/D;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAE8B;;;;;;;;;;;;;;;;;;;;;;;;;;AC3K0D;AAC3C;AAC0B;AACG;AAC9B;AAC2H;AAC3G;AACF;AACkB;AACnC;AACsB;;AAE/D,4BAA4B,oDAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kDAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,0BAA0B,8CAAM;AACpC;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iFAAc;AACvC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,yBAAyB,qEAAmB;AAC5C,4BAA4B,4EAAa;AACzC,yBAAyB,+EAAc;AACvC,wBAAwB,mEAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD;AACA,kBAAkB,gFAAQ,GAAG;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA,QAAQ,8EAAmB;AAC3B,yBAAyB,UAAU,GAAG,UAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA,mBAAmB,yBAAyB;AAC5C;AACA,QAAQ,8EAAmB;AAC3B,oDAAoD,WAAW,GAAG,UAAU;AAC5E;AACA,oEAAoE,qEAAS;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,QAAQ;AACR,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iFAAc;AACzC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iFAAc;AACzC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+EAAoB;AAC1D;AACA;AACA,+BAA+B,+EAAoB;AACnD;AACA;AACA,sCAAsC,iFAAsB;AAC5D;AACA;AACA;AACA,gCAAgC,iFAAsB;AACtD;AACA;AACA;AACA,sCAAsC,iFAAsB;AAC5D;AACA;AACA,+BAA+B,iFAAsB;AACrD;AACA;AACA,sCAAsC,iFAAsB;AAC5D;AACA;AACA,+BAA+B,iFAAsB;AACrD;AACA;AACA;AACA;AACA;AACA,+BAA+B,iFAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;ACvdzB;AACA;AACA;AACA;AACA;;AAE6B;;;;;;;;;;;;;;;;;;;;ACNkC;AACnB;AACG;AACA;AACD;;AAE9C;AACA,kCAAkC,uDAAe;AACjD;AACA;AACA;AACA,uBAAuB,wDAAa;AACpC,kBAAkB,uDAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,oEAAS;AACzD,uFAAuF,WAAW,GAAG,UAAU;AAC/G;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAS,iBAAiB,wDAAa;;AAER;;;;;;;;;;;;;;;;;;;;;;ACvH8B;AACU;AACR;AACc;AACb;AACnB;AACD;;AAE5C,iCAAiC,oDAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kDAAK;AAChC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qCAAqC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,qBAAqB,kEAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oEAAS;AACtC;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kEAAQ;AAC/B,qBAAqB,kEAAQ;AAC7B,uBAAuB,kEAAQ;AAC/B;AACA;AACA,IAAI;AACJ,4BAA4B,4EAAa,KAAK,kFAAiB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA,KAAK;AACL,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qCAAqC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA,2BAA2B,kDAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8B;;;;;;;;;;;;;;;ACzb9B;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;;;;;ACNU;AACG;AACK;AACD;;AAEnD;AACA,uCAAuC,uDAAe;AACtD;AACA;AACA;AACA,uBAAuB,6DAAkB;AACzC,kBAAkB,4DAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAS,iBAAiB,6DAAkB;;AAER;;;;;;;;;;;;;;;;ACvEQ;;AAE5C,qCAAqC,oDAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;ACvBlC;AACA;AACA;AACA;AACA;;AAEsC;;;;;;;;;;;;;;;;;;;ACNM;AACG;AACS;AACD;;AAEvD;AACA,2CAA2C,uDAAe;AAC1D;AACA;AACA;AACA,uBAAuB,iEAAsB;AAC7C,kBAAkB,gEAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAS,iBAAiB,iEAAsB;;AAER;;;;;;;;;;;;;;;;;;ACpCK;AACoB;AACrB;;AAE5C,mCAAmC,oDAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA,gCAAgC,kDAAK;AACrC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mEAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mEAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mEAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mEAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA,2BAA2B,kDAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,qCAAqC,WAAW;AAChD;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;;AAEgC;;;;;;;;;;;;;;;;ACpQwC;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEoC;;;;;;;;;;;;;;;;;;;;;ACtB6B;AACxB;AACG;AACG;AACO;AACD;;AAErD;AACA,yCAAyC,uDAAe;AACxD;AACA;AACA;AACA,uBAAuB,+DAAoB;AAC3C,kBAAkB,8DAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD,8BAA8B,8CAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,mEAAS;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAS,iBAAiB,+DAAoB;;AAER;;;;;;;;;;;;;;;;;;;;;;ACrEM;AACM;AACE;AACK;AACb;AACuD;AACvC;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAS;AAC/B;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oEAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,sEAA2B;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,+EAAoC;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAA2B;AACnC;AACA;AACA;AACA,QAAQ,+EAAoC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,oEAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,oEAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kDAAG;AACjB,aAAa,sDAAK;AAClB;AACA,kBAAkB,sDAAK;AACvB;AACA;AACA;AACA,sBAAsB,kDAAG;AACzB;AACA,sBAAsB,oDAAI;AAC1B;AACA;AACA;AACA,kCAAkC,sDAAK;AACvC,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAK;AACjB;;AAE2B;;;;;;;;;;;;;;;;ACnlB3B;AACA;;AAE6E;;;;;;;;;;;;;;;;;;ACHzB;AACF;AACW;;AAE7D;AACA;AACA;AACA;AACA;AACA,wBAAwB,oDAAI;AAC5B,wBAAwB,sEAA2B;AACnD,uBAAuB,sDAAK;AAC5B,yBAAyB,sDAAK;AAC9B,0BAA0B,sDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;;;;ACxBgB;AACE;AACD;;AAEhD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD,oCAAoC,uDAAe;AACnD;AACA;AACA;AACA,uBAAuB,0DAAe;AACtC,kBAAkB,yDAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiC;;;;;;;;;;;;;;;;;;;;AClDoD;AACnC;AACS;AACf;AACa;;AAEzD,8BAA8B,oDAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2DAAU;AAC5C,qBAAqB,oDAAM;AAC3B;AACA;AACA;AACA;AACA,0BAA0B,kEAAe;AACzC;AACA;AACA,qBAAqB,6DAAU;AAC/B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,8DAAa;AAC7E;AACA,gEAAgE,8DAAa;AAC7E;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,4DAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;ACxb3B;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;;;;;ACN8H;AAClF;AACX;AACJ;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kEAAO;AACjC;AACA;AACA;AACA;AACA;AACA,cAAc,2EAAc;AAC5B,cAAc,2EAAc;AAC5B,aAAa,kFAAqB;AAClC,aAAa,kFAAqB;AAClC,GAAG;AACH;AACA;AACA;AACA;AACA,uDAAuD,gFAAmB,EAAE,gFAAmB,YAAY,8EAAiB;AAC5H,kBAAkB,wBAAwB,cAAc,oBAAoB;AAC5E;AACA,aAAa,6EAAY;AACzB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,8DAAa;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,8DAAa;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;;;;;;;;ACpO0B;AACD;AACF;AACN;AACG;AACE;AACD;;AAEhD;AACA,oCAAoC,uDAAe;AACnD;AACA;AACA;AACA;AACA,uBAAuB,0DAAe;AACtC,kBAAkB,yDAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oDAAI;AACrC,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,iCAAiC,sDAAK;AACtC,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA,EAAE,2DAAY;AACd;AACA;AACA;AACA;AACA;AACA,GAAG,2DAAY;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAS,iBAAiB,0DAAe;;AAER;;;;;;;;;;;;;;;;;;;AChHiB;AACA;AACL;AACD;;AAE5C,kBAAkB,oDAAI;AACtB,kBAAkB,oDAAI;AACtB,iCAAiC,oDAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,oDAAI,0CAA0C,oDAAI;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kDAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kDAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8B;;;;;;;;;;;;;;;;;ACzWoB;AACA;;AAElD;AACA;AACA;AACA;AACA,yBAAyB,oDAAI;AAC7B,0BAA0B,oDAAI;AAC9B,2BAA2B,oDAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;;;;;;;;;;;ACxBgB;AACA;AACA;AAC0B;AACnB;AACT;AACD;AACK;AACD;AACZ;;AAEvC,iBAAiB,oDAAI;AACrB,eAAe,oDAAI;AACnB,eAAe,oDAAI;AACnB,iBAAiB,oDAAI;AACrB,0BAA0B,2DAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kDAAK;AACxB,yBAAyB,2DAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,0BAA0B,gDAAO;AACjC,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA,yBAAyB,8EAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,EAAE,GAAG,EAAE,GAAG,EAAE;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,sBAAsB,GAAG;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,0BAA0B,gDAAO;AACjC,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uDAAe;AACtD;AACA;AACA;AACA,uBAAuB,6DAAkB;AACzC,kBAAkB,4DAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oDAAI;AAC9B;AACA;AACA,2BAA2B,oDAAI;AAC/B;AACA;AACA;AACA;AACA,6BAA6B,oDAAI;AACjC,KAAK;AACL,6BAA6B,oDAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoC;;;;;;;;;;;;;;;;AClrBgI;;AAEpK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,gFAA0B;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uEAAiB,EAAE,yEAAmB,GAAG,uEAAiB;AAC5F;AACA,4BAA4B,0EAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kFAA4B;AACxD;AACA;;AAEmB;;;;;;;;;;;;;;;;ACtGwC;;AAE3D,wBAAwB,gEAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,KAAK;AACzB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9D6B;AACA;AACA;AACA;AACwE;AACjE;AACW;AACiB;AAC5C;AACG;AAC6D;AACvD;AACF;;AAEhD,qBAAqB,oDAAI;AACzB,yBAAyB,oDAAI;AAC7B,iBAAiB,oDAAI;AACrB,iBAAiB,oDAAI;AACrB,iBAAiB,oDAAI;AACrB,iBAAiB,oDAAI;AACrB,iBAAiB,oDAAI;AACrB,iBAAiB,oDAAI;AACrB,+BAA+B,oDAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAI;AACzB,0BAA0B,oDAAI;AAC9B,oBAAoB,oDAAI;AACxB;AACA;AACA,qBAAqB,oDAAI;AACzB,6BAA6B,oDAAI;AACjC,4BAA4B,oDAAI;AAChC,8BAA8B,oDAAI;AAClC;AACA,mCAAmC,oDAAI;AACvC,8BAA8B,oDAAI;AAClC,6BAA6B,oDAAI,QAAQ,oDAAI,QAAQ,oDAAI,QAAQ,oDAAI;AACrE,6BAA6B,oDAAI,QAAQ,oDAAI,QAAQ,oDAAI,QAAQ,oDAAI;AACrE,4BAA4B,oDAAI,QAAQ,oDAAI,QAAQ,oDAAI,QAAQ,oDAAI;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4DAAiB;AAChC;AACA;AACA;AACA;AACA,kBAAkB,0DAAe;AACjC;AACA,kBAAkB,2DAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAI;AAC3B;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,sEAAU;AACvG;AACA;AACA;AACA,+FAA+F,sEAAU;AACzG;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA,oBAAoB,8BAA8B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,uBAAuB,oDAAI;AAC3B;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4DAAiB;AAClC,sBAAsB,2DAAY;AAClC,KAAK,mBAAmB,2DAAgB;AACxC,qBAAqB,yDAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,eAAe,oDAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+CAAM;AAC5B,4BAA4B,+CAAM;AAClC,iCAAiC,+CAAM;AACvC;AACA;AACA;AACA,GAAG,+CAAM;AACT;AACA;AACA,mBAAmB,oDAAI;AACvB;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAI;AACvB;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,+CAAM;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oDAAI;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mCAAmC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,wFAAiB;AACnF;AACA,UAAU,wEAAU;AACpB,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wFAAiB;AACpC;AACA,WAAW,wEAAU;AACrB,YAAY,iFAAmB;AAC/B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,mBAAmB,wFAAiB;AACpC;AACA,WAAW,yEAAW;AACtB,YAAY,+EAAiB;AAC7B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,sEAAU;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,sEAAU;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;;;;;;AC/1C5B;AACA;AACA;AACA;AACA;AACA;;AAEmH;;;;;;;;;;;;;;;ACPnH;AACA;AACA;AACA;AACA;;AAEgC;;;;;;;;;;;;;;;;;;;;;;;ACNqB;AACS;AACZ;AACA;AACA;AACA;AACD;AACI;;AAErD,iCAAiC,oDAAI;AACrC,gCAAgC,oDAAI;AACpC,iBAAiB,mDAAG;AACpB,mBAAmB,uDAAK;AACxB,oBAAoB,oDAAI;AACxB,mBAAmB,oDAAI;AACvB,4BAA4B,oDAAI;AAChC;AACA;AACA;AACA;AACA,gCAAgC,gEAAY;AAC5C;AACA;AACA,uCAAuC,2DAAgB;AACvD;AACA;AACA;AACA,yCAAyC,KAAK;AAC9C;AACA;AACA;AACA;AACA;AACA,wBAAwB,oDAAI;AAC5B,qCAAqC,oDAAI;AACzC,sCAAsC,oDAAI;AAC1C,iCAAiC,oDAAI;AACrC,kCAAkC,oDAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,uDAAQ;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAI;AAC3B,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrLqB;AACE;AACF;AACA;AACA;AACkI;AACzG;AACA;AACF;AACyE;AACzF;AACX;AACiB;AACf;AACqC;AACJ;AACpC;;AAE7C,qCAAqC,2EAAW;AAChD;AACA;AACA;AACA;AACA,mBAAmB,kDAAK;AACxB,kBAAkB,2DAAS;AAC3B;AACA;AACA,0BAA0B,iEAAY;AACtC,4CAA4C,YAAY;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iEAAY;AAC7C,6CAA6C,kBAAkB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAI;AACvB;AACA;AACA,yBAAyB,oDAAI;AAC7B;AACA,0BAA0B,oDAAI;AAC9B;AACA,wBAAwB,oDAAI;AAC5B;AACA;AACA;AACA,oBAAoB,sDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,yEAAwB,+BAA+B,wEAAuB;AAClI;AACA;AACA;AACA,kEAAkE,yEAAwB;AAC1F,iEAAiE,wEAAuB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,0DAAS,GAAG,4DAAW;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6EAAY;AAC1B,cAAc,8EAAiB;AAC/B;AACA,UAAU,yEAAY;AACtB,IAAI;AACJ,cAAc,4EAAe;AAC7B;AACA,UAAU,yEAAY;AACtB,IAAI;AACJ,cAAc,+EAAkB;AAChC;AACA,UAAU,yEAAY;AACtB,IAAI;AACJ,GAAG;AACH,2BAA2B,8EAAY;AACvC;AACA,GAAG;AACH,mBAAmB,iDAAI;AACvB;AACA,2BAA2B,+EAAkB;AAC7C;AACA;AACA;AACA,sBAAsB,qDAAI,WAAW,qDAAI;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAe;AACzC;AACA,2BAA2B,2DAAe,iEAAiE,yDAAa;AACxH;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yEAAwB,+BAA+B,wEAAuB;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qDAAI;AACjB,aAAa,qDAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qDAAI;AACvB,mBAAmB,qDAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,yEAAwB,gCAAgC,wEAAuB;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6BAA6B;AACpE;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC,yBAAyB,aAAa;AACtC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAI;AAC3B;AACA;AACA;AACA;AACA,iCAAiC,yEAAwB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAK;AAClC;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wFAAiB;AACnC;AACA,UAAU,uEAAU;AACpB,WAAW,gFAAmB;AAC9B,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAI;AAC3B;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mDAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oBAAoB;AAC1C,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2DAAe;AACjD;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,iCAAiC,2DAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mDAAK;AAC5B;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mDAAK;AAC5B;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,uBAAuB,qDAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAI;AAC3B,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,yEAAwB,gCAAgC,wEAAuB;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;AC58BxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAuD,GAAG,oBAAoB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iCAAiC,GAAG,qCAAqC;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,YAAY;AACjD,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,qBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,oDAAoD,gBAAgB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkB;;;;;;;;;;;;;;;;;;;;;;;;;;ACvZkC;AACF;AACA;AAC0B;AACZ;AACqD;AACpC;AAClC;AACsB;AACnB;AACD;;AAEjD;AACA,qCAAqC,uDAAe;AACpD;AACA;AACA;AACA,uBAAuB,2DAAgB;AACvC,kBAAkB,0DAAoB;AACtC;AACA;AACA;AACA,6BAA6B,kEAAO;AACpC;AACA;AACA,WAAW,8EAAiB;AAC5B;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAI;AAClC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,6BAA6B,oDAAI;AACjC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAI;AAClC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA,2BAA2B,sDAAK;AAChC,iBAAiB,sDAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,4BAA4B,2DAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,2BAA2B,sDAAK;AAChC,iBAAiB,sDAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mFAAgB;AACjC;AACA;AACA;AACA;AACA,IAAI;AACJ,mBAAmB,KAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,KAAK;AAC7B;AACA;AACA,4BAA4B,KAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qEAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mFAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qEAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,0EAAwB;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,sEAAsE,yEAAuB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mEAAmE,0EAAwB;AAC3F;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,kEAAkE,yEAAuB;AACzF;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,4DAA4D,0EAAwB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,2DAA2D,yEAAuB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wDAAwD,0EAAwB;AAChF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,uDAAuD,yEAAuB;AAC9E;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9ee;AACC;AACE;AACF;AACgB;AAC4F;AAC/E;AACtB;AACM;AACf;AACF;AACkB;AACC;AAC5B;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gDAAI;AACtB;AACA;AACA;AACA;AACA;AACA,sBAAsB,2EAAc,mCAAmC,yEAAY;AACnF,sBAAsB,2EAAc,kCAAkC,yEAAY;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sDAAK;AAC1B,oBAAoB,oDAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qEAAc;AACtC;AACA;AACA;AACA;AACA;AACA,oBAAoB,sDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oDAAI;AAC5B;AACA;AACA;AACA;AACA,mBAAmB,2DAAS;AAC5B,oBAAoB,kDAAK;AACzB;AACA;AACA;AACA;AACA;AACA,mBAAmB,oEAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sDAAK;AAChC;AACA;AACA;AACA,0BAA0B,sDAAK;AAC/B;AACA;AACA,2BAA2B,oDAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mDAAM;AACxB;AACA;AACA;AACA;AACA,mBAAmB,8CAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM;AACN;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,aAAa,mCAAmC,GAAG,qBAAqB;AACxE;AACA;AACA,aAAa,mCAAmC,GAAG,oBAAoB,GAAG,oBAAoB;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,sBAAsB,EAAE;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kEAAY;AAC/B,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,0DAAS;AAC1D;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mDAAM;AACxC;AACA,2BAA2B,mDAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,8DAA8D,KAAK;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qCAAqC,kBAAkB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iBAAiB;AAClD;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kFAAc;AAChC,mBAAmB,iBAAiB;AACpC;AACA,gBAAgB,8EAAiB;AACjC,gBAAgB,+EAAkB;AAClC,gBAAgB,2EAAc;AAC9B,gBAAgB,2EAAc;AAC9B,gBAAgB,2EAAc;AAC9B,MAAM;AACN,gBAAgB,8EAAiB;AACjC,gBAAgB,+EAAkB;AAClC,gBAAgB,2EAAc;AAC9B,gBAAgB,2EAAc;AAC9B,gBAAgB,2EAAc;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0DAAS;AACpC;AACA;AACA;AACA,KAAK,6BAA6B,4DAAW;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,2BAA2B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAI;AAC3B;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sDAAK;AAClC,6BAA6B,sDAAK;AAClC,6BAA6B,sDAAK;AAClC,6BAA6B,sDAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sDAAK;AAClC,6BAA6B,sDAAK;AAClC,6BAA6B,sDAAK;AAClC,6BAA6B,sDAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oDAAI;AACjC,wBAAwB,oDAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;;;;AC9/CqC;AACf;AACmB;AACpB;;AAE5C,8BAA8B,oDAAS;AACvC;AACA;AACA,kBAAkB,8DAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qEAAc;AAC3C;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;ACvO3B;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;;;;;;;ACNmB;AACgB;AACtB;AACG;AACE;AACD;;AAEhD;AACA;AACA,oCAAoC,uDAAe;AACnD;AACA;AACA;AACA,uBAAuB,0DAAe;AACtC,kBAAkB,yDAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA,8BAA8B,oEAAW,KAAK,oDAAI,wBAAwB,oDAAI;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAS,iBAAiB,0DAAe;;AAER;;;;;;;;;;;;;;;;;;;;;ACrDiB;AACA;AACA;AACA;AACN;AACgC;;AAE5E;AACA,6BAA6B,oDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wDAAa;AACrC,4BAA4B,oDAAI;AAChC;AACA;AACA;AACA;AACA,wBAAwB,wDAAa;AACrC,4BAA4B,oDAAI;AAChC;AACA;AACA;AACA;AACA,wBAAwB,wDAAa;AACrC,4BAA4B,oDAAI;AAChC;AACA;AACA;AACA;AACA,yBAAyB,wDAAa;AACtC,6BAA6B,oDAAI;AACjC;AACA;AACA;AACA;AACA,yBAAyB,wDAAa;AACtC,6BAA6B,oDAAI;AACjC;AACA;AACA;AACA;AACA,yBAAyB,wDAAa;AACtC,6BAA6B,oDAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oDAAI;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yDAAc;AAC9C,kCAAkC,oDAAI;AACtC,kCAAkC,oDAAI;AACtC,KAAK,kCAAkC,sDAAW;AAClD;AACA;AACA,KAAK;AACL;AACA;AACA,gCAAgC,yDAAc;AAC9C,kCAAkC,oDAAI;AACtC,kCAAkC,oDAAI;AACtC,KAAK,kCAAkC,sDAAW;AAClD;AACA;AACA,KAAK;AACL;AACA;AACA,gCAAgC,yDAAc;AAC9C,kCAAkC,oDAAI;AACtC,kCAAkC,oDAAI;AACtC,KAAK,kCAAkC,sDAAW;AAClD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yDAAc;AAC7C;AACA;AACA,KAAK,iCAAiC,sDAAW;AACjD;AACA;AACA,KAAK;AACL;AACA;AACA,+BAA+B,yDAAc;AAC7C;AACA;AACA,KAAK,iCAAiC,sDAAW;AACjD;AACA;AACA,KAAK;AACL;AACA;AACA,+BAA+B,yDAAc;AAC7C;AACA;AACA,KAAK,iCAAiC,sDAAW;AACjD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA,6CAA6C,KAAK,QAAQ,QAAQ;AAClE,2CAA2C,KAAK,SAAS,QAAQ;AACjE,oDAAoD,KAAK,aAAa,QAAQ;AAC9E,6CAA6C,KAAK,WAAW,QAAQ;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAI;AAClC,cAAc,KAAK;AACnB,MAAM;AACN,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,KAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH,EAAE;AACF,CAAC;;AAEyB;;;;;;;;;;;;;;;;;ACjY1B;AACA;AACA;;AAEsD;;;;;;;;;;;;;;;ACJtD;AACA;AACA;AACA;AACA;;AAE8B;;;;;;;;;;;;;;;;;;;ACNc;AACG;AACC;AACD;;AAE/C;AACA,mCAAmC,uDAAe;AAClD;AACA;AACA;AACA;AACA,uBAAuB,yDAAc;AACrC,kBAAkB,wDAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,oDAAS,iBAAiB,yDAAc;;AAER;;;;;;;;;;;;;;;;ACrBY;;AAE5C,mCAAmC,oDAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;;;;;;;;;;;;;;;AC9EhC;AACA;AACA;AACA;AACA;;AAEoC;;;;;;;;;;;;;;;;;;;ACNQ;AACG;AACO;AACD;;AAErD;AACA,yCAAyC,uDAAe;AACxD;AACA;AACA;AACA,uBAAuB,+DAAoB;AAC3C,kBAAkB,8DAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,oDAAS,iBAAiB,+DAAoB;;AAER;;;;;;;;;;;;;;;;;;;;;ACzCY;AACA;AACmB;AACvB;AACF;AACc;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oDAAS;AAC5C;AACA;AACA,sBAAsB,uEAAsB;AAC5C;AACA;AACA,wBAAwB,oDAAI;AAC5B,sBAAsB,oDAAI;AAC1B,sBAAsB,oDAAI;AAC1B,uBAAuB,uDAAY;AACnC,wBAAwB,uDAAY;AACpC;AACA,+BAA+B,mEAAgB;AAC/C;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oDAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEgC;;;;;;;;;;;;;;;;;;ACxMhC;AACA;AACA;AACA;;AAEuE;;;;;;;;;;;;;;;ACLvE;AACA;AACA;AACA;AACA;;AAEoC;;;;;;;;;;;;;;;;;;;ACNc;AACA;AACyC;AACE;;AAE7F;AACA,cAAc,uEAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qEAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uEAAsB,IAAI,qEAAoB;AACnE,qBAAqB,qEAAoB,IAAI,uEAAsB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oDAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA,qBAAqB,oDAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,yDAAc;AAC5D,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,uEAAsB,gDAAgD,qEAAoB;AACzI,+CAA+C,uEAAsB,gDAAgD,qEAAoB;AACzI;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4BAA4B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA,8BAA8B,4BAA4B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAY;AACpB;AACA,QAAQ,0DAAe;AACvB;AACA;AACA;AACA;AACA,QAAQ,yDAAc;AACtB;AACA;AACA;AACA;AACA,QAAQ,uDAAY;AACpB;AACA;AACA;AACA;AACA;AACA,kDAAkD,YAAY;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4BAA4B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA;AACA;AACA,8BAA8B,4BAA4B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA,8BAA8B,4BAA4B;AAC1D;AACA;AACA;AACA,gCAAgC,uEAAsB;AACtD;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAI;AACnB;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA,IAAI;AACJ,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uEAAsB,qBAAqB,uEAAsB;AAC/E,cAAc,qEAAoB,qBAAqB,qEAAoB;AAC3E;AACA;AACA;AACA;AACA,sDAAsD,oBAAoB;AAC1E,IAAI;AACJ;AACA;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;;;;;;;ACpbsB;AACA;AACN;AACG;AACO;AACD;;AAErD;AACA;AACA,yCAAyC,uDAAe;AACxD;AACA;AACA;AACA,uBAAuB,+DAAoB;AAC3C,kBAAkB,8DAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,oDAAI;AACjE;AACA;AACA,yDAAyD,oDAAI;AAC7D;AACA;AACA,yDAAyD,oDAAI;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAS,iBAAiB,+DAAoB;;AAER;;;;;;;;;;;;;;;;;;;;;AC5FY;AACA;AACoD;AACzD;AACD;AACL;;AAEvC,6BAA6B,oDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oDAAI;AACvC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAI;AAChC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oDAAI;AACnC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAI;AAC7B,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oDAAI;AACxC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oDAAI;AACrC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oDAAI;AAC5B,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,kDAAK;AACxD;AACA;AACA;AACA;AACA,2BAA2B,kDAAK;AAChC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,sCAAsC,oBAAoB;AAC1D;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oDAAI;AACpC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,oDAAI;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oDAAI;AACtC,kCAAkC,oDAAI;AACtC;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,oDAAI;AAC1D;AACA;AACA,0CAA0C,oDAAI;AAC9C,0CAA0C,oDAAI;AAC9C;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oEAAmB;AAC1C,KAAK;AACL,wBAAwB,oEAAmB;AAC3C;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wEAAuB;AAC9C,uCAAuC,0DAAS;AAChD,KAAK;AACL,wBAAwB,wEAAuB;AAC/C,sCAAsC,0DAAS;AAC/C;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0DAAS;AAChC,oDAAoD,wEAAuB;AAC3E,KAAK;AACL,wBAAwB,0DAAS;AACjC,mDAAmD,wEAAuB;AAC1E;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,IAAI,gDAAU,SAAS;AACzC,gBAAgB,gDAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oBAAoB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;;;;ACnkB+H;AACrG;;AAEpD;AACA;AACA;AACA;AACA;AACA,mBAAmB,sDAAK;AACxB;AACA;AACA,eAAe,oEAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oEAAmB;AACxC,oBAAoB,4DAAW;AAC/B;AACA,qBAAqB,8DAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sEAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8DAAa;AAC9B;AACA;AACA;AACA;;AAE0C;;;;;;;;;;;;;;;;;;;;;;;ACpD8C;AACpC;AACF;AACgB;AACN;AACb;AACC;AACW;;AAE3D,mCAAmC,uDAAe;AAClD;AACA;AACA;AACA,uBAAuB,yDAAc;AACrC,kBAAkB,wDAAkB;AACpC;AACA;AACA;AACA,eAAe,gFAAQ,GAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sDAAK;AACzB;AACA;AACA,2BAA2B,oDAAI;AAC/B;AACA;AACA,0BAA0B,oDAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAmB;AACnC;AACA,oBAAoB,kDAAK;AACzB,eAAe,uDAAU;AACzB;AACA;AACA,iDAAiD,gDAAU;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,IAAI,gDAAU,SAAS;AACzC,UAAU,gDAAU;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uDAAU;AACpC;AACA;AACA;;AAEgC;;;;;;;;;;;;;;;;;;;;;;;AC3E4B;AACQ;AACX;AACM;AACf;AACsB;AACzB;AACD;;AAE5C,6BAA6B,oDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8DAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ,oBAAoB,+EAAiB;AACrC;AACA;AACA,oBAAoB,2DAAS;AAC7B,qBAAqB,kDAAK;AAC1B;AACA,8BAA8B,iEAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kDAAK;AAC5B;AACA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,sEAAU;AACvG;AACA;AACA;AACA,+FAA+F,sEAAU;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kDAAK;AAC5B;AACA;AACA;AACA;AACA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oBAAoB;AAC1C,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAM,GAAG,GAAG;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,sEAAU;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,sEAAU;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;AC5oB1B;AACA;AACA;AACA;AACA;;AAE8B;;;;;;;;;;;;;;;;;;;;;;;;ACNiB;AACG;AACgB;AACgB;AACrC;AACD;AACG;AACC;AACD;;AAE/C;AACA,mCAAmC,uDAAe;AAClD;AACA;AACA;AACA,uBAAuB,yDAAc;AACrC,kBAAkB,wDAAkB;AACpC;AACA,yBAAyB,wFAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA,8BAA8B,oEAAW,KAAK,oDAAI,wBAAwB,oDAAI;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qDAAM,GAAG;AACrB;AACA;AACA,iCAAiC,kDAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAS,iBAAiB,yDAAc;;AAER;;;;;;;;;;;;;;;;;;;;AC3F4B;AACd;AACuC;AACxC;AACD;;AAE5C;AACA;AACA;AACA;AACA;AACA,sCAAsC,oDAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,KAAK;AACvB,GAAG;AACH;AACA,kBAAkB,KAAK;AACvB,GAAG;AACH;AACA,kBAAkB,KAAK;AACvB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kDAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,uBAAuB,SAAS;AAChC;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kDAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,uBAAuB,SAAS;AAChC;AACA,KAAK;AACL;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kDAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,uCAAuC,kDAAK;AAC5C;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,gCAAgC,gDAAI;AACpC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kDAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,8DAAa;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA,2BAA2B,kDAAK;AAChC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gDAAI;AAC7B;AACA;AACA,sBAAsB,uFAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmC;;;;;;;;;;;;;;;;;ACr9Be;AACwF;;AAE1I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAI;AAChC,iCAAiC,oDAAI;AACrC;AACA;AACA,sBAAsB,iEAAgB;AACtC;AACA;AACA,wBAAwB,oDAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iEAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2EAA0B;AAC/C,4BAA4B,oDAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6DAAY;AAC/B;AACA;AACA;AACA,iBAAiB,8DAAa;AAC9B;AACA;;AAEuC;;;;;;;;;;;;;;;;;;;;;;AC1Ea;AACO;AACT;AACL;AACE;AACU;AACD;;AAExD;AACA,4CAA4C,uDAAe;AAC3D;AACA;AACA;AACA,uBAAuB,kEAAuB;AAC9C,kBAAkB,iEAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oDAAI;AAC1B;AACA,KAAK;AACL,gCAAgC,sDAAK;AACrC;AACA,sBAAsB,sDAAK;AAC3B;AACA;AACA,KAAK;AACL,gCAAgC,6DAAQ;AACxC;AACA,sBAAsB,6DAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA,6BAA6B,oDAAI,0BAA0B,sDAAK,0BAA0B,6DAAQ;AAClG;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kCAAkC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyC;;;;;;;;;;;;;;;;ACtJkB;;AAE3D,sCAAsC,gEAAY;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,GAAG;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,GAAG;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;;AAEmC;;;;;;;;;;;;;;;;;;;;;;;;;ACzD4C;AACX;AACL;AACE;AACK;AACb;AACiB;AAC7B;AACmB;AACpB;;AAE5C,8BAA8B,oDAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8DAAa;AAC/B,sBAAsB,kEAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qEAAc;AAC3C;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,iEAAY;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+EAAiB;AACtC;AACA,8BAA8B,iEAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,sEAAU;AACxG;AACA;AACA;AACA,gGAAgG,sEAAU;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qCAAqC;AACnE;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA,sCAAsC,qEAAc;AACpD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mCAAmC,kDAAK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,8BAA8B,kDAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2DAAS;AACjC;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qCAAqC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,kBAAkB,qCAAqC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,sEAAU;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,sEAAU;AAC3E;AACA;AACA;AACA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gCAAgC;AAClD;AACA,GAAG,4EAAiB;AACpB;AACA;AACA;AACA;AACA,8DAA8D,2DAAS;AACvE,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA,iCAAiC,4EAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA,yBAAyB,iEAAY;AACrC;AACA;AACA,kCAAkC,mEAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;AC/iB3B;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;;;;;;;;ACNmB;AACgB;AACgB;AACtC;AACG;AACE;AACD;;AAEhD;AACA;AACA,oCAAoC,uDAAe;AACnD;AACA;AACA;AACA,uBAAuB,0DAAe;AACtC,kBAAkB,yDAAmB;AACrC;AACA,yBAAyB,wFAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA,8BAA8B,oEAAW,KAAK,oDAAI,wBAAwB,oDAAI;AAC9E;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAS,iBAAiB,0DAAe;;AAER;;;;;;;;;;;;;;;;;;;AC9DiB;AACA;AACiP;AACvP;;AAE5C;AACA;AACA,mBAAmB,oDAAI;AACvB,mBAAmB,oDAAI;AACvB,kBAAkB,oDAAI;AACtB,iCAAiC,oDAAS;AAC1C;AACA;AACA;AACA,4BAA4B,oDAAI;AAChC,8BAA8B,oDAAI;AAClC;AACA;AACA,gBAAgB,2DAAgB;AAChC;AACA,2BAA2B,oDAAI;AAC/B,6BAA6B,oDAAI;AACjC,eAAe,8DAAmB;AAClC;AACA;AACA;AACA;AACA,eAAe,0DAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2DAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2DAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2DAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2DAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2DAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2DAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,2DAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,2DAAgB;AACzB,mBAAmB,4DAAiB;AACpC,kBAAkB,uDAAY;AAC9B;AACA,SAAS,6DAAkB;AAC3B,mBAAmB,8DAAmB;AACtC,kBAAkB,uDAAY;AAC9B;AACA,SAAS,0DAAe;AACxB;AACA,mBAAmB,2DAAgB;AACnC,kBAAkB,8DAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2DAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,wBAAwB,6DAAkB;AAC/C,sDAAsD,oEAAyB;AAC/E,4BAA4B,yEAA8B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,2DAAgB;AAC1B;AACA,gCAAgC,+DAAoB;AACpD;AACA;AACA,UAAU,6DAAkB;AAC5B;AACA,gCAAgC,yEAA8B;AAC9D;AACA,UAAU,0DAAe;AACzB,gCAAgC,+DAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uEAA4B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAI;AACxB;AACA,KAAK;AACL;AACA;AACA,oBAAoB,oDAAI;AACxB;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAI;AACxB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAI;AACxB;AACA,KAAK;AACL;AACA;AACA,oBAAoB,oDAAI;AACxB;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAI;AACxB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0DAAe;AACvC;AACA;AACA,wBAAwB,0DAAe,mBAAmB,6DAAkB;AAC5E;AACA;AACA,wBAAwB,6DAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6DAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAI;AACvB;AACA,IAAI;AACJ;AACA;AACA,mBAAmB,oDAAI;AACvB;AACA,IAAI,sBAAsB,oDAAI;AAC9B;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpf9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2rB;;;;;;;;;;;;;;;AClC3rB;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;;;;;;;;;;;;ACNwB;AACR;AACN;AACG;AACa;AACR;AACD;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,0BAA0B,oDAAI;AAC9B,0BAA0B,oDAAI;AAC9B,qBAAqB,oDAAI;AACzB,qBAAqB,oDAAI;AACzB,qBAAqB,oDAAI;AACzB;AACA;AACA;AACA;AACA,8BAA8B,oDAAI,0BAA0B,oDAAI,gBAAgB,oDAAI,qBAAqB,oDAAI,iBAAiB,oDAAI;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uDAAe;AACtD;AACA;AACA;AACA;AACA,qBAAqB,oDAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6DAAkB;AACzC,kBAAkB,4DAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,6DAAkB;AACrB,+BAA+B,4DAAU;AACzC,gCAAgC,4DAAU;AAC1C,sCAAsC,4DAAU;AAChD;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oDAAI;AACnC,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,oDAAI,uCAAuC,oDAAI;AAC/F;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,oDAAI,uCAAuC,oDAAI;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,qEAA0B,aAAa,qEAA0B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qEAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA,qCAAqC,qEAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,sBAAsB,iBAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,6DAAkB;AACrB;AACA;AACA;AACA;AACA,oDAAS,iBAAiB,6DAAkB;;AAEyD;;;;;;;;;;;;;;;;;;;;AC5hBnD;AACA;AACT;AACwB;AACrB;;AAE5C,uBAAuB,oDAAI;AAC3B,8BAA8B,oDAAS;AACvC;AACA;AACA,yBAAyB,oDAAI;AAC7B,kCAAkC,oDAAI;AACtC,oBAAoB,yDAAc;AAClC;AACA;AACA;AACA;AACA;AACA,2BAA2B,oDAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yDAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAc,cAAc,0DAAe;AAC3D,WAAW,yDAAc;AACzB;AACA,sCAAsC,yDAAc;AACpD,WAAW,yDAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;;ACvL3B;AACA;;AAE2C;;;;;;;;;;;;;;;ACH3C;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;;;;;;;ACN6B;AACV;AACN;AACG;AACE;AACD;;AAEhD;AACA,oCAAoC,uDAAe;AACnD;AACA;AACA;AACA,uBAAuB,0DAAe;AACtC,kBAAkB,yDAAmB;AACrC;AACA,8BAA8B,oDAAI;AAClC,iCAAiC,8DAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,oDAAI;AACtC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,2CAA2C,oDAAI;AAC/C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,oDAAS,iBAAiB,0DAAe;;AAER;;;;;;;;;;;;;;;;;AChGY;AACD;;AAE5C,oCAAoC,oDAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA,UAAU,+CAAI;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,WAAW,+CAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;;AAEiC;;;;;;;;;;;;;;;ACrJjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqC;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACdU;AACE;AACG;AACA;AACO;AACT;AACA;AACA;AACT;AACG;AACG;AACQ;AACD;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,uDAAe;AACzD;AACA;AACA;AACA,uBAAuB,gEAAqB;AAC5C,kBAAkB,+DAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8BAA8B;AACnD;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA,qBAAqB,qDAAM,GAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD,+BAA+B,8CAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD,+BAA+B,8CAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,KAAK,mBAAmB,IAAI,SAAS,wCAAwC,GAAG,EAAE,kBAAkB;AAC9I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,mDAAM;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD,8BAA8B,8CAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qDAAM,GAAG;AAC3B,KAAK;AACL;AACA;AACA,kBAAkB,qDAAM,GAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,sDAAK,mEAAmE,sDAAK;AACtI;AACA,IAAI;AACJ;AACA,0BAA0B,oDAAI;AAC9B;AACA,IAAI;AACJ;AACA,0BAA0B,oDAAI;AAC9B;AACA,IAAI;AACJ;AACA,0BAA0B,oDAAI;AAC9B;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ,gEAAgE,8DAAQ,GAAG,uDAAK;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAS,iBAAiB,gEAAqB;;AAER;;;;;;;;;;;;;;;;;;;;;;ACrZ8B;AAC0B;AACuC;AAC1F;AACH;AACgB;AACF;;AAEvD;AACA,8BAA8B,oDAAS;AACvC;AACA;AACA;AACA;AACA,yBAAyB,uEAAe;AACxC;AACA,GAAG;AACH,6BAA6B,uEAAe;AAC5C;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,UAAU,0EAAgB;AAC1B;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA,gCAAgC,wEAAsB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA,wBAAwB,8DAAU;AAClC;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,sFAAwB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA,gCAAgC,mEAAiB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8BAA8B;AACzD;AACA;AACA,+BAA+B,+DAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8BAA8B;AACzD;AACA;AACA,+BAA+B,oEAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B,4CAA4C,8CAAM;AAClD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,2BAA2B,8CAAM;AACjC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,8IAA8I,gEAAa;AAC3J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,oCAAoC,8DAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC,uCAAuC,WAAW;AAClD;AACA;AACA;AACA;AACA,0CAA0C,mEAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA,0CAA0C,wEAAsB;AAChE;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,sCAAsC,WAAW;AACjD;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6DAAW;AAChD;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;AC5hB3B;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;;;;;ACNsC;AACtB;AACE;AACD;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uDAAe;AACnD;AACA;AACA;AACA,uBAAuB,0DAAe;AACtC,kBAAkB,yDAAmB;AACrC,yBAAyB,uEAAe;AACxC;AACA,GAAG;AACH,gCAAgC,uEAAe;AAC/C;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mCAAmC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA,iCAAiC,0CAA0C;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiC;;;;;;;;;;;;;;;;;;;;;;;;AChIiB;AACA;AACA;AACyC;AAClC;AACa;AACkG;AAC5H;AAC4B;;AAExE,6BAA6B,oDAAI;AACjC,kCAAkC,oDAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uEAAsB;AAC/C,yBAAyB,qEAAoB;AAC7C,qBAAqB,oDAAI;AACzB,uBAAuB,oDAAI;AAC3B,gCAAgC,oDAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2DAAS;AAC9B;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2DAAS;AAC9B;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2DAAS;AAC9B;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,0BAA0B,uEAAsB;AAChD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2DAAS;AAC9B;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,0BAA0B,qEAAoB;AAC9C;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0EAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,8EAAiB;AACjD;AACA;AACA;AACA,yBAAyB,uEAAsB;AAC/C,yBAAyB,qEAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uEAAsB;AACxD;AACA;AACA;AACA;AACA,kCAAkC,qEAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uEAAsB;AACxD,8BAA8B,uEAAsB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qEAAoB;AACtD,8BAA8B,qEAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uEAAsB;AACxD;AACA;AACA,kCAAkC,qEAAoB;AACtD;AACA;AACA;AACA;AACA;AACA,4CAA4C,uEAAsB;AAClE,4CAA4C,qEAAoB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4DAAiB;AACzB,WAAW,oDAAI;AACf,QAAQ,6DAAkB;AAC1B;AACA;AACA,QAAQ,+DAAoB;AAC5B;AACA;AACA,0CAA0C,gBAAgB;AAC1D;AACA;AACA;AACA;AACA,4BAA4B,uEAAsB;AAClD,4BAA4B,qEAAoB;AAChD,8BAA8B,uEAAsB;AACpD,8BAA8B,qEAAoB;AAClD,kCAAkC,uEAAsB;AACxD,kCAAkC,qEAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,yBAAyB,oDAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2EAAgC;AACxC;AACA;AACA,QAAQ,kFAAuC;AAC/C;AACA;AACA;AACA,mDAAmD,oBAAoB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uEAAsB;AAC9D,wCAAwC,qEAAoB;AAC5D;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAsB;AAC5C;AACA,IAAI,yBAAyB,qEAAoB;AACjD;AACA;AACA;AACA;AACA;AACA,sBAAsB,uEAAsB;AAC5C;AACA,IAAI,yBAAyB,qEAAoB;AACjD;AACA;AACA;AACA;AACA;AACA,yBAAyB,uEAAsB;AAC/C;AACA;AACA,yBAAyB,uEAAsB;AAC/C;AACA;AACA,yBAAyB,uEAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,uEAAsB;AACzD,mCAAmC,qEAAoB;AACvD;AACA;AACA;AACA;AACA,2BAA2B,6DAAkB;AAC7C,gCAAgC,uEAAsB;AACtD,wDAAwD,uEAAsB;AAC9E;AACA,gCAAgC,qEAAoB;AACpD,wDAAwD,qEAAoB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uEAAsB;AAC1D,mDAAmD,uEAAsB;AACzE;AACA;AACA,IAAI;AACJ;AACA;AACA,gCAAgC,qEAAoB;AACpD,+CAA+C,qEAAoB;AACnE;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oDAAI,qEAAqE,uEAAsB;AACjH,kBAAkB,oDAAI,qEAAqE,qEAAoB;AAC/G,oBAAoB,oDAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;;;;;ACzxB/B;AACA;AACA;AACA;AACA;;AAEkJ;;;;;;;;;;;;;;;;ACNhG;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oDAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmC;;;;;;;;;;;;;;;;;;;ACvBY;AACM;AACD;AACF;;AAElD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,wCAAwC,uDAAe;AACvD;AACA;AACA;AACA,uBAAuB,8DAAmB;AAC1C,kBAAkB,6DAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oDAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqC;;;;;;;;;;;;;;;;;;;;ACrFa;AACmB;AACZ;AACb;AAC0B;;AAEtE,iCAAiC,oDAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2DAAS;AAC9B;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yCAAyC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,8EAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oDAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uEAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uEAAsB;AACpD;AACA;AACA,8BAA8B,uEAAsB;AACpD;AACA;AACA,8BAA8B,uEAAsB;AACpD;AACA;AACA,8BAA8B,uEAAsB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8B;;;;;;;;;;;;;;;;AC9NuC;;AAErE;AACA;AACA;AACA,qBAAqB,uEAAsB;AAC3C;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;;;;ACZa;AACK;AACD;;AAEnD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD,uCAAuC,uDAAe;AACtD;AACA;AACA;AACA,uBAAuB,6DAAkB;AACzC,kBAAkB,4DAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoC;;;;;;;;;;;;;;;;;;ACvCmC;AAC3B;AACN;;AAEtC,6BAA6B,oDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yEAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+CAAS;AAC3C;AACA,qCAAqC,+CAAS;AAC9C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+CAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;ACrQ1B;AACA;AACA;AACA;AACA;;AAE8B;;;;;;;;;;;;;;;;;;;;;ACNgC;AACZ;AACA;AACL;AACuB;AACI;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAY;AACpC,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,oDAAI;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kDAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,YAAY;AACvC,4BAA4B,YAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0EAAe;AACjC,IAAI;AACJ,kBAAkB,sEAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,IAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kDAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oDAAI;AACrB;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;;;;;;ACnYqD;AAC9B;AACG;AACC;AACD;;AAE/C;AACA,mCAAmC,uDAAe;AAClD;AACA;AACA;AACA,uBAAuB,yDAAc;AACrC,kBAAkB,wDAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,gFAAe;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAS,iBAAiB,yDAAc;;AAER;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzGkB;AACE;AACF;AACA;AAC6D;AAC3C;AACX;AACM;AACf;AACJ;AAC4B;AACP;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAS;AACvC;AACA;AACA;AACA;AACA;AACA,eAAe,4DAAiB;AAChC;AACA,oBAAoB,sDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8DAAa;AAC/B,yBAAyB,oDAAI;AAC7B;AACA,0BAA0B,oDAAI;AAC9B;AACA,wBAAwB,oDAAI;AAC5B;AACA;AACA;AACA,mBAAmB,2DAAS;AAC5B,oBAAoB,kDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0EAAmB;AAC7C;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI,wBAAwB,8DAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,wEAAuB,+BAA+B,yEAAwB;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,wEAAuB,+BAA+B,yEAAwB;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6FAA6F,sEAAU;AACvG;AACA;AACA;AACA,+FAA+F,sEAAU;AACzG,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,0EAAmB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,sEAAU;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,sEAAU;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yEAAwB;AACzD;AACA,IAAI,oCAAoC,wEAAuB;AAC/D;AACA,IAAI;AACJ;AACA;AACA;AACA,4BAA4B,kEAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,uDAAuD,yEAAwB,+BAA+B,wEAAuB;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yEAAwB,+BAA+B,wEAAuB;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qDAAI;AACjB,aAAa,qDAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8DAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0EAAmB;AACtC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;;AC1kB3B;AACA;;AAEkD;;;;;;;;;;;;;;;ACHlD;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;;;;;ACN+B;AACZ;AACL;AAC0B;;AAEvE,kCAAkC,gEAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kDAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,6BAA6B;AAC9E;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,uBAAuB,aAAa;AACpC,wBAAwB,aAAa;AACrC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kDAAK;AAClC;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yEAAwB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oDAAI;AACrB,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;;;;;;;;;;ACjTqB;AACuC;AAC3B;AACqD;AACpC;AACrC;AACG;AACE;AACD;;AAEhD;AACA,oCAAoC,uDAAe;AACnD;AACA;AACA;AACA,uBAAuB,0DAAe;AACtC,kBAAkB,yDAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kEAAO;AAC9B;AACA;AACA,YAAY,8EAAiB;AAC7B;AACA,IAAI;AACJ;AACA;AACA;AACA,wBAAwB,mFAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oEAAmB;AAC3C;AACA;AACA,mBAAmB,0EAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yEAAwB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,wEAAuB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sDAAK;AAClC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAS,iBAAiB,0DAAe;;AAER;;;;;;;;;;;;;;;;;;;;ACnM0B;AACV;AACF;AACA;AACA;;AAE/C,8BAA8B,gEAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAK;AAC7B;AACA;AACA,cAAc,sDAAK;AACnB;AACA,wBAAwB,sDAAK;AAC7B;AACA;AACA,cAAc,sDAAK;AACnB;AACA,wBAAwB,oDAAI;AAC5B;AACA;AACA,cAAc,oDAAI;AAClB;AACA,wBAAwB,oDAAI;AAC5B;AACA;AACA,cAAc,oDAAI;AAClB;AACA,wBAAwB,oDAAI;AAC5B;AACA;AACA,cAAc,oDAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,KAAK;AAC7D;AACA;;AAE2B;;;;;;;;;;;;;;;;;ACxHuB;AACN;;AAE5C,4BAA4B,oDAAS;AACrC;AACA;AACA;AACA,mBAAmB,oDAAI;AACvB;AACA;AACA;AACA,sBAAsB,oDAAI;AAC1B;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;AC/CzB;AACA;AACA;AACA;AACA;;AAE6B;;;;;;;;;;;;;;;;;;;;ACNqB;AACN;AACG;AACA;AACD;;AAE9C;AACA,kCAAkC,uDAAe;AACjD;AACA;AACA;AACA,uBAAuB,wDAAa;AACpC,kBAAkB,uDAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAI;AAChC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAS,iBAAiB,wDAAa;;AAER;;;;;;;;;;;;;;;;;;;ACtC/B;AACA;AACA;AACA;AACA;;AAEwG;;;;;;;;;;;;;;;;;;ACNjE;AACY;AACL;;AAE9C;AACA,qBAAqB,2DAAS;AAC9B,yBAAyB,2DAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,gBAAgB,+CAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;;AAEkB;;;;;;;;;;;;;;;;ACnPlB;AACA;;AAEkC;;;;;;;;;;;;;;;;ACHS;;AAE3C;AACA;AACA,kCAAkC,oDAAS,GAAG,oDAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgB;;;;;;;;;;;;;;;;ACvChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;;;;;;;;;;;;;;;;;;;;;;;;ACRK;AAC4B;AACN;AACQ;AACN;AAC5B;AACwB;AACM;AACF;;AAEvE;AACA;AACA;AACA,iBAAiB,4BAA4B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gDAAI,0BAA0B,wEAAW;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gDAAI,0BAA0B,gFAAe;AACxD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gDAAI,0BAA0B,0EAAY;AACrD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gDAAI,0BAA0B,kFAAgB;AACzD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gDAAI,0BAA0B,4EAAa;AACtD,sBAAsB,oDAAI;AAC1B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gDAAI,0BAA0B,8EAAc;AACvD;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gDAAI,0BAA0B,4EAAa;AACtD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,KAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAE6B;;;;;;;;;;;;;;;;;;;;ACxH2B;AACI;AACF;AACE;AACb;;AAE/C,8BAA8B,wDAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uDAAI;AAC9B;AACA,EAAE,uDAAI;AACN;AACA,uDAAuD,cAAc,GAAG,IAAI;AAC5E,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,cAAc,kEAAQ;AACtB,GAAG;AACH;AACA,cAAc,kEAAQ;AACtB,GAAG;AACH;AACA,cAAc,oEAAS;AACvB,GAAG;AACH,aAAa,oEAAS;AACtB;AACA;;AAE2B;;;;;;;;;;;;;;;;;;AChD6B;AACiB;AAC1B;;AAE/C,oCAAoC,wDAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uDAAI;AAC9B;AACA,EAAE,uDAAI;AACN;AACA,8DAA8D,cAAc,GAAG,IAAI;AACnF,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,aAAa,iFAAc;AAC3B;AACA;;AAEiC;;;;;;;;;;;;;;;;;;;;;;;ACnCS;AACK;AACA;AACS;AACkB;AACZ;AACT;AACN;;AAE/C,+BAA+B,wDAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,+CAAI;AACX,2BAA2B,uDAAI;AAC/B,KAAK;AACL,2BAA2B,uDAAI;AAC/B;AACA;AACA,EAAE,uDAAI;AACN;AACA,kDAAkD,cAAc,GAAG,IAAI;AACvE,KAAK;AACL,QAAQ,+CAAI;AACZ;AACA,KAAK,6DAAS,sJAAsJ;AACpK;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C,oCAAoC,sEAAU;AAC9C;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM;AACN,4CAA4C,2BAA2B;AACvE;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oEAAS;AAC5B;AACA;AACA,kBAAkB,2BAA2B;AAC7C,oBAAoB,+DAAI;AACxB;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAI;AACxB,oBAAoB,oDAAI;AACxB,oBAAoB,oDAAI;AACxB,oBAAoB,8DAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oEAAS;AAC5B;AACA;AACA,kBAAkB,2BAA2B;AAC7C,oBAAoB,+DAAI;AACxB;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA,oBAAoB,oDAAI;AACxB,oBAAoB,oDAAI;AACxB,oBAAoB,oDAAI;AACxB,oBAAoB,8DAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;;;;;;ACtHc;AACc;AACe;AACjB;AACP;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,2BAA2B,wDAAe;AAC1C;AACA;AACA;AACA;AACA;AACA,cAAc,+CAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAK;AAC3B;AACA;AACA,yCAAyC,aAAa;AACtD;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM,gFAAe;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uDAAI;AAC/B;AACA,GAAG,uDAAI;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;AChHxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,KAAK,QAAQ,OAAO,SAAS,QAAQ,SAAS,OAAO;AACxG;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,IAAI;AAC1D;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA,qDAAqD,IAAI;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,KAAK,QAAQ,OAAO,SAAS,QAAQ,SAAS,QAAQ,SAAS,OAAO;AACzH;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,IAAI;AAC1D;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA,6FAA6F,IAAI;AACjG,MAAM;AACN;AACA;AACA,sDAAsD,IAAI;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,0CAA0C,OAAO;AACjD,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;;;;;AC5VgC;AACsC;AAC7C;AACE;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,yDAAW,YAAY;AACzE;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,uDAAI;AACN;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA,GAAG;AACH,EAAE,uDAAI;AACN;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA,IAAI;AACJ,uBAAuB,+EAAkB,oBAAoB,8EAAiB;AAC9E;AACA;AACA,KAAK;AACL,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,uBAAuB,4DAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,IAAI;AAC5D,KAAK;AACL,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAE2C;;;;;;;;;;;;;;;;;ACtPa;AACT;;AAE/C,4BAA4B,wDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,uDAAI;AACN,iBAAiB,uDAAI;AACrB;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL,+CAA+C,cAAc,GAAG,IAAI;AACpE;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;;;;AC/BoB;AACV;AACY;;AAE/C,4BAA4B,wDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,sBAAsB,qDAAM;AAC5B;AACA,qBAAqB,4CAAK;AAC1B;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;;;;;ACxDiB;AAC8B;AACzB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wDAAe;AAC9C;AACA;AACA,gCAAgC,gFAAkB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+CAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+C;;;;;;;;;;;;;;;;;ACvDG;AACH;;AAE/C,yBAAyB,wDAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,uDAAI;AACN;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL,4CAA4C,cAAc,GAAG,IAAI;AACjE;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;;;;;ACjCqJ;AAC9G;AACnB;AACK;;AAE/C,6BAA6B,wDAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6EAAgB,GAAG,gFAAmB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB,6BAA6B,kEAAO;AACpC,gBAAgB,kBAAkB,gBAAgB,eAAe;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kFAAqB;AACtC,iBAAiB,kFAAqB;AACtC;AACA,OAAO;AACP;AACA,MAAM;AACN,gBAAgB,6EAAgB;AAChC,oBAAoB,kFAAqB;AACzC,oBAAoB,kFAAqB;AACzC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAkB,sCAAsC;AACxD;AACA;AACA,MAAM;AACN;AACA;AACA,sBAAsB,kEAAO;AAC7B,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA,wBAAwB,6EAAgB,GAAG,8EAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA,eAAe,kFAAqB;AACpC,eAAe,kFAAqB;AACpC;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAyB;AACxC;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,0BAA0B,YAAY;AACtC,2BAA2B,YAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ;AACR,gEAAgE,SAAS;AACzE;AACA,MAAM;AACN;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM;AACN,mBAAmB,kDAAK,IAAI,kBAAkB,QAAQ,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;;AC1OqB;;AAE/C,4BAA4B,wDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;;;;;;ACXiB;AACI;AACI;AACX;AACQ;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,2CAA2C;AAC3C;AACA,oEAAoE,mDAAM;AAC1E;AACA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA;AACA;AACA,0BAA0B,wDAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,+CAAI;AACV,GAAG,uDAAI;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA,MAAM;AACN,MAAM;AACN,8CAA8C,cAAc,GAAG,IAAI;AACnE;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,uCAAuC,MAAM;AAC7C;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+CAAI;AAClB,IAAI;AACJ,cAAc,+CAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;;AC1HuB;AACC;;AAE/C,4BAA4B,wDAAe;AAC3C;AACA;AACA,oBAAoB,sDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;ACtBzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;;;;ACrBuB;AACJ;AACC;;AAE/C,+BAA+B,wDAAe;AAC9C;AACA;AACA;AACA;AACA,EAAE,uDAAU;AACZ;AACA;AACA;AACA,qBAAqB,0DAAW;AAChC;AACA;AACA;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;;;ACpBsB;AACH;;AAE/C,0BAA0B,wDAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,uDAAI;AACN;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL,6CAA6C,cAAc,GAAG,IAAI;AAClE;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;;ACjCiC;AACT;;AAE/C,0BAA0B,wDAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uDAAI;AAC9B;AACA,EAAE,uDAAI;AACN;AACA;AACA,KAAK;AACL,6CAA6C,cAAc,GAAG,IAAI;AAClE;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;ACrCvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAI,GAAG,KAAK;AACxB;AACA;AACA;AACA;AACA,uDAAuD,KAAK,kBAAkB,IAAI;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,kBAAkB,gCAAgC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,KAAK;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,WAAW;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;;;;;;;;;AChMwB;AACuB;AACZ;AACH;AACmF;AAChF;AAC8B;AAC5C;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wDAAe;AAC7C;AACA;AACA;AACA;AACA;AACA,qBAAqB,mGAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,uDAAI;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,yCAAyC,cAAc,GAAG,IAAI;AAC9D;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kEAAO;AAC/C;AACA;AACA,YAAY,8EAAiB;AAC7B;AACA,IAAI;AACJ;AACA,mBAAmB,OAAO;AAC1B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,+DAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+GAAiC;AACpD;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qEAAc;AACxC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,mBAAmB,+GAAiC;AACpD,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA,0BAA0B,qEAAc;AACxC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;;;;;;;ACtPe;AACc;AACuB;AACtB;AACE;AACZ;;AAE/C,2BAA2B,wDAAe;AAC1C;AACA;AACA;AACA;AACA;AACA,yBAAyB,wFAAkB;AAC3C,qBAAqB,mEAAe;AACpC,UAAU,+CAAI;AACd,GAAG;AACH,qBAAqB,iEAAc;AACnC,UAAU,+CAAI;AACd,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,+CAAI;AACX,2BAA2B,uDAAI;AAC/B,KAAK;AACL,2BAA2B,uDAAI;AAC/B;AACA;AACA,EAAE,uDAAI;AACN;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL,qCAAqC,cAAc,GAAG,IAAI;AAC1D;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,QAAQ;AACR,0BAA0B,GAAG;AAC7B;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP,6BAA6B,KAAK;AAClC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEwB;;;;;;;;;;;;;;;;;AC7HuB;AACA;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD,iCAAiC,kBAAkB;AACnD,oCAAoC,kBAAkB;AACtD,qCAAqC,kBAAkB;AACvD;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,kCAAkC,kBAAkB;AACpD;AACA;AACA;AACA;AACA,4BAA4B,wDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA,aAAa,oDAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;;ACpDyB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,uDAAI;AACN;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL,mDAAmD,aAAa;AAChE;AACA,oBAAoB,YAAY;AAChC;AACA,qBAAqB,UAAU;AAC/B;AACA,MAAM;AACN,oBAAoB,IAAI;AACxB;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEsB;;;;;;;;;;;;;;;;;;AChCwB;AACI;AACH;;AAE/C,2BAA2B,wDAAe;AAC1C;AACA;AACA;AACA;AACA,EAAE,uDAAU;AACZ;AACA;AACA;AACA,qBAAqB,0DAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;;;;;;;;ACvB0B;AACZ;AACkB;AACI;AACf;AACE;AACF;;AAE7C;AACA,4BAA4B,wDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,8CAAM;AACR;AACA;AACA,QAAQ,8CAAM;AACd;AACA,SAAS,gEAAW;AACpB,aAAa,gEAAW;AACxB;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,MAAM;AACN;AACA,qBAAqB,IAAI,gEAAW,gBAAgB;AACpD,UAAU,gEAAW,mBAAmB,gEAAW;AACnD;AACA,KAAK,gEAAW;AAChB;AACA,gCAAgC,sDAAc;AAC9C;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,cAAc;AACrC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uDAAQ,+DAA+D,iGAAe;AACxG;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,qDAAM;AACrE;AACA;AACA,KAAK,wEAAc;AACnB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEyB;;;;;;;;;;;;;;;;;AChHyB;AACH;;AAE/C,4BAA4B,wDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,uDAAI;AACN;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL,+CAA+C,cAAc,GAAG,IAAI;AACpE;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;;;;;ACjCiB;AACQ;AACH;AACA;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wDAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,+CAAI;AACV,GAAG,uDAAI;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,qBAAqB,oDAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,2DAA2D,gCAAgC;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6BAA6B;AACxD,0BAA0B,6BAA6B;AACvD;AACA;AACA;AACA,IAAI;AACJ;AACA,4BAA4B,6BAA6B;AACzD,2BAA2B,6BAA6B;AACxD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2BAA2B;AACxD,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;;;;ACtGyB;AACR;AACK;;AAE/C,8BAA8B,wDAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,uDAAI;AACN;AACA,2CAA2C,aAAa;AACxD,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,aAAa,kDAAQ;AACrB;AACA;AACA;AACA;AACA,aAAa,kDAAQ;AACrB;AACA;;AAE2B;;;;;;;;;;;;;;;;;ACtCuB;AACH;;AAE/C,0BAA0B,wDAAe;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,uDAAI;AACN;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL,6CAA6C,cAAc,GAAG,IAAI;AAClE;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;;;;;;;ACjCmB;AACK;AACA;AACqQ;AAClQ;AACU;AACb;;AAE/C;AACA,WAAW,2EAAc;AACzB,UAAU,kFAAqB;AAC/B,WAAW,oFAAuB;AAClC;AACA;AACA,YAAY,2EAAc;AAC1B,WAAW,0EAAa;AACxB,wBAAwB,0FAA6B;AACrD,uBAAuB,yFAA4B;AACnD,uBAAuB,yFAA4B;AACnD,sBAAsB,wFAA2B;AACjD;AACA;AACA,kCAAkC,wDAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,+CAAI;AACV,GAAG,uDAAI;AACP;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA,MAAM;AACN,MAAM;AACN;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA,uBAAuB,iEAAY;AACnC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6EAAgB,GAAG,gFAAmB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oDAAI;AAClB,eAAe,oDAAI;AACnB,gBAAgB,oDAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAI;AACnB,gBAAgB,oDAAI;AACpB,iBAAiB,oDAAI;AACrB;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oDAAI;AACrB,kBAAkB,oDAAI;AACtB,mBAAmB,oDAAI;AACvB;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;;;;;;;;;;;;AC7KW;AACiY;AAC9W;AACW;AACd;AACJ;AACA;AACE;AACF;AACA;AACP;;AAE/C;AACA,WAAW,2EAAc;AACzB,UAAU,kFAAqB;AAC/B,WAAW,oFAAuB;AAClC;AACA;AACA,YAAY,2EAAc;AAC1B,WAAW,0EAAa;AACxB,wBAAwB,0FAA6B;AACrD,uBAAuB,yFAA4B;AACnD,uBAAuB,yFAA4B;AACnD,sBAAsB,wFAA2B;AACjD;AACA;AACA,YAAY,gFAAmB;AAC/B,SAAS,6EAAgB;AACzB,SAAS,6EAAgB;AACzB,SAAS,6EAAgB;AACzB,gBAAgB,oFAAuB;AACvC;AACA;AACA,2BAA2B,6EAAY;AACvC;AACA;AACA;AACA,2BAA2B,8EAAiB,wBAAwB,gFAAmB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC,mBAAmB,kBAAkB;AACrC,oBAAoB,OAAO;AAC3B;AACA,sBAAsB,SAAS;AAC/B,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,2BAA2B;AACrE;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,6BAA6B,wDAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8DAAS;AAChC;AACA,YAAY,8DAAS;AACrB,YAAY,8DAAS;AACrB,aAAa,gEAAU;AACvB,cAAc,kEAAW;AACzB,YAAY,8DAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+CAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB,6EAAgB;AACnC,KAAK;AACL,mBAAmB,oFAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mEAAO;AACxB;AACA;AACA,YAAY,6EAAgB;AAC5B,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;;ACrMiC;;AAE3D,oBAAoB,gEAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiB;;;;;;;;;;;;;;;;ACvFjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;;;;;;;;;;;;;;;ACfpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA,sDAAsD,EAAE;AACxD;AACA;AACA,sDAAsD,EAAE;AACxD;AACA;AACA,8CAA8C,EAAE;AAChD;AACA;AACA,sDAAsD,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;;;;;;ACrCqC;AACjB;AACI;AAC4B;AACU;;AAEpF,mBAAmB,gEAAY;AAC/B;AACA;AACA,gBAAgB,yDAAc;AAC9B;AACA;AACA;AACA;AACA,qBAAqB,uDAAU;AAC/B;AACA;AACA;AACA,uCAAuC,UAAU;AACjD,mCAAmC,kDAAK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,GAAG;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,MAAM;AACvC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kDAAO;AACpB;AACA;AACA,WAAW,sDAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8DAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA,eAAe,kDAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kDAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,UAAU,kDAAO;AACjB,cAAc,sDAAW;AACzB;AACA;AACA;AACA;AACA,UAAU,kDAAO;AACjB,cAAc,sDAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA,iBAAiB,kDAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kDAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mEAAwB;AACvC;AACA;AACA;AACA,WAAW,mEAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,yDAAc;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgB;;;;;;;;;;;;;;;;;;;AC7O0D;;AAE1E;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mEAAwB;AACxC;AACA;AACA;AACA;AACA,YAAY,mEAAwB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yDAAc;AACtB;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,CAAC;AACD,0CAA0C,yDAAc;AACxD;AACA;AACA;;AAEkE;;;;;;;;;;;;;;;;;;;;;ACvHnB;AACI;AACF;AACX;AACiB;AACX;;AAE5C,uBAAuB,oDAAI;AAC3B,+BAA+B,qDAAS;AACxC;AACA;AACA,0BAA0B,8CAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4DAAW;AAC1B,UAAU,sDAAK;AACf;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,wDAAM;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;;;;;AC5CmB;AACI;AACc;AACrB;;AAE5C,uBAAuB,oDAAI;AAC3B,8BAA8B,qDAAS;AACvC;AACA;AACA;AACA;AACA,0BAA0B,sEAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,wDAAM;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;;;;AChCoC;AACM;AACJ;;AAEjE,uBAAuB,0EAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sEAAqB;AAC1C;AACA;AACA,0BAA0B,oEAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;AC1DrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;;;;AClB+C;AACA;AACuB;;AAE9F;AACA;AACA;AACA;AACA,sBAAsB,gFAAoB,SAAS,4EAAY,mBAAmB,mGAAuB;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gFAAoB,cAAc,4EAAY,mBAAmB,mGAAuB;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxDc;AACQ;AACF;AACA;AACgB;AACqI;AAC5H;AACO;AAClB;AACD;AACa;AACF;AACA;AACuB;AAC4P;AAC3S;AACO;AACwB;AACrB;AACE;AACR;AACoB;AACf;AACY;AACA;AACC;;AAErE;AACA;AACA;AACA,oBAAoB,oDAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,4EAAa;AACf;AACA,EAAE,4EAAa;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iEAAe;AAC7C;AACA;AACA,uBAAuB,kEAAO;AAC9B;AACA;AACA,YAAY,8EAAiB;AAC7B,UAAU,6EAAgB;AAC1B;AACA,IAAI;AACJ,GAAG,4EAAa;AAChB,sBAAsB,oDAAM;AAC5B;AACA;AACA;AACA;AACA;AACA,uBAAuB,wEAAuB;AAC9C;AACA,qBAAqB,2DAAS;AAC9B;AACA;AACA;AACA,8BAA8B,8EAAc,2DAA2D;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAI;AAClC;AACA,4BAA4B,6EAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,4EAAa;AAChB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oFAAgB;AACvC,qCAAqC,KAAK,WAAW,WAAW;AAChE,+BAA+B,0EAAa;AAC5C;AACA,mDAAmD,6EAAY;AAC/D;AACA,wBAAwB,oGAAuB;AAC/C;AACA;AACA,yDAAyD,+CAA+C;AACxG,kCAAkC,gDAAgD;AAClF;AACA;AACA,UAAU,eAAe;AACzB,KAAK;AACL,2BAA2B,sDAAK;AAChC;AACA;AACA,4BAA4B,6EAAY,yCAAyC,8EAAiB;AAClG;AACA;AACA,IAAI;AACJ,+BAA+B,6EAAY,QAAQ,wCAAwC,wBAAwB;AACnH,2BAA2B,oGAAuB;AAClD;AACA;AACA;AACA;AACA,kBAAkB,0EAAa;AAC/B;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kEAAO;AACpB;AACA;AACA;AACA;AACA,4CAA4C,8EAAiB,GAAG,6EAAgB,GAAG,gFAAmB;AACtG,cAAc,2EAAc;AAC5B,cAAc,2EAAc;AAC5B,aAAa,kFAAqB;AAClC,aAAa,kFAAqB;AAClC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6DAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,6DAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA,yBAAyB,6DAAY;AACrC,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6DAAY;AACpC;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAI;AACpC;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wEAAuB;AAChD,wBAAwB,kBAAkB;AAC1C;AACA,sBAAsB,0EAAa;AACnC,sBAAsB,0EAAa;AACnC,uCAAuC,kEAAY;AACnD;AACA;AACA;AACA;AACA;AACA,oBAAoB,8DAAa;AACjC;AACA,oBAAoB,mDAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,8BAA8B,8DAAa;AAC3C;AACA;AACA;AACA,oBAAoB,6DAAY;AAChC,gBAAgB,8DAAa;AAC7B,kBAAkB,gEAAe;AACjC;AACA;AACA,kBAAkB,oEAAmB;AACrC;AACA;AACA;AACA;AACA,kBAAkB,mDAAG;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA,sBAAsB,kBAAkB;AACxC,iEAAiE,EAAE;AACnE,IAAI,4EAAa;AACjB,uCAAuC,8EAAY;AACnD;AACA;AACA,KAAK;AACL;AACA;AACA,sEAAsE,KAAK;AAC3E,IAAI,4EAAa;AACjB,qCAAqC,8EAAY;AACjD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,4BAA4B,qEAAgB;AAC5C;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA,yBAAyB,mEAAe;AACxC;AACA,sCAAsC,0DAAS;AAC/C,iBAAiB,0DAAS,GAAG,wEAAuB,GAAG,oEAAmB;AAC1E,4CAA4C,sEAAqB,GAAG,sEAAqB,GAAG,uEAAsB;AAClH;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qEAAW;AAChC;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA,qBAAqB,qEAAW;AAChC,kBAAkB,0BAA0B;AAC5C;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+DAAc;AACnC;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAsB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sEAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,qBAAqB,+DAAc;AACnC;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sEAAqB;AAClC,aAAa,+DAAc;AAC3B,aAAa,+DAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sEAAqB;AAC3C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAAU;AACjC,uBAAuB,0EAAU;AACjC;AACA,qBAAqB,yBAAyB;AAC9C;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA,KAAK,yFAAkB;AACvB;AACA,KAAK,yFAAkB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA;AACA,aAAa,0DAAS;AACtB,0BAA0B,kEAAY;AACtC,0BAA0B,kEAAY;AACtC;AACA;AACA,cAAc,uBAAuB;AACrC;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC;AACA,+CAA+C,qEAAgB;AAC/D,kDAAkD,sEAAqB;AACvE;AACA;AACA;AACA;AACA,mCAAmC,sCAAsC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+EAAqB;AACnD;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,kEAAiB;AAClF;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA,6BAA6B,kEAAY;AACzC,wBAAwB,6DAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;;ACvtB6C;AACP;;AAE7D,oCAAoC,yEAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,qEAAqE,kEAAiB;AACtF;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEiC;;;;;;;;;;;;;;;;;;;ACtCsB;AACP;AACE;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,uDAAI;AACN;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,wBAAwB,4DAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,yDAAW,YAAY;AACzF;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;;;;;;;;;;;;;;;ACjLxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kJAAkJ,OAAO;AACzJ;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;;;;AClOmB;AACA;AACE;AACuB;;AAEnE;AACA;AACA;AACA;AACA,0BAA0B,qDAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,kDAAK;AACP;AACA;AACA,KAAK;AACL,IAAI,qDAAS,gDAAgD,+CAAI;AACjE;AACA;AACA,OAAO;AACP,yBAAyB,4EAAoB;AAC7C;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAE8B;;;;;;;;;;;;;;;;;;;;;;;ACpCwB;AACM;AACf;AACiB;AACF;AACW;AACjC;AACI;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA,kBAAkB,4BAA4B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kDAAK,IAAI,UAAU,GAAG,KAAK,GAAG,MAAM;AAC3D;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAM;AAC3B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iEAAY;AACxC;AACA,qCAAqC,mEAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,sBAAsB,8CAAM;AAC5B;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4EAAiB;AACrD;AACA,GAAG;AACH,gEAAgE,8CAAM;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iEAAY;AACxC;AACA,8BAA8B,mEAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kDAAK;AACzB;AACA;AACA,4BAA4B,iEAAY;AACxC;AACA;AACA;AACA,sEAAsE,2DAAS;AAC/E,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;;;;;;;;;;;;;;;;;AC9QmC;AACvB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,qDAAS,oJAAoJ;AAC/J;AACA;AACA,KAAK;AACL,kBAAkB,4EAAoB;AACtC;AACA;AACA;AACA,GAAG;AACH;AACA;;AAE0B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvBgB;AACO;AACF;AACA;AACA;AACA;AACgB;AACi1B;AAC10B;AACT;AACW;AACA;AACtB;AACwI;AACpI;AACG;AACd;AACE;AACa;AACgB;AAC3B;AACJ;AACmC;AACxC;AAC+D;AACzC;AACF;AACE;AAClB;AACW;AACJ;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,sEAAS;AACnB;AACA,UAAU,uEAAU;AACpB;AACA,UAAU,uEAAU;AACpB;AACA,UAAU,wEAAW;AACrB;AACA,UAAU,uEAAU;AACpB;AACA,UAAU,wEAAW;AACrB;AACA,UAAU,yEAAY;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8EAAiB;AAC9B,WAAW,4EAAe;AAC1B,YAAY,6EAAgB;AAC5B,YAAY,2EAAc;AAC1B,aAAa,kFAAqB;AAClC,cAAc,iFAAoB;AAClC,eAAe,+EAAkB;AACjC,eAAe,+EAAkB;AACjC,eAAe,+EAAkB;AACjC,eAAe,+EAAkB;AACjC,eAAe,+EAAkB;AACjC,eAAe,+EAAkB;AACjC,eAAe,+EAAkB;AACjC,eAAe,+EAAkB;AACjC;AACA;AACA,EAAE,8EAAiB;AACnB,EAAE,4EAAe;AACjB,EAAE,6EAAgB;AAClB,EAAE,2EAAc;AAChB,EAAE,kFAAqB;AACvB,EAAE,iFAAoB;AACtB,EAAE,+EAAkB;AACpB,EAAE,+EAAkB;AACpB,EAAE,+EAAkB;AACpB,EAAE,+EAAkB;AACpB,EAAE,+EAAkB;AACpB,EAAE,+EAAkB;AACpB,EAAE,+EAAkB;AACpB,EAAE,+EAAkB;AACpB;AACA;AACA;AACA,OAAO,sEAAS;AAChB;AACA,OAAO,uEAAU;AACjB;AACA,OAAO,uEAAU;AACjB;AACA,OAAO,wEAAW;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAW,KAAK,oDAAI,iFAAiF,oDAAI;AACrH;AACA;AACA;AACA,SAAS,gFAAmB;AAC5B;AACA;AACA;AACA,UAAU,6EAAgB;AAC1B;AACA,UAAU,4EAAe;AACzB;AACA,UAAU,+EAAkB;AAC5B;AACA,UAAU,gFAAmB;AAC7B;AACA,UAAU,gFAAmB;AAC7B;AACA,UAAU,+EAAkB;AAC5B;AACA,UAAU,6EAAgB;AAC1B;AACA,UAAU,gFAAmB;AAC7B;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA,sBAAsB,8EAAiB;AACvC;AACA;AACA;AACA;AACA;AACA,+BAA+B,oFAAuB;AACtD,kBAAkB,4EAAe;AACjC,kBAAkB,4EAAe;AACjC,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA,GAAG;AACH,kBAAkB,4EAAe;AACjC;AACA;AACA;AACA;AACA;AACA,qBAAqB,mFAAgB;AACrC;AACA;AACA,YAAY,4EAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yEAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yCAAyC;AACtD;AACA,uBAAuB,+EAAkB,qBAAqB,+EAAkB;AAChF;AACA,SAAS,yEAAY;AACrB;AACA;AACA;AACA,MAAM;AACN;AACA,SAAS,wEAAW;AACpB;AACA;AACA;AACA,MAAM;AACN;AACA,SAAS,uEAAU;AACnB;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC;AACA;AACA,eAAe,8BAA8B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8BAA8B;AAClD;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kEAAO;AAC3B;AACA;AACA;AACA;AACA,oBAAoB,kDAAK,IAAI,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,8EAAiB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6EAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,0BAA0B,6EAAY;AACtC;AACA,aAAa,kCAAkC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6EAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,cAAc,yCAAyC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO,GAAG,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,4EAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B,eAAe,QAAQ;AACvB;AACA;AACA,oBAAoB,oDAAI;AACxB;AACA;AACA;AACA,GAAG;AACH,cAAc,eAAe;AAC7B,oBAAoB,oDAAI;AACxB;AACA;AACA;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA,aAAa,gDAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iDAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG,2EAAc,uBAAuB,uEAAU,sBAAsB,wEAAW;AACzL,GAAG;AACH;AACA;AACA;AACA,EAAE,+DAAW;AACb;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,YAAY,yEAAY;AACxB,MAAM;AACN;AACA,6BAA6B,6EAAY;AACzC;AACA,+CAA+C,+EAAkB,GAAG,+EAAkB;AACtF;AACA,6BAA6B,6EAAY;AACzC;AACA,KAAK;AACL,4BAA4B,4EAAW,kCAAkC,0EAAa;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,oBAAoB,iDAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8EAAiB;AACpC,MAAM;AACN,mBAAmB,+EAAkB;AACrC,MAAM;AACN,mBAAmB,+EAAkB;AACrC;AACA,wBAAwB,+EAAkB;AAC1C,mBAAmB,+EAAkB;AACrC;AACA;AACA,wBAAwB,8EAAiB;AACzC,mBAAmB,+EAAkB;AACrC;AACA;AACA,4BAA4B,4EAAW,sCAAsC,0EAAa;AAC1F;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yEAAY;AAC/C;AACA;AACA;AACA;AACA;AACA,iCAAiC,yEAAY;AAC7C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAW;AACjC,KAAK;AACL,qBAAqB,mDAAK;AAC1B;AACA,KAAK;AACL;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,qDAAI;AAChF,wBAAwB,qDAAI;AAC5B,wBAAwB,qDAAI;AAC5B,gBAAgB,mBAAmB;AACnC,eAAe,UAAU;AACzB,eAAe,UAAU;AACzB,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8DAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8DAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oFAAgB;AACtC,4BAA4B,4DAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,4DAAU;AACnC;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,yBAAyB,8DAAY;AACrC;AACA;AACA;AACA;AACA,yBAAyB,4DAAU;AACnC;AACA;AACA,GAAG;AACH,uBAAuB,4DAAU;AACjC;AACA;AACA;AACA,6CAA6C,0EAAa,GAAG,0EAAa;AAC1E,GAAG;AACH;AACA,kBAAkB,0EAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mEAAQ;AACrB;AACA;AACA,UAAU,mEAAkB;AAC5B,YAAY,qEAAoB;AAChC,iBAAiB,oEAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mCAAmC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wJAAwJ,qEAAoB;AAC5K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA,sBAAsB,mEAAQ;AAC9B,wFAAwF,eAAe;AACvG;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW;AACzC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,0BAA0B,EAAE,GAAG,EAAE;AACjC;AACA;AACA,aAAa,mCAAmC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qEAAS;AAC3B,0HAA0H,oEAAmB;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uBAAuB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA,YAAY,qEAAS,0EAA0E,eAAe;AAC9G;AACA,oBAAoB,oDAAI;AACxB,oBAAoB,oDAAI;AACxB;AACA,oBAAoB,4DAAS;AAC7B;AACA;AACA,GAAG;AACH,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,yEAAuB,GAAG,wEAAsB;AACzG,uCAAuC,yEAAuB;AAC9D;AACA;AACA;AACA;AACA,mBAAmB,6DAAW;AAC9B;AACA;AACA;AACA;AACA,oBAAoB,yEAAuB;AAC3C;AACA;AACA,mCAAmC,+DAAa;AAChD;AACA;AACA,GAAG;AACH,4CAA4C,qDAAI;AAChD;AACA,mCAAmC,+DAAa;AAChD;AACA;AACA;AACA,0BAA0B,+CAAM;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,uDAAK,oBAAoB,uDAAK;AAC/E;AACA,eAAe,6EAA2B;AAC1C,qDAAqD,qDAAI;AACzD;AACA;AACA,gHAAgH,qDAAI;AACpH,gHAAgH,qDAAI;AACpH;AACA;AACA,+CAA+C,mDAAK,wBAAwB,wDAAU;AACtF;AACA,yBAAyB,+CAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA,mBAAmB,8BAA8B;AACjD;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,kBAAkB,WAAW;AAC7B;AACA;AACA,0BAA0B,4DAAS;AACnC,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC,mBAAmB,qDAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2EAAc;AACzB;AACA,WAAW,0EAAa;AACxB;AACA,WAAW,0FAA6B;AACxC;AACA,WAAW,yFAA4B;AACvC;AACA,WAAW,yFAA4B;AACvC;AACA,WAAW,wFAA2B;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kFAAqB;AAChC;AACA,WAAW,oFAAuB;AAClC;AACA,WAAW,2EAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,wFAA2B;AAClF,uDAAuD,0EAAa;AACpE,gDAAgD,2EAAc;AAC9D,gDAAgD,2EAAc;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iCAAiC,GAAG,sBAAsB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS,GAAG,UAAU;AAC/C;AACA;AACA,sBAAsB,kDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,IAAI;AACJ,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,kCAAkC,8DAAY,uCAAuC,gDAAI;AACzF;AACA,KAAK;AACL,KAAK;AACL;AACA;AACA,2GAA2G,EAAE;AAC7G,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,IAAI;AACJ,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,IAAI;AACJ,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA,KAAK,wDAAI,KAAK,8DAAY,yCAAyC,gDAAI;AACvE;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,mBAAmB;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,mBAAmB;AACxG;AACA;AACA;AACA,4EAA4E,QAAQ;AACpF;AACA;AACA;AACA,wDAAwD,OAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,YAAY;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,4BAA4B;AAC7G;AACA;AACA;AACA,iFAAiF,4BAA4B;AAC7G;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6BAA6B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,IAAI;AACJ,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEqB;;;;;;;;;;;;;;;;;;;ACx8DiB;AACiC;AACjB;AACqB;;AAE3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gFAAgB,oCAAoC,2DAAM;AAC5G;AACA;AACA;AACA,yBAAyB;AACzB;AACA,qBAAqB,8CAAM;AAC3B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,aAAa,4EAAc;AAC3B;AACA;;AAE0B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1CqB;AACA;AACgB;AACghB;AACzgB;AACE;AACA;AACI;AACtB;AACX;AACiB;AACf;AACA;AACiB;AACJ;AACf;AACiB;;AAE5D;AACA,WAAW,6EAAgB;AAC3B,UAAU,4EAAe;AACzB,aAAa,+EAAkB;AAC/B,cAAc,gFAAmB;AACjC,cAAc,gFAAmB;AACjC,kBAAkB,+EAAkB;AACpC,gBAAgB,6EAAgB;AAChC;AACA;AACA,SAAS,sEAAS;AAClB,UAAU,uEAAU;AACpB,UAAU,uEAAU;AACpB,WAAW,wEAAW;AACtB,UAAU,uEAAU;AACpB,WAAW,wEAAW;AACtB,YAAY,yEAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4BAA4B;AAC1C;AACA,oBAAoB,2DAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8BAA8B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,4BAA4B;AAC1C;AACA;AACA,eAAe,yCAAyC;AACxD;AACA,iCAAiC,oDAAI;AACrC;AACA,oBAAoB,gDAAI;AACxB;AACA,4BAA4B,iEAAY;AACxC;AACA,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6BAA6B;AAC5C;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA,sBAAsB,oEAAW,KAAK,oDAAI,iFAAiF,oDAAI;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+DAAW;AAClC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,sBAAsB,kDAAK;AAC3B;AACA,8BAA8B,oEAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8EAAiB;AAC9B,WAAW,4EAAe;AAC1B,YAAY,6EAAgB;AAC5B,gBAAgB,iFAAoB;AACpC,iBAAiB,kFAAqB;AACtC,UAAU,2EAAc;AACxB,cAAc,+EAAkB;AAChC,cAAc,+EAAkB;AAChC,cAAc,+EAAkB;AAChC,cAAc,+EAAkB;AAChC,cAAc,+EAAkB;AAChC,cAAc,+EAAkB;AAChC,cAAc,+EAAkB;AAChC,cAAc,+EAAkB;AAChC;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,2EAAc;AAC9D,KAAK;AACL;AACA,4BAA4B,8EAAY;AACxC;AACA,4BAA4B,8EAAY;AACxC,wBAAwB,kFAAc;AACtC,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6BAA6B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0BAA0B;AACxC;AACA;AACA;AACA;AACA,sBAAsB,4EAAW,eAAe,+EAAkB;AAClE;AACA,KAAK;AACL,sBAAsB,4EAAW,eAAe,+EAAkB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;AACA,oBAAoB,oEAAW,KAAK,oDAAI,iFAAiF,oDAAI;AAC7H;AACA,oBAAoB,iDAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oCAAoC;AAClD;AACA;AACA;AACA,4BAA4B,kEAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;;;;;;;;;;;;AChU6D;AACpC;AACF;AACA;AACc;AACE;AACW;AACI;AACmB;AACM;AACb;;AAE7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mFAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gFAAQ,GAAG;AAChC;AACA;AACA,gBAAgB,4GAA8B;AAC9C;AACA;AACA,wBAAwB,oDAAI;AAC5B,KAAK;AACL,wBAAwB,sDAAK;AAC7B,KAAK;AACL,yBAAyB,kEAAO;AAChC;AACA,MAAM,oCAAoC,kEAAO;AACjD;AACA;AACA,KAAK;AACL,yBAAyB,kEAAO;AAChC;AACA,MAAM,oCAAoC,kEAAO;AACjD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,uBAAuB,oDAAI;AAC3B,4BAA4B,oDAAI;AAChC,wBAAwB,oEAAW;AACnC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,+DAAc,GAAG,+DAAc;AAChF;AACA,IAAI;AACJ,uBAAuB,+DAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+BAA+B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kCAAkC;AAChD;AACA;AACA;AACA;AACA;AACA,EAAE,mGAA4B;AAC9B;AACA;AACA;AACA;AACA;AACA,0BAA0B,uGAAyB;AACnD;AACA;AACA;AACA;AACA;AACA;;AAEsC;;;;;;;;;;;;;;;;;;AC1GyB;AACqB;AAC9B;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,0DAA0D,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,kDAAkD,SAAS;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,EAAE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yFAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAU;AACtB;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,OAAO;AAChE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B,oBAAoB,+BAA+B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,oEAAU;AACtB;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+DAAc;AACvC;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;;;;AC7YiB;AACiC;AACP;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qEAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAM;AAC3B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAG,4EAAa;AAChB,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;;;;;;ACjGiE;AACQ;AAChC;AACnB;AACY;AACZ;;AAE7C,0BAA0B,sDAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kEAAc;AAC1C;AACA,IAAI;AACJ;AACA,+CAA+C,WAAW;AAC1D;AACA;AACA,EAAE,kDAAK;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA,4CAA4C;AAC5C,sBAAsB,kEAAO,SAAS,gFAAQ;AAC9C;AACA,4BAA4B,kFAAqB,GAAG,2EAAc;AAClE,4BAA4B,kFAAqB,GAAG,2EAAc;AAClE;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;;;;;AChDiE;AACuQ;AAC/R;AACnB;AACA;;AAE7C,wBAAwB,sDAAa;AACrC;AACA;AACA;AACA;AACA;AACA,EAAE,kDAAK;AACP;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6EAAgB;AAC7B;AACA,KAAK;AACL,aAAa,6EAAgB;AAC7B;AACA,KAAK;AACL,aAAa,gFAAmB;AAChC;AACA,KAAK;AACL,aAAa,gFAAmB;AAChC;AACA,KAAK;AACL,aAAa,6EAAgB;AAC7B;AACA;AACA,KAAK;AACL,4CAA4C,yFAA4B,GAAG,0FAA6B;AACxG;AACA;AACA,KAAK;AACL,4CAA4C,yFAA4B,GAAG,0FAA6B;AACxG;AACA;AACA;AACA,IAAI;AACJ;AACA,aAAa,8EAAiB;AAC9B;AACA;AACA;AACA,iBAAiB,kEAAO;AACxB;AACA;AACA,YAAY,6EAAgB;AAC5B;AACA,IAAI;AACJ;AACA;AACA,gBAAgB,kEAAO,SAAS,gFAAQ;AACxC;AACA,yBAAyB,kFAAqB,GAAG,2EAAc;AAC/D,yBAAyB,kFAAqB,GAAG,2EAAc;AAC/D;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,+BAA+B,gFAAmB,wDAAwD,gFAAmB;AAC7H;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;;;;;;;ACrImE;AAC9B;AAC2F;AACrF;AACnB;AACA;;AAE7C,wBAAwB,sDAAa;AACrC;AACA;AACA;AACA;AACA;AACA,EAAE,kDAAK;AACP;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,sBAAsB,kEAAO,SAAS,gFAAQ;AAC9C;AACA,aAAa,2EAAc;AAC3B,aAAa,kFAAqB;AAClC,cAAc,2EAAc;AAC5B,cAAc,2EAAc;AAC5B;AACA;AACA;AACA,WAAW,8EAAiB;AAC5B,SAAS,6EAAgB;AACzB;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,yBAAyB,4DAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;;;;;;;AC9HmE;AACZ;AACZ;AACX;AACG;AACX;;AAE7C,wBAAwB,sDAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,SAAS,6DAAY;AACzB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,4CAA4C;AAC5C,sBAAsB,kEAAO,SAAS,gFAAQ;AAC9C;AACA;AACA;AACA,WAAW,8EAAiB;AAC5B,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,YAAY,kBAAkB,WAAW;AACzF;AACA;AACA;AACA,oBAAoB,gBAAgB,QAAQ,WAAW;AACvD;AACA,KAAK;AACL,KAAK;AACL,6CAA6C,YAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,uDAAI;AACN;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEqB;;;;;;;;;;;;;;;;;;;;AC1GmE;AAC+X;AACvZ;AACnB;AACA;;AAE7C;AACA;AACA,SAAS,6EAAgB;AACzB,SAAS,6EAAgB;AACzB,SAAS,6EAAgB;AACzB,SAAS,6EAAgB;AACzB,SAAS,iFAAoB;AAC7B,SAAS,kFAAqB;AAC9B,SAAS,yFAA4B;AACrC,SAAS,yFAA4B;AACrC,SAAS,0FAA6B;AACtC,SAAS,0FAA6B;AACtC,SAAS,6EAAgB;AACzB,SAAS,8EAAiB;AAC1B,SAAS,6EAAgB;AACzB,SAAS,8EAAiB;AAC1B,SAAS,gFAAmB;AAC5B,SAAS,+EAAkB;AAC3B,SAAS,gFAAmB;AAC5B;AACA;AACA,wBAAwB,gFAAmB;AAC3C;AACA,wBAAwB,sDAAa;AACrC;AACA;AACA;AACA;AACA;AACA,EAAE,kDAAK;AACP;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,sBAAsB,kEAAO,SAAS,gFAAQ;AAC9C;AACA,mCAAmC,kFAAqB,GAAG,2EAAc;AACzE,mCAAmC,kFAAqB,GAAG,2EAAc;AACzE;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kDAAkD;AAC9E;AACA;AACA;AACA;AACA;AACA,sBAAsB,4BAA4B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;;;;;;;;AC7GmE;AAC9B;AACsC;AAChC;AACnB;AACY;AACZ;;AAE7C;AACA;AACA;AACA;AACA,yBAAyB,sDAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,kDAAK;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA,4CAA4C;AAC5C,sBAAsB,kEAAO,SAAS,gFAAQ;AAC9C;AACA,4BAA4B,kFAAqB,GAAG,2EAAc;AAClE,4BAA4B,kFAAqB,GAAG,2EAAc;AAClE;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,iBAAiB,4DAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oCAAoC;AACtD;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kEAAc;AAC1C;AACA;AACA,IAAI;AACJ;AACA,+CAA+C,WAAW;AAC1D;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;ACjGtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;ACTzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6B;;;;;;;;;;;;;;;;;;AClBU;AACa;AACS;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sEAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,sEAAiB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,6DAAY;AACtD,SAAS,+CAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yCAAyC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,6DAAY;AACtD,SAAS,+CAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEyB;;;;;;;;;;;;;;;;;;ACpMkB;AACG;AACS;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,gEAAW;AACb;AACA,EAAE;AACF,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA,cAAc,2DAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,CAAC;AACD,mDAAM;;AAEY;;;;;;;;;;;;;;;;;;;ACrClB;AACA;AACA;AACA;AACA;;AAEqG;;;;;;;;;;;;;;;;;;;;;;;;ACNpD;AACA;AACO;AACT;AACA;AACA;AACO;AACZ;;AAE1C;AACA,yCAAyC,oDAAI,EAAE,oDAAI,EAAE,oDAAI;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kDAAK;AAC7B;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wBAAwB,2DAAS;AACjC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wBAAwB,sDAAK;AAC7B,uBAAuB,sDAAK;AAC5B;AACA;AACA;AACA;AACA,KAAK;AACL,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA,wBAAwB,sDAAK;AAC7B;AACA;AACA;AACA;AACA;AACA,KAAK,oDAAoD,EAAE,EAAE,IAAI;AACjE;AACA,eAAe,sDAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sDAAK,qBAAqB,6DAAQ;AAC3D;AACA,MAAM;AACN,wDAAwD,6DAAQ,GAAG,sDAAK;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,4BAA4B,KAAK;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsD;;;;;;;;;;;;;;;;;;;;;;;ACnNK;AAClB;AACiB;AACZ;AACE;AACX;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,KAAK;AACvC;AACA;AACA,EAAE,gEAAY;AACd,EAAE,uDAAU;AACZ;AACA,sCAAsC,uDAAU;AAChD;AACA,qBAAqB,uDAAU;AAC/B,6BAA6B,mEAAgB;AAC7C;AACA;AACA;AACA;AACA,mEAAgB;AAChB;AACA,CAAC;AACD;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA,mCAAmC,8CAAM;AACzC,oCAAoC,uDAAU,yBAAyB;AACvE;AACA,iCAAiC,uDAAU;AAC3C;AACA,mCAAmC,KAAK;AACxC;AACA;AACA,sCAAsC,iDAAO;AAC7C;AACA,CAAC,yDAAW;AACZ;;AAEgE;;;;;;;;;;;;;;;;AChDL;;AAE3D,6BAA6B,gEAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC,MAAM;AACN,kDAAkD,WAAW;AAC7D;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0CAA0C;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uCAAuC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;;;AC/HgC;AACrB;;AAErC,yBAAyB,8CAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,mEAAgB;AACpF;AACA;AACA;AACA,EAAE,8CAAM;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;ACjDtB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;;;ACXoC;AACgB;;AAE3E,qBAAqB,gEAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,4DAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA,2CAA2C,iEAAsB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;;AAEiC;;;;;;;;;;;;;;;;ACvEa;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,SAAS,2DAAc;AACvB;AACA;AACA;AACA,kCAAkC,2DAAc;AAChD;AACA;AACA,kBAAkB,2DAAc;AAChC;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;;AC/EqB;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0DAAW;AAChC;AACA;AACA;;AAEoB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtBpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkb;;;;;;;;;;;;;;;;;;ACzBvX;AACZ;AACA;;AAE/C,uBAAuB,gEAAY;AACnC;AACA;AACA,uBAAuB,oDAAI;AAC3B,uBAAuB,oDAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoB;;;;;;;;;;;;;;;;;;AChGuC;AACT;AACR;;AAE1C,wBAAwB,gEAAY;AACpC;AACA;AACA;AACA;AACA,oBAAoB,uDAAQ;AAC5B;AACA;AACA,sBAAsB,uDAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iCAAiC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mDAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,gBAAgB;AACrB;AACA;AACA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;;;ACnOsC;AACZ;;AAE/C,6BAA6B,gEAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;;ACpFwB;;AAElD;AACA;AACA;AACA,oBAAoB,uDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;AChCxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoB;;;;;;;;;;;;;;;;;;;;;ACxBuC;AACT;AACH;AACF;AACH;AACF;;AAExC;AACA,iBAAiB,oDAAI;AACrB,iBAAiB,oDAAI;AACrB,iBAAiB,oDAAI;AACrB,IAAI,uDAAQ;AACZ;AACA;AACA,qBAAqB,gEAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iDAAO;AAC5B;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C,sBAAsB,mDAAQ;AAC9B,mBAAmB,8BAA8B;AACjD;AACA;AACA,sBAAsB,iDAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sDAAW;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkB;;;;;;;;;;;;;;;;;;AC/IyC;AACZ;AACA;;AAE/C;AACA;AACA,8BAA8B,gEAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,oDAAI;AACpF;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,oFAAoF,oDAAI;AACxF,kFAAkF,oDAAI;AACtF,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;;;;;AC3FuB;AACS;AACX;AACU;;AAE1D,wBAAwB,gEAAY;AACpC;AACA;AACA;AACA,oBAAoB,uDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,8CAA8C,yDAAc;AAC5D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK,gBAAgB;AACrB,IAAI,gBAAgB;AACpB;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yDAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mEAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;;;;AC3IsC;AACT;AACK;;AAEvD,8BAA8B,gEAAY;AAC1C;AACA;AACA;AACA,oBAAoB,uDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gEAAc;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;;;;;;;;ACpGgC;AACZ;AACA;AACA;AACD;AACR;AACG;;AAEzC,kBAAkB,oDAAI;AACtB,iBAAiB,oDAAI;AACrB;AACA,4BAA4B,gEAAY;AACxC;AACA;AACA;AACA;AACA;AACA,kBAAkB,mDAAG;AACrB,uBAAuB,mDAAG;AAC1B;AACA;AACA;AACA,8BAA8B,kDAAG;AACjC;AACA;AACA,uBAAuB,oDAAI;AAC3B,uBAAuB,oDAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+CAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oDAAI;AACrC,iCAAiC,oDAAI;AACrC,oCAAoC,oDAAI;AACxC,gCAAgC,oDAAI;AACpC,gCAAgC,oDAAI;AACpC,iCAAiC,oDAAI;AACrC;AACA,uBAAuB,kDAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,oDAAI;AAC7E;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;;;;AC5OkC;AACT;AACG;;AAErD,sBAAsB,gEAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uDAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8DAAa;AACvC;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmB;;;;;;;;;;;;;;;;;;;ACzI+B;AACH;AACA;AACA;;AAE/C,oBAAoB,uDAAQ;AAC5B;AACA,gBAAgB,wBAAwB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oDAAI;AACjC,6BAA6B,oDAAI;AACjC,4BAA4B,oDAAI;AAChC,4BAA4B,oDAAI;AAChC,uBAAuB,oDAAI;AAC3B,uBAAuB,oDAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,oDAAI;AAC7E;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmB;;;;;;;;;;;;;;;;;;;;;AClFwC;AACV;AACF;AACA;AACA;AACJ;;AAE3C,kBAAkB,oDAAI;AACtB,kBAAkB,oDAAI;AACtB,kBAAkB,oDAAI;AACtB,kBAAkB,oDAAI;AACtB,gCAAgC,gEAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAI;AAC3B,oBAAoB,sDAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oDAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oDAAI;AACpC,yBAAyB,oDAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvH8B;AACT;AACH;AACA;AACA;AAC0E;AAC7B;AACrC;AACJ;AACN;AACY;AACjB;AACqB;AACF;AACf;AACa;AACjB;;AAExC,wBAAwB,gEAAY;AACpC;AACA;AACA;AACA,oBAAoB,uDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAI;AAChC,4BAA4B,oDAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAa;AAC/B,kBAAkB,oDAAS;AAC3B,kBAAkB,oDAAS;AAC3B,mBAAmB,iDAAO;AAC1B,0BAA0B,gEAAc;AACxC,wBAAwB,4DAAY;AACpC,qBAAqB,sDAAS;AAC9B,2BAA2B,kEAAe;AAC1C,4BAA4B,qEAAgB;AAC5C,2BAA2B,mEAAe;AAC1C,mBAAmB,kDAAO;AAC1B,6BAA6B,uEAAiB;AAC9C,qBAAqB,sDAAS;AAC9B,mBAAmB,iDAAO;AAC1B;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kEAAuB;AACjD,+BAA+B,oEAAyB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,KAAK;AAC/B,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,sBAAsB,+EAAiB,mBAAmB,+EAAiB;AAC3E;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qDAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,qBAAqB,oDAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;;;;ACzd6B;AACS;AACrB;;AAEtC,8BAA8B,gEAAY;AAC1C;AACA;AACA;AACA,oBAAoB,uDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAM;AACrB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;;;;ACnFgC;AACZ;AACA;;AAE/C,qBAAqB,gEAAY;AACjC;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAI;AAC3B,uBAAuB,oDAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkB;;;;;;;;;;;;;;;;;;ACvDgC;AACS;AACnB;;AAExC,+BAA+B,gEAAY;AAC3C;AACA;AACA;AACA,oBAAoB,uDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAO;AACvB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;;;;ACtF+B;AACZ;AACA;;AAE/C;AACA,sBAAsB,gEAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAI;AAC3B,uBAAuB,oDAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmB;;;;;;;;;;;;;;;;;;AC5DwC;AACZ;AACA;;AAE/C,6BAA6B,gEAAY;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAI;AAC3B,uBAAuB,oDAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;;;;;;;ACzEiC;AACE;AACd;AACA;AACA;AAC+D;;AAE9G,qBAAqB,gEAAY;AACjC;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAI;AAC3B,sBAAsB,oDAAI;AAC1B,6BAA6B,oDAAI;AACjC,sBAAsB,oDAAI;AAC1B,yBAAyB,oDAAI;AAC7B,uBAAuB,oDAAI;AAC3B,yBAAyB,oDAAI;AAC7B,4BAA4B,oDAAI;AAChC;AACA;AACA;AACA;AACA;AACA,0BAA0B,oDAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kEAAO;AACpC,aAAa,6EAAgB;AAC7B;AACA,eAAe,kFAAqB;AACpC,eAAe,kFAAqB;AACpC,gBAAgB,0EAAa;AAC7B,gBAAgB,0EAAa;AAC7B;AACA;AACA,qBAAqB,iBAAiB;AACtC,KAAK;AACL;AACA;AACA;AACA,4BAA4B,kEAAO;AACnC;AACA;AACA;AACA,cAAc,kFAAqB;AACnC,cAAc,kFAAqB;AACnC,eAAe,0EAAa;AAC5B,eAAe,0EAAa;AAC5B;AACA;AACA,oBAAoB,iBAAiB;AACrC,IAAI;AACJ,mBAAmB,uCAAuC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkB;;;;;;;;;;;;;;;;;;;;ACxPgC;AACS;AACrB;AACmF;AAChC;;AAEzF,sBAAsB,gEAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uDAAQ;AACjC,yBAAyB,uDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA,IAAI,oEAAyB,GAAG,4EAAe;AAC/C,IAAI,mEAAwB,GAAG,6EAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kEAAuB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAM;AACrB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oDAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmB;;;;;;;;;;;;;;;ACpHnB;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;;;ACJoB;AACK;;AAEpD;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,iEAAe;AACrB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oDAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,iEAAe;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,YAAY,oDAAI;AAChB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;;AAEmB;;;;;;;;;;;;;;;;;;;;ACtM4B;AACA;AAC0C;AACrC;AACb;;AAEvC;AACA,wBAAwB,gDAAO;AAC/B;AACA;AACA,sBAAsB,oDAAI;AAC1B,sBAAsB,oDAAI;AAC1B,MAAM,iEAAe;AACrB;AACA,IAAI;AACJ;AACA;AACA;AACA,wBAAwB,2DAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,iEAAe;AACpB,kBAAkB,oDAAI;AACtB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,wBAAwB,0DAAe;AACvC;AACA,IAAI,2BAA2B,2DAAgB;AAC/C;AACA,IAAI,2BAA2B,+DAAoB;AACnD;AACA;AACA,SAAS,oDAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;;AAEqB;;;;;;;;;;;;;;;;;ACvIrB;AACA;AACA;;AAEmE;;;;;;;;;;;;;;;;;;;;ACJoJ;;AAEvN;AACA;AACA,EAAE,8DAAmB;AACrB,EAAE,gEAAqB;AACvB,EAAE,8DAAmB;AACrB,EAAE,oEAAyB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,8DAAmB,eAAe,2DAAgB;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4DAAiB,qBAAqB,8DAAmB;AACrF,cAAc,8DAAmB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,0DAAe,+BAA+B,yDAAc;AAC9G,oBAAoB,iBAAiB,EAAE,YAAY;AACnD;AACA;AACA;AACA;AACA,2BAA2B,aAAa,EAAE,iBAAiB,iBAAiB,YAAY,EAAE,YAAY,IAAI,YAAY;AACtH;AACA,2BAA2B,UAAU,cAAc,YAAY,YAAY,aAAa,EAAE,YAAY,EAAE,aAAa;AACrH;AACA,4BAA4B,UAAU,cAAc,gBAAgB,oBAAoB,YAAY,SAAS;AAC7G;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAE0H;;;;;;;;;;;;;;;;AC9HxD;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2EAAgC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,kBAAkB,gCAAgC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA,kBAAkB,kCAAkC;AACpD;AACA;AACA;AACA;AACA,kBAAkB,iCAAiC;AACnD;AACA;AACA;AACA;AACA;AACA,kBAAkB,gCAAgC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;;;ACtGuC;AAC0E;;AAEtI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4DAAiB,mBAAmB,wDAAa,mBAAmB,yDAAc;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iEAAU;AAC3B;AACA;AACA,SAAS,iEAAU;AACnB;AACA;AACA,iBAAiB,iEAAU;AAC3B,iBAAiB,iEAAU;AAC3B,iBAAiB,iEAAU;AAC3B;AACA;AACA,iBAAiB,iEAAU;AAC3B,iBAAiB,iEAAU;AAC3B,iBAAiB,iEAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,iEAAU;AACnB;AACA;AACA,SAAS,iEAAU;AACnB;AACA;AACA,SAAS,iEAAU;AACnB;AACA;AACA,SAAS,iEAAU;AACnB;AACA;AACA,SAAS,iEAAU;AACnB;AACA;AACA,SAAS,iEAAU;AACnB;AACA;AACA,iBAAiB,iEAAU;AAC3B;AACA;AACA,SAAS,iEAAU;AACnB;AACA;AACA,iBAAiB,iEAAU;AAC3B;AACA;AACA,SAAS,iEAAU;AACnB;AACA;AACA,iBAAiB,iEAAU;AAC3B;AACA;AACA,SAAS,iEAAU;AACnB;AACA;AACA,iBAAiB,iEAAU;AAC3B;AACA;AACA,SAAS,iEAAU;AACnB;AACA;AACA,SAAS,iEAAU;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,4DAAiB,EAAE,8DAAmB,EAAE,wEAA6B;AACjI,0DAA0D,4DAAiB,EAAE,wDAAa,EAAE,wDAAa;;AAEnF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnHtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmkL;;;;;;;;;;;;;;;;;;AC3hBvgL;AACP;AACQ;;AAE7D;AACA,sBAAsB,0DAAS;AAC/B;AACA;AACA;AACA;AACA,oBAAoB,yDAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAc,GAAG,sDAAW;AAClD;AACA;AACA;AACA,uBAAuB,sDAAW;AAClC;AACA;AACA,cAAc,iEAAU;AACxB;AACA;AACA;AACA,SAAS,iEAAU;AACnB;AACA;AACA,cAAc,iEAAU;AACxB;AACA;AACA;AACA,SAAS,iEAAU;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,iBAAiB,KAAK,GAAG,WAAW,GAAG,gBAAgB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,sDAAW;AAC9D,sDAAsD,sDAAW;;AAE3C;;;;;;;;;;;;;;;AClFtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;;;ACxBwB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oDAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkE;;;;;;;;;;;;;;;;;ACvFJ;AACd;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,qDAAO,KAAK,mEAAmB;AACtC,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxD8D;AAC1B;AACT;AACH;AACE;AACoK;AACvK;AACA;AACA;AACI;AACA;AACU;;AAE5D,6BAA6B,gEAAY;AACzC;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uDAAU;AAClC,wBAAwB,uDAAU;AAClC;AACA,0BAA0B,qEAAiB;AAC3C,yBAAyB,qEAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,0DAAe,GAAG,0DAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gFAAQ,GAAG;AAChC;AACA;AACA;AACA;AACA,wBAAwB,uDAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2DAAgB,EAAE,KAAK,2DAAgB,EAAE;AACxD;AACA;AACA;AACA,mBAAmB,uDAAU;AAC7B;AACA;AACA;AACA;AACA,2BAA2B,2DAAY;AACvC,aAAa,4DAAiB;AAC9B;AACA,SAAS,uDAAY;AACrB,GAAG;AACH;AACA,8BAA8B,4DAAY;AAC1C;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uDAAU;AAClC,wBAAwB,uDAAU;AAClC,kBAAkB,wDAAa;AAC/B;AACA;AACA,wBAAwB,uDAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,uDAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,uDAAQ;AACd;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,8DAAmB,EAAE,8DAAmB,EAAE,8DAAmB;AAChG,kBAAkB,oBAAoB;AACtC;AACA;AACA,SAAS,8DAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8DAAmB;AAC5B;AACA;AACA;AACA;AACA,SAAS,8DAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;;ACjT6F;;AAEvH;AACA;AACA,yDAAyD,wDAAa;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yEAA8B;AACtD;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,6DAAkB,2CAA2C,6DAAkB;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;;;AClG0B;;AAEjD;AACA;AACA,wBAAwB,sDAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqE;;;;;;;;;;;;;;;;;AC1JQ;AACvB;;AAEtD;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+DAAc;AACvC;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4DAAiB;AACnC;AACA;AACA,KAAK,oBAAoB,mEAAwB;AACjD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;;ACxLgC;;AAExD;AACA;AACA;AACA;AACA,2BAA2B,iEAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmB;;;;;;;;;;;;;;;;ACpBqB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iDAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;ACvBtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8B;;;;;;;;;;;;;;;AC5C9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8B;;;;;;;;;;;;;;;ACzE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;AChB/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;AC9D/B;AACA;AACA;AACA;AACA;;AAE8B;;;;;;;;;;;;;;;ACN9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8B;;;;;;;;;;;;;;;ACb9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;;ACdiB;;AAEhD;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAc;AACpC,wBAAwB,yDAAc;AACtC;AACA;AACA;AACA,kBAAkB,gCAAgC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kCAAkC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;;;;;;;;;AC3CiR;AAC/P;AACA;AACA;AACA;AACE;AACA;AACA;;AAEtD;AACA,kBAAkB,4DAAiB;AACnC,gBAAgB,0DAAe;AAC/B,iBAAiB,2DAAgB;AACjC,mBAAmB,6DAAkB;AACrC,mBAAmB,6DAAkB;AACrC,mBAAmB,6DAAkB;AACrC,mBAAmB,6DAAkB;AACrC,mBAAmB,6DAAkB;AACrC,mBAAmB,6DAAkB;AACrC,mBAAmB,6DAAkB;AACrC,mBAAmB,6DAAkB;AACrC,eAAe,yDAAc;AAC7B,qBAAqB,gEAAqB;AAC1C,qBAAqB,+DAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA,sDAAsD,EAAE;AACxD;AACA,6CAA6C,GAAG,EAAE,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA,gEAAgE,qEAAQ,EAAE,oEAAO,EAAE,oEAAO,uEAAuE,qEAAQ;AACzK,sBAAsB,gFAAgF,qEAAQ,EAAE,oEAAO,EAAE,oEAAO,4GAA4G,IAAI,qEAAQ,CAAC,EAAE,oCAAoC,EAAE,wDAAwD;AACzV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,KAAK,EAAE,MAAM;AACnC,GAAG;AACH;AACA;AACA;AACA,gCAAgC,KAAK;AACrC;AACA;AACA;AACA;AACA,wCAAwC,yBAAyB;AACjE,IAAI;AACJ,0CAA0C,2BAA2B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW,MAAM,cAAc,WAAW,IAAI;AACrE;AACA,yBAAyB,WAAW,gBAAgB;AACpD;AACA,IAAI;AACJ,uBAAuB,WAAW,MAAM,cAAc,WAAW,IAAI;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,MAAM;AACN,kCAAkC,MAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;;ACnJ2B;AACQ;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,wBAAwB,+DAAY;AACpC,mEAAmE,uDAAQ,mBAAmB,uDAAQ;AACtG,wBAAwB,+DAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS,EAAE,UAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkB;;;;;;;;;;;;;;;;;ACxC2C;AACR;;AAErD;AACA,sBAAsB,0DAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,sDAAW;AACnF;AACA;AACA;AACA,wEAAwE,yDAAc;AACtF,4EAA4E,yDAAc;AAC1F,4EAA4E,yDAAc;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,iBAAiB,MAAM,GAAG,KAAK,GAAG,MAAM,GAAG,OAAO,GAAG,OAAO,GAAG,UAAU,GAAG,WAAW;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6B;;;;;;;;;;;;;;;;ACnHiF;;AAE9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,0DAAe;AACpC,qEAAqE,0DAAe;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uEAA4B,eAAe,wEAA6B;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;;;;;ACxCuB;AACG;AACA;AAC2a;;AAE7d;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2DAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,4DAAiB;AACjG,qBAAqB,sEAAuB;AAC5C,wBAAwB,mEAAoB;AAC5C;AACA;AACA,uBAAuB,yDAAc;AACrC,uBAAuB,yDAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,sEAA2B;AACvH,4FAA4F,wDAAa;AACzG;AACA,wFAAwF,yDAAc;AACtG,wFAAwF,yDAAc;AACtG,wFAAwF,yDAAc;AACtG;AACA,oGAAoG,oDAAS;AAC7G,cAAc,8DAAmB;AACjC;AACA;AACA,IAAI;AACJ,8BAA8B,2DAAgB,GAAG,8DAAmB;AACpE,IAAI;AACJ,qCAAqC,kEAAuB,GAAG,8DAAmB;AAClF;AACA,oBAAoB,iEAAsB;AAC1C;AACA,qBAAqB,iEAAsB;AAC3C,IAAI,sDAAsD,iEAAsB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2DAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,mEAAoB,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,mEAAoB,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS,mEAAoB,kBAAkB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,2DAAY;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,oDAAI,4BAA4B,oDAAI;AAC7C;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA,QAAQ,2DAAgB;AACxB;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA,2BAA2B,6DAAkB,oBAAoB,6DAAkB,oBAAoB,8DAAmB,oBAAoB,8DAAmB,IAAI,mEAAoB;AACzL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,0EAA0E,4DAAiB;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2DAAY;AAC5C,gCAAgC,sEAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAgB;AAC3C,2BAA2B,4DAAiB;AAC5C;AACA;AACA;AACA,qBAAqB,2DAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4BAA4B;AAC9C;AACA,4BAA4B,2DAAY;AACxC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEmB;;;;;;;;;;;;;;;;;;AChZ4B;AACmwB;;AAElzB;AACA,2BAA2B,4DAAiB;AAC5C,2BAA2B,2DAAgB;AAC3C,2BAA2B,2DAAgB;AAC3C,2BAA2B,2DAAgB;AAC3C,2BAA2B,0DAAe;AAC1C,2BAA2B,4DAAiB;AAC5C,2BAA2B,4DAAiB;AAC5C,2BAA2B,4DAAiB;AAC5C,2BAA2B,2DAAgB;AAC3C,2BAA2B,4DAAiB;AAC5C,2BAA2B,4DAAiB;AAC5C,2BAA2B,4DAAiB;AAC5C,2BAA2B,2DAAgB;AAC3C,2BAA2B,2DAAgB;AAC3C,2BAA2B,2DAAgB;AAC3C,2BAA2B,2DAAgB;AAC3C,2BAA2B,4DAAiB;AAC5C,2BAA2B,4DAAiB;AAC5C,2BAA2B,4DAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,KAAK;AAC9B;AACA;AACA;AACA;AACA;AACA,SAAS,4DAAiB;AAC1B,uBAAuB,iEAAsB;AAC7C;AACA,SAAS,0DAAe;AACxB,uBAAuB,+DAAoB;AAC3C;AACA,SAAS,2DAAgB;AACzB,uBAAuB,gEAAqB;AAC5C;AACA,SAAS,2DAAgB;AACzB,uBAAuB,gEAAqB;AAC5C;AACA,SAAS,2DAAgB;AACzB,uBAAuB,gEAAqB;AAC5C;AACA,SAAS,4DAAiB;AAC1B,uBAAuB,iEAAsB;AAC7C;AACA,SAAS,4DAAiB;AAC1B,uBAAuB,iEAAsB;AAC7C;AACA,SAAS,4DAAiB;AAC1B,uBAAuB,iEAAsB;AAC7C;AACA,SAAS,2DAAgB;AACzB,uBAAuB,gEAAqB;AAC5C;AACA,SAAS,4DAAiB;AAC1B,uBAAuB,iEAAsB;AAC7C;AACA,SAAS,4DAAiB;AAC1B,uBAAuB,iEAAsB;AAC7C;AACA,SAAS,4DAAiB;AAC1B,uBAAuB,iEAAsB;AAC7C;AACA,SAAS,2DAAgB;AACzB,uBAAuB,gEAAqB;AAC5C;AACA,SAAS,4DAAiB;AAC1B,uBAAuB,iEAAsB;AAC7C;AACA,SAAS,4DAAiB;AAC1B,uBAAuB,iEAAsB;AAC7C;AACA,SAAS,4DAAiB;AAC1B,uBAAuB,iEAAsB;AAC7C;AACA,SAAS,2DAAgB;AACzB,uBAAuB,gEAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oDAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oDAAI;AACtB;AACA;AACA;AACA;AACA;AACA,eAAe,yDAAc;AAC7B,6BAA6B,UAAU,cAAc,UAAU,uBAAuB,OAAO;AAC7F;AACA,sBAAsB,4DAAiB;AACvC,kBAAkB,YAAY,EAAE,kBAAkB,EAAE,oBAAoB,cAAc,SAAS;AAC/F,GAAG;AACH,YAAY,OAAO;AACnB;AACA;;AAE8C;;;;;;;;;;;;;;;;;AChJ8gB;AAC7f;;AAE/D;AACA,iBAAiB,4DAAiB;AAClC;AACA;AACA;AACA,iBAAiB,2DAAgB;AACjC;AACA;AACA;AACA;AACA,iBAAiB,2DAAgB;AACjC;AACA;AACA;AACA;AACA;AACA,iBAAiB,2DAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0DAAe;AAChC;AACA;AACA;AACA,iBAAiB,4DAAiB;AAClC;AACA;AACA;AACA;AACA,iBAAiB,4DAAiB;AAClC;AACA;AACA;AACA;AACA;AACA,iBAAiB,4DAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2DAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2DAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iEAAsB;AACvC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA,iBAAiB,gEAAqB;AACtC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA,iBAAiB,gEAAqB;AACtC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA,iBAAiB,2DAAgB;AACjC;AACA;AACA;AACA,iBAAiB,4DAAiB;AAClC;AACA;AACA;AACA;AACA,iBAAiB,4DAAiB;AAClC;AACA;AACA;AACA;AACA;AACA,iBAAiB,4DAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,+DAAoB;AACrC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA,iBAAiB,gEAAqB,qBAAqB,+DAAoB;AAC/E,iBAAiB,gEAAqB;AACtC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA,iBAAiB,iEAAsB;AACvC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA,iBAAiB,iEAAsB,qBAAqB,iEAAsB;AAClF,iBAAiB,iEAAsB;AACvC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA,iBAAiB,iEAAsB;AACvC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA,iBAAiB,iEAAsB,qBAAqB,iEAAsB;AAClF,iBAAiB,iEAAsB;AACvC;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,yBAAyB,wEAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;AC/OzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmB;;;;;;;;;;;;;;;;AClBoB;;AAEvC;AACA;AACA;AACA;AACA,qBAAqB,gDAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;;ACdoB;;AAE/C;AACA;AACA;AACA,eAAe,wDAAa;AAC5B;AACA;AACA;AACA,4EAA4E,wDAAa;AACzF;AACA,IAAI;AACJ;AACA,qEAAqE,wDAAa;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;;;;;;ACxEsB;AACC;AACM;AACgK;AACrK;;AAEhD,sBAAsB,0DAAS;AAC/B;AACA,wBAAwB,yDAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,kEAAuB;AACrE,GAAG;AACH;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA,0CAA0C,kEAAuB;AACjE;AACA,aAAa,oDAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gCAAgC,6DAAkB;AAClD;AACA,KAAK,kCAAkC,6DAAkB;AACzD;AACA,KAAK,kCAAkC,yDAAc;AACrD;AACA,KAAK,kCAAkC,2DAAgB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0DAAe;AAC7B;AACA,UAAU,uDAAY;AACtB,IAAI;AACJ,cAAc,0DAAe;AAC7B;AACA,UAAU,uDAAY;AACtB,IAAI;AACJ,cAAc,0DAAe;AAC7B;AACA,UAAU,uDAAY;AACtB,IAAI;AACJ,cAAc,0DAAe;AAC7B;AACA,UAAU,uDAAY;AACtB,IAAI;AACJ,GAAG;AACH;AACA;AACA,+CAA+C,kEAAuB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uDAAQ;AAC9B;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;;;ACjIyB;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0DAAe;AACnC,IAAI;AACJ,oBAAoB,0DAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kCAAkC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,sBAAsB,eAAe;AACrC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkD;;;;;;;;;;;;;;;;ACzLgD;;AAElG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,wDAAa;AACtB;AACA;AACA,SAAS,yDAAc;AACvB;AACA;AACA,SAAS,wDAAa;AACtB;AACA;AACA,SAAS,4DAAiB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;AC9C0B;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yDAAW;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4BAA4B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClHsB;AACG;AACD;AAC0/C;AACv/C;AACJ;AACX;AACqB;AACF;AACX;AACE;AACW;AACZ;AACX;AACS;AACA;AACc;AACF;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAa;AACjC,sBAAsB,uDAAU;AAChC,sBAAsB,uDAAU;AAChC;AACA;AACA;AACA;AACA,QAAQ,6DAAkB;AAC1B;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8CAAM,SAAS,yDAAW;AAC/C;AACA;AACA;AACA,EAAE;AACF,qBAAqB,8CAAM,SAAS,yDAAW;AAC/C;AACA;AACA;AACA,EAAE;AACF;AACA,UAAU,8DAAmB;AAC7B;AACA;AACA;AACA,aAAa,yDAAc;AAC3B,aAAa,yDAAc;AAC3B;AACA;AACA,kBAAkB,gDAAO;AACzB,mBAAmB,2DAAY;AAC/B;AACA;AACA,EAAE;AACF;AACA,yBAAyB,4DAAiB;AAC1C,kBAAkB,gDAAO;AACzB,mBAAmB,2DAAY;AAC/B;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,+DAAc;AAChD,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,uDAAQ;AACd;AACA;AACA;AACA;AACA;AACA,6BAA6B,uDAAQ,8DAA8D,uDAAQ;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,4DAAiB,GAAG,4DAAiB;AAC1E;AACA,mBAAmB,uDAAQ;AAC3B,mBAAmB,uDAAQ;AAC3B,gBAAgB,uDAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2DAAgB;AAChD,+BAA+B,0DAAe;AAC9C,iCAAiC,4DAAiB;AAClD,sCAAsC,2DAAgB;AACtD,sCAAsC,2DAAgB;AACtD,sCAAsC,2DAAgB;AACtD,oCAAoC,4DAAiB;AACrD,oCAAoC,4DAAiB;AACrD,oCAAoC,4DAAiB;AACrD,qCAAqC,4DAAiB;AACtD,qCAAqC,4DAAiB;AACtD,qCAAqC,4DAAiB;AACtD,sCAAsC,2DAAgB;AACtD,sCAAsC,2DAAgB;AACtD,sCAAsC,2DAAgB;AACtD,sCAAsC,gEAAqB;AAC3D,wCAAwC,kEAAuB;AAC/D,wCAAwC,2DAAgB;AACxD,6CAA6C,4DAAiB;AAC9D,6CAA6C,4DAAiB;AAC9D,6CAA6C,4DAAiB;AAC9D;AACA,8CAA8C,uEAA4B;AAC1E,gDAAgD,yEAA8B;AAC9E,6CAA6C,sEAA2B;AACxE,uCAAuC,gEAAqB;AAC5D,2CAA2C,iEAAsB;AACjE,oDAAoD,iEAAsB;AAC1E,6CAA6C,mEAAwB;AACrE,oDAAoD,mEAAwB;AAC5E,2CAA2C,iEAAsB;AACjE,oDAAoD,iEAAsB;AAC1E,iDAAiD,uEAA4B;AAC7E,0DAA0D,uEAA4B;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAgB;AACtC;AACA;AACA;AACA;AACA;AACA,sBAAsB,0DAAe,wBAAwB,2DAAgB;AAC7E,sBAAsB,4DAAiB;AACvC;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAiB,wBAAwB,4DAAiB;AAChF,sBAAsB,4DAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAiB,wBAAwB,4DAAiB;AAChF,sBAAsB,4DAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAiB,wBAAwB,4DAAiB;AAChF,sBAAsB,2DAAgB;AACtC;AACA;AACA,sBAAsB,2DAAgB;AACtC;AACA;AACA,sBAAsB,2DAAgB;AACtC;AACA;AACA,sBAAsB,iEAAsB;AAC5C;AACA;AACA,sBAAsB,gEAAqB;AAC3C;AACA;AACA,sBAAsB,gEAAqB;AAC3C;AACA;AACA,sBAAsB,gEAAqB;AAC3C;AACA;AACA,sBAAsB,2DAAgB;AACtC;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+DAAoB;AAC1C;AACA;AACA,sBAAsB,gEAAqB;AAC3C;AACA;AACA,sBAAsB,gEAAqB,wBAAwB,+DAAoB;AACvF,sBAAsB,iEAAsB;AAC5C;AACA;AACA,sBAAsB,iEAAsB;AAC5C;AACA;AACA,sBAAsB,iEAAsB,wBAAwB,iEAAsB;AAC1F,sBAAsB,iEAAsB;AAC5C;AACA;AACA,sBAAsB,iEAAsB;AAC5C;AACA;AACA,sBAAsB,iEAAsB,wBAAwB,iEAAsB;AAC1F,sBAAsB,iEAAsB;AAC5C;AACA;AACA,sBAAsB,iEAAsB;AAC5C;AACA;AACA,sBAAsB,iEAAsB,wBAAwB,iEAAsB;AAC1F,sBAAsB,gEAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4DAAiB;AAC7C;AACA,6BAA6B,8DAAmB;AAChD,IAAI;AACJ,6BAA6B,8DAAmB;AAChD;AACA;AACA;AACA;AACA;AACA,yBAAyB,oEAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2DAAY;AACpC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4DAAiB,GAAG,2DAAgB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uEAAiB;AAC9B;AACA;AACA,aAAa,qEAAgB;AAC7B;AACA;AACA,aAAa,0DAAW;AACxB;AACA;AACA,aAAa,4DAAY;AACzB;AACA;AACA,aAAa,uEAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,uDAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,sDAAW;AAC5D;AACA;AACA;AACA,iDAAiD,yDAAc;AAC/D,mDAAmD,yDAAc;AACjE,mDAAmD,yDAAc;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uDAAK;AAC7B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,8CAAM,OAAO,yDAAW;AAClD;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0DAAe;AACjC;AACA;AACA;AACA,kBAAkB,0DAAe;AACjC;AACA;AACA;AACA,kBAAkB,4DAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iCAAiC;AACvD,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wEAA6B,eAAe,uEAA4B;AAC3F,cAAc,yDAAc;AAC5B,MAAM,oBAAoB,uEAA4B,eAAe,sEAA2B;AAChG,cAAc,wDAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,iGAAiG,gEAAqB;AACtH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,iGAAiG,gEAAqB;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,qDAAI;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA,iBAAiB,6DAAkB;AACnC;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA,+BAA+B,gDAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0DAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uDAAU;AACjC;AACA,eAAe,0DAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uDAAU;AACjC;AACA,eAAe,4DAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,4EAA4E,sEAAiB;AAC7F;AACA;AACA,wEAAwE,sEAAiB;AACzF;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW,sDAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAa;AACjC;AACA,KAAK;AACL,0BAA0B,wDAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;;;AC/qD6D;AAC5C;;AAEhD,+BAA+B,yDAAW;AAC1C;AACA;AACA;AACA;AACA,iBAAiB,4DAAiB;AAClC;AACA,IAAI,oBAAoB,6DAAkB;AAC1C;AACA,IAAI,oBAAoB,6DAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;;ACtBwB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,4DAAiB;AACxE;AACA;AACA;AACA,KAAK;AACL,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sCAAsC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAE6B;;;;;;;;;;;;;;;;;ACjPsqB;AAC3pB;;AAExC;AACA;AACA;AACA;AACA,qBAAqB,gDAAO;AAC5B;AACA;AACA,SAAS,4DAAiB;AAC1B,YAAY,iEAAsB;AAClC;AACA,SAAS,0DAAe;AACxB,YAAY,+DAAoB;AAChC;AACA,SAAS,2DAAgB;AACzB,YAAY,gEAAqB;AACjC;AACA,SAAS,2DAAgB;AACzB,YAAY,gEAAqB;AACjC;AACA,SAAS,2DAAgB;AACzB,YAAY,gEAAqB;AACjC;AACA,SAAS,4DAAiB;AAC1B,YAAY,iEAAsB;AAClC;AACA,SAAS,4DAAiB;AAC1B,YAAY,iEAAsB;AAClC;AACA,SAAS,4DAAiB;AAC1B,YAAY,iEAAsB;AAClC;AACA,SAAS,2DAAgB;AACzB,YAAY,gEAAqB;AACjC;AACA,SAAS,4DAAiB;AAC1B,YAAY,iEAAsB;AAClC;AACA,SAAS,4DAAiB;AAC1B,YAAY,iEAAsB;AAClC;AACA,SAAS,4DAAiB;AAC1B,YAAY,iEAAsB;AAClC;AACA,SAAS,2DAAgB;AACzB,YAAY,gEAAqB;AACjC;AACA,SAAS,4DAAiB;AAC1B,YAAY,iEAAsB;AAClC;AACA,SAAS,4DAAiB;AAC1B,YAAY,iEAAsB;AAClC;AACA,SAAS,4DAAiB;AAC1B,YAAY,iEAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;;;;AClE+B;AACN;AACJ;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,+BAA+B,yDAAW;AAC1C,iCAAiC,yDAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,KAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6DAAkB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,gCAAgC;AAC5F;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,UAAU,8DAA8D,aAAa;AACnI;AACA,KAAK;AACL,4BAA4B,oEAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA,2BAA2B,oEAAgB;AAC3C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,YAAY,aAAa,QAAQ,IAAI,MAAM,kBAAkB,OAAO;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B,eAAe,MAAM,KAAK,SAAS;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;ACtMmhC;;AAE1iC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gCAAgC;AACnD;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yDAAc;AACtB;AACA;AACA;AACA;AACA,QAAQ,yDAAc;AACtB;AACA;AACA;AACA;AACA,QAAQ,0DAAe;AACvB;AACA;AACA;AACA;AACA,QAAQ,6DAAkB;AAC1B;AACA;AACA;AACA;AACA,QAAQ,+DAAoB;AAC5B;AACA;AACA;AACA;AACA,QAAQ,4DAAiB;AACzB;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA,QAAQ,4DAAiB;AACzB;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA,QAAQ,uEAA4B;AACpC;AACA;AACA;AACA,QAAQ,wEAA6B;AACrC;AACA;AACA;AACA,QAAQ,uEAA4B;AACpC;AACA;AACA;AACA,QAAQ,wEAA6B;AACrC;AACA;AACA;AACA,QAAQ,+DAAoB;AAC5B;AACA;AACA;AACA,QAAQ,gEAAqB;AAC7B;AACA;AACA;AACA,QAAQ,+DAAoB;AAC5B;AACA;AACA;AACA,QAAQ,8DAAmB;AAC3B;AACA;AACA;AACA,QAAQ,+DAAoB;AAC5B;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,QAAQ,4DAAiB;AACzB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAkB;AAC1B;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ,8DAAmB;AAC3B;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ,6DAAkB;AAC1B;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ,8DAAmB;AAC3B;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA,QAAQ,4DAAiB;AACzB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAwB;AAChC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ,8DAAmB;AAC3B;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA,QAAQ,4DAAiB;AACzB;AACA;AACA;AACA;AACA,QAAQ,0DAAe;AACvB;AACA;AACA;AACA;AACA,QAAQ,0DAAe;AACvB;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA,QAAQ,2DAAgB;AACxB;AACA;AACA;AACA;AACA,QAAQ,4DAAiB;AACzB;AACA;AACA;AACA;AACA,QAAQ,4DAAiB;AACzB;AACA;AACA;AACA;AACA,QAAQ,4DAAiB;AACzB;AACA;AACA;AACA;AACA,QAAQ,4DAAiB;AACzB;AACA;AACA;AACA;AACA,QAAQ,6DAAkB;AAC1B;AACA;AACA;AACA;AACA,QAAQ,6DAAkB;AAC1B;AACA;AACA;AACA;AACA,QAAQ,8DAAmB;AAC3B;AACA;AACA;AACA;AACA,QAAQ,8DAAmB;AAC3B;AACA;AACA;AACA;AACA,QAAQ,8DAAmB;AAC3B;AACA;AACA;AACA;AACA,QAAQ,8DAAmB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,0BAA0B,8BAA8B;AACxD;AACA;AACA,OAAO;AACP,0BAA0B,8BAA8B;AACxD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;;ACzfwB;;AAEhD,gCAAgC,yDAAW;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrB7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE85D;;;;;;;;;;;;;;;;;;;;;AClKl3D;AACH;AACC;AACF;AACO;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,wBAAwB,WAAW,GAAG,aAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,qBAAqB,kDAAG;AACxB,aAAa,6CAAG;AAChB;AACA,sBAAsB,UAAU;AAChC,KAAK;AACL,mBAAmB,UAAU,MAAM,UAAU;AAC7C;AACA;AACA;AACA;AACA,aAAa,6CAAG;AAChB,WAAW,qDAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6CAAG;AACrB,cAAc,+CAAI;AAClB;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oDAAI;AAC1B,kBAAkB,OAAO,IAAI,KAAK,UAAU,WAAW,gBAAgB,YAAY;AACnF;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;;;;ACrQqC;AACZ;AACY;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,gEAAY;AACxC;AACA;AACA;AACA;AACA,gDAAgD,oDAAI;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,uEAAe;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oDAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,uEAAe;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,kCAAkC;AAClC,oCAAoC;AACpC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA,YAAY,oDAAI;AAChB;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEyB;;;;;;;;;;;;;;;;;;;;AC1kBsB;AACA;AACiD;AACrC;AACb;;AAE9C;AACA,8BAA8B,uDAAa;AAC3C,yCAAyC;AACzC;AACA,uBAAuB,oDAAI;AAC3B,uBAAuB,oDAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,gEAAe;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,uEAAe;AACpB,kBAAkB,oDAAI;AACtB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,wBAAwB,gEAAe;AACvC;AACA,IAAI,2BAA2B,iEAAgB;AAC/C;AACA,IAAI,2BAA2B,qEAAoB;AACnD;AACA;AACA,SAAS,oDAAI;AACb;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,EAAE;AACF;;AAE2B;;;;;;;;;;;;;;;;;AC9IoB;AACA;;AAE/C;AACA;AACA;AACA,sBAAsB,oDAAI;AAC1B,sBAAsB,oDAAI;AAC1B,yBAAyB,oDAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoB;;;;;;;;;;;;;;;;;;;;ACzDuC;AACZ;AACD;AACI;AACT;;AAEzC;AACA;AACA,2BAA2B,gEAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kDAAQ;AAC9B;AACA;AACA;AACA,WAAW,oDAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,MAAM,sDAAO;AACb,iBAAiB,sDAAO;AACxB;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,MAAM,0DAAS;AACf,iBAAiB,0DAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,SAAS,eAAe;AAC3B;AACA;AACA;AACA;AACA,GAAG,SAAS,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEwB;;;;;;;;;;;;;;;ACtIxB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEiB;;;;;;;;;;;;;;;;;ACrBjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;;;;;;;;;;;;;;;;;ACjCe;AACA;;AAE/C;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAI;AACvB,kBAAkB,oDAAI;AACtB,oBAAoB,oDAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,qDAAqD;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mCAAmC;AACtD;AACA;AACA;AACA;AACA,IAAI;AACJ,mBAAmB,mCAAmC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mCAAmC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoB;;;;;;;;;;;;;;;;;;;ACpLyC;AACH;AACS;AACqG;;AAExK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2EAAW;AACnC;AACA;AACA,kBAAkB,kEAAO;AACzB,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA,aAAa,kFAAqB;AAClC,aAAa,kFAAqB;AAClC,SAAS,gFAAmB;AAC5B,cAAc,0EAAa;AAC3B,cAAc,2EAAc;AAC5B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qEAAY;AAClC,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gFAAmB;AACpC;AACA;AACA,IAAI,oBAAoB,gFAAmB;AAC3C;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;;AC1GuB;;AAEhD;AACA,uDAAuD,wDAAa;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;;;;;;;;;;;AC7ByB;AACgB;AAC+M;AACnN;AACzB;AACiB;AACW;AAC3B;AACW;AACe;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oDAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4BAA4B;AAC9C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD;AACA;AACA,mBAAmB,8BAA8B;AACjD;AACA;AACA,mBAAmB,+BAA+B;AAClD;AACA;AACA,mBAAmB,8BAA8B;AACjD;AACA,yGAAyG,mEAAwB;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4BAA4B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,mBAAmB,8BAA8B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oEAAW;AAC9B,uBAAuB,oEAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+BAA+B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,2BAA2B,6EAAgB,sBAAsB,+EAAkB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kFAAqB;AACnC;AACA,iBAAiB,yEAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,2BAA2B;AACtE,yBAAyB,UAAU,wBAAwB,sEAAY,aAAa;AACpF,oBAAoB,sEAAY;AAChC,sBAAsB,sEAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4CAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4EAAe;AAC1C,6BAA6B,oFAAuB;AACpD;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kFAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA,wBAAwB,8EAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,sBAAsB,4EAAe,iBAAiB,6EAAgB;AAC/E;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kFAAqB;AAC3C,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mFAAsB;AAC3C,MAAM;AACN;AACA,2BAA2B,6EAAgB,sBAAsB,+EAAkB;AACnF;AACA;AACA;AACA,qCAAqC,6EAAgB;AACrD,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA,cAAc,0CAAI;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gFAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oCAAoC;AACxD;AACA;AACA,oCAAoC,sEAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,4BAA4B;AAC9C;AACA;AACA;AACA;AACA;AACA,qBAAqB,4CAAK;AAC1B;AACA;AACA,kBAAkB,gCAAgC;AAClD;AACA;AACA,4BAA4B,2DAAY;AACxC;AACA;AACA;AACA;AACA;AACA,0CAA0C,sEAAiB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;;ACjlBuC;;AAE/D;AACA;AACA,mBAAmB,oEAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mCAAmC;AACrD;AACA;AACA;AACA;AACA;AACA;;AAEiB;;;;;;;;;;;;;;;;AC9CkC;;AAEnD,gCAAgC,2DAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6B;;;;;;;;;;;;;;;;;;;;;;;;;ACnCiB;AACF;AACA;AACA;AACA;AACO;AAC+F;AACvE;AACA;AACT;;AAElE,yBAAyB,oDAAI;AAC7B,sBAAsB,oDAAI;AAC1B,mBAAmB,oDAAI;AACvB,4BAA4B,oDAAI;AAChC,4BAA4B,oDAAI,QAAQ,oDAAI,QAAQ,oDAAI,QAAQ,oDAAI,QAAQ,oDAAI,QAAQ,oDAAI,QAAQ,oDAAI,QAAQ,oDAAI;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAW;AACrC;AACA;AACA,yBAAyB,sDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wDAAa,EAAE,wDAAa,EAAE,yDAAc,EAAE,qDAAU,EAAE,4DAAiB;AAC7F;AACA;AACA;AACA;AACA,qBAAqB,iEAAsB;AAC3C,mBAAmB,oDAAI;AACvB;AACA,0BAA0B,oDAAI;AAC9B;AACA;AACA;AACA;AACA,sBAAsB,oDAAI;AAC1B;AACA,4BAA4B,oDAAI;AAChC,sBAAsB,oDAAI;AAC1B;AACA,0BAA0B,oDAAI;AAC9B;AACA;AACA,8BAA8B,oDAAI;AAClC;AACA,+BAA+B,oDAAI;AACnC;AACA,qBAAqB,2DAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mHAAmH,oDAAI;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oFAAmB;AACtD;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,2EAAe,+BAA+B,oFAAmB;AACtH;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,oDAAI;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,oDAAI;AACrD;AACA;AACA;AACA,mBAAmB,oDAAI;AACvB,2BAA2B,iEAAsB;AACjD,GAAG,oDAAI;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iEAAsB;AAClD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iEAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,oDAAI;AACxD;AACA;AACA,SAAS,oDAAI;AACb;AACA;AACA;AACA,+BAA+B,iEAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iEAAsB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkB;;;;;;;;;;;;;;;;;;;AC9eyC;AACT;AACF;AACE;;AAElD,+BAA+B,gEAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,2DAAY;AAChB;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wDAAa;AACjC;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA,uCAAuC,wDAAa;AACpD;AACA;AACA,oBAAoB,wDAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;ACxX5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;AC9BxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;;AC7B2B;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6DAAa;AACzB,IAAI;AACJ,YAAY,6DAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3CtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEonF;;;;;;;;;;;;;;;AC/JpnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;;;;ACrFyB;AACS;AACf;;AAEzC;AACA;AACA,0BAA0B,kDAAQ;AAClC,sBAAsB;AACtB;AACA;AACA,sFAAsF,oDAAI;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAI,yBAAyB,oDAAI,wBAAwB,oDAAI,wBAAwB,oDAAI,yBAAyB,oDAAI,yBAAyB,oDAAI,0BAA0B,oDAAI,0BAA0B,oDAAI;AACtO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAI;AACzB,qBAAqB,oDAAI;AACzB,qBAAqB,oDAAI;AACzB,iBAAiB,oDAAI;AACrB,mBAAmB,gBAAgB;AACnC,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAiB;AACpC;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;;AChFoC;AACH;;AAExD,8BAA8B,oEAAgB;AAC9C,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAiB;AACpC;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;;;ACjBoB;AACN;;AAEzC;AACA;AACA,+BAA+B,kDAAQ;AACvC;AACA;AACA,kBAAkB,oDAAI;AACtB,0BAA0B,oDAAI;AAC9B,mBAAmB,oDAAI;AACvB,kBAAkB,oDAAI;AACtB,qBAAqB,oDAAI;AACzB,sBAAsB,oDAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;;;ACrL+B;AACH;;AAExD,2BAA2B,oEAAgB;AAC3C,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAiB;AACpC;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;;;AClBmC;AACH;;AAExD,+BAA+B,oEAAgB;AAC/C,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAiB;AACpC;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;;ACjB0B;;AAEtD,2BAA2B,+DAAc;AACzC,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;;;;AClCuB;AACA;;AAE/C;AACA;AACA;AACA,gBAAgB,oDAAI;AACpB,gBAAgB,oDAAI;AACpB,gBAAgB,oDAAI;AACpB,kBAAkB,oDAAI;AACtB,kBAAkB,oDAAI;AACtB,wBAAwB,oDAAI;AAC5B;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oDAAI;AACpB,gBAAgB,oDAAI;AACpB,gBAAgB,oDAAI;AACpB,gBAAgB,oDAAI;AACpB,gBAAgB,oDAAI;AACpB,gBAAgB,oDAAI;AACpB,kBAAkB,oDAAI;AACtB,kBAAkB,oDAAI;AACtB;AACA;AACA;AACA,iBAAiB,mBAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oDAAI;AACpB,gBAAgB,oDAAI;AACpB,eAAe,oDAAI;AACnB,kBAAkB,oDAAI;AACtB,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+C;;;;;;;;;;;;;;;;ACjI2B;;AAE1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,oEAAgB;AACjC;AACA;AACA,kBAAkB,qEAAiB;AACnC;AACA;;AAEoB;;;;;;;;;;;;;;;;;;ACtB2B;AACS;AACf;;AAEzC,4BAA4B,kDAAQ;AACpC,sBAAsB;AACtB;AACA;AACA,sFAAsF,oDAAI;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAiB;AACpC;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;;;AC5C+B;AACf;;AAEzC,6BAA6B,kDAAQ;AACrC,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAiB;AACpC;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;;;;ACnDqB;AACS;AACf;;AAEzC,4BAA4B,kDAAQ;AACpC,sBAAsB;AACtB;AACA;AACA;AACA;AACA,mGAAmG,oDAAI;AACvG;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qEAAiB;AACpC;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;;;;;;;ACnD+B;AACjB;AACK;AACA;AACA;AACA;;AAE5C,wCAAwC,oDAAI;AAC5C,+BAA+B,oDAAI;AACnC,+BAA+B,oDAAI;AACnC,gCAAgC,oDAAI;AACpC,iCAAiC,oDAAI;AACrC,0CAA0C,oDAAI;AAC9C,oBAAoB,oDAAI;AACxB,oBAAoB,oDAAI;AACxB,qBAAqB,oDAAI;AACzB,yBAAyB,oDAAI;AAC7B,qBAAqB,oDAAI;AACzB,yBAAyB,oDAAI;AAC7B,mBAAmB,oDAAI;AACvB,mBAAmB,oDAAI;AACvB,eAAe,oDAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAY;AACpC;AACA;AACA;AACA,kBAAkB,+CAAI;AACtB;AACA,2BAA2B,oDAAI;AAC/B,2BAA2B,oDAAI;AAC/B,wBAAwB,oDAAI;AAC5B,8BAA8B,oDAAI;AAClC,sBAAsB,oDAAI;AAC1B,sBAAsB,oDAAI;AAC1B,yBAAyB,oDAAI;AAC7B;AACA,4BAA4B,oDAAI;AAChC;AACA;AACA;AACA,4BAA4B,oDAAI;AAChC;AACA;AACA,2BAA2B,oDAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAI;AACzB;AACA;AACA;AACA;AACA;AACA,kBAAkB,oDAAI;AACtB;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU,GAAG,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,UAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oDAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAI;AACvB;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAI;AACvB;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAI;AACvB;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAI;AACvB;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAI;AACvB;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA,mBAAmB,oDAAI;AACvB;AACA,oBAAoB,oDAAI;AACxB;AACA,KAAK;AACL,YAAY,oDAAI;AAChB;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAI;AACvB;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAI;AACvB;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;;;;;AC1oB0B;AACc;AACH;AACmJ;;AAE7M;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gFAAmB,6BAA6B,gFAAmB,GAAG,8EAAiB;AACzH;AACA;AACA,QAAQ,8EAAiB;AACzB;AACA;AACA,YAAY,kEAAO;AACnB,oBAAoB,KAAK;AACzB;AACA;AACA;AACA;AACA,QAAQ,6EAAgB;AACxB,YAAY,kFAAqB;AACjC,YAAY,kFAAqB;AACjC;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,mGAAmG,8EAAiB;AACpH,EAAE,uEAAgB;AAClB;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,oEAAoE,kEAAO;AAC3E;AACA;AACA;AACA;AACA;AACA,oBAAoB,8EAAiB,GAAG,6EAAgB,GAAG,gFAAmB;AAC9E,aAAa,kFAAqB;AAClC,aAAa,kFAAqB;AAClC;AACA;AACA,GAAG;AACH,EAAE,uEAAgB;AAClB;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,oEAAoE,kEAAO;AAC3E;AACA;AACA;AACA;AACA,SAAS,6EAAgB;AACzB,eAAe,uFAA0B;AACzC,aAAa,kFAAqB;AAClC,aAAa,kFAAqB;AAClC;AACA,GAAG;AACH;AACA,mBAAmB,oDAAI;AACvB;AACA,kBAAkB,YAAY;AAC9B,GAAG,uEAAgB;AACnB;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,GAAG,uEAAgB;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,EAAE,uEAAgB;AAClB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,kEAAO;AAC3E;AACA;AACA;AACA;AACA;AACA,eAAe,uFAA0B;AACzC,aAAa,kFAAqB;AAClC,aAAa,kFAAqB;AAClC;AACA,GAAG;AACH;AACA,mBAAmB,oDAAI;AACvB;AACA,kBAAkB,YAAY;AAC9B,GAAG,uEAAgB;AACnB;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC,GAAG,uEAAgB;AACnB;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,uEAAgB;AACnB;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ,GAAG,uEAAgB;AACnB;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;;AC7KwB;AACS;;AAExD,0BAA0B,oDAAI,gBAAgB,oDAAI,eAAe,oDAAI,gBAAgB,oDAAI,eAAe,oDAAI,gBAAgB,oDAAI;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA,uBAAuB,gEAAqB;AAC5C,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;;ACnC6C;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uEAAe;;AAEhB;;;;;;;;;;;;;;;;;;;ACfqC;AACgE;AACxD;AACT;;AAE7D;AACA,qBAAqB,kEAAO;AAC5B,WAAW,WAAW,EAAE,KAAK;AAC7B;AACA;AACA,UAAU,8EAAiB;AAC3B,YAAY,2EAAc;AAC1B,YAAY,2EAAc;AAC1B,QAAQ,gFAAmB;AAC3B,aAAa,2EAAc;AAC3B,aAAa,2EAAc;AAC3B;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA,iCAAiC,2EAAW;AAC5C;AACA;AACA,eAAe,uEAAa;AAC5B;AACA;AACA,EAAE;AACF;;AAE+B;;;;;;;;;;;;;;;;;;;AChCgB;AACD;AACS;;AAEvD,sBAAsB,oDAAI;AAC1B;AACA,kBAAkB,uDAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2C;;;;;;;;;;;;;;;;;;;;;AC9BI;AACmB;AACwB;AACG;AACnB;AACnB;;AAEvD;AACA,OAAO,+EAAkB;AACzB;AACA;AACA;AACA;AACA,0BAA0B,oDAAI;AAC9B,yBAAyB,oDAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kGAAsB;AACvD,iBAAiB,mEAAa;AAC9B;AACA;AACA,6BAA6B,+EAAa;AAC1C;AACA;AACA,wBAAwB,uEAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2EAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;;;;;ACnEmG;AACrD;AACI;AACX;;AAE7D;AACA,kCAAkC,yEAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAO;AAC7B;AACA;AACA;AACA;AACA;AACA,wBAAwB,wFAA2B,GAAG,0EAAa;AACnE,cAAc,0EAAa;AAC3B,aAAa,kFAAqB;AAClC,aAAa,kFAAqB;AAClC,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI;AACJ,sBAAsB,6EAAY;AAClC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;;;;;AChG6H;AACxF;AACI;AACX;;AAE7D;AACA,kCAAkC,yEAAU;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAO;AAC7B;AACA;AACA;AACA;AACA;AACA,cAAc,2EAAc;AAC5B,cAAc,2EAAc;AAC5B,aAAa,kFAAqB;AAClC,aAAa,kFAAqB;AAClC,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI;AACJ,sBAAsB,6EAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,qFAAwB,GAAG,8EAAiB;AACnF;AACA;AACA;AACA,aAAa,6EAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;;;;;;;;AChGkB;AAC+D;AACnD;AACO;AACA;AACI;AACV;;AAE9D,kCAAkC,sDAAK;AACvC;AACA;AACA;AACA,8BAA8B,yEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAO;AAC7B;AACA,WAAW,8EAAiB;AAC5B;AACA;AACA;AACA,cAAc,2EAAc;AAC5B,cAAc,2EAAc;AAC5B,aAAa,kFAAqB;AAClC,aAAa,kFAAqB;AAClC,GAAG;AACH,2BAA2B,6EAAY;AACvC,YAAY,sBAAsB,GAAG;AACrC;AACA;AACA;AACA,GAAG;AACH,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA,sBAAsB,wDAAa;AACnC;AACA;AACA;AACA;AACA,qBAAqB,0BAA0B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,uDAAY;AAC3E,2BAA2B,yEAAU;AACrC,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;;;;AC/F0C;AACD;AACA;;AAEpE,6BAA6B,yEAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,qBAAqB,0EAAa;AAClC,uBAAuB,yEAAU;AACjC;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtByB;AACJ;AAC6E;AACtD;AACM;AACJ;AACZ;AACC;AACH;AACI;AACW;AACX;AACM;;AAEpE;AACA;AACA,OAAO,mFAAsB;AAC7B;AACA,OAAO,yFAA4B;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAI;AACnB;AACA,iBAAiB,gBAAgB;AACjC,2CAA2C,wDAAM;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAI;AACnB;AACA,iBAAiB,gBAAgB;AACjC,6CAA6C,wDAAM;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAI;AACnB,eAAe,oDAAI;AACnB,eAAe,oDAAI;AACnB;AACA;AACA,iBAAiB,qBAAqB;AACtC,8CAA8C,wDAAM;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAO;AACnB;AACA;AACA;AACA;AACA,aAAa,2EAAc;AAC3B,aAAa,2EAAc;AAC3B;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2EAAW;AACnC;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA,gCAAgC,WAAW,GAAG,kBAAkB;AAChE;AACA;AACA,EAAE;AACF;AACA;AACA,8BAA8B,WAAW,GAAG,cAAc;AAC1D;AACA;AACA,EAAE;AACF;AACA;AACA,4BAA4B,WAAW,GAAG,cAAc,GAAG,kBAAkB;AAC7E;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA,uBAAuB,iFAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kEAAU;AAC9B,oBAAoB,kEAAU;AAC9B,6BAA6B,qCAAqC;AAClE,mCAAmC,qCAAqC;AACxE;AACA,sBAAsB,YAAY,GAAG,WAAW,GAAG,WAAW,GAAG,WAAW,GAAG,WAAW,GAAG,WAAW;AACxG;AACA,cAAc,qFAAiB;AAC/B;AACA,0CAA0C,YAAY,IAAI,oDAAoD,EAAE,iDAAiD,sBAAsB,WAAW,6BAA6B,WAAW,6BAA6B,WAAW,6BAA6B,WAAW,6BAA6B,WAAW,kCAAkC,6CAA6C;AACjb,WAAW,0EAAoB,oBAAoB,QAAQ,IAAI,sEAAY,aAAa;AACxF;AACA,sBAAsB,0EAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8BAA8B;AAC/C;AACA;AACA,4BAA4B,8EAAY;AACxC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG,0EAAkB;AACrB;AACA;AACA;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;;;;;ACjUmB;AACA;AACA;AACD;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,mBAAmB,QAAQ;AAC3B,6BAA6B,EAAE;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,gBAAgB,oDAAI;AACpB,gBAAgB,oDAAI;AACpB,gBAAgB,oDAAI;AACpB,gBAAgB,oDAAI;AACpB;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B,oBAAoB,GAAG;AACvB;AACA;AACA;AACA,aAAa,uDAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;;AAEgC;;;;;;;;;;;;;;;;;;;;;;;;;ACzPyE;AACZ;AACyC;AAClF;AACqB;AAC3B;AACwB;AACR;AACe;AAC9B;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uDAAQ;AACzB,iBAAiB,uDAAQ;AACzB;AACA,kBAAkB,aAAa,GAAG,cAAc,GAAG,oBAAoB,GAAG,OAAO,GAAG,OAAO,GAAG,eAAe,GAAG,QAAQ;AACxH;AACA;AACA;AACA,yBAAyB,uDAAU;AACnC;AACA,qHAAqH,EAAE;AACvH,qBAAqB,kBAAkB,SAAS,cAAc,wBAAwB,6BAA6B,yBAAyB,wBAAwB,yDAAc,0BAA0B;AAC5M;AACA,uBAAuB,sEAAY,gCAAgC,sDAAW,QAAQ,sEAAY,WAAW,sEAAY,oBAAoB,qFAAe,oCAAoC,qFAAe;AAC/M,SAAS,2EAAW;AACpB;AACA;AACA,qBAAqB,8EAAiB;AACtC,sBAAsB,4EAAe;AACrC,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,mFAAmF,sDAAW;AAC9F,+BAA+B,sDAAW;AAC1C,sBAAsB,4DAAQ;AAC9B;AACA,iBAAiB,0EAAa;AAC9B,+BAA+B,qDAAU,GAAG,uDAAY;AACxD;AACA;AACA;AACA;AACA;AACA,mBAAmB,4DAAiB,2BAA2B,wDAAa,GAAG,qDAAU;AACzF,yBAAyB,4DAAiB,GAAG,yDAAc;AAC3D;AACA;AACA;AACA;AACA;AACA,gCAAgC,kGAAsB;AACtD,kBAAkB,qFAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAE0C;;;;;;;;;;;;;;;;;;;;;ACtY2C;AACtC;AACwF;AAC1E;AACE;AACkB;;AAEjF;AACA,iBAAiB,gBAAgB;AACjC,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,kBAAkB,oEAAW;AAC7B;AACA;AACA;AACA,wDAAwD,gFAAmB;AAC3E;AACA;AACA,sDAAsD,gFAAmB;AACzE;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qDAAqD,gFAAmB;AACxE,qDAAqD,gFAAmB;AACxE,qDAAqD,gFAAmB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8FAA8B,CAAC,gFAAQ,GAAG;AAC3D;AACA,IAAI,IAAI;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oDAAI;AACjB;AACA;AACA,aAAa,kEAAO,cAAc,gFAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,2EAAc;AAC5B,cAAc,2EAAc;AAC5B,aAAa,kFAAqB;AAClC,aAAa,kFAAqB;AAClC,GAAG;AACH;AACA,IAAI,IAAI;AACR;AACA;;AAE4B;;;;;;;;;;;;;;;;;;;;ACrIqB;AACF;AACA;AACA;AACgB;;AAE/D,iBAAiB,oDAAI;AACrB,iBAAiB,oDAAI;AACrB,iBAAiB,oEAAW;AAC5B,kBAAkB,oEAAW;AAC7B,uBAAuB,sDAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oDAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oDAAI;AACpB,gBAAgB,oDAAI;AACpB,gBAAgB,oDAAI;AACpB;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oDAAI;AACpB,gBAAgB,oDAAI;AACpB,gBAAgB,oDAAI;AACpB,kBAAkB,oDAAI;AACtB,kBAAkB,oDAAI;AACtB;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B,+BAA+B,EAAE;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA,mBAAmB,gBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;;;;;;;;;;ACrTyB;AACA;AACsE;AACvE;AACK;AACjB;AACgB;AACsB;AACA;;AAExE,gBAAgB,oDAAI;AACpB,2BAA2B,oDAAI;AAC/B,4BAA4B,oDAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oDAAI;AACpC,iCAAiC,oDAAI;AACrC;AACA;AACA;AACA;AACA,6DAA6D,6EAAgB;AAC7E;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA,2BAA2B,6EAAY;AACvC,aAAa,4EAAe;AAC5B;AACA,SAAS,wEAAW;AACpB;AACA,GAAG;AACH,wBAAwB,6EAAY;AACpC,UAAU,0EAAa;AACvB;AACA,GAAG;AACH;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA,mBAAmB,0CAAI;AACvB;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAY;AACtC;AACA;AACA;AACA;AACA,4CAA4C,sDAAW;AACvD,qBAAqB,2DAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;;;;;;;ACrI2C;AACwB;AACyC;AAClF;AACqB;AACnB;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA,mFAAmF,sDAAW;AAC9F,+BAA+B,sDAAW;AAC1C,sBAAsB,4DAAQ;AAC9B;AACA,iBAAiB,0EAAa;AAC9B,+BAA+B,qDAAU,GAAG,uDAAY;AACxD;AACA;AACA;AACA;AACA;AACA,mBAAmB,4DAAiB,2BAA2B,wDAAa,GAAG,qDAAU;AACzF,yBAAyB,4DAAiB,GAAG,yDAAc;AAC3D;AACA;AACA;AACA;AACA;AACA,gCAAgC,kGAAsB;AACtD,kBAAkB,qFAAiB;AACnC,4BAA4B,+DAAM;AAClC;AACA;AACA;AACA;AACA;;AAEgC;;;;;;;;;;;;;;;;;ACvF2B;AACa;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gEAAY;AACvC;AACA;AACA;AACA;AACA;AACA,6DAA6D,sBAAsB;AACnF;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,6EAAgB;AACzB,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEwB;;;;;;;;;;;;;;;;;;;;;;;;;AC1O6D;AACrB;AACjB;AACA;AACA;AACA;AAC2G;AAC7F;AACE;AACH;;AAE5D;AACA;AACA,iBAAiB,QAAQ;AACzB,2CAA2C,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oEAAW;AAC7B;AACA;AACA,uDAAuD,8EAAiB;AACxE,4DAA4D,gFAAmB;AAC/E,4DAA4D,gFAAmB;AAC/E;AACA;AACA;AACA;AACA,2DAA2D,gFAAmB;AAC9E,2DAA2D,gFAAmB;AAC9E,6DAA6D,gFAAmB;AAChF,+DAA+D,gFAAmB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yEAAoB,CAAC,gFAAQ,GAAG;AACjD;AACA,IAAI,IAAI;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oDAAI;AACjB;AACA;AACA,aAAa,kEAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,2EAAc;AAC5B,cAAc,2EAAc;AAC5B,aAAa,kFAAqB;AAClC,aAAa,kFAAqB;AAClC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qEAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oDAAI;AACpB,gBAAgB,oDAAI;AACpB,gBAAgB,oDAAI;AACpB;AACA,kBAAkB,oDAAI;AACtB,iBAAiB,oDAAI;AACrB,iBAAiB,oDAAI;AACrB,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkB;;;;;;;;;;;;;;;;;;;;;;AC9P4B;AAC4C;AACpB;AACR;AACA;AACe;AAC9B;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uDAAQ;AACzB,iBAAiB,uDAAQ;AACzB;AACA,kBAAkB,aAAa,GAAG,cAAc,GAAG,oBAAoB,GAAG,OAAO,GAAG,OAAO,GAAG,eAAe,GAAG,QAAQ;AACxH;AACA;AACA;AACA,yBAAyB,uDAAU;AACnC;AACA,qHAAqH,EAAE;AACvH,qBAAqB,kBAAkB,SAAS,cAAc,wBAAwB,6BAA6B,yBAAyB,wBAAwB,yDAAc,0BAA0B;AAC5M;AACA,uBAAuB,sEAAY,gCAAgC,sDAAW,QAAQ,sEAAY,WAAW,sEAAY,oBAAoB,qFAAe,oCAAoC,qFAAe;AAC/M,SAAS,2EAAW;AACpB;AACA;AACA,qBAAqB,8EAAiB;AACtC,sBAAsB,4EAAe;AACrC,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEkB;;;;;;;;;;;;;;;;;;;;ACtO6B;AACwB;AACrC;AACiB;AACN;;AAE7C,8BAA8B,qDAAS;AACvC,mCAAmC,oDAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0CAAI;AACtB;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA,IAAI;AACJ,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA,IAAI;AACJ;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4EAAe;AACnC;AACA,4BAA4B,2DAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;;ACvE4B;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+DAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;;;;;;;;;;;ACzB8C;AAC3B;AACF;AACX;AACiB;AACY;AACD;AACA;AACJ;AACX;;AAE/C;AACA,gBAAgB,oDAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,uEAAa;AACpC;AACA,uBAAuB,uDAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,mEAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0EAAoB,+CAA+C,GAAG;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,sEAAY;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0CAAI;AAC3B;AACA,wBAAwB,+EAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;;;;;AClNyB;AACqJ;AAChJ;;AAEnD;AACA;AACA;AACA;AACA,6BAA6B,0DAAe;AAC5C,6BAA6B,0DAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,2GAA2G,gEAAqB;AAChI,qHAAqH,8DAAmB;AACxI;AACA;AACA;AACA,+FAA+F,yDAAc;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4DAAQ;AAC1C;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gEAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gEAAqB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC,2CAA2C,gEAAqB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,0DAAW;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA,yBAAyB,mDAAQ;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wDAAa;AAChC;AACA;AACA;AACA;AACA;AACA,mBAAmB,0DAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,oBAAoB,8DAAmB,iBAAiB,8DAAmB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;;;;;;;;;;;AC5XU;AACE;AACF;AACA;AACA;AACA;AACmS;AAChR;AACE;;AAEjE,mBAAmB,oDAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gEAAqB;AACrC,SAAS,yDAAc;AACvB,UAAU,yDAAc;AACxB,SAAS,yDAAc;AACvB;AACA,kCAAkC,oDAAI,oBAAoB,oDAAI,sBAAsB,oDAAI,0BAA0B,oDAAI,sBAAsB,oDAAI,wBAAwB,oDAAI,0BAA0B,oDAAI,sBAAsB,oDAAI,wBAAwB,oDAAI,wBAAwB,oDAAI;AAC5R;AACA;AACA;AACA;AACA;AACA,sBAAsB,wEAAc;AACpC,0BAA0B,oDAAI;AAC9B,4BAA4B,oDAAI;AAChC,2BAA2B,oDAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yDAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yEAAU;AACpC;AACA;AACA;AACA,eAAe,gEAAqB;AACpC,oBAAoB,sDAAK;AACzB;AACA;AACA;AACA;AACA;AACA,eAAe,8DAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8DAAmB;AACzC,qBAAqB,sDAAW;AAChC;AACA,qBAAqB,wDAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8DAAmB;AACnC;AACA;AACA;AACA,uBAAuB,oDAAI;AAC3B,wBAAwB,oDAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,6BAA6B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gEAAqB;AACpC;AACA,IAAI,kBAAkB,yDAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yDAAc,cAAc,sDAAW,cAAc,sDAAW;AACrF,WAAW,sDAAW;AACtB;AACA;AACA,gBAAgB,sDAAW;AAC3B,WAAW,sDAAW;AACtB;AACA,gBAAgB,uDAAY;AAC5B,WAAW,uDAAY;AACvB;AACA,gBAAgB,uDAAY;AAC5B,WAAW,sDAAW;AACtB;AACA,yBAAyB,sDAAW,aAAa,uDAAY;AAC7D,0BAA0B,sDAAW,cAAc,sDAAW,cAAc,sDAAW;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,oDAAS;AACtD;AACA;AACA,6CAA6C,oDAAS;AACtD;AACA;AACA;AACA,sBAAsB,yDAAc;AACpC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gEAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAI;AAChC;AACA;AACA;AACA;AACA;AACA,6BAA6B,oDAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oDAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,8BAA8B,oDAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gEAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4DAAiB;AACjD,2BAA2B,iEAAsB;AACjD;AACA;AACA,mBAAmB,uCAAuC;AAC1D,0CAA0C,4DAAiB;AAC3D,qCAAqC,iEAAsB;AAC3D;AACA;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yDAAc;AACtB;AACA;AACA;AACA;AACA;AACA,QAAQ,yDAAc;AACtB;AACA,QAAQ,gEAAqB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yDAAc;AACtB;AACA;AACA;AACA,QAAQ,yDAAc;AACtB;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,QAAQ,gEAAqB;AAC7B;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yDAAc;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI,wBAAwB,yDAAc;AAC1C;AACA;AACA;AACA;AACA;AACA,qBAAqB,yDAAc;AACnC;AACA;AACA;AACA,yCAAyC,oDAAI;AAC7C;AACA;AACA;AACA,IAAI,wBAAwB,yDAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yDAAc;AACpC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,oDAAI,oCAAoC,oDAAI;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6B;;;;;;;;;;;;;;;;;;;;;;AChsBkB;AACA;AACiE;AACxC;AACX;AACiB;AACxB;;AAEtD;AACA;AACA,sBAAsB,oDAAI;AAC1B,qBAAqB,oDAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kEAAO;AAChC;AACA;AACA;AACA,WAAW,8EAAiB;AAC5B;AACA;AACA,cAAc,2EAAc;AAC5B,cAAc,2EAAc;AAC5B,aAAa,kFAAqB;AAClC,aAAa,kFAAqB;AAClC,GAAG;AACH,gCAAgC,6EAAY;AAC5C;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,+BAA+B,oDAAI,YAAY,oDAAI,YAAY,oDAAI,YAAY,oDAAI,YAAY,oDAAI,YAAY,oDAAI;AACnH,wBAAwB,oDAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8DAAS,sCAAsC,sDAAW;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC,qBAAqB,gBAAgB;AACrC,uBAAuB,oDAAI;AAC3B;AACA;AACA,uBAAuB,oBAAoB;AAC3C,wBAAwB,oBAAoB;AAC5C;AACA,8BAA8B,oDAAI;AAClC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;AACL,iCAAiC,oDAAI;AACrC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA,wBAAwB,yDAAc;AACtC;AACA;AACA,wBAAwB,yDAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6B;;;;;;;;;;;;;;;;;;ACpQkB;AACA;AACD;;AAE9C;AACA;AACA;AACA,oBAAoB,oDAAI;AACxB;AACA;AACA,qBAAqB,sDAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oDAAI;AAC/B;AACA;AACA;AACA;AACA;AACA,gCAAgC,oDAAI;AACpC;AACA;AACA;AACA;AACA;AACA,gCAAgC,oDAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;;;;;;;;ACjGqB;AAC2G;AAC1F;AACoD;AACvD;AACS;AACZ;;AAE1D;AACA,qBAAqB,oDAAI;AACzB;AACA,8BAA8B,oDAAI;AAClC,+BAA+B,oDAAI;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,2EAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO,EAAE,KAAK,EAAE,YAAY,EAAE,YAAY;AAC/F;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,UAAU;AACV,UAAU;AACV;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,yFAAyF,8EAAiB;AAC1G;AACA;AACA;AACA,kGAAkG,gFAAmB;AACrH;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAI;AAC3B,yBAAyB,oDAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kEAAO;AACzB;AACA;AACA;AACA;AACA;AACA,aAAa,kFAAqB;AAClC,aAAa,kFAAqB;AAClC,SAAS,gFAAmB;AAC5B,cAAc,2EAAc;AAC5B,cAAc,2EAAc;AAC5B;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,qEAAY;AACd,EAAE,qEAAY;AACd,EAAE,qEAAY;AACd;AACA,oCAAoC,8DAAmB;AACvD,wCAAwC,kEAAuB;AAC/D;AACA;AACA;AACA,EAAE,qEAAY;AACd,EAAE,qEAAY;AACd;AACA;AACA;AACA;AACA,EAAE,qEAAY;AACd,EAAE,qEAAY;AACd;AACA;AACA;AACA,EAAE,qEAAY;AACd,EAAE,qEAAY;AACd,EAAE,qEAAY;AACd,EAAE,qEAAY;AACd;AACA;AACA;AACA,EAAE,qEAAY;AACd,EAAE,qEAAY;AACd,EAAE,qEAAY;AACd;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B,GAAG,qEAAY;AACf;AACA,mBAAmB,QAAQ;AAC3B,GAAG,qEAAY;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,qEAAY;AACd,EAAE,qEAAY;AACd,EAAE,qEAAY;AACd;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,GAAG,qEAAY;AACf;AACA;AACA;AACA,iCAAiC,yDAAc;AAC/C;AACA;AACA,2DAA2D,8DAAmB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,4BAA4B,kEAAW;AACvC;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;;;;;;;AC7VuB;AACA;AACgB;AACO;AACgD;AACpE;;AAElD,qBAAqB,oDAAI;AACzB,qBAAqB,oDAAI;AACzB,qBAAqB,oDAAI;AACzB,oBAAoB,oEAAW;AAC/B;AACA;AACA;AACA;AACA,iBAAiB,oDAAI;AACrB,iBAAiB,oDAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oDAAI;AAC3B,uBAAuB,oDAAI;AAC3B,yBAAyB,oDAAI;AAC7B,oBAAoB,oDAAI;AACxB,yBAAyB,oDAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oDAAI;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oDAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,2EAAc;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,oDAAI;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,8DAAmB,GAAG,kEAAuB;AACtF,6CAA6C,yDAAc;AAC3D,uCAAuC,gEAAqB;AAC5D;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC,yBAAyB,WAAW;AACpC,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;;;;;;;ACpRwB;AAC4C;AACkF;AACtG;AACjB;AACf;;AAEzC,4BAA4B,kDAAQ;AACpC;AACA;AACA,mBAAmB,sDAAK;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yDAAc;AAC7C,sCAAsC,gEAAqB;AAC3D,wCAAwC,+DAAoB;AAC5D,2CAA2C,mEAAwB;AACnE,yCAAyC,iEAAsB;AAC/D,+CAA+C,wEAA6B;AAC5E;AACA;AACA;AACA;AACA;AACA,gCAAgC,kGAAsB;AACtD,kBAAkB,qFAAiB;AACnC,4BAA4B,gEAAK;AACjC;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;;;ACrD6C;;AAEtE,uCAAuC,2EAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEkD;;;;;;;;;;;;;;;;ACbwW;;AAE1Z;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4DAAiB;AAChC,sBAAsB,wDAAa;AACnC,wBAAwB,yDAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gEAAqB;AACtE,0CAA0C,yDAAc;AACxD,mDAAmD,+DAAoB;AACvE,sDAAsD,mEAAwB;AAC9E,oDAAoD,iEAAsB;AAC1E,0DAA0D,wEAA6B;AACvF,iDAAiD,6DAAkB;AACnE,yDAAyD,mEAAwB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wDAAa;AAC9C,mFAAmF,yDAAc;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,qDAAU;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,8DAAmB;AAC7D,2CAA2C,8DAAmB;AAC9D;AACA;AACA,4CAA4C,gEAAqB,eAAe,gEAAqB;AACrG,4CAA4C,yDAAc,eAAe,yDAAc;AACvF,4CAA4C,yDAAc,eAAe,yDAAc;AACvF;AACA;AACA,IAAI;AACJ;AACA;AACA,mDAAmD,6DAAkB;AACrE;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqC;;;;;;;;;;;;;;;;;;;;;;AC/IqR;AACtP;AACA;AACyB;AAC6H;AACnK;AACI;;AAE3D;AACA,WAAW,4DAAiB;AAC5B,MAAM,0EAAa;AACnB,MAAM,0EAAa;AACnB,KAAK,2FAA8B;AACnC;AACA,WAAW,qDAAU;AACrB,MAAM,0EAAa;AACnB,MAAM,2EAAc;AACpB,KAAK,8EAAiB;AACtB;AACA,WAAW,uDAAY;AACvB,MAAM,gFAAmB;AACzB,MAAM,0FAA6B;AACnC,KAAK,8EAAiB;AACtB;AACA,WAAW,8DAAmB;AAC9B,MAAM,0EAAa;AACnB,MAAM,0FAA6B;AACnC,KAAK,8EAAiB;AACtB;AACA,WAAW,yDAAc;AACzB,MAAM,0EAAa;AACnB,MAAM,0EAAa;AACnB,KAAK,8EAAiB;AACtB;AACA,WAAW,8DAAmB;AAC9B,MAAM,gFAAmB;AACzB,MAAM,0EAAa;AACnB,KAAK,8EAAiB;AACtB;AACA,WAAW,iEAAsB;AACjC,MAAM,gFAAmB;AACzB,MAAM,gFAAmB;AACzB,KAAK,8EAAiB;AACtB;AACA,WAAW,uDAAY;AACvB,MAAM,0FAA6B;AACnC,MAAM,0EAAa;AACnB,KAAK,8EAAiB;AACtB;AACA,WAAW,+DAAoB;AAC/B,MAAM,gFAAmB;AACzB,MAAM,2EAAc;AACpB,KAAK,8EAAiB;AACtB;AACA,WAAW,oDAAS;AACpB,MAAM,0EAAa;AACnB,MAAM,0EAAa;AACnB,KAAK,8EAAiB;AACtB;AACA,WAAW,oDAAS;AACpB,MAAM,0EAAa;AACnB,MAAM,0EAAa;AACnB,KAAK,8EAAiB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yEAAU;AACnC,yBAAyB,yEAAU;AACnC,cAAc,0EAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qDAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,qDAAU;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA,SAAS,uDAAY;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA,gCAAgC,kGAAsB;AACtD,SAAS,mEAAa;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA,4BAA4B,wEAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoB;;;;;;;;;;;;;;;;;;;AC9TgG;AACmZ;AACxc;AACe;;AAE9E;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4DAAiB;AAChC,4DAA4D,wDAAa;AACzE,gCAAgC,yDAAc;AAC9C;AACA,yDAAyD,6DAAkB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gEAAqB;AAC9E,kDAAkD,yDAAc;AAChE,2DAA2D,+DAAoB;AAC/E,8DAA8D,mEAAwB;AACtF,4DAA4D,iEAAsB;AAClF,kEAAkE,wEAA6B;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAa;AACpC,uBAAuB,wDAAa;AACpC,0BAA0B,2DAAgB;AAC1C;AACA;AACA;AACA;AACA,kBAAkB,uEAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,EAAE;AACtB,oBAAoB,EAAE;AACtB,qBAAqB,EAAE;AACvB,oBAAoB,MAAM;AAC1B,oBAAoB,MAAM;AAC1B,oBAAoB,MAAM;AAC1B,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qDAAU,oFAAoF,sDAAW;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,qDAAU,mCAAmC,sDAAW;AACrG,6BAA6B,kEAAuB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,6EAAgB,8BAA8B,oFAAuB;AAChJ,6CAA6C,qDAAU,qDAAqD,sDAAW;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,yDAAc;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,qDAAU;AACxF;AACA;AACA,0CAA0C,yDAAc;AACxD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,6DAAkB;AAC9D,kBAAkB,uDAAY;AAC9B,6DAA6D,8EAAiB;AAC9E;AACA;AACA;AACA;AACA;AACA,mBAAmB,0DAAe;AAClC;AACA;AACA,mBAAmB,8DAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,8DAAmB;AAC7D,mDAAmD,8DAAmB;AACtE;AACA,IAAI,uFAAyB,eAAe,gEAAqB,eAAe,gEAAqB;AACrG,IAAI,uFAAyB,eAAe,yDAAc,eAAe,yDAAc;AACvF,IAAI,uFAAyB,eAAe,yDAAc,eAAe,yDAAc;AACvF;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;;;;;;;;;;;;;;;;AChVsC;;AAEhF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wFAAgB;AACxC;AACA;AACA;AACA;AACA;;AAEmC;;;;;;;;;;;;;;;;;;;;ACzBkD;AACe;;AAEpG;AACA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA,YAAY,KAAK;AACjB;AACA,aAAa,KAAK;AAClB,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA,uCAAuC,gFAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,6GAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmJ;;;;;;;;;;;;;;;;;;;AC5JwF;AAC9K;AAC+O;AACtL;;AAEtH;AACA;AACA;AACA;AACA;AACA,+CAA+C,uDAAY,EAAE,qDAAU,EAAE,iEAAsB;AAC/F,oCAAoC,0EAAa,EAAE,0EAAa,EAAE,2EAAc,EAAE,kFAAqB;AACvG,yCAAyC,4DAAiB,EAAE,yDAAc,EAAE,uDAAY,EAAE,qDAAU,EAAE,8DAAmB,EAAE,+DAAoB,EAAE,8DAAmB,EAAE,iEAAsB,EAAE,uDAAY,EAAE,oDAAS,EAAE,oDAAS;AAChO,yCAAyC,uEAAU,EAAE,sEAAS,EAAE,uEAAU,EAAE,2EAAc,EAAE,yEAAY,EAAE,0EAAa,EAAE,8EAAiB,EAAE,wEAAW;AACvJ,4CAA4C,yDAAc,EAAE,yDAAc;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4FAA8B;AAC9C,kBAAkB,+FAAiC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iCAAiC,kEAAO;AACxC;AACA;AACA;AACA,MAAM;AACN;AACA,iCAAiC,kEAAO;AACxC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gCAAgC,kEAAO;AACvC;AACA;AACA;AACA,KAAK;AACL;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA,KAAK;AACL,4CAA4C,KAAK;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqC;;;;;;;;;;;;;;;;;;;;;;;;;;;AChHY;AACF;AACA;AAC8C;AAC+G;AAC7J;AACW;AACe;AACA;AAChC;AAC+C;AACiC;;AAEzH;AACA;AACA;AACA,+BAA+B,kDAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iGAA8B;AAC5D;AACA;AACA;AACA;AACA,YAAY,KAAK;AACjB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,mBAAmB,EAAE;AACrB;AACA;AACA,iCAAiC,MAAM;AACvC,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uDAAY;AAC7C;AACA;AACA,kBAAkB,uEAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yDAAc;AACtD;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yDAAc;AACtD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uDAAU;AACnC,kCAAkC,uDAAY,aAAa,sDAAW,aAAa,kEAAuB;AAC1G,iCAAiC,sEAAQ,qBAAqB,sEAAQ;AACtE;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,gCAAgC,kGAAsB;AACtD,kBAAkB,qFAAiB;AACnC,+BAA+B,sEAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,+FAAiC;AACvE,sCAAsC,+FAAiC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,KAAK;AACxB,GAAG;AACH;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uEAAS;AACV;AACA,WAAW,KAAK;AAChB;AACA;AACA;AACA;AACA,EAAE;AACF;AACA,WAAW,KAAK;AAChB,oBAAoB,oDAAI;AACxB,EAAE;AACF;AACA,WAAW,KAAK;AAChB,oBAAoB,oDAAI;AACxB,EAAE;AACF;AACA,WAAW,KAAK;AAChB;AACA,EAAE;AACF;AACA,WAAW,KAAK;AAChB;AACA,EAAE;AACF;AACA;AACA,YAAY,KAAK;AACjB;AACA,GAAG;AACH;AACA;AACA,aAAa,KAAK;AAClB;AACA,IAAI;AACJ;AACA,aAAa,KAAK;AAClB;AACA,IAAI;AACJ;AACA;AACA,sBAAsB,KAAK;AAC3B,sBAAsB,KAAK;AAC3B,wBAAwB,KAAK;AAC7B,yBAAyB,KAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,aAAa;AAClC;AACA,IAAI;AACJ,qBAAqB,aAAa;AAClC;AACA,IAAI;AACJ,GAAG;AACH,iCAAiC,oDAAI;AACrC,iCAAiC,oDAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,KAAK;AACxB;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA,6BAA6B,uDAAK;AAClC,6BAA6B,uDAAK;AAClC,8BAA8B,uDAAK;AACnC,8BAA8B,uDAAK;AACnC,2BAA2B,uDAAK;AAChC,iCAAiC,uDAAK;AACtC;AACA;AACA;AACA;AACA,mCAAmC,yDAAc;AACjD,EAAE;AACF;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAU;AAC1C,6BAA6B,yDAAc;AAC3C,6BAA6B,0DAAe;AAC5C;AACA,kCAAkC,wDAAa;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sDAAW;AACzC,oCAAoC,sDAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,yDAAc;AAChD,6BAA6B,yDAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mEAAW;AAC/B;AACA,KAAK;AACL,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;;;;;;;;;ACpkBgC;AACM;AACH;AACQ;AACuX;AAClZ;AACyB;AACR;;AAE7D;AACA,qBAAqB,oEAAW;AAChC,0BAA0B,oEAAW;AACrC,wBAAwB,0EAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,+EAAa;AAC1C;AACA,wBAAwB,uEAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qDAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8DAAmB;AACxC;AACA;AACA,uCAAuC,wDAAa;AACpD,uCAAuC,wDAAa;AACpD,yCAAyC,2DAAgB;AACzD,4CAA4C,6DAAkB;AAC9D;AACA,eAAe,sDAAW;AAC1B,sBAAsB,4DAAiB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oEAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,WAAW,GAAG,WAAW,GAAG,UAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,6DAAkB,sBAAsB,6DAAkB;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,yDAAc,uBAAuB,yDAAc;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,wEAA6B,iBAAiB,wEAA6B;AAC1I,8DAA8D,mEAAwB,iBAAiB,mEAAwB;AAC/H,4DAA4D,iEAAsB,iBAAiB,iEAAsB;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,gEAAqB,uBAAuB,gEAAqB;AACpH;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAe;AAC3B;AACA;AACA,mBAAmB,0DAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,uDAAY;AACjF,YAAY,0DAAe,+CAA+C,qDAAU;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,2DAA2D,+DAAoB,uBAAuB,+DAAoB;AAC1H;AACA;AACA;AACA,mBAAmB,kFAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,sEAAa;AAChB;AACA;AACA,GAAG,sEAAa;AAChB;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kEAAuB,MAAM,8DAAmB,GAAG,oDAAS;AACxF,IAAI;AACJ;AACA;AACA,yBAAyB,uDAAY,GAAG,0DAAe,GAAG,8DAAmB;AAC7E,4BAA4B,8DAAmB,MAAM,kEAAuB,GAAG,oDAAS;AACxF;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;;;;;;;;;;ACzdyC;AACrB;AACgB;AACkV;AAC3U;AACE;AACA;AACI;AACqB;;AAE9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAAa;AACpC,sBAAsB,0EAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yEAAgB;AACnC;AACA;AACA;AACA,mBAAmB,oEAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6EAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kFAAqB,4CAA4C,uEAAU;AACnG;AACA;AACA,wBAAwB,iFAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC,oBAAoB,oDAAI;AACxB,oBAAoB,oDAAI;AACxB;AACA,uBAAuB,iFAAc;AACrC,sCAAsC,8EAAiB;AACvD,0CAA0C,iFAAoB;AAC9D,0CAA0C,kFAAqB;AAC/D;AACA,kBAAkB,cAAc;AAChC,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,8EAAiB;AACvG;AACA;AACA;AACA,UAAU,sEAAS;AACnB;AACA,UAAU,uEAAU;AACpB;AACA,UAAU,uEAAU;AACpB;AACA,UAAU,wEAAW;AACrB;AACA;AACA;AACA;AACA,IAAI;AACJ,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC,oBAAoB,oEAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,0EAAa,GAAG,2EAAc;AACrF,qDAAqD,0EAAa,GAAG,2EAAc;AACnF;AACA,yEAAyE,yEAAY;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iFAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8EAAiB,0CAA0C,yEAAY;AAC9F;AACA;AACA,uBAAuB,4EAAe,wCAAwC,yEAAY;AAC1F;AACA;AACA,uBAAuB,8EAAiB,8CAA8C,yEAAY;AAClG;AACA;AACA,uBAAuB,2EAAc,uCAAuC,yEAAY;AACxF;AACA;AACA,uBAAuB,2EAAc,+DAA+D,uEAAU;AAC9G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8EAAiB;AAC/C;AACA;AACA,8BAA8B,4EAAe;AAC7C;AACA;AACA,8BAA8B,8EAAiB;AAC/C;AACA;AACA,8BAA8B,2EAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gFAAmB;AAC3C;AACA;AACA,6DAA6D,8EAAiB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,aAAa,6EAAY;AACzB;AACA;AACA;AACA;AACA;AACA,2BAA2B,6EAAY;AACvC;AACA;AACA,IAAI;AACJ;AACA,uBAAuB,iFAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,+EAAkB,GAAG,+EAAkB;AAC3G;AACA;AACA,KAAK;AACL,6BAA6B,2EAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB;AAC3C;AACA,IAAI,yBAAyB,6DAAkB;AAC/C,kBAAkB,6DAAkB;AACpC,UAAU,6EAAgB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6DAAkB;AACvC,2BAA2B,6DAAkB;AAC7C;AACA,qBAAqB,gEAAqB;AAC1C,2BAA2B,gEAAqB;AAChD;AACA;AACA;AACA,2BAA2B,gEAAqB;AAChD;AACA;AACA;AACA;AACA;AACA,+BAA+B,4DAAiB;AAChD,gCAAgC,4DAAiB;AACjD,wCAAwC,4DAAiB;AACzD,0BAA0B,mFAAsB;AAChD;AACA,sBAAsB,kBAAkB;AACxC,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,mBAAmB,iBAAiB;AACpC;AACA;AACA,mCAAmC,+EAAkB,GAAG,+EAAkB;AAC1E;AACA,yBAAyB,2EAAW;AACpC,yBAAyB,mFAAsB;AAC/C;AACA;AACA,iBAAiB,gEAAqB;AACtC,SAAS,4EAAe;AACxB;AACA;AACA;AACA;AACA,mBAAmB,gEAAqB;AACxC;AACA;;AAEgB;;;;;;;;;;;;;;;;;;;AC3hBuC;AACL;AACE;AACF;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA,iCAAiC,2DAAY;AAC7C;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gCAAgC;AAClD;AACA,kCAAkC,6DAAa;AAC/C;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA,iCAAiC,2DAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA,EAAE,2DAAY,iDAAiD,gEAAqB;AACpF;AACA;;AAEiB;;;;;;;;;;;;;;;;;;;;AC/GoE;AAChB;AACA;AACR;AACI;;AAEjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yEAAU,OAAO,8EAAiB,EAAE,0EAAa,EAAE,0EAAa;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6EAAY;AAC3B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C,yBAAyB,EAAE,+CAA+C,EAAE;AAC5E;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,yCAAyC,YAAY,EAAE;AAC9F;AACA,kBAAkB,iBAAiB;AACnC,6DAA6D,GAAG;AAChE;AACA,uCAAuC,+CAA+C;AACtF,kBAAkB,iBAAiB;AACnC,qDAAqD,EAAE,6BAA6B,EAAE,WAAW;AACjG;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0EAAoB,2DAA2D,MAAM;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,yEAAU;AAClE;AACA,GAAG,kFAAkB;AACrB;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA,kBAAkB,gCAAgC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;;;;;ACnOmC;AACqB;AACZ;AACA;;AAErE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oEAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,yEAAY;AAC1D;AACA;AACA,cAAc,2EAAc;AAC5B;AACA;AACA,IAAI;AACJ,cAAc,6EAAY,aAAa,6EAAY;AACnD;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;;;;;;;;ACpF0C;AACrB;AACiB;AACD;AACF;AACW;AACA;AAC+H;;AAEpM,oBAAoB,yEAAgB;AACpC;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4FAA4F,gFAAmB;AAC/G,qFAAqF,gFAAmB;AACxG;AACA,wFAAwF,gFAAmB;AAC3G,iDAAiD,+EAAkB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oDAAI;AACvB,mBAAmB,oDAAI;AACvB,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA,oBAAoB,oEAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qEAAY;AACjC,8BAA8B,gFAAmB;AACjD;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,4EAAe;AAC5B;AACA,sBAAsB,wEAAW,GAAG,yEAAY;AAChD,GAAG;AACH,6BAA6B,6EAAY,kBAAkB,6EAAY;AACvE;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kEAAO;AACpB;AACA;AACA;AACA;AACA;AACA,cAAc,2EAAc;AAC5B,cAAc,2EAAc;AAC5B,aAAa,kFAAqB;AAClC,aAAa,kFAAqB;AAClC;AACA,GAAG;AACH;AACA;;AAEiB;;;;;;;;;;;;;;;;;;;AC3N8B;AACA;AACA;AAC4C;;AAE3F;AACA;AACA;AACA,mBAAmB,oDAAI;AACvB,sBAAsB,oDAAI;AAC1B,6BAA6B,oDAAI;AACjC,sBAAsB,oDAAI;AAC1B,0BAA0B,oDAAI;AAC9B,4BAA4B,oDAAI;AAChC,wBAAwB,oDAAI;AAC5B,6BAA6B,oDAAI;AACjC,yBAAyB,oDAAI;AAC7B,8BAA8B,oDAAI;AAClC,8BAA8B,oDAAI;AAClC,wBAAwB,oDAAI;AAC5B,6BAA6B,oDAAI;AACjC,uBAAuB,oDAAI;AAC3B,oBAAoB,oDAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2DAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,uBAAuB,oDAAI;AAC3B;AACA;AACA;AACA;AACA;AACA,eAAe,oDAAI,2BAA2B,oDAAI,mCAAmC,oDAAI;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,8CAA8C,oDAAI,2BAA2B,oDAAI,mCAAmC,oDAAI;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,oDAAI;AAC9E,uEAAuE,oDAAI;AAC3E;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,8DAAmB;AACrD,qDAAqD,oDAAI;AACzD;AACA,OAAO;AACP,2BAA2B,oDAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,8BAA8B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAiB;AACtC;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,mBAAmB,0BAA0B;AAC7C;AACA;AACA,oBAAoB,yCAAyC;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAE8B;;;;;;;;;;;;;;;;;;;;;;;;ACtXiB;AACA;AACA;AACA;AACsB;AACD;AACA;AACE;AACnB;;AAEnD,yBAAyB,oDAAI;AAC7B,2BAA2B,oDAAI;AAC/B,8BAA8B,oDAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yEAAU;AACjC,uBAAuB,yEAAU;AACjC,qBAAqB,0EAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oDAAI;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,oDAAI;AAC/D,wCAAwC,oDAAI;AAC5C,+BAA+B,2DAAgB;AAC/C;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,oDAAI;AAC5D,0DAA0D,oDAAI;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,kFAAkB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7JmB;AACO;AACT;AACA;AACA;AACA;AACgB;AAC+Q;AACxQ;AACA;AACE;AACX;AACW;AACA;AACqB;AACgF;AAC3I;AACiB;AACC;AACqB;AACX;AACA;AACA;AACR;AACA;;AAEtD;AACA,mEAAmE,gFAAmB;AACtF,iBAAiB,2EAAc;AAC/B,0BAA0B,8EAAiB;AAC3C,cAAc,0EAAa;AAC3B;AACA,qBAAqB,kEAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kFAAqB;AACjC,YAAY,kFAAqB;AACjC;AACA,EAAE;AACF;AACA,gBAAgB,8EAAiB;AACjC;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAK;AAC/B,0BAA0B,sDAAK;AAC/B,2BAA2B,6DAAQ;AACnC,2BAA2B,6DAAQ;AACnC;AACA;AACA;AACA,wBAAwB,oDAAI;AAC5B,oBAAoB,oDAAI;AACxB,iBAAiB,oDAAI;AACrB,iBAAiB,oDAAI;AACrB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,cAAc;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,2EAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oDAAI;AACxC,yCAAyC,oDAAI;AAC7C;AACA;AACA,8BAA8B,2DAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAiB;AACvC,sBAAsB,2DAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oDAAI;AACxC,6BAA6B,qEAA0B;AACvD;AACA;AACA,2BAA2B,uDAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+DAAkB;AAC3C,yBAAyB,+DAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qEAAW;AACpC,gCAAgC,qEAAW;AAC3C,+BAA+B,qEAAW,QAAQ,qEAAW;AAC7D,yBAAyB,qEAAW;AACpC,6BAA6B,oDAAI;AACjC,iCAAiC,oDAAI;AACrC,mCAAmC,oDAAI;AACvC;AACA;AACA,4BAA4B,oDAAI;AAChC,4BAA4B,oDAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gBAAgB;AACnC,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,8EAAiB;AACtG,uBAAuB,0EAAa;AACpC,uBAAuB,0EAAa;AACpC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2DAAgB;AAC7C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,oDAAI;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAAgB;AAC5C;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,2DAAgB;AAC3D,2CAA2C,4DAAiB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA,yBAAyB,qDAAI;AAC7B;AACA;AACA;AACA;AACA,+EAA+E,oDAAI;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA,6DAA6D,oDAAI;AACjE,4BAA4B,2DAAgB;AAC5C;AACA,uBAAuB,oDAAI,OAAO,qDAAI;AACtC,KAAK;AACL,uBAAuB,oDAAI;AAC3B;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA,kBAAkB,kCAAkC;AACpD;AACA;AACA;AACA;AACA,uGAAuG,8EAAiB;AACxH,wGAAwG,8EAAiB;AACzH,+GAA+G,8EAAiB;AAChI,KAAK;AACL;AACA;AACA;AACA;AACA,8BAA8B,8EAAY;AAC1C;AACA;AACA,IAAI;AACJ,+BAA+B,8EAAY;AAC3C;AACA;AACA,IAAI;AACJ;AACA;AACA,6EAA6E,uEAAY,uCAAuC,uEAAY,wBAAwB,uEAAY,yBAAyB,uEAAY,wBAAwB,uEAAY,iDAAiD,2DAAgB,GAAG,uEAAY,yBAAyB,uEAAY,4BAA4B,uEAAY;AACtZ,8CAA8C,uEAAY,4BAA4B,uEAAY;AAClG,gDAAgD,uEAAY,8BAA8B,uEAAY;AACtG,6CAA6C,uEAAY,2BAA2B,uEAAY;AAChG,oBAAoB,kBAAkB,EAAE,WAAW,EAAE,gBAAgB;AACrE,qCAAqC,2EAAoB,KAAK,uEAAY,gDAAgD,OAAO;AACjI,uCAAuC,2EAAoB,KAAK,uEAAY,kDAAkD,OAAO;AACrI,oCAAoC,2EAAoB,KAAK,uEAAY,+CAA+C,OAAO;AAC/H;AACA;AACA;AACA,mBAAmB,2CAAI;AACvB;AACA;AACA,2BAA2B,gFAAmB;AAC9C;AACA;AACA;AACA,sBAAsB,6DAAQ;AAC9B;AACA,uBAAuB,0EAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,4DAAY;AACtC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC,wBAAwB,qDAAI;AAC5B,yBAAyB,qDAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAgG,8EAAiB;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sFAAiB;AACtC,kCAAkC,uEAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mGAAsB;AACvD;AACA,UAAU,yDAAc;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,qEAA0B;AACvE,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,0EAAa;AACvD;AACA;AACA;AACA;AACA,2BAA2B,qEAA0B;AACrD;AACA;AACA,IAAI;AACJ;AACA,4BAA4B,oEAAyB;AACrD;AACA,KAAK;AACL,4CAA4C,oDAAI;AAChD;AACA;AACA,iBAAiB,oDAAI;AACrB;AACA;AACA;AACA,iBAAiB,oDAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2EAAc;AAC7B;AACA,WAAW,yEAAY;AACvB,KAAK;AACL;AACA;AACA,gBAAgB,2EAAc;AAC9B;AACA,YAAY,yEAAY;AACxB,MAAM;AACN;AACA,+BAA+B,8EAAY;AAC3C,4BAA4B,8EAAY;AACxC,YAAY,2EAAc;AAC1B,KAAK;AACL,2BAA2B,4EAAW,sBAAsB,+EAAkB;AAC9E,KAAK;AACL;AACA,eAAe,2EAAc;AAC7B;AACA,WAAW,yEAAY;AACvB,KAAK;AACL,eAAe,2EAAc;AAC7B;AACA,WAAW,yEAAY;AACvB,KAAK;AACL,eAAe,2EAAc;AAC7B;AACA,WAAW,yEAAY;AACvB,KAAK;AACL,eAAe,2EAAc;AAC7B;AACA,WAAW,yEAAY;AACvB,KAAK;AACL,eAAe,2EAAc;AAC7B;AACA,WAAW,yEAAY;AACvB,KAAK;AACL,+BAA+B,8EAAY;AAC3C,4BAA4B,8EAAY;AACxC,YAAY,2EAAc;AAC1B,KAAK;AACL,2BAA2B,4EAAW,sBAAsB,+EAAkB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sDAAsD;AAC7E,+DAA+D,+EAAkB;AACjF;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,qBAAqB,6BAA6B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kCAAkC;AACrD;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAAgB;AAC5C;AACA;AACA;AACA;AACA,uBAAuB,oDAAI,OAAO,qDAAI;AACtC,KAAK;AACL,uBAAuB,oDAAI;AAC3B;AACA;AACA;AACA,yDAAyD,oDAAI;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;;ACz/B6B;;AAExD,qBAAqB,gEAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkB;;;;;;;;;;;;;;;;;;;;;AC/C6B;AACmG;AACzG;AACO;AACa;AACc;;AAE3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kDAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,EAAE;AAC1B,0CAA0C,MAAM;AAChD;AACA,wCAAwC,MAAM;AAC9C,8CAA8C,MAAM;AACpD,iDAAiD,MAAM;AACvD,iDAAiD,MAAM;AACvD,kDAAkD,MAAM;AACxD,qDAAqD,MAAM;AAC3D,2CAA2C,MAAM;AACjD;AACA,wCAAwC,MAAM;AAC9C;AACA,0CAA0C,MAAM;AAChD;AACA,2CAA2C,MAAM;AACjD,4CAA4C,MAAM;AAClD,6CAA6C,MAAM;AACnD,2CAA2C,MAAM;AACjD,8CAA8C,MAAM;AACpD,iDAAiD,MAAM;AACvD,iDAAiD,MAAM;AACvD,iDAAiD,MAAM;AACvD,mDAAmD,MAAM;AACzD,sDAAsD,MAAM;AAC5D,kDAAkD,MAAM;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oDAAI;AAC7C;AACA;AACA;AACA;AACA,0CAA0C,oDAAI;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8DAAmB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oDAAI;AAC7C;AACA;AACA;AACA;AACA,0CAA0C,oDAAI;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8DAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,8DAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yDAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,yDAAc;AAC3C;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAc;AAC1C;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,gEAAqB;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sGAAsG;AACtG;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mDAAQ;AAC5B;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA,qBAAqB,qDAAU;AAC/B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wDAAa;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,wDAAa;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oFAAwB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sEAAiB;AAC1C;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;;;;;;;ACroBoB;AACA;AACA;AACyG;AAClH;AACO;;AAE7C,qBAAqB,oDAAI;AACzB,yBAAyB,oDAAI;AAC7B,4BAA4B,oDAAI;AAChC;AACA;AACA,qBAAqB,8CAAM;AAC3B,oBAAoB,qDAAS;AAC7B;AACA,2BAA2B,wDAAa;AACxC;AACA;AACA,QAAQ,yDAAc;AACtB;AACA;AACA,wBAAwB,iEAAsB;AAC9C;AACA,QAAQ,yDAAc;AACtB,wBAAwB,iEAAsB;AAC9C;AACA,QAAQ,gEAAqB;AAC7B,wBAAwB,kEAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,yDAAc;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,oDAAI;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oDAAI,uCAAuC,oDAAI,wCAAwC,oDAAI,qCAAqC,oDAAI,sCAAsC,oDAAI,wCAAwC,oDAAI;AACjQ;;AAEuB;;;;;;;;;;;;;;;;;;;;;;;;;ACvDwB;AACA;AACsB;AACG;AACV;AACd;AACoB;AACZ;AACY;AACA;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF,sBAAsB,oDAAI;AAC1B;AACA,uCAAuC,yEAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA,uBAAuB,gEAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC,mBAAmB,yDAAW,cAAc,yDAAc;AAC1D;AACA;AACA,qCAAqC,oDAAI;AACzC;AACA;AACA;AACA;AACA;AACA,kBAAkB,0EAAoB;AACtC,8BAA8B,gEAAU;AACxC;AACA;AACA;AACA;AACA;AACA,kBAAkB,0EAAoB;AACtC,gCAAgC,gEAAU;AAC1C;AACA;AACA;AACA;AACA;AACA,uBAAuB,yEAAU;AACjC,qBAAqB,0EAAa;AAClC,uBAAuB,yEAAU;AACjC;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoC;;;;;;;;;;;;;;;;;;ACjJgC;AACA;AACL;;AAE/D,gCAAgC,yEAAU;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uEAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yEAAU;AAClC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6B;;;;;;;;;;;;;;;;ACzLuC;;AAEpE,uCAAuC,yEAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoC;;;;;;;;;;;;;;;;;AChBgC;AACQ;;AAE5E,0CAA0C,yEAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,qBAAqB,kBAAkB;AACvC,kFAAkF,4DAAiB;AACnG;AACA;AACA,kFAAkF,iEAAsB;AACxG,kCAAkC,4DAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;;;;;;;;;;;;;;;;AClC6B;;AAEpE,6CAA6C,yEAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA,sBAAsB,6BAA6B;AACnD;AACA;AACA;AACA;AACA;AACA;;AAE0C;;;;;;;;;;;;;;;;AC/B0B;;AAEpE,gDAAgD,yEAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6C;;;;;;;;;;;;;;;;;;ACvBuB;AACQ;AACa;;AAEzF,wCAAwC,yEAAU;AAClD;AACA;AACA;AACA;AACA,2BAA2B,qFAAwB;AACnD;AACA,8BAA8B,kGAA8B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEqC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxCU;AACA;AACA;AACA;AACA;AACsB;AACoG;AAClG;AACnB;AACE;AACka;AAC9Y;AACR;AACoC;AACqB;AACpE;AACU;AACY;AACvB;AACiB;AACO;AACV;AACV;;AAE1D;AACA,wBAAwB,oDAAI;AAC5B,uBAAuB,oDAAI;AAC3B,oBAAoB,oDAAI;AACxB,qBAAqB,oDAAI;AACzB,uBAAuB,0EAAc;AACrC,sBAAsB,oDAAI;AAC1B;AACA;AACA,6BAA6B,oDAAI;AACjC,6BAA6B,oDAAI,qBAAqB,oDAAI,sBAAsB,oDAAI,sBAAsB,oDAAI,uBAAuB,oDAAI,uBAAuB,oDAAI,uBAAuB,oDAAI,uBAAuB,oDAAI,wBAAwB,oDAAI,wBAAwB,oDAAI,wBAAwB,oDAAI,wBAAwB,oDAAI,wBAAwB,oDAAI,wBAAwB,oDAAI,wBAAwB,oDAAI,wBAAwB,oDAAI;AAC1b,0BAA0B,oDAAI;AAC9B,0BAA0B,oDAAI;AAC9B,0BAA0B,oDAAI;AAC9B,0BAA0B,oDAAI;AAC9B,0BAA0B,oDAAI;AAC9B,0BAA0B,oDAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+DAAS;AAChC;AACA;AACA,oCAAoC,gFAAsB;AAC1D,+BAA+B,+EAAiB;AAChD,4BAA4B,gEAAc;AAC1C,4BAA4B,+DAAc;AAC1C,kCAAkC,0EAAmB;AACrD,wCAAwC,uFAAyB;AACjE,wCAAwC,wFAAyB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,+DAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA,wBAAwB,2DAAe,mBAAmB,2DAAe;AACzE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,8BAA8B,2DAAe;AAC7C,8BAA8B,2DAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yDAAa;AAC3C,8BAA8B,yDAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,wCAAwC,uDAAW;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,qDAAI;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,uDAAW;AACrD,KAAK;AACL;AACA;AACA,gCAAgC,qDAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,mEAAuB;AACtE;AACA;AACA;AACA;AACA;AACA,gFAAgF,6EAAe,wEAAwE,6EAAe,8EAA8E,+EAAiB;AACrR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6EAAe,oCAAoC,6EAAe,sCAAsC,+EAAiB;AAChK;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,aAAa,2EAAa;AAC1B;AACA;AACA,yBAAyB,4EAAc,sBAAsB,2EAAa;AAC1E;AACA;AACA;AACA,6BAA6B,4EAAc,GAAG,2EAAa,GAAG,4EAAc;AAC5E,KAAK;AACL;AACA;AACA;AACA;AACA,eAAe,2EAAa,sBAAsB,2EAAa;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uDAAW;AAClD;AACA;AACA,yCAAyC,uDAAW;AACpD,IAAI;AACJ;AACA;AACA,+BAA+B,qDAAI;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,oBAAoB,+CAA+C;AACnE;AACA;AACA,uBAAuB,2EAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uFAAa,0BAA0B,8EAAgB,OAAO,uFAAa,0BAA0B,8EAAgB,OAAO,uFAAa,kBAAkB,8EAAgB,OAAO,uFAAa,oBAAoB,+EAAiB,OAAO,uFAAa,aAAa,+EAAiB,OAAO,uFAAa,gBAAgB,+EAAiB;AACpW;AACA,0BAA0B,uFAAa,kCAAkC,8EAAgB,OAAO,uFAAa,uBAAuB,8EAAgB,OAAO,uFAAa,qBAAqB,8EAAgB,OAAO,uFAAa,uBAAuB,8EAAgB,OAAO,uFAAa,oBAAoB,8EAAgB,OAAO,uFAAa,oBAAoB,8EAAgB,OAAO,uFAAa,6BAA6B,8EAAgB,OAAO,uFAAa,sBAAsB,8EAAgB,OAAO,uFAAa,oBAAoB,6EAAe,OAAO,uFAAa,gBAAgB,+EAAiB;AAC/lB;AACA,gCAAgC,6FAAmB;AACnD,wBAAwB,6FAAuB,CAAC,8FAAgC,EAAE,gFAAkB,GAAG,kFAAoB,OAAO,uFAAiB,uBAAuB,kFAAoB,EAAE,iFAAmB,EAAE,2FAA6B,OAAO,uFAAiB,mBAAmB,kFAAoB,EAAE,iFAAmB,EAAE,2FAA6B,OAAO,uFAAiB,uBAAuB,kFAAoB,EAAE,iFAAmB,EAAE,8EAAgB,OAAO,uFAAiB,uBAAuB,kFAAoB,EAAE,iFAAmB,EAAE,8EAAgB,OAAO,uFAAiB,sBAAsB,kFAAoB,EAAE,iFAAmB,EAAE,8EAAgB,OAAO,uFAAiB,sBAAsB,kFAAoB,EAAE,iFAAmB,EAAE,8EAAgB;AAC3wB;AACA,yBAAyB,uFAAiB,wBAAwB,kFAAoB,EAAE,iFAAmB,EAAE,2FAA6B;AAC1I;AACA,kCAAkC,qFAAe;AACjD;AACA;AACA;AACA;AACA;AACA,kBAAkB,gFAAa;AAC/B,kBAAkB,wEAAS;AAC3B;AACA;AACA;AACA;AACA;AACA,sBAAsB,4EAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4EAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA,0BAA0B,iEAAqB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA,wBAAwB,iEAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6BAA6B;AAC/C;AACA,uBAAuB,iEAAqB;AAC5C;AACA,8DAA8D,6DAAiB;AAC/E,+BAA+B,kEAAsB;AACrD;AACA,MAAM;AACN,oCAAoC,6DAAiB;AACrD;AACA,gCAAgC,kEAAsB;AACtD;AACA;AACA;AACA,kFAAkF,6DAAiB;AACnG;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA,qDAAqD,iEAAqB;AAC1E,sBAAsB,2BAA2B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA,kCAAkC,6DAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iFAAmB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoB;;;;;;;;;;;;;;;;;AC7vB6B;AACL;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,GAAG;AACH;AACA;AACA;AACA,oCAAoC,yDAAc;AAClD;AACA;AACA,YAAY,UAAU,GAAG,WAAW,GAAG,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qDAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;;;;;AC9C+L;AACjJ;AACX;AACoE;;AAEjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA,qBAAqB,uDAAY;AACjC,UAAU,gFAAmB;AAC7B,IAAI,wBAAwB,uDAAY;AACxC,UAAU,gFAAmB;AAC7B,IAAI,wBAAwB,sDAAW;AACvC,UAAU,8EAAiB;AAC3B,IAAI,yBAAyB,sDAAW,mBAAmB,sDAAW;AACtE,UAAU,8EAAiB;AAC3B,IAAI,wBAAwB,sDAAW;AACvC,UAAU,6EAAgB;AAC1B;AACA,SAAS,8EAAiB;AAC1B;AACA;AACA,sBAAsB,sDAAW,mBAAmB,sDAAW,mBAAmB,sDAAW;AAC7F,UAAU,2EAAc;AACxB,IAAI,wBAAwB,uDAAY;AACxC,yCAAyC,0EAAa,GAAG,2EAAc;AACvE,IAAI,wBAAwB,uDAAY;AACxC,6CAA6C,0EAAa,GAAG,2EAAc;AAC3E;AACA,SAAS,0EAAa;AACtB;AACA;AACA;AACA,sBAAsB,yDAAc;AACpC;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kEAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kFAAqB;AAClC,aAAa,kFAAqB;AAClC;AACA,GAAG;AACH;AACA,qBAAqB,sDAAW,oBAAoB,sDAAW,mBAAmB,sDAAW;AAC7F;AACA,yBAAyB,sEAAS;AAClC,gBAAgB,6EAAY;AAC5B;AACA,IAAI;AACJ,IAAI;AACJ,gBAAgB,6EAAY;AAC5B;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAW,uBAAuB,6EAAgB,GAAG,8EAAiB;AACtG,sBAAsB,kEAAO;AAC7B;AACA;AACA;AACA;AACA;AACA,cAAc,2EAAc;AAC5B,cAAc,2EAAc;AAC5B,aAAa,kFAAqB;AAClC,aAAa,kFAAqB;AAClC;AACA,GAAG;AACH;AACA,kBAAkB,OAAO;AACzB,sBAAsB,6EAAY;AAClC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;;;;;;;;AC3H0B;AACA;AACA;AACgB;AACX;AACR;AACsC;;AAElF,6BAA6B,oEAAW;AACxC,mBAAmB,oDAAI;AACvB,0BAA0B,oDAAI;AAC9B,wBAAwB,oDAAI,QAAQ,oDAAI,QAAQ,oDAAI,QAAQ,oDAAI,QAAQ,oDAAI,QAAQ,oDAAI,QAAQ,oDAAI,QAAQ,oDAAI;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qDAAS;AAC/B;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD,qFAAqF,4DAAiB;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA,gBAAgB,oDAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC,mFAAmF,4DAAiB;AACpG;AACA;AACA;AACA;AACA,oBAAoB,2FAA2B;AAC/C;AACA;AACA;AACA;AACA;;AAEqC;;;;;;;;;;;;;;;;;;;ACtJU;AACH;AACqB;AAC+B;;AAEhG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qDAAS;AAChC;AACA;AACA;AACA,6BAA6B,yDAAc;AAC3C,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yDAAc;AAC9B;AACA;AACA;AACA,KAAK,kBAAkB,yDAAc;AACrC;AACA;AACA;AACA;AACA,iDAAiD,oDAAI;AACrD,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA,uBAAuB,6BAA6B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA,qCAAqC,yDAAc;AACnD;AACA,uBAAuB,kBAAkB;AACzC,4BAA4B,yGAAiC;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChFkB;AACF;AACA;AACA;AACqG;AAC9E;AAC4J;AACnL;AACe;AACA;AACd;AACsD;AACE;AACpC;;AAEpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA,0BAA0B,oDAAI;AAC9B,8BAA8B,oDAAI;AAClC;AACA,4BAA4B,oDAAI;AAChC,2BAA2B,oDAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sEAAY,8BAA8B,sEAAY,WAAW;AAC7F;AACA;AACA,0BAA0B,IAAI;AAC9B,gCAAgC,IAAI;AACpC;AACA;AACA;AACA;AACA,6BAA6B,yEAAU;AACvC,+BAA+B,yEAAU;AACzC;AACA;AACA;AACA,oBAAoB,yDAAW;AAC/B,oBAAoB,sDAAW,kBAAkB,uDAAY;AAC7D,8BAA8B,sDAAK;AACnC,IAAI;AACJ,8BAA8B,sDAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sDAAW,oBAAoB,sDAAW,mBAAmB,sDAAW;AACrG,eAAe,yDAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yDAAc;AACrC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gHAAgH,yDAAc;AAC9H;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB;AAC3C;AACA;AACA;AACA,iFAAiF,oDAAI;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,UAAU,GAAG,WAAW;AAChE,oBAAoB,uDAAU;AAC9B;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,wDAAa;AACtC;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wDAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,4DAAiB;AAClG,iCAAiC,iEAAsB;AACvD,4BAA4B,4DAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gEAAqB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gEAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gEAAqB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sEAAY;AAC9B,mCAAmC,WAAW;AAC9C;AACA;AACA,KAAK;AACL;AACA;AACA,oCAAoC,SAAS,EAAE,WAAW,EAAE,OAAO;AACnE,gBAAgB,0EAAoB;AACpC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,yEAAU;AACjC,8DAA8D,gEAAqB;AACnF;AACA;AACA;AACA;AACA,uCAAuC,sDAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wDAAa;AAChC,EAAE,mFAAkB;AACpB;AACA;AACA;AACA;AACA,EAAE,mFAAkB;AACpB;AACA;AACA;AACA;AACA,gCAAgC,6FAAmB,mBAAmB,uFAAa,0BAA0B,8EAAgB;AAC7H,kCAAkC,qFAAe,mBAAmB,6FAAuB,CAAC,8FAAgC,EAAE,gFAAkB,GAAG,kFAAoB;AACvK;AACA;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;;ACrVoC;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sEAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yGAAyG,sEAAa;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEkC;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9EsB;AACV;AACF;AACA;AACA;AACA;AACA;AACgE;AACpB;AACzB;AACzB;AACe;AACI;;AAEzD,oBAAoB,gEAAY;AAChC;AACA;AACA;AACA;AACA;AACA,0BAA0B,sDAAK;AAC/B;AACA;AACA,sBAAsB,sDAAK;AAC3B;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oDAAI;AAC1B;AACA,cAAc,mDAAQ;AACtB,0BAA0B,qDAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oDAAI;AACjC,iCAAiC,oDAAI;AACrC,iCAAiC,oDAAI;AACrC;AACA;AACA;AACA;AACA;AACA,6BAA6B,wEAAc;AAC3C;AACA,GAAG;AACH,kBAAkB,+CAAG;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8DAAS;AAChC;AACA;AACA,kCAAkC,4DAAiB;AACnD;AACA;AACA,gCAAgC,qDAAI;AACpC;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mFAAqB;AAC1C,qBAAqB,mFAAqB;AAC1C,sBAAsB,2EAAa;AACnC,sBAAsB,2EAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mEAAW;AACxC;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oDAAI;AACvC;AACA;AACA;AACA,KAAK;AACL,oCAAoC,oDAAI,cAAc,oDAAI;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sDAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,oDAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,qEAAqE,+EAAiB;AACtF;AACA;AACA;AACA;;AAEiB;;;;;;;;;;;;;;;ACtVjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,oBAAoB,MAAM;AAC1B;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB,MAAM,IAAI,UAAU;AACvC;AACA,GAAG;AACH;AACA;;AAEwB;;;;;;;;;;;;;;;ACxBxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;;;;;ACvB0C;AACN;AACN;AACoB;;AAExE;AACA,eAAe;AACf,YAAY;AACZ,SAAS;AACT,mBAAmB;AACnB;;AAEmC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACZoB;AACO;AACV;AACF;AACT;AACkB;AACH;AACN;AACU;AACY;AACV;AACtB;AACA;AACoB;AACA;AACU;AACzB;AACK;AACJ;AACS;AACU;AACE;AACG;AACI;AACA;AACd;AACd;AACF;AACsB;AACE;AACV;AACH;AACmB;AAC3B;AACY;AACR;AACkB;AAChB;AACN;AACT;AACA;AACa;AACA;AACM;AACP;AACA;AACgB;AACR;AACe;AACM;AAClB;AACjB;AACE;AACI;AACJ;AACc;AACG;AACA;AACZ;AACA;AAC0B;AACA;AACA;AACA;AAC9B;AAC6B;AACjB;AACkB;AACzB;AACT;AAC2B;AACZ;AACJ;AACM;AACD;AACM;AACS;AACN;AACA;AAChB;AACW;AACA;AACzB;AACiB;AACZ;AACuB;AACvB;AACC;AACuB;AACL;AACP;AACG;AACL;AACE;AACJ;AACa;AACpB;AACU;AACY;AACA;AACT;AACJ;AACN;AACU;AACJ;AACA;AACA;AAC4B;AACF;AACZ;AACM;AACA;AACE;AACA;AACA;AACF;AACE;AACU;AACN;AACE;AACF;AACF;AACJ;AACF;AACU;AACJ;AAChB;AACQ;AACM;AACd;AACA;AACgB;AACd;AACM;AACE;AACI;AACZ;AACI;AACM;AACE;AACZ;AACA;AACM;AACR;AACE;AACjB;AACU;AACA;AACI;AACE;AACJ;AACM;AACF;AACF;AACM;AACb;AACc;AACV;AACG;AACR;AACE;AACF;AACc;AACN;AACM;AACd;AACY;AACD;AACJ;AACN;AACJ;AACI;AACA;AACN;AACM;AACA;AACkB;AAC/B;AACE;AACA;AACoB;AACU;AACtB;AACY;AACxB;AACoB;AACZ;AACc;AACG;AACR;AACU;AACE;AACE;AACJ;AACI;AACE;AACN;AACZ;AACQ;AACA;AACG;AAC1B;AACA;AACQ;AACM;AAC2B;AACA;;AAE/E;AACA,YAAY;AACZ,kBAAkB;AAClB,aAAa;AACb,YAAY;AACZ,KAAK;AACL,cAAc;AACd,eAAe;AACf,YAAY;AACZ,iBAAiB;AACjB,uBAAuB;AACvB,kBAAkB;AAClB,OAAO;AACP,OAAO;AACP,iBAAiB;AACjB,iBAAiB;AACjB,sBAAsB;AACtB,QAAQ;AACR,YAAY;AACZ,UAAU;AACV,YAAY;AACZ,iBAAiB;AACjB,kBAAkB;AAClB,wBAAwB;AACxB,wBAAwB;AACxB,sBAAsB;AACtB,iBAAiB;AACjB,UAAU;AACV,SAAS;AACT,oBAAoB;AACpB,qBAAqB;AACrB,gBAAgB;AAChB,cAAc;AACd,uBAAuB;AACvB,cAAc;AACd,UAAU;AACV,mBAAmB;AACnB,SAAS;AACT,WAAW;AACX,SAAS;AACT,MAAM;AACN,MAAM;AACN,WAAW;AACX,WAAW;AACX,cAAc;AACd,YAAY;AACZ,YAAY;AACZ,oBAAoB;AACpB,gBAAgB;AAChB,sBAAsB;AACtB,yBAAyB;AACzB,iBAAiB;AACjB,SAAS;AACT,UAAU;AACV,YAAY;AACZ,UAAU;AACV,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,WAAW;AACX,WAAW;AACX,QAAQ;AACR,QAAQ;AACR,QAAQ;AACR,QAAQ;AACR,QAAQ;AACR,yBAAyB;AACzB,cAAc;AACd,uBAAuB;AACvB,aAAa;AACb,MAAM;AACN,sBAAsB;AACtB,gBAAgB;AAChB,cAAc;AACd,iBAAiB;AACjB,cAAc;AACd,iBAAiB;AACjB,wBAAwB;AACxB,qBAAqB;AACrB,qBAAqB;AACrB,aAAa;AACb,iBAAiB;AACjB,gBAAgB;AAChB,MAAM;AACN,YAAY;AACZ,oBAAoB;AACpB,OAAO;AACP,OAAO;AACP,SAAS;AACT,kBAAkB;AAClB,kBAAkB;AAClB,YAAY;AACZ,gBAAgB;AAChB,WAAW;AACX,YAAY;AACZ,UAAU;AACV,gBAAgB;AAChB,SAAS;AACT,cAAc;AACd,oBAAoB;AACpB,oBAAoB;AACpB,cAAc;AACd,YAAY;AACZ,QAAQ;AACR,aAAa;AACb,WAAW;AACX,WAAW;AACX,WAAW;AACX,yBAAyB;AACzB,wBAAwB;AACxB,kBAAkB;AAClB,qBAAqB;AACrB,qBAAqB;AACrB,sBAAsB;AACtB,sBAAsB;AACtB,sBAAsB;AACtB,qBAAqB;AACrB,sBAAsB;AACtB,2BAA2B;AAC3B,wBAAwB;AACxB,yBAAyB;AACzB,wBAAwB;AACxB,uBAAuB;AACvB,qBAAqB;AACrB,oBAAoB;AACpB,yBAAyB;AACzB,uBAAuB;AACvB,eAAe;AACf,mBAAmB;AACnB,sBAAsB;AACtB,eAAe;AACf,eAAe;AACf,uBAAuB;AACvB,gBAAgB;AAChB,mBAAmB;AACnB,oBAAoB;AACpB,sBAAsB;AACtB,gBAAgB;AAChB,kBAAkB;AAClB,qBAAqB;AACrB,sBAAsB;AACtB,gBAAgB;AAChB,gBAAgB;AAChB,mBAAmB;AACnB,eAAe;AACf,gBAAgB;AAChB,UAAU;AACV,eAAe;AACf,eAAe;AACf,iBAAiB;AACjB,kBAAkB;AAClB,gBAAgB;AAChB,mBAAmB;AACnB,kBAAkB;AAClB,iBAAiB;AACjB,oBAAoB;AACpB,YAAY;AACZ,mBAAmB;AACnB,cAAc;AACd,iBAAiB;AACjB,aAAa;AACb,cAAc;AACd,aAAa;AACb,oBAAoB;AACpB,iBAAiB;AACjB,oBAAoB;AACpB,aAAa;AACb,mBAAmB;AACnB,iBAAiB;AACjB,eAAe;AACf,YAAY;AACZ,UAAU;AACV,YAAY;AACZ,YAAY;AACZ,SAAS;AACT,WAAW;AACX,YAAY;AACZ,oBAAoB;AACpB,OAAO;AACP,QAAQ;AACR,QAAQ;AACR,kBAAkB;AAClB,uBAAuB;AACvB,YAAY;AACZ,kBAAkB;AAClB,MAAM;AACN,gBAAgB;AAChB,UAAU;AACV,iBAAiB;AACjB,gBAAgB;AAChB,YAAY;AACZ,kBAAkB;AAClB,mBAAmB;AACnB,oBAAoB;AACpB,kBAAkB;AAClB,oBAAoB;AACpB,qBAAqB;AACrB,kBAAkB;AAClB,YAAY;AACZ,gBAAgB;AAChB,eAAe;AACf,mBAAmB;AACnB,MAAM;AACN,MAAM;AACN,UAAU;AACV,aAAa;AACb,SAAS;AACT,SAAS;AACT;;AAEwB;;;;;;;;;;;;;;;AClaxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8B;;;;;;;;;;;;;;;ACjB9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;ACjC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;AClC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiC;;;;;;;;;;;;;;;ACjBjC;AACA;AACA;AACA;AACA;;AAEiC;;;;;;;;;;;;;;;ACNjC;AACA;AACA;AACA;AACA;AACA;;AAEoC;;;;;;;;;;;;;;;ACPpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4C;;;;;;;;;;;;;;;AClB5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+C;;;;;;;;;;;;;;;ACxC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;;;;;;;;;;;;;;;ACRvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiC;;;;;;;;;;;;;;;ACfjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiC;;;;;;;;;;;;;;;ACnBjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;;;;;;;;;;;;;;;AC7BvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6B;;;;;;;;;;;;;;;AC5D7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoC;;;;;;;;;;;;;;;ACRpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;;;ACVC;AACA;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,8BAA8B;AAC9B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,EAAE,kDAAQ;AACV,EAAE,kDAAQ;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D,+DAA+D;AAC/D,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;AC7MlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyC;;;;;;;;;;;;;;;AC5BzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoC;;;;;;;;;;;;;;;ACnDpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;ACXlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;;;;;;;;;;;;;;;ACbxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyC;;;;;;;;;;;;;;;AC3BzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;;;;;;;;;;;;;;;ACpB1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;;;;;;;;;;;;;;;ACXxC;AACA;AACA;AACA;AACA;AACA;;AAE0C;;;;;;;;;;;;;;;ACP1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2C;;;;;;;;;;;;;;;ACnB3C;AACA;AACA;AACA;AACA;;AAEwC;;;;;;;;;;;;;;;ACNxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;;;;;;;;;;;;;;;ACVvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6B;;;;;;;;;;;;;;;ACrB7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;;;;;;;;;;;;;;;AChBvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqC;;;;;;;;;;;;;;;ACvBrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;AC/BlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;;;;;;;;;;;;;;;ACxChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;AClHlC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsC;;;;;;;;;;;;;;;ACRtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEqC;;;;;;;;;;;;;;;AClBrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;ACblC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyC;;;;;;;;;;;;;;;AC1DzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;AClB/B;AACA;AACA;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;ACN5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;;;;;;;;;;;;;;;AC3BvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsC;;;;;;;;;;;;;;;AClBtC;AACA;AACA;AACA;AACA;;AAEgC;;;;;;;;;;;;;;;ACNhC;AACA;AACA;AACA;AACA;;AAEwC;;;;;;;;;;;;;;;ACNxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmC;;;;;;;;;;;;;;;ACdnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;AClBlC;AACA;AACA;AACA;AACA;;AAEqC;;;;;;;;;;;;;;;ACNrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;AChBlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;;;;;;;;;;;;;;;ACdvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6C;;;;;;;;;;;;;;;ACX7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;;;;;;;;;;;;;;;ACbxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6B;;;;;;;;;;;;;;;ACd7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;;;;;;;;;;;;;;;ACVvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4C;;;;;;;;;;;;;;;ACX5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;ACRlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;;;;;;;;;;;;;;;AC3ChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kCAAkC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gCAAgC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;;;;;;;;;;;;;;;AC1hBvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8C;;;;;;;;;;;;;;;ACf9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8C;;;;;;;;;;;;;;;AC5G9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4C;;;;;;;;;;;;;;;AC1C5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;;;;;;;;;;;;;;;AC1BhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;AChC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;;;;;;;;;;;;;;;AClB1C;AACA;AACA;AACA;AACA;;AAE2C;;;;;;;;;;;;;;;ACN3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsC;;;;;;;;;;;;;;;ACbtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoC;;;;;;;;;;;;;;;AC9BpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6C;;;;;;;;;;;;;;;ACb7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;ACV5B;AACA;;AAEkC;;;;;;;;;;;;;;;ACHlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;;;;;;;;;;;;;;;AChB1C;AACA;AACA;AACA;AACA;AACA;;AAEsC;;;;;;;;;;;;;;;ACPtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;;;;;;;;;;;;;;;AC3BvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;ACZ/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;;;;;;;;;;;;;;;ACZhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;ACblC;AACA;AACA;AACA;AACA;AACA;;AAEgC;;;;;;;;;;;;;;;ACPhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;;;;;;;;;;;;;;;ACzBvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+C;;;;;;;;;;;;;;;ACnF/C;AACA;AACA;AACA;AACA;;AAE4C;;;;;;;;;;;;;;;ACN5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsC;;;;;;;;;;;;;;;ACRtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmC;;;;;;;;;;;;;;;ACpBnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8C;;;;;;;;;;;;;;;AChC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2C;;;;;;;;;;;;;;;ACZ3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2C;;;;;;;;;;;;;;;ACV3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoC;;;;;;;;;;;;;;;ACpBpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;;;;;;;;;;;;;;;ACzCvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;ACpT5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;;;;;;;;;;;;;;;ACV1C;AACA;;AAE+B;;;;;;;;;;;;;;;ACH/B;AACA;AACA;;AAEoC;;;;;;;;;;;;;;;ACJpC;AACA;AACA;;AAE0C;;;;;;;;;;;;;;;ACJ1C;AACA;AACA;AACA;;AAE0C;;;;;;;;;;;;;;;ACL1C;AACA;AACA;AACA;AACA;;AAEgC;;;;;;;;;;;;;;;ACNhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqC;;;;;;;;;;;;;;;ACZrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqC;;;;;;;;;;;;;;;ACRrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;;;;;;;;;;;;;;;ACbvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsC;;;;;;;;;;;;;;;AC3CtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;;;;;;;;;;;;;;;ACvBxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;;;;;;;;;;;;;;;ACXxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyC;;;;;;;;;;;;;;;AClBzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;;;;;;;;;;;;;;;AC/BvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;;;;;;;;;;;;;;;ACvE1C;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;;;;;;;;;;;;;;;ACtCvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmC;;;;;;;;;;;;;;;ACbnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoC;;;;;;;;;;;;;;;ACtBpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uBAAuB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmC;;;;;;;;;;;;;;;AClJnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;;;;;;;;;;;;;;;AC7C1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;;;;;;;;;;;;;;;AC9JvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;;;;;;;;;;;;;;;AClD1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmC;;;;;;;;;;;;;;;ACvBnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyC;;;;;;;;;;;;;;;AC1BzC;AACA;AACA;AACA;AACA;AACA;;AAE6B;;;;;;;;;;;;;;;ACP7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8B;;;;;;;;;;;;;;;ACT9B;AACA;AACA;AACA;;AAEwC;;;;;;;;;;;;;;;ACLxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6C;;;;;;;;;;;;;;;ACX7C;AACA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;ACPlC;AACA;AACA;AACA;AACA;AACA;;AAEyC;;;;;;;;;;;;;;;ACPzC;AACA;AACA;AACA;AACA;;AAEgC;;;;;;;;;;;;;;;ACNhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6B;;;;;;;;;;;;;;;ACf7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;;;;;;;;;;;;;;;ACTvC;AACA;;AAE4B;;;;;;;;;;;;;;;ACH5B;AACA;;AAEkC;;;;;;;;;;;;;;;ACHlC;AACA;AACA;AACA;AACA;AACA;;AAEmC;;;;;;;;;;;;;;;ACPnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;ACzC/B;AACA;AACA;AACA;AACA;AACA;;AAEwC;;;;;;;;;;;;;;;ACPxC;AACA;AACA;AACA;AACA;AACA;;AAEsC;;;;;;;;;;;;;;;ACPtC;AACA;AACA;AACA;;AAE8B;;;;;;;;;;;;;;;ACL9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;;;;;;;;;;;;;;;ACTxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;ACnB5B;AACA;AACA;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;ACN5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmC;;;;;;;;;;;;;;;ACVnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiC;;;;;;;;;;;;;;;AChCjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2C;;;;;;;;;;;;;;;ACZ3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2C;;;;;;;;;;;;;;;AC7B3C;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAE4C;;;;;;;;;;;;;;;ACV5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;;AAE4C;;;;;;;;;;;;;;;AClC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4C;;;;;;;;;;;;;;;ACtB5C;AACA;AACA;AACA;;AAE2C;;;;;;;;;;;;;;;ACL3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4C;;;;;;;;;;;;;;;ACxC5C;AACA;AACA;AACA;AACA;AACA;;AAEiD;;;;;;;;;;;;;;;ACPjD;AACA;AACA;;AAE8C;;;;;;;;;;;;;;;ACJ9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+C;;;;;;;;;;;;;;;ACR/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8C;;;;;;;;;;;;;;;AClB9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6C;;;;;;;;;;;;;;;ACnE7C;AACA;AACA;AACA;AACA;;AAE0C;;;;;;;;;;;;;;;ACN1C;AACA;AACA;AACA;;AAE+C;;;;;;;;;;;;;;;ACL/C;AACA;AACA;;AAE6C;;;;;;;;;;;;;;;ACJ7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqC;;;;;;;;;;;;;;;ACRrC;AACA;AACA;AACA;AACA;AACA;;AAE6C;;;;;;;;;;;;;;;ACP7C;AACA;AACA;AACA;;AAEyC;;;;;;;;;;;;;;;ACLzC;AACA;AACA;AACA;AACA;AACA;;AAE0C;;;;;;;;;;;;;;;ACP1C;AACA;AACA;AACA;;AAE2C;;;;;;;;;;;;;;;ACL3C;AACA;AACA;AACA;AACA;AACA;;AAEsC;;;;;;;;;;;;;;;ACPtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiC;;;;;;;;;;;;;;;AC5EjC;AACA;AACA;;AAE+C;;;;;;;;;;;;;;;ACJ/C;AACA;AACA;;AAE8C;;;;;;;;;;;;;;;ACJ9C;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;;;;;;;;;;;;;;;ACdxC;AACA;AACA;AACA;;AAEqC;;;;;;;;;;;;;;;ACLrC;AACA;AACA;AACA;;AAE2C;;;;;;;;;;;;;;;ACL3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqC;;;;;;;;;;;;;;;AC5ErC;AACA;AACA;AACA;AACA;;AAEyC;;;;;;;;;;;;;;;ACNzC;AACA;AACA;AACA;;AAE4C;;;;;;;;;;;;;;;ACL5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqC;;;;;;;;;;;;;;;ACVrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsC;;;;;;;;;;;;;;;AClDtC;AACA;AACA;;AAE4C;;;;;;;;;;;;;;;ACJ5C;AACA;AACA;AACA;AACA;AACA;;AAEsC;;;;;;;;;;;;;;;ACPtC;AACA;AACA;;AAEwC;;;;;;;;;;;;;;;ACJxC;AACA;AACA;;AAE4C;;;;;;;;;;;;;;;ACJ5C;AACA;AACA;;AAEsC;;;;;;;;;;;;;;;ACJtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyC;;;;;;;;;;;;;;;ACTzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsC;;;;;;;;;;;;;;;ACRtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;ACZlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;ACrBlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;AC5B/B;AACA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;ACPlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2B;;;;;;;;;;;;;;;ACb3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoC;;;;;;;;;;;;;;;ACXpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;AClBlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;;;;;;;;;;;;;;;ACtBvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;;;;;;;;;;;;;;;ACfxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoC;;;;;;;;;;;;;;;ACrBpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;;;;;;;;;;;;;;;ACnBhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyC;;;;;;;;;;;;;;;ACXzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiC;;;;;;;;;;;;;;;ACxBjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8B;;;;;;;;;;;;;;;ACtB9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;ACb5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoC;;;;;;;;;;;;;;;AChBpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6C;;;;;;;;;;;;;;;AChB7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoC;;;;;;;;;;;;;;;ACXpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEuC;;;;;;;;;;;;;;;ACZvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsC;;;;;;;;;;;;;;;ACzBtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;ACnBlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwC;;;;;;;;;;;;;;;ACpBxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;ACflC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiC;;;;;;;;;;;;;;;ACTjC;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;ACNlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsC;;;;;;;;;;;;;;;ACvBtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgC;;;;;;;;;;;;;;;AClBhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiC;;;;;;;;;;;;;;;ACZjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8B;;;;;;;;;;;;;;;ACnB9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmC;;;;;;;;;;;;;;;ACvBnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiC;;;;;;;;;;;;;;;ACnBjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0C;;;;;;;;;;;;;;;ACnB1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsC;;;;;;;;;;;;;;;ACrBtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;AClBlC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqC;;;;;;;;;;;;;;;;;ACnBiC;;AAEtE,sCAAsC,2EAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEgD;;;;;;;;;;;;;;;;;;;;;ACbF;AACS;AACI;AACyD;AACrE;AACqC;;AAEpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,4FAAuB;AACzD,qCAAqC,4FAAuB;AAC5D,2EAA2E,8BAA8B,yDAAc;AACvH,iFAAiF,0BAA0B,wDAAa;AACxH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,KAAK,QAAQ,aAAa;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uDAAQ;AAChC;AACA,wBAAwB,uDAAQ;AAChC,sBAAsB,cAAc,GAAG,cAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uDAAU;AAC/B,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,aAAa,wBAAwB,EAAE,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gEAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,2GAA2G;AAC3G;AACA;AACA,kBAAkB,4BAA4B;AAC9C;AACA,kBAAkB,qCAAqC;AACvD,mBAAmB,4BAA4B;AAC/C;AACA,eAAe;AACf,0DAA0D;AAC1D,iCAAiC,kDAAO,CAAC,yBAAyB,mDAAQ,CAAC;AAC3E,uHAAuH;AACvH;AACA,gDAAgD,gBAAgB,yBAAyB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,yBAAyB,uDAAU;AACnC,kBAAkB,uDAAY,aAAa,sDAAW,aAAa,kEAAuB;AAC1F;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE0B;;;;;;;;;;;;;;;;;;;;ACjMmI;AACpF;AACtB;AACD;AACM;;AAExD;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iEAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA,oBAAoB,8EAAiB;AACrC;AACA;AACA,mCAAmC,iFAAoB;AACvD,mCAAmC,kFAAqB;AACxD;AACA;AACA,6BAA6B,2EAAc;AAC3C;AACA;AACA,iCAAiC,+EAAkB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2DAAY;AAC9C,8BAA8B,2DAAY;AAC1C,2BAA2B,iEAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,iEAAe;AACzC,8BAA8B,2DAAY;AAC1C,8BAA8B,2DAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uDAAU;AACnC;AACA;AACA;AACA,SAAS,2EAAW;AACpB;AACA;AACA;;AAEiB;;;;;;;;;;;;;;;;AC3L0C;;AAE3D;AACA;AACA,eAAe;AACf;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG,aAAa;AAChB,EAAE;AACF;AACA,mBAAmB;AACnB,+DAA+D,gEAAqB,MAAM,UAAU;AACpG,GAAG,WAAW;AACd,EAAE;AACF;AACA;AACA,qBAAqB,6EAA6E,wDAAwD;AAC1J;AACA;;AAE2B;;;;;;;;;;;;;;;;ACxBwD;;AAEnF;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qDAAU;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sDAAW;AAClC,6BAA6B,sDAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mDAAQ;AACrB,eAAe,qDAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4B;;;;;;;;;;;;;;;;;;;;;;;;AC9EqW;AAC9U;AACJ;AACge;AAChd;AACb;AACuB;AACtB;AACK;;AAExD;AACA,gBAAgB,4EAAe;AAC/B,iBAAiB,6EAAgB;AACjC,mBAAmB,+EAAkB;AACrC,mBAAmB,+EAAkB;AACrC,eAAe,2EAAc;AAC7B,qBAAqB,iFAAoB;AACzC,qBAAqB,kFAAqB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,8EAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2DAAY;AAC3C,2BAA2B,2DAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,iBAAiB,2DAAY;AAC7B;AACA,wBAAwB,uDAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mEAAwB,+BAA+B,kEAAuB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,KAAK;AACnC,+BAA+B,QAAQ,EAAE;AACzC,+BAA+B,QAAQ,EAAE;AACzC,kCAAkC,GAAG,GAAG,IAAI;AAC5C,wBAAwB,GAAG,GAAG,IAAI,oBAAoB,GAAG,QAAQ,QAAQ,iBAAiB,GAAG,QAAQ,QAAQ,IAAI;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mEAAwB;AACzD;AACA,IAAI,oCAAoC,kEAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mEAAwB;AACzD;AACA,IAAI,oCAAoC,kEAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAe;AACvB;AACA,QAAQ,0DAAe;AACvB;AACA,QAAQ,4DAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD,4BAA4B,uDAAY,0BAA0B,kEAAuB;AACzF,iCAAiC;AACjC;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,uCAAuC;AACvC;AACA,uFAAuF;AACvF;AACA,4BAA4B,kEAAuB;AACnD;AACA,oCAAoC,4EAAe;AACnD,oCAAoC,4EAAe;AACnD,oCAAoC,4EAAe;AACnD,oCAAoC,4EAAe;AACnD;AACA;AACA;AACA,mCAAmC,4EAAe;AAClD,0CAA0C;AAC1C;AACA;AACA,kDAAkD;AAClD;AACA;AACA,qCAAqC,6EAAgB;AACrD;AACA,+CAA+C;AAC/C,gDAAgD;AAChD,KAAK;AACL,+EAA+E;AAC/E;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA,sCAAsC,EAAE,gBAAgB,EAAE;AAC1D,wBAAwB,EAAE;AAC1B,6BAA6B,GAAG,SAAS,EAAE,GAAG;AAC9C;AACA;AACA,yBAAyB,GAAG,MAAM,GAAG;AACrC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,kCAAkC,2EAAc;AAChD,+CAA+C;AAC/C;AACA;AACA,8CAA8C,2EAAc;AAC5D,6CAA6C,2EAAc;AAC3D,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4EAAe;AACrD;AACA,yBAAyB,aAAa,gBAAgB;AACtD,KAAK;AACL;AACA;AACA,kCAAkC,2EAAc;AAChD,kCAAkC,2EAAc;AAChD,kCAAkC,4EAAe;AACjD,kCAAkC,4EAAe;AACjD;AACA,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,MAAM;AACN,kCAAkC,2EAAc;AAChD,kCAAkC,2EAAc;AAChD,kCAAkC,4EAAe;AACjD,kCAAkC,4EAAe;AACjD;AACA,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC;AACA;AACA,kCAAkC,4EAAe;AACjD,kCAAkC,4EAAe;AACjD,kCAAkC,4EAAe;AACjD,kCAAkC,4EAAe;AACjD;AACA,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,MAAM;AACN,kCAAkC,4EAAe;AACjD,kCAAkC,4EAAe;AACjD,kCAAkC,4EAAe;AACjD,kCAAkC,4EAAe;AACjD;AACA,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC,wCAAwC;AACxC;AACA;AACA;AACA;AACA,wCAAwC,iFAAoB;AAC5D,wCAAwC,kFAAqB;AAC7D,WAAW,iEAAe;AAC1B;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,gCAAgC,oBAAoB,EAAE,GAAG;AACzD,8CAA8C,gBAAgB;AAC9D;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA,UAAU,iEAAe;AACzB;AACA,qCAAqC;AACrC,UAAU,iEAAe;AACzB;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,UAAU,iEAAe;AACzB;AACA,gDAAgD;AAChD,UAAU,iEAAe;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAqB;AACzC,sBAAsB,sDAAW,mBAAmB,uDAAY,mBAAmB,uDAAY,mBAAmB,sDAAW;AAC7H,iBAAiB,sDAAW;AAC5B;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA,qBAAqB,uDAAY;AACjC;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI,wBAAwB,uDAAY;AACxC;AACA;AACA,oBAAoB,gEAAqB;AACzC,uCAAuC;AACvC,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,sCAAsC,sDAAW,mBAAmB,sDAAW,mBAAmB,sDAAW,mBAAmB,sDAAW;AAC3I,sCAAsC,yDAAc,mBAAmB,sDAAW;AAClF;AACA;AACA;AACA,IAAI,wBAAwB,sDAAW;AACvC,2CAA2C;AAC3C,gDAAgD;AAChD,iCAAiC;AACjC,2DAA2D;AAC3D,2BAA2B;AAC3B,aAAa;AACb;AACA,qBAAqB,sDAAW;AAChC,WAAW,2DAAY;AACvB;AACA,UAAU,iEAAe;AACzB;AACA,+BAA+B,sDAAW,mBAAmB,uDAAY,mBAAmB,uDAAY;AACxG;AACA,4CAA4C,gEAAqB,4BAA4B,yDAAc;AAC3G;AACA;AACA,6CAA6C;AAC7C,IAAI;AACJ,+FAA+F;AAC/F;AACA;AACA;AACA,yDAAyD,0CAA0C;AACnG,gHAAgH;AAChH;AACA;AACA;AACA,gDAAgD;AAChD,IAAI;AACJ,oCAAoC,sDAAW;AAC/C;AACA,wCAAwC;AACxC,KAAK;AACL;AACA,uCAAuC;AACvC;AACA,0CAA0C;AAC1C;AACA,IAAI,wBAAwB,sDAAW;AACvC,sFAAsF;AACtF,IAAI;AACJ;AACA;AACA,UAAU,iEAAe;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAY;AAC/B,mBAAmB,2DAAY;AAC/B,sBAAsB,2DAAY;AAClC,mBAAmB,2DAAY;AAC/B;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,8DAAmB;AAC9D,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,qCAAqC,8EAAiB;AACtD;AACA;AACA;AACA;AACA,0BAA0B,mBAAmB,4BAA4B;AACzE,0BAA0B,mBAAmB,4BAA4B;AACzE;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA,yDAAyD,gEAAqB;AAC9E;AACA;AACA,qEAAqE,8DAAmB;AACxF,oCAAoC,EAAE,OAAO;AAC7C,6BAA6B,sDAAW;AACxC,sCAAsC,EAAE,kBAAkB;AAC1D,qCAAqC,EAAE,cAAc;AACrD;AACA,qBAAqB,gEAAqB;AAC1C,qCAAqC,EAAE,WAAW;AAClD,KAAK;AACL,qCAAqC,EAAE,UAAU;AACjD,sCAAsC,EAAE,QAAQ;AAChD,sBAAsB,yDAAc;AACpC,sCAAsC,EAAE,WAAW;AACnD,uCAAuC,EAAE,gBAAgB;AACzD,uCAAuC,EAAE,gBAAgB;AACzD;AACA;AACA,sBAAsB,8DAAmB;AACzC,sBAAsB,gEAAqB;AAC3C,sCAAsC,EAAE,UAAU;AAClD;AACA,qCAAqC,EAAE,WAAW;AAClD,qCAAqC,EAAE,YAAY;AACnD;AACA;AACA,qCAAqC,EAAE,cAAc;AACrD,sCAAsC,EAAE,iBAAiB;AACzD,sBAAsB,gEAAqB;AAC3C,sCAAsC,EAAE,wBAAwB;AAChE,uCAAuC,EAAE,2BAA2B;AACpE,uCAAuC,EAAE,oBAAoB;AAC7D;AACA,qCAAqC,EAAE,cAAc;AACrD,sBAAsB,gEAAqB;AAC3C;AACA;AACA,sBAAsB,yDAAc;AACpC,6CAA6C,EAAE,WAAW;AAC1D,MAAM;AACN;AACA,kDAAkD,EAAE,WAAW;AAC/D,OAAO;AACP,4CAA4C,EAAE,WAAW;AACzD;AACA;AACA;AACA;AACA;AACA,8BAA8B,sDAAW;AACzC;AACA;AACA;AACA,uBAAuB,yDAAc;AACrC,8CAA8C,EAAE,QAAQ;AACxD,wCAAwC,EAAE,iBAAiB;AAC3D;AACA,wCAAwC,EAAE,cAAc;AACxD;AACA;AACA,MAAM;AACN,uBAAuB,yDAAc;AACrC,4CAA4C,EAAE,QAAQ;AACtD,wCAAwC,EAAE,iBAAiB;AAC3D;AACA,wCAAwC,EAAE,cAAc;AACxD;AACA;AACA,wCAAwC,EAAE,cAAc;AACxD,wCAAwC,EAAE,cAAc;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iEAAe;AAC7B,cAAc,iEAAe;AAC7B,cAAc,iEAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0DAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,qDAAU;AACnB;AACA;AACA,SAAS,iEAAsB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,uDAAU,qEAAqE,uDAAU;AAC9J,IAAI;AACJ;AACA,2DAA2D,uDAAU;AACrE,IAAI;AACJ;AACA,4DAA4D,uDAAU;AACtE,IAAI;AACJ,8DAA8D,uDAAU;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sDAAW;AAC9B,mBAAmB,sDAAW;AAC9B,mBAAmB,sDAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sDAAW,oBAAoB,sDAAW;AAChE;AACA;AACA,sBAAsB,sDAAW;AACjC;AACA;AACA;AACA;AACA,uBAAuB,sDAAW;AAClC;AACA;AACA,uBAAuB,uDAAY;AACnC;AACA;AACA,uBAAuB,uDAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yDAAc;AACvD;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,yDAAyD,uDAAU;AACnE,KAAK;AACL;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,6DAAkB,sCAAsC;AACvG;AACA;AACA;AACA;AACA,eAAe,oEAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA,2CAA2C;AAC3C,6CAA6C;AAC7C;AACA,iCAAiC;AACjC;AACA,mEAAmE;AACnE;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF;AACxF;AACA;AACA,mGAAmG;AACnG;AACA;AACA;AACA;AACA,sDAAsD,8BAA8B,SAAS;AAC7F,8HAA8H;AAC9H,8FAA8F;AAC9F;AACA;AACA,oKAAoK;AACpK;AACA;AACA;AACA,uDAAuD;AACvD;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,8EAA8E;AAC9E;AACA,kGAAkG;AAClG,wDAAwD;AACxD,OAAO;AACP,0CAA0C;AAC1C;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA,iGAAiG;AACjG;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,MAAM;AACN,gEAAgE;AAChE;AACA;AACA,sEAAsE;AACtE;AACA;AACA;AACA,8DAA8D;AAC9D;AACA,uMAAuM;AACvM;AACA;AACA,mBAAmB,2BAA2B;AAC9C;AACA;AACA,0DAA0D,gEAAqB;AAC/E;AACA;AACA;AACA,qEAAqE,8DAAmB;AACxF;AACA,uBAAuB,8DAAmB;AAC1C,+BAA+B,YAAY,mBAAmB,EAAE,kBAAkB,EAAE,mBAAmB,EAAE,aAAa;AACtH;AACA,sBAAsB,gEAAqB;AAC3C,iDAAiD,EAAE,WAAW;AAC9D,sCAAsC;AACtC,MAAM;AACN;AACA,wBAAwB,yDAAc;AACtC;AACA;AACA,QAAQ,uBAAuB,yDAAc;AAC7C;AACA;AACA;AACA;AACA,iDAAiD,EAAE,WAAW;AAC9D;AACA;AACA,wBAAwB,yDAAc;AACtC,kDAAkD,mCAAmC,EAAE,sCAAsC,QAAQ,EAAE,gBAAgB,EAAE,sBAAsB,EAAE,kBAAkB,mCAAmC,EAAE,sBAAsB,EAAE,oBAAoB,IAAI,sBAAsB;AAC9S,QAAQ;AACR,0DAA0D,EAAE,gBAAgB,EAAE,sBAAsB,EAAE,oBAAoB,sBAAsB;AAChJ;AACA;AACA,wBAAwB,8DAAmB;AAC3C,iCAAiC,8DAAmB;AACpD,4DAA4D,EAAE,qBAAqB;AACnF;AACA,QAAQ;AACR,gEAAgE,EAAE,qBAAqB;AACvF;AACA;AACA,OAAO;AACP,2DAA2D,EAAE,qBAAqB;AAClF;AACA;AACA,gDAAgD;AAChD,uBAAuB,yDAAc;AACrC;AACA,0DAA0D,EAAE,mBAAmB,EAAE,wBAAwB,EAAE,iCAAiC;AAC5I;AACA;AACA;AACA;AACA,uBAAuB,8DAAmB;AAC1C,uBAAuB,gEAAqB;AAC5C,gHAAgH;AAChH,OAAO;AACP,yCAAyC,YAAY,gFAAgF;AACrI;AACA,MAAM;AACN,+GAA+G;AAC/G;AACA;AACA,+CAA+C,sDAAW;AAC1D,8CAA8C,sDAAW,0BAA0B,uDAAY,0BAA0B,uDAAY;AACrI,8CAA8C,sDAAW,0BAA0B,sDAAW,0BAA0B,sDAAW;AACnI;AACA;AACA;AACA,WAAW,sDAAW;AACtB;AACA;AACA;AACA,WAAW,uDAAY;AACvB;AACA;AACA;AACA,WAAW,uDAAY;AACvB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW,sDAAW;AACtB;AACA;AACA,WAAW,sDAAW;AACtB;AACA;AACA,WAAW,sDAAW;AACtB;AACA;AACA,WAAW,sDAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gEAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,EAAE;AACnC,wBAAwB,gEAAqB;AAC7C,yDAAyD,EAAE,6BAA6B,EAAE,gCAAgC,EAAE,qBAAqB;AACjJ;AACA;AACA,+DAA+D,EAAE,GAAG,aAAa,SAAS,EAAE,mFAAmF;AAC/K,wBAAwB,gEAAqB;AAC7C,6CAA6C,EAAE,yBAAyB;AACxE;AACA,mDAAmD,EAAE,kCAAkC,EAAE;AACzF;AACA,4BAA4B,gBAAgB,IAAI,QAAQ;AACxD,QAAQ;AACR,0CAA0C,EAAE;AAC5C,0BAA0B,8DAAmB;AAC7C,8CAA8C,EAAE,2BAA2B,EAAE,uBAAuB,EAAE;AACtG;AACA,4BAA4B,gBAAgB,SAAS,EAAE,iBAAiB,gBAAgB;AACxF;AACA,wBAAwB,yDAAc;AACtC,gCAAgC,eAAe;AAC/C;AACA,6BAA6B,gBAAgB;AAC7C;AACA,QAAQ,uBAAuB,yDAAc;AAC7C,+BAA+B,eAAe;AAC9C;AACA,wCAAwC,GAAG,aAAa,eAAe,GAAG,gBAAgB,EAAE;AAC5F,qDAAqD,EAAE,SAAS,EAAE,kBAAkB;AACpF;AACA;AACA,uBAAuB,8DAAmB;AAC1C;AACA,wEAAwE,EAAE,QAAQ,kCAAkC,yBAAyB;AAC7I,OAAO;AACP,uEAAuE,EAAE,QAAQ,mCAAmC;AACpH;AACA,MAAM;AACN;AACA,4DAA4D,EAAE,QAAQ,kCAAkC,gCAAgC;AACxI,OAAO;AACP,2DAA2D,EAAE,QAAQ,mCAAmC;AACxG;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA,wBAAwB,8DAAmB;AAC3C;AACA,mEAAmE,YAAY,0EAA0E,EAAE,QAAQ,mCAAmC;AACtM;AACA;AACA,iEAAiE,YAAY,gEAAgE,EAAE,QAAQ,mCAAmC;AAC1L;AACA,OAAO;AACP;AACA,wBAAwB,gEAAqB;AAC7C;AACA;AACA;AACA,iMAAiM,EAAE,QAAQ,kCAAkC,EAAE,0DAA0D,MAAM,EAAE;AACjT;AACA;AACA,qKAAqK,EAAE,QAAQ,4BAA4B,MAAM,EAAE;AACnN;AACA;AACA,2KAA2K,EAAE,QAAQ,kCAAkC,EAAE;AACzN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B,EAAE;AACjD;AACA;AACA;AACA,sBAAsB,gEAAqB;AAC3C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,6DAA6D;AAC7D;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA,mCAAmC,qDAAU,gCAAgC,iEAAsB;AACnG,mGAAmG;AACnG;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA,6BAA6B,uDAAY,0BAA0B,8DAAmB;AACtF,4HAA4H;AAC5H,8LAA8L;AAC9L,oGAAoG;AACpG;AACA,yDAAyD;AACzD;AACA;AACA,4BAA4B,uDAAY,0BAA0B,8DAAmB;AACrF;AACA,IAAI,+BAA+B,8DAAmB;AACtD;AACA,IAAI;AACJ;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,IAAI,aAAa,GAAG;AACnE;AACA;AACA,qCAAqC;AACrC,cAAc,iEAAe;AAC7B;AACA,4DAA4D;AAC5D,gFAAgF;AAChF,sEAAsE;AACtE,wEAAwE;AACxE,sEAAsE;AACtE,sEAAsE;AACtE,sEAAsE;AACtE,wEAAwE;AACxE,gFAAgF;AAChF,wEAAwE;AACxE,wEAAwE;AACxE,4EAA4E;AAC5E,0EAA0E;AAC1E,8EAA8E;AAC9E,gFAAgF;AAChF,iEAAiE;AACjE,mEAAmE;AACnE,kEAAkE;AAClE,8DAA8D;AAC9D,uEAAuE;AACvE,4EAA4E;AAC5E,kFAAkF;AAClF,2FAA2F;AAC3F,gFAAgF;AAChF,0EAA0E;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,sDAAW;AAClC;AACA,IAAI,0BAA0B,uDAAY;AAC1C;AACA,IAAI,0BAA0B,kEAAuB;AACrD;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,qBAAqB,2EAAW;AAChC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,oBAAoB,+EAAkB;AACtC;AACA;AACA;AACA;;AAEqB;;;;;;;;;;;;;;;;;;;AC1tCoD;AACe;AACrC;AACK;;AAExD,sCAAsC,iEAAe;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,2DAAY,2BAA2B,2DAAY;AACtF,aAAa,2DAAY;AACzB;AACA;AACA;AACA,8CAA8C,+BAA+B;AAC7E,qCAAqC,gBAAgB;AACrD,yCAAyC,gBAAgB;AACzD;AACA;AACA;AACA,qEAAqE;AACrE,gEAAgE;AAChE,qEAAqE;AACrE,mEAAmE;AACnE,8DAA8D;AAC9D,uDAAuD;AACvD,sCAAsC,2DAAY,yBAAyB,2DAAY;AACvF;AACA,cAAc,2DAAY;AAC1B,8BAA8B,2DAAY,wBAAwB,2DAAY;AAC9E,oCAAoC,2DAAY;AAChD,cAAc,2DAAY;AAC1B,sCAAsC,2DAAY;AAClD;AACA,gCAAgC,2DAAY;AAC5C,yCAAyC,2DAAY;AACrD,6BAA6B,2DAAY;AACzC,wCAAwC,2DAAY;AACpD,wCAAwC,2DAAY;AACpD,yCAAyC,2DAAY;AACrD,cAAc,2DAAY;AAC1B,oCAAoC,2DAAY;AAChD,IAAI;AACJ,oCAAoC,2DAAY;AAChD,cAAc,2DAAY;AAC1B,sCAAsC,2DAAY;AAClD;AACA,yCAAyC,2DAAY;AACrD,6BAA6B,2DAAY;AACzC,wCAAwC,2DAAY;AACpD,wCAAwC,2DAAY;AACpD,yCAAyC,2DAAY;AACrD,cAAc,2DAAY;AAC1B,oCAAoC,2DAAY;AAChD;AACA,eAAe;AACf;AACA;AACA,sCAAsC;AACtC,KAAK;AACL,2CAA2C;AAC3C;AACA,2CAA2C;AAC3C;AACA,uDAAuD;AACvD;AACA,aAAa,2DAAY;AACzB,aAAa,iEAAe;AAC5B,aAAa,iEAAe;AAC5B;AACA,cAAc,2DAAY;AAC1B,IAAI;AACJ,cAAc,2DAAY;AAC1B,IAAI;AACJ,cAAc,2DAAY;AAC1B,IAAI;AACJ,cAAc,2DAAY;AAC1B;AACA,sEAAsE;AACtE,mCAAmC,2DAAY;AAC/C,aAAa,2DAAY;AACzB,mCAAmC,2DAAY;AAC/C,+DAA+D;AAC/D,uCAAuC,2DAAY;AACnD,2DAA2D,2DAAY,0BAA0B,2DAAY;AAC7G,qCAAqC,2DAAY;AACjD,wBAAwB,uDAAY;AACpC,cAAc,2DAAY;AAC1B,IAAI,2BAA2B,yDAAc;AAC7C,cAAc,2DAAY;AAC1B,IAAI,2BAA2B,+DAAoB;AACnD,cAAc,2DAAY;AAC1B;AACA,aAAa,2DAAY;AACzB,SAAS,2EAAW;AACpB;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEoB;;;;;;;;;;;;;;;;;AC/GuJ;AACxH;;AAEnD;AACA;AACA,4BAA4B;AAC5B;AACA;AACA,WAAW;AACX;AACA,kCAAkC,2DAAY;AAC9C;AACA;AACA;AACA,+BAA+B,sBAAsB,IAAI,mBAAmB;AAC5E;AACA,gCAAgC,2DAAY;AAC5C;AACA,oDAAoD,2DAAY;AAChE,IAAI;AACJ,8CAA8C,2DAAY;AAC1D,IAAI;AACJ,gDAAgD,2DAAY;AAC5D;AACA,+CAA+C,2DAAY;AAC3D;AACA,kCAAkC,2DAAY;AAC9C,gBAAgB,qDAAU,cAAc,yDAAc;AACtD,kDAAkD,2DAAY;AAC9D,IAAI,mBAAmB,wDAAa;AACpC,0BAA0B,wCAAwC,2DAAY,YAAY;AAC1F;AACA,iDAAiD,2DAAY;AAC7D;AACA,oCAAoC,2DAAY;AAChD;AACA;AACA,QAAQ,yDAAc;AACtB,kGAAkG,2DAAY;AAC9G,QAAQ,yDAAc;AACtB,kGAAkG,2DAAY;AAC9G,QAAQ,uDAAY;AACpB,gGAAgG,2DAAY;AAC5G,QAAQ,uDAAY;AACpB,gGAAgG,2DAAY;AAC5G,QAAQ,wDAAa;AACrB,mGAAmG,2DAAY;AAC/G,QAAQ,0DAAe;AACvB,mGAAmG,2DAAY;AAC/G;AACA,6FAA6F,2DAAY;AACzG;AACA;;AAE2B;;;;;;;;;;;;;;;;;;;;;ACtDiD;AACzB;AACJ;AAC0B;AACjB;AACF;;AAEtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iEAAe;AACnD;AACA,8BAA8B,aAAa,GAAG,iBAAiB,GAAG,cAAc,GAAG,oBAAoB,GAAG,gBAAgB;AAC1H,uDAAuD,YAAY;AACnE;AACA;AACA;AACA,mCAAmC,uDAAU;AAC7C,0BAA0B,2DAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAY;AACvC,wBAAwB,iEAAe;AACvC,8BAA8B,iEAAe;AAC7C,gCAAgC,2DAAY;AAC5C;AACA,8CAA8C,2DAAY,4BAA4B,2DAAY;AAClG,+BAA+B,2DAAY;AAC3C,IAAI;AACJ,+BAA+B,2DAAY;AAC3C,8BAA8B,2DAAY;AAC1C,+BAA+B,2DAAY;AAC3C;AACA,SAAS,2EAAW;AACpB;AACA;AACA,eAAe,8EAAiB;AAChC,IAAI;AACJ,eAAe,2DAAY;AAC3B;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEkB;;;;;;;;;;;;;;;;;;;;;;;;AChEiL;AACjJ;AACN;AACO;AACJ;AACwC;AAC9B;AACD;;AAExD;AACA;AACA;AACA;AACA,sCAAsC,iEAAe;AACrD;AACA;AACA,4BAA4B,4FAAuB;AACnD,+BAA+B,4FAAuB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA,4BAA4B,mDAAmD,EAAE,kEAAe,iCAAiC;AACjI;AACA;AACA;AACA;AACA;AACA,iDAAiD,yDAAc,gCAAgC,4DAAiB;AAChH;AACA,0DAA0D,mEAAwB;AAClF;AACA,IAAI,6DAA6D,kEAAuB;AACxF;AACA,IAAI;AACJ;AACA,uBAAuB,UAAU;AACjC,KAAK;AACL,uBAAuB,UAAU,GAAG,YAAY;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,KAAK,gBAAgB,KAAK;AACxD;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC,wBAAwB,YAAY;AACpC,gCAAgC,YAAY;AAC5C,+BAA+B,YAAY;AAC3C,6BAA6B,YAAY;AACzC,wCAAwC,SAAS;AACjD,0BAA0B,SAAS;AACnC,iCAAiC,SAAS;AAC1C,gCAAgC,SAAS;AACzC,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,YAAY;AAC7C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,4CAA4C,uDAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uDAAU;AACnC;AACA,wBAAwB,qDAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,EAAE;AACtB,kBAAkB,EAAE;AACpB,qBAAqB,EAAE;AACvB;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B,qBAAqB,MAAM;AAC3B,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yDAAc;AACxD;AACA;AACA,IAAI;AACJ,6EAA6E,0DAAe;AAC5F;AACA,mBAAmB,2DAAY;AAC/B,mBAAmB,2DAAY;AAC/B,mBAAmB,2DAAY;AAC/B,mBAAmB,2DAAY;AAC/B;AACA,4CAA4C,kEAAuB;AACnE,kDAAkD;AAClD,IAAI;AACJ,0CAA0C;AAC1C;AACA;AACA;AACA,gCAAgC;AAChC;AACA,+BAA+B;AAC/B;AACA,wCAAwC,qDAAU,+GAA+G,sDAAW;AAC5K,8BAA8B;AAC9B;AACA,8BAA8B;AAC9B,0CAA0C;AAC1C;AACA;AACA,oCAAoC;AACpC;AACA;AACA,0BAA0B,sDAAW;AACrC,2BAA2B,wDAAa;AACxC;AACA;AACA,mCAAmC,4BAA4B;AAC/D;AACA,6CAA6C;AAC7C;AACA,KAAK;AACL,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS,eAAe,SAAS;AACnF;AACA;AACA,+BAA+B;AAC/B;AACA;AACA,6BAA6B;AAC7B,gDAAgD;AAChD;AACA;AACA,kDAAkD;AAClD;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,oDAAoD;AACpD,2CAA2C;AAC3C;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,4BAA4B;AAC5B,yCAAyC;AACzC;AACA,qCAAqC;AACrC;AACA,iCAAiC;AACjC,sDAAsD;AACtD,kCAAkC;AAClC;AACA,gCAAgC;AAChC,gDAAgD;AAChD;AACA,2DAA2D;AAC3D;AACA;AACA;AACA,oCAAoC;AACpC;AACA,kCAAkC;AAClC,8DAA8D;AAC9D,6CAA6C;AAC7C;AACA,2CAA2C;AAC3C,uEAAuE;AACvE;AACA;AACA,mCAAmC;AACnC,mCAAmC;AACnC;AACA,oCAAoC;AACpC;AACA,6BAA6B;AAC7B,2DAA2D;AAC3D,oCAAoC;AACpC;AACA,uCAAuC;AACvC,oDAAoD;AACpD;AACA;AACA,mCAAmC;AACnC;AACA,iCAAiC;AACjC,iDAAiD;AACjD,6BAA6B;AAC7B;AACA,2BAA2B;AAC3B,qCAAqC;AACrC;AACA;AACA,2CAA2C;AAC3C;AACA,yCAAyC;AACzC,iEAAiE;AACjE;AACA;AACA;AACA,MAAM;AACN,0CAA0C,yBAAyB;AACnE;AACA;AACA,iCAAiC;AACjC,kCAAkC;AAClC,oDAAoD;AACpD,6CAA6C;AAC7C,KAAK;AACL,+CAA+C;AAC/C,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,yBAAyB;AACzB,kCAAkC;AAClC;AACA,+BAA+B;AAC/B;AACA,8BAA8B;AAC9B,6CAA6C;AAC7C;AACA,qCAAqC;AACrC,oCAAoC;AACpC,gCAAgC;AAChC;AACA;AACA;AACA,gCAAgC;AAChC,0CAA0C;AAC1C,sCAAsC;AACtC,+DAA+D;AAC/D,wDAAwD;AACxD,2DAA2D;AAC3D;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,oCAAoC;AACpC;AACA;AACA,+BAA+B;AAC/B,8CAA8C;AAC9C;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,8BAA8B;AAC9B;AACA,8BAA8B;AAC9B,0CAA0C;AAC1C;AACA;AACA,oCAAoC;AACpC;AACA,gCAAgC,sDAAW;AAC3C,iCAAiC,wDAAa;AAC9C;AACA;AACA,mCAAmC,kCAAkC;AACrE;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,yCAAyC,IAAI,UAAU,IAAI,UAAU,IAAI;AACzE,kCAAkC;AAClC;AACA,oCAAoC,yBAAyB;AAC7D;AACA,mBAAmB,sCAAsC,EAAE,cAAc;AACzE;AACA;AACA;AACA;AACA;;AAE+B;;;;;;;;;;;;;;;;;;;;;;;;ACxYsD;AAC1B;AACW;AACpB;AACW;AACI;AACU;;AAE3E,wGAAwG;AACxG;AACA;AACA,GAAG;AACH,4BAA4B,gFAAQ,GAAG;AACvC;AACA,YAAY,gEAAM,SAAS,2EAAW,0BAA0B,gFAAQ,GAAG;AAC3E,WAAW,OAAO,GAAG,OAAO;AAC5B,cAAc,2DAAY;AAC1B,gBAAgB,2DAAY;AAC5B,EAAE;AACF;AACA,wIAAwI;AACxI;AACA;AACA,GAAG;AACH,4BAA4B,gFAAQ,GAAG;AACvC;AACA,wBAAwB,0EAAiB;AACzC;AACA;AACA,eAAe,gEAAM,SAAS,2EAAW,0BAA0B,gFAAQ,GAAG;AAC9E;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,yCAAyC,0EAAe;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,KAAK,MAAM,UAAU;AACrC;AACA;AACA,iBAAiB,0EAAiB;AAClC;AACA,yDAAyD;AACzD,0CAA0C,gFAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,2DAAY;AACZ,2DAAY;;AAEiD;;;;;;;;;;;;;;;;;;ACxEiC;AAC3B;;AAEnE,kCAAkC,2EAAW;AAC7C;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI,wBAAwB,uDAAY;AACxC;AACA,IAAI,wBAAwB,sDAAW;AACvC;AACA;AACA,uCAAuC,QAAQ;AAC/C,6BAA6B,wBAAwB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,yDAAc;AAC/B;AACA,GAAG;AACH,qBAAqB,4DAAiB;AACtC;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsC;;;;;;;;;;;;;;;;;ACzE2B;AACf;;AAElD,uCAAuC,yEAAgB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2DAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6B;;;;;;;;;;;;;;;;;;;ACzEe;AACA;AAC8D;AAChD;;AAE1D,uBAAuB,oDAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oDAAI;AACf;AACA,0BAA0B,kEAAO;AACjC;AACA;AACA,YAAY,gFAAmB;AAC/B;AACA,eAAe,2EAAc;AAC7B,eAAe,2EAAc;AAC7B;AACA,IAAI;AACJ;AACA;AACA,UAAU,6EAAgB;AAC1B,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC,0BAA0B,oDAAI;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;AC3HxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgB;;;;;;;;;;;;;;;;;;;ACR4C;AAC1B;AACwB;AACE;;AAE5D;AACA;AACA;AACA,QAAQ,sDAAW;AACnB;AACA,QAAQ,uDAAY;AACpB;AACA;AACA;AACA;AACA;AACA,SAAS,0CAAI,0BAA0B,kEAAW;AAClD;AACA;AACA,SAAS,0CAAI,0BAA0B,kEAAW;AAClD;AACA,GAAG;AACH;AACA;AACA,mBAAmB,oEAAY;AAC/B;AACA;AACA,GAAG;AACH;AACA;AACA,SAAS,0CAAI;AACb;AACA;;AAEuB;;;;;;;;;;;;;;;;;;;;;;;AClC+C;AACuB;AACkB;AAC3D;AACD;AACsB;AACf;AACV;;AAEhD;AACA;AACA;AACA,uBAAuB,4DAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA,oBAAoB,4DAAiB,2BAA2B,wDAAa,GAAG,qDAAU;AAC1F,0BAA0B,4DAAiB,GAAG,yDAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,iCAAiC,kGAAsB;AACvD,mBAAmB,qFAAiB;AACpC,8BAA8B,kEAAM;AACpC;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,kBAAkB,2EAAc;AAChC;AACA,6CAA6C,yDAAc;AAC3D;AACA,gBAAgB,yDAAW;AAC3B,4BAA4B,2DAAY;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmB;;;;;;;;;;;;;;;;;;;AChE4B;AACI;AACN;AACL;;AAExC;AACA;AACA,eAAe,2DAAgB;AAC/B,qBAAqB,oDAAI;AACzB;AACA,kBAAkB,qDAAS;AAC3B;AACA;AACA,oBAAoB,oDAAI;AACxB;AACA;AACA;AACA;AACA;AACA,6EAA6E,2DAAgB;AAC7F,iCAAiC,oDAAI;AACrC,oCAAoC,oDAAI;AACxC,8BAA8B,oDAAI;AAClC;AACA,sBAAsB,oDAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iDAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2DAAgB;AACpC;AACA;AACA;AACA,KAAK;AACL,oBAAoB,oDAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe;;;;;;;;;;;;;;;;;;;;ACxEyC;AACZ;AACiE;AAC5E;AACiB;;AAElD;AACA;AACA,qBAAqB,gEAAY;AACjC;AACA;AACA;AACA;AACA,wFAAwF,mEAAwB;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,mEAAwB;AACpF;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mEAAwB,cAAc,mEAAwB;AAC7E;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mEAAwB,yBAAyB,kEAAuB;AACrH,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAQ;AAC3B;AACA;AACA;AACA;AACA,SAAS,0CAAI;AACb;AACA;AACA,aAAa,oDAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAQ;AAC3B;AACA;AACA;AACA;AACA,SAAS,0CAAI;AACb;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mEAAwB;AACnD;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEkB;;;;;;;;;;;;;;;;ACvNsC;;AAExD,2BAA2B,gEAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwB;;;;;;;;;;;;;;;;;;ACnDgB;AACI;AACA;AAGrC,MAAM,MAAM;IAQjB;QAFQ,wBAAmB,GAAkB,IAAI,CAAC;QAGhD,IAAI,CAAC,SAAS,GAAG,QAAQ,CAAC,cAAc,CAAC,YAAY,CAAgB,CAAC;QACtE,IAAI,CAAC,YAAY,GAAG,QAAQ,CAAC,cAAc,CAAC,cAAc,CAAgB,CAAC;QAE3E,IAAI,CAAC,SAAS,GAAG,IAAI,iDAAS,CAAC,IAAI,CAAC,CAAC;QACrC,IAAI,CAAC,WAAW,GAAG,IAAI,qDAAW,CAAC,IAAI,CAAC,CAAC;QACzC,IAAI,CAAC,WAAW,GAAG,IAAI,qDAAW,CAAC,IAAI,CAAC,CAAC;QAEzC,IAAI,CAAC,UAAU,EAAE,CAAC;IACpB,CAAC;IAED,UAAU;QACR,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,CAAC;QAC5B,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,CAAC;QAC9B,IAAI,CAAC,WAAW,CAAC,UAAU,EAAE,CAAC;QAE9B,IAAI,CAAC,SAAS,CAAC,oBAAoB,CAAC,CAAC;IACvC,CAAC;IAED,SAAS,CAAC,OAAe;QACvB,IAAI,IAAI,CAAC,SAAS,EAAE,CAAC;YACnB,IAAI,CAAC,SAAS,CAAC,WAAW,GAAG,OAAO,CAAC;QACvC,CAAC;IACH,CAAC;IAED,gBAAgB,CAAC,OAAe,EAAE,QAAQ,GAAG,IAAI;QAC/C,IAAI,IAAI,CAAC,YAAY,EAAE,CAAC;YACtB,IAAI,CAAC,YAAY,CAAC,WAAW,GAAG,OAAO,CAAC;YACxC,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;YAExC,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAC;gBAC7B,YAAY,CAAC,IAAI,CAAC,mBAAmB,CAAC,CAAC;YACzC,CAAC;YAED,IAAI,CAAC,mBAAmB,GAAG,MAAM,CAAC,UAAU,CAAC,GAAG,EAAE;gBAChD,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;gBAC3C,IAAI,CAAC,mBAAmB,GAAG,IAAI,CAAC;YAClC,CAAC,EAAE,QAAQ,CAAC,CAAC;QACf,CAAC;IACH,CAAC;IAED,2BAA2B;IAC3B,QAAQ;QACN,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,CAAC;QAC5B,IAAI,CAAC,SAAS,CAAC,mBAAmB,CAAC,CAAC;QACpC,IAAI,CAAC,gBAAgB,CAAC,mBAAmB,CAAC,CAAC;IAC7C,CAAC;IAED,OAAO;QACL,MAAM,MAAM,GAAG,IAAI,CAAC,SAAS,CAAC,OAAO,EAAE,CAAC;QACxC,IAAI,CAAC,SAAS,CAAC,eAAe,MAAM,CAAC,IAAI,EAAE,CAAC,CAAC;QAC7C,IAAI,CAAC,gBAAgB,CAAC,eAAe,MAAM,CAAC,IAAI,EAAE,CAAC,CAAC;IACtD,CAAC;IAED,SAAS,CAAC,SAAiB;QACzB,IAAI,CAAC;YACH,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,SAAS,CAAc,CAAC;YAChD,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;YAC/B,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,CAAC;YAC/B,IAAI,CAAC,gBAAgB,CAAC,2BAA2B,CAAC,CAAC;QACrD,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,SAAS,CAAC,qBAAqB,CAAC,CAAC;YACtC,IAAI,CAAC,gBAAgB,CAAC,uBAAuB,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;YAC/D,OAAO,CAAC,KAAK,CAAC,sBAAsB,EAAE,KAAK,CAAC,CAAC;QAC/C,CAAC;IACH,CAAC;IAED,SAAS;QACP,IAAI,CAAC;YACH,MAAM,SAAS,GAAG,IAAI,CAAC,SAAS,CAAC,cAAc,EAAE,CAAC;YAClD,IAAI,CAAC,WAAW,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;QACxC,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,IAAI,CAAC,SAAS,CAAC,oBAAoB,CAAC,CAAC;YACrC,IAAI,CAAC,gBAAgB,CAAC,sBAAsB,GAAG,MAAM,CAAC,KAAK,CAAC,CAAC,CAAC;YAC9D,OAAO,CAAC,KAAK,CAAC,qBAAqB,EAAE,KAAK,CAAC,CAAC;QAC9C,CAAC;IACH,CAAC;IAED,YAAY,CAAC,QAAgB;QAC3B,IAAI,CAAC,SAAS,CAAC,kBAAkB,QAAQ,EAAE,CAAC,CAAC;QAC7C,IAAI,CAAC,gBAAgB,CAAC,kBAAkB,QAAQ,EAAE,CAAC,CAAC;IACtD,CAAC;IAED,0CAA0C;IAC1C,YAAY;QACV,OAAO,IAAI,CAAC,SAAS,CAAC;IACxB,CAAC;CACF;;;;;;;;;;;;;;;AClGM,MAAM,WAAW;IAGtB,YAAY,MAAc;QACxB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACvB,CAAC;IAED,UAAU;QACR,+CAA+C;QAC/C,MAAM,CAAC,WAAW,CAAC,mBAAmB,CAAC,CAAC,KAAK,EAAE,QAAQ,EAAE,EAAE;YACzD,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,QAAQ,CAAC,CAAC;QACrC,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,WAAW,CAAC,gBAAgB,CAAC,CAAC,KAAK,EAAE,KAAK,EAAE,EAAE;YACnD,OAAO,CAAC,KAAK,CAAC,qBAAqB,EAAE,KAAK,CAAC,CAAC;YAC5C,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,uBAAuB,KAAK,EAAE,EAAE,IAAI,CAAC,CAAC;QACrE,CAAC,CAAC,CAAC;IACL,CAAC;IAED,OAAO;QACL,wEAAwE;IAC1E,CAAC;IAED,2DAA2D;IAC3D,SAAS,CAAC,SAAiB;QACzB,MAAM,CAAC,WAAW,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;IAC1C,CAAC;CACF;;;;;;;;;;;;;;;AC3BM,MAAM,WAAW;IAGtB,YAAY,MAAc;QACxB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;IACvB,CAAC;IAED,UAAU;QACR,4CAA4C;QAC5C,MAAM,CAAC,WAAW,CAAC,QAAQ,CAAC,GAAG,EAAE;YAC/B,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE,CAAC;QACzB,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,WAAW,CAAC,OAAO,CAAC,GAAG,EAAE;YAC9B,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC;QACxB,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,WAAW,CAAC,SAAS,CAAC,CAAC,KAAK,EAAE,IAAI,EAAE,EAAE;YAC3C,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;QAC9B,CAAC,CAAC,CAAC;QAEH,MAAM,CAAC,WAAW,CAAC,gBAAgB,CAAC,GAAG,EAAE;YACvC,IAAI,CAAC,MAAM,CAAC,SAAS,EAAE,CAAC;QAC1B,CAAC,CAAC,CAAC;IACL,CAAC;IAED,OAAO;QACL,wEAAwE;IAC1E,CAAC;CACF;;;;;;;;;;;;;;;;;;;;;AChCgC;AAIuB;AACN;AAE3C,MAAM,SAAS;IAUpB,YAAY,MAAc;QAJlB,cAAS,GAAW,CAAC,CAAC;QAK5B,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,MAAM,GAAG,QAAQ,CAAC,cAAc,CAAC,cAAc,CAAsB,CAAC;IAC7E,CAAC;IAED,UAAU;QACR,IAAI,CAAC,GAAG,GAAG,IAAI,mDAAc,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAE3C,IAAI,CAAC,cAAc,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,YAAY,EAAE,CAAC;QACpD,MAAM,CAAC,gBAAgB,CAAC,QAAQ,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;QAEvD,IAAI,CAAC,cAAc,EAAE,CAAC;QAEtB,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,CAAC;IACnB,CAAC;IAED,OAAO;QACL,MAAM,CAAC,mBAAmB,CAAC,QAAQ,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;QAC1D,IAAI,IAAI,CAAC,gBAAgB,EAAE,CAAC;YAC1B,IAAI,CAAC,gBAAgB,CAAC,OAAO,EAAE,CAAC;QAClC,CAAC;QAED,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC;IACrB,CAAC;IAED,cAAc;QACZ,IAAI,CAAC,IAAI,GAAG,IAAI,8CAAS,CAAC,MAAM,CAAC,CAAC;QAClC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAElC,IAAI,CAAC,MAAM,GAAG,IAAI,8CAAS,CAAC,QAAQ,CAAC,CAAC;QACtC,IAAI,CAAC,MAAM,CAAC,YAAY,CAAC,QAAQ,EAAE;YACjC,UAAU,EAAE,IAAI,6CAAQ,CAAC,GAAG,EAAE,IAAI,EAAE,GAAG,CAAC;SACzC,CAAC,CAAC;QACH,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QACjC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAC5B,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAEpC,IAAI,CAAC,gBAAgB,GAAG,IAAI,iEAAgB,CAAC,IAAI,CAAC,GAAG,EAAE,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,MAAM,CAAC,CAAC;QAEjF,MAAM,KAAK,GAAG,IAAI,8CAAS,CAAC,mBAAmB,CAAC,CAAC;QACjD,KAAK,CAAC,YAAY,CAAC,OAAO,EAAE;YAC1B,IAAI,EAAE,aAAa;YACnB,KAAK,EAAE,IAAI,6CAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;YAC5B,WAAW,EAAE,IAAI;YACjB,SAAS,EAAE,GAAG;YACd,UAAU,EAAE,IAAI;YAChB,cAAc,EAAE,EAAE;YAClB,gBAAgB,EAAE,IAAI;SACvB,CAAC,CAAC;QACH,KAAK,CAAC,mBAAmB,CAAC,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC,CAAC;QACrC,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QAE9B,+DAAgB,CAAC,IAAI,CAAC,GAAG,EAAE,EAAE,KAAK,EAAE,IAAI,6CAAQ,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC;IACrE,CAAC;IAED,OAAO;QACL,IAAI,CAAC,SAAS,EAAE,CAAC;QACjB,MAAM,IAAI,GAAG,QAAQ,IAAI,CAAC,SAAS,EAAE,CAAC;QAEtC,MAAM,IAAI,GAAG,IAAI,8CAAS,CAAC,IAAI,CAAC,CAAC;QAEjC,MAAM,QAAQ,GAAG,IAAI,wDAAmB,EAAE,CAAC;QAC3C,QAAQ,CAAC,OAAO,GAAG,IAAI,6CAAQ,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,GAAG,EAAE,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,GAAG,CAAC,CAAC;QACjH,QAAQ,CAAC,MAAM,EAAE,CAAC;QAElB,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE;YAC1B,IAAI,EAAE,KAAK;YACX,QAAQ,EAAE,QAAQ;SACnB,CAAC,CAAC;QAEH,IAAI,CAAC,WAAW,CACd,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,GAAG,CAAC,GAAG,CAAC,EACzB,GAAG,EACH,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,GAAG,CAAC,GAAG,CAAC,CAC1B,CAAC;QAEF,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;QACzB,OAAO,IAAI,CAAC;IACd,CAAC;IAED,UAAU;QACR,OAAO,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YACrC,MAAM,KAAK,GAAG,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;YACpC,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;YACpD,IAAI,KAAK,KAAK,IAAI,CAAC,MAAM,IAAI,KAAK,KAAK,UAAU,EAAE,CAAC;gBACjD,KAAK,CAAC,OAAO,EAAE,CAAC;YACnB,CAAC;iBAAM,CAAC;gBACL,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;YAChC,CAAC;QACH,CAAC;QACD,IAAI,CAAC,SAAS,GAAG,CAAC,CAAC;IACrB,CAAC;IAED,cAAc;QACZ,MAAM,SAAS,GAAc;YAC3B,QAAQ,EAAE,EAAE;YACZ,OAAO,EAAE,OAAO;SACjB,CAAC;QAEF,MAAM,eAAe,GAAG,CAAC,MAAiB,EAAuB,EAAE;YACjE,MAAM,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;YACpD,IAAI,MAAM,KAAK,IAAI,CAAC,MAAM,IAAI,MAAM,CAAC,IAAI,KAAK,mBAAmB,IAAI,MAAM,KAAK,UAAU,EAAE,CAAC;gBAC3F,OAAO,IAAI,CAAC;YACd,CAAC;YAED,MAAM,QAAQ,GAAG,MAAM,CAAC,WAAW,EAAE,CAAC;YACtC,MAAM,QAAQ,GAAG,MAAM,CAAC,cAAc,EAAE,CAAC;YACzC,MAAM,KAAK,GAAG,MAAM,CAAC,aAAa,EAAE,CAAC;YAErC,MAAM,IAAI,GAAiB;gBACzB,EAAE,EAAE,MAAM,CAAC,OAAO,EAAE;gBACpB,IAAI,EAAE,MAAM,CAAC,IAAI;gBACjB,IAAI,EAAE,MAAM,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,OAAO;gBACnE,QAAQ,EAAE,CAAC,QAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC;gBAC9C,QAAQ,EAAE,CAAC,QAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,EAAE,QAAQ,CAAC,CAAC,CAAC;gBAC9C,KAAK,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,CAAC;gBAClC,UAAU,EAAE,EAAE;aACf,CAAC;YAEF,MAAM,eAAe,GAAG,MAAM,CAAC,MAAM,CAAC;YACtC,IAAI,eAAe,IAAI,eAAe,CAAC,QAAQ,YAAY,wDAAmB,EAAE,CAAC;gBAC/E,MAAM,gBAAgB,GAAG,eAAe,CAAC,QAA+B,CAAC;gBACzE,IAAI,CAAC,UAAU,GAAG;oBAChB,MAAM,EAAE;wBACN,IAAI,EAAE,eAAe,CAAC,IAAI;wBAC1B,QAAQ,EAAE;4BACR,OAAO,EAAE,gBAAgB,CAAC,OAAO,CAAC,CAAC,CAAC;gCAClC,gBAAgB,CAAC,OAAO,CAAC,CAAC;gCAC1B,gBAAgB,CAAC,OAAO,CAAC,CAAC;gCAC1B,gBAAgB,CAAC,OAAO,CAAC,CAAC;6BAC3B,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC;yBACd;qBACF;iBACF,CAAC;YACJ,CAAC;iBAAM,IAAI,eAAe,EAAE,CAAC;gBAC1B,IAAI,CAAC,UAAU,GAAG;oBACd,MAAM,EAAE,EAAE,IAAI,EAAE,eAAe,CAAC,IAAI,EAAE;iBACzC,CAAC;YACL,CAAC;YAED,OAAO,IAAI,CAAC;QACd,CAAC,CAAC;QAEF,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE;YAClC,MAAM,UAAU,GAAG,eAAe,CAAC,MAAmB,CAAC,CAAC;YACxD,IAAI,UAAU,EAAE,CAAC;gBACb,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YACxC,CAAC;QACH,CAAC,CAAC,CAAC;QAEH,OAAO,IAAI,CAAC,SAAS,CAAC,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC,CAAC;IAC5C,CAAC;IAED,SAAS,CAAC,SAAoB;QAC5B,IAAI,CAAC,UAAU,EAAE,CAAC;QAClB,+DAAgB,CAAC,IAAI,CAAC,GAAG,EAAE,EAAE,KAAK,EAAE,IAAI,6CAAQ,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,CAAC;QAEnE,SAAS,CAAC,QAAQ,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE;YACtC,IAAI,UAAU,CAAC,IAAI,KAAK,MAAM,EAAE,CAAC;gBAC/B,MAAM,IAAI,GAAG,IAAI,8CAAS,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;gBAC5C,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC;gBAE5B,MAAM,UAAU,GAAG,UAAU,CAAC,UAAU,EAAE,MAAM,CAAC;gBACjD,IAAI,UAAU,EAAE,CAAC;oBACb,MAAM,QAAQ,GAAG,IAAI,wDAAmB,EAAE,CAAC;oBAC3C,IAAI,UAAU,CAAC,QAAQ,EAAE,OAAO,EAAE,CAAC;wBACjC,MAAM,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,GAAG,UAAU,CAAC,QAAQ,CAAC,OAAO,CAAC;wBAC9C,QAAQ,CAAC,OAAO,GAAG,IAAI,6CAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;oBAC3C,CAAC;yBAAM,CAAC;wBACN,QAAQ,CAAC,OAAO,GAAG,IAAI,6CAAQ,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;oBAC3C,CAAC;oBACD,QAAQ,CAAC,MAAM,EAAE,CAAC;oBAElB,IAAI,CAAC,YAAY,CAAC,QAAQ,EAAE;wBAC1B,IAAI,EAAE,KAAK;wBACX,QAAQ,EAAE,QAAQ;qBACnB,CAAC,CAAC;gBACP,CAAC;gBAED,IAAI,CAAC,WAAW,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;gBACzF,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;gBAC5F,IAAI,CAAC,aAAa,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;gBAElF,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;gBAEzB,MAAM,KAAK,GAAG,UAAU,CAAC,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC;gBAClD,IAAI,KAAK,EAAE,CAAC;oBACV,MAAM,GAAG,GAAG,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;oBACnC,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,EAAE,GAAG,CAAC,CAAC;gBACjD,CAAC;YACH,CAAC;iBAAM,CAAC;gBACN,OAAO,CAAC,IAAI,CAAC,4CAA4C,UAAU,CAAC,IAAI,EAAE,CAAC,CAAC;YAC9E,CAAC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;CACF;;;;;;;;;;;;;;;;;;;;;ACpNgC;AAajC;;;;;GAKG;AACI,SAAS,gBAAgB,CAAC,GAAmB,EAAE,OAAqB;IACzE,MAAM,IAAI,GAAG,OAAO,EAAE,IAAI,IAAI,EAAE,CAAC;IACjC,MAAM,SAAS,GAAG,OAAO,EAAE,SAAS,IAAI,EAAE,CAAC;IAC3C,MAAM,KAAK,GAAG,OAAO,EAAE,KAAK,IAAI,IAAI,6CAAQ,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;IAC5D,MAAM,IAAI,GAAG,OAAO,EAAE,IAAI,IAAI,MAAM,CAAC;IAErC,MAAM,IAAI,GAAG,IAAI,GAAG,SAAS,CAAC;IAC9B,MAAM,QAAQ,GAAG,IAAI,GAAG,CAAC,CAAC;IAE1B,MAAM,SAAS,GAAa,EAAE,CAAC;IAC/B,MAAM,OAAO,GAAa,EAAE,CAAC;IAC7B,IAAI,KAAK,GAAG,CAAC,CAAC;IAEd,gCAAgC;IAChC,KAAK,IAAI,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC,IAAI,QAAQ,EAAE,CAAC,IAAI,IAAI,EAAE,CAAC;QACjD,SAAS,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC;QAChC,SAAS,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC;QAC/B,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,KAAK,EAAE,CAAC,CAAC;QAE/B,SAAS,CAAC,IAAI,CAAC,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAChC,SAAS,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QAC/B,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,EAAE,KAAK,EAAE,CAAC,CAAC;IACjC,CAAC;IAED,cAAc;IACd,MAAM,IAAI,GAAG,IAAI,4CAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC;IAC7C,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,CAAC;IAC7B,IAAI,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC;IACzB,IAAI,CAAC,MAAM,CAAC,uDAAkB,CAAC,CAAC;IAEhC,kBAAkB;IAClB,MAAM,QAAQ,GAAG,IAAI,qDAAgB,EAAE,CAAC;IACxC,QAAQ,CAAC,KAAK,GAAG,KAAK,CAAC;IACvB,QAAQ,CAAC,MAAM,EAAE,CAAC;IAElB,wBAAwB;IACxB,IAAI,UAAU,GAAG,GAAG,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAc,CAAC;IACxD,IAAI,CAAC,UAAU,EAAE,CAAC;QAChB,UAAU,GAAG,IAAI,8CAAS,CAAC,IAAI,CAAC,CAAC;QACjC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;IAChC,CAAC;SAAM,CAAC;QACN,UAAU,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC;IACvC,CAAC;IAED,uBAAuB;IACvB,UAAU,CAAC,YAAY,CAAC,QAAQ,EAAE;QAChC,IAAI,EAAE,OAAO;QACb,aAAa,EAAE,CAAC,IAAI,oDAAe,CAAC,IAAI,EAAE,QAAQ,CAAC,CAAC;KACrD,CAAC,CAAC;IAEH,OAAO,CAAC,GAAG,CAAC,gBAAgB,IAAI,oBAAoB,CAAC,CAAC;IACtD,OAAO,UAAU,CAAC;AACpB,CAAC;;;;;;;;;;;;;;;;ACvEgC;AAE1B,MAAM,gBAAgB;IAkB3B,YAAY,GAAmB,EAAE,MAAyB,EAAE,MAAiB;QAbrE,eAAU,GAAG,KAAK,CAAC;QACnB,UAAK,GAAG,CAAC,CAAC;QACV,UAAK,GAAG,CAAC,CAAC;QACV,mBAAc,GAAG,CAAC,CAAC;QACnB,eAAU,GAAG,CAAC,CAAC;QACf,eAAU,GAAG,EAAE,CAAC;QAStB,IAAI,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC,8CAA8C;QAC9D,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QAErB,IAAI,CAAC,UAAU,EAAE,CAAC;IACpB,CAAC;IAEO,UAAU;QAChB,yBAAyB;QACzB,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACpD,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAChD,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QACpD,IAAI,CAAC,iBAAiB,GAAG,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;QAEtD,mBAAmB;QACnB,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,WAAW,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;QACjE,MAAM,CAAC,gBAAgB,CAAC,SAAS,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;QACxD,MAAM,CAAC,gBAAgB,CAAC,WAAW,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;QAC5D,IAAI,CAAC,MAAM,CAAC,gBAAgB,CAAC,OAAO,EAAE,IAAI,CAAC,iBAAiB,EAAE,EAAE,OAAO,EAAE,KAAK,EAAE,CAAC,CAAC;QAElF,uBAAuB;QACvB,IAAI,CAAC,oBAAoB,EAAE,CAAC;IAC9B,CAAC;IAED,OAAO;QACL,mBAAmB;QACnB,IAAI,CAAC,MAAM,CAAC,mBAAmB,CAAC,WAAW,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;QACpE,MAAM,CAAC,mBAAmB,CAAC,SAAS,EAAE,IAAI,CAAC,cAAc,CAAC,CAAC;QAC3D,MAAM,CAAC,mBAAmB,CAAC,WAAW,EAAE,IAAI,CAAC,gBAAgB,CAAC,CAAC;QAC/D,IAAI,CAAC,MAAM,CAAC,mBAAmB,CAAC,OAAO,EAAE,IAAI,CAAC,iBAAiB,CAAC,CAAC;IACnE,CAAC;IAEO,oBAAoB;QAC1B,MAAM,GAAG,GAAG,IAAI,CAAC,EAAE,GAAG,GAAG,CAAC;QAC1B,MAAM,CAAC,GAAG,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,GAAG,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,GAAG,GAAG,CAAC,CAAC;QAClG,MAAM,CAAC,GAAG,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,GAAG,GAAG,CAAC,CAAC;QAChE,MAAM,CAAC,GAAG,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,GAAG,GAAG,CAAC,GAAG,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,UAAU,GAAG,GAAG,CAAC,CAAC;QAElG,gEAAgE;QAChE,IAAI,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;QACjC,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,4CAAO,CAAC,IAAI,CAAC,CAAC,CAAC,gCAAgC;IACpE,CAAC;IAEO,WAAW,CAAC,CAAa;QAC/B,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC;QACvB,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,OAAO,CAAC;QACvB,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,OAAO,CAAC;IACzB,CAAC;IAEO,SAAS;QACf,IAAI,CAAC,UAAU,GAAG,KAAK,CAAC;IAC1B,CAAC;IAEO,WAAW,CAAC,CAAa;QAC/B,IAAI,IAAI,CAAC,UAAU,EAAE,CAAC;YACpB,MAAM,MAAM,GAAG,CAAC,CAAC,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC;YACtC,MAAM,MAAM,GAAG,CAAC,CAAC,OAAO,GAAG,IAAI,CAAC,KAAK,CAAC;YAEtC,IAAI,CAAC,UAAU,IAAI,MAAM,GAAG,GAAG,CAAC;YAChC,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,IAAI,CAAC,UAAU,GAAG,MAAM,GAAG,GAAG,CAAC,CAAC,CAAC;YAE9E,IAAI,CAAC,oBAAoB,EAAE,CAAC;YAE5B,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,OAAO,CAAC;YACvB,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC,OAAO,CAAC;QACzB,CAAC;IACH,CAAC;IAEO,YAAY,CAAC,CAAa;QAChC,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE,IAAI,CAAC,cAAc,GAAG,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC,CAAC;QACzE,IAAI,CAAC,oBAAoB,EAAE,CAAC;QAC5B,CAAC,CAAC,cAAc,EAAE,CAAC,CAAC,sBAAsB;IAC5C,CAAC;CACF;;;;;;;;;;;;;AC9FwC;AAEzC,2BAA2B;AAC3B,QAAQ,CAAC,gBAAgB,CAAC,kBAAkB,EAAE,GAAG,EAAE;IACjD,6BAA6B;IAC7B,MAAM,MAAM,GAAG,IAAI,kDAAM,EAAE,CAAC;IAE5B,gDAAgD;IAC/C,MAAc,CAAC,MAAM,GAAG,MAAM,CAAC;AAClC,CAAC,CAAC,CAAC;;;;;;;UCTH;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;UACA,sBAAsB;UACtB,oDAAoD,uBAAuB;UAC3E;UACA;UACA,GAAG;UACH;UACA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;;UAEA;UACA;;;;;WCxCA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;;;;;WCJA;;;;;WCAA;;;;;WCAA;;;;;WCAA;WACA;WACA;WACA;WACA,uBAAuB,4BAA4B;WACnD;WACA;WACA;WACA,iBAAiB,oBAAoB;WACrC;WACA,mGAAmG,YAAY;WAC/G;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,mEAAmE,iCAAiC;WACpG;WACA;WACA;WACA;;;;;WCzCA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;WACA;;WAEA;WACA;WACA;;WAEA;WACA;WACA;;WAEA;WACA;WACA;;WAEA;WACA;WACA;;WAEA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,CAAC;;WAED;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,KAAK;WACL;WACA;WACA;WACA;WACA;WACA;WACA,IAAI;WACJ;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,IAAI;WACJ;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA,2BAA2B;WAC3B,4BAA4B;WAC5B,2BAA2B;WAC3B;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,GAAG;;WAEH;WACA;WACA;WACA;WACA;WACA;WACA,oBAAoB,gBAAgB;WACpC;WACA;WACA;WACA,KAAK;WACL;WACA;WACA;WACA,GAAG;WACH;WACA;WACA;WACA,oBAAoB,gBAAgB;WACpC;WACA;WACA,GAAG;WACH;WACA;WACA,GAAG;WACH;WACA;WACA,GAAG;WACH;WACA;WACA;WACA,GAAG;WACH;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,MAAM;WACN;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,MAAM;WACN;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,GAAG;;WAEH;WACA;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,GAAG;WACH;WACA;WACA;WACA,GAAG;;WAEH;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;;WAEA,iBAAiB,qCAAqC;WACtD;;WAEA,gDAAgD;WAChD;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA,oBAAoB,iBAAiB;WACrC;WACA;WACA;WACA,GAAG;WACH;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA,GAAG;WACH,EAAE;WACF;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,MAAM;WACN;WACA;WACA;WACA;WACA;WACA;WACA;WACA,OAAO;WACP,MAAM;WACN,KAAK;WACL,IAAI;WACJ,GAAG;WACH;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA;;WAEA;WACA;;WAEA;;WAEA;WACA;WACA,EAAE;WACF;;WAEA;WACA;WACA;WACA,GAAG;WACH;;WAEA;WACA;WACA;WACA,GAAG;WACH;;WAEA;WACA;;WAEA;WACA;WACA,EAAE;;WAEF;WACA;;WAEA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA,oBAAoB,oBAAoB;WACxC;WACA;WACA;WACA;WACA,EAAE;;WAEF;WACA;WACA;WACA;WACA;WACA,IAAI;WACJ;;WAEA;WACA;WACA;WACA;WACA,KAAK;WACL;WACA,IAAI;WACJ;;WAEA;WACA;WACA,GAAG;WACH,EAAE;WACF;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,IAAI;WACJ,GAAG;WACH;WACA;WACA;WACA;;;;;WClYA;;;;;WCAA;;WAEA;WACA;WACA;WACA;WACA;WACA;;WAEA;;WAEA;;WAEA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,mBAAmB,2BAA2B;WAC9C;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,KAAK;WACL;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA,kBAAkB,cAAc;WAChC;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA,cAAc,MAAM;WACpB;WACA;WACA;WACA;WACA;WACA;WACA,cAAc,aAAa;WAC3B;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA,iBAAiB,4BAA4B;WAC7C;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,IAAI;WACJ;WACA;;WAEA;;WAEA;WACA;WACA;WACA;WACA,IAAI;WACJ;;WAEA;WACA;WACA;WACA;WACA;WACA;;WAEA;;WAEA;WACA;WACA,gBAAgB,4BAA4B;WAC5C;WACA;WACA;;WAEA;WACA;;WAEA;WACA;;WAEA;WACA;;WAEA;WACA,gBAAgB,4BAA4B;WAC5C;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,kBAAkB,uCAAuC;WACzD;WACA;WACA;WACA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA,mBAAmB,iCAAiC;WACpD;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,sBAAsB,uCAAuC;WAC7D;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,sBAAsB,sBAAsB;WAC5C;WACA;WACA,SAAS;WACT;WACA;WACA;WACA;WACA;WACA,WAAW;WACX,WAAW;WACX;WACA;WACA;WACA;WACA;WACA;WACA;WACA,YAAY;WACZ;WACA;WACA;WACA;WACA;WACA;WACA,UAAU;WACV;WACA;WACA;WACA;WACA;WACA;WACA,WAAW;WACX;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA,mBAAmB,wCAAwC;WAC3D;WACA;WACA;WACA;WACA,MAAM;WACN;WACA;WACA;WACA;WACA;WACA,QAAQ;WACR,QAAQ;WACR;WACA;WACA;WACA;WACA;WACA;WACA,SAAS;WACT;WACA;WACA;WACA;WACA;WACA;WACA,OAAO;WACP;WACA;WACA;WACA;WACA;WACA,QAAQ;WACR;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE,IAAI;WACN;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,IAAI;WACJ;WACA;WACA,EAAE;WACF;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA,sCAAsC;WACtC;WACA;WACA,EAAE;WACF;;WAEA;;WAEA;;;;;UE3fA;UACA;UACA;UACA","sources":["webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/_virtual/_rollupPluginBabelHelpers.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/constants.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/core.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/event-handle.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/event-handler.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/events.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/guid.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/hash.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/indexed-list.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/math/bit-packing.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/math/blue-noise.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/math/color.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/math/constants.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/math/curve-evaluator.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/math/curve-set.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/math/curve.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/math/float-packing.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/math/mat3.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/math/mat4.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/math/math.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/math/quat.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/math/random.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/math/vec2.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/math/vec3.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/math/vec4.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/object-pool.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/path.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/platform.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/preprocessor.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/read-stream.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/ref-counted-cache.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/ref-counted-object.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/shape/bounding-box.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/shape/bounding-sphere.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/shape/frustum.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/shape/plane.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/shape/ray.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/sort.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/sorted-loop-array.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/string-ids.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/string.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/tags-cache.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/tags.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/time.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/tracing.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/uri.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/core/wasm-module.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/deprecated/compatibility-v2-utils.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/binder/anim-binder.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/binder/default-anim-binder.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/constants.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/controller/anim-blend-tree-1d.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/controller/anim-blend-tree-2d-cartesian.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/controller/anim-blend-tree-2d-directional.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/controller/anim-blend-tree-direct.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/controller/anim-blend-tree.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/controller/anim-controller.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/controller/anim-node.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/controller/anim-state.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/controller/anim-transition.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/controller/constants.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/evaluator/anim-blend.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/evaluator/anim-cache.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/evaluator/anim-clip.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/evaluator/anim-curve.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/evaluator/anim-data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/evaluator/anim-evaluator.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/evaluator/anim-events.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/evaluator/anim-snapshot.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/evaluator/anim-target-value.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/evaluator/anim-target.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/evaluator/anim-track.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/anim/state-graph/anim-state-graph.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/app-base.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/app-options.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/application.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/asset/asset-file.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/asset/asset-localized.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/asset/asset-reference.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/asset/asset-registry.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/asset/asset.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/asset/constants.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/bundle/bundle-registry.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/bundle/bundle.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/anim/component-binder.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/anim/component-layer.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/anim/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/anim/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/anim/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/animation/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/animation/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/animation/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/audio-listener/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/audio-listener/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/audio-listener/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/audio-source/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/audio-source/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/audio-source/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/button/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/button/constants.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/button/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/button/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/camera/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/camera/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/camera/post-effect-queue.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/camera/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/collision/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/collision/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/collision/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/collision/trigger.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/element/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/element/constants.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/element/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/element/element-drag-helper.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/element/image-element.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/element/markup.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/element/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/element/text-element.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/gsplat/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/gsplat/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/gsplat/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/joint/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/joint/constants.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/joint/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/joint/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/layout-child/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/layout-child/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/layout-child/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/layout-group/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/layout-group/constants.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/layout-group/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/layout-group/layout-calculator.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/layout-group/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/light/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/light/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/light/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/model/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/model/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/model/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/particle-system/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/particle-system/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/particle-system/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/registry.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/render/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/render/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/render/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/rigid-body/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/rigid-body/constants.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/rigid-body/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/rigid-body/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/screen/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/screen/constants.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/screen/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/screen/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/script-legacy/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/script-legacy/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/script-legacy/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/script/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/script/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/script/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/scroll-view/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/scroll-view/constants.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/scroll-view/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/scroll-view/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/scrollbar/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/scrollbar/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/scrollbar/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/sound/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/sound/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/sound/slot.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/sound/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/sprite/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/sprite/constants.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/sprite/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/sprite/sprite-animation-clip.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/sprite/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/zone/component.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/zone/data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/components/zone/system.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/constants.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/entity.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/font/constants.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/font/font.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/globals.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/graphics/primitive-cache.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/anim-clip.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/anim-state-graph.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/animation.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/audio.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/basis-worker.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/basis.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/binary.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/bundle.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/container.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/css.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/cubemap.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/folder.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/font.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/gsplat.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/handler.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/hierarchy.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/html.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/json.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/loader.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/material.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/model.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/render.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/scene-utils.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/scene.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/script.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/shader.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/sprite.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/template.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/text.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/texture-atlas.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/texture.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/handlers/untar.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/i18n/constants.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/i18n/i18n-parser.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/i18n/i18n.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/i18n/utils.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/lightmapper/bake-light-ambient.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/lightmapper/bake-light-simple.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/lightmapper/bake-light.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/lightmapper/bake-mesh-node.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/lightmapper/lightmap-filters.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/lightmapper/lightmapper.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/lightmapper/render-pass-lightmapper.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/parsers/draco-decoder.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/parsers/draco-worker.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/parsers/glb-container-parser.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/parsers/glb-container-resource.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/parsers/glb-model.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/parsers/glb-parser.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/parsers/gsplat-resource.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/parsers/json-model.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/parsers/material/json-standard-material.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/parsers/ply.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/parsers/scene.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/parsers/texture/basis.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/parsers/texture/dds.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/parsers/texture/hdr.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/parsers/texture/img.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/parsers/texture/ktx.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/parsers/texture/ktx2.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/parsers/texture/texture.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/scene-registry-item.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/scene-registry.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/script.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/script/constants.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/script/script-attributes.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/script/script-create.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/script/script-registry.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/script/script-type.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/script/script-types.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/script/script.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/stats.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/template.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/xr/constants.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-anchor.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-anchors.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-depth-sensing.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-dom-overlay.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-finger.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-hand.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-hit-test-source.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-hit-test.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-image-tracking.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-input-source.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-input.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-joint.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-light-estimation.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-manager.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-mesh-detection.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-mesh.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-plane-detection.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-plane.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-tracked-image.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-view.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/framework/xr/xr-views.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/audio/capabilities.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/audio/channel.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/audio/channel3d.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/audio/constants.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/bind-group-format.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/bind-group.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/blend-state.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/constants.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/depth-state.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/device-cache.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/dynamic-buffers.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/gpu-profiler.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/graphics-device.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/index-buffer.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/render-pass.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/render-target.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/scope-id.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/scope-space.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/shader-chunks/frag/gles2.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/shader-chunks/frag/gles3.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/shader-chunks/frag/shared.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/shader-chunks/frag/webgpu.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/shader-chunks/vert/gles2.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/shader-chunks/vert/gles3.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/shader-chunks/vert/webgpu.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/shader-processor-options.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/shader-utils.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/shader.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/stencil-parameters.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/texture-utils.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/texture.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/uniform-buffer-format.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/uniform-buffer.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/version.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/versioned-object.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/vertex-buffer.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/vertex-format.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/vertex-iterator.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgl/webgl-buffer.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgl/webgl-gpu-profiler.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgl/webgl-graphics-device.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgl/webgl-index-buffer.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgl/webgl-render-target.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgl/webgl-shader-input.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgl/webgl-shader.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgl/webgl-texture.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/graphics/webgl/webgl-vertex-buffer.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/input/constants.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/net/http.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/sound/instance.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/sound/instance3d.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/sound/listener.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/sound/manager.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/platform/sound/sound.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/animation/animation.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/animation/skeleton.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/area-light-luts.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/batching/batch-group.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/batching/batch-manager.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/batching/batch.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/batching/skin-batch-instance.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/camera.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/composition/layer-composition.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/composition/render-action.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/compress/compress-utils.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/compress/decompress.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/constants.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/frame-graph.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/geometry/box-geometry.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/geometry/capsule-geometry.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/geometry/cone-base-geometry.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/geometry/cone-geometry.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/geometry/cylinder-geometry.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/geometry/dome-geometry.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/geometry/geometry-utils.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/geometry/geometry.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/geometry/plane-geometry.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/geometry/sphere-geometry.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/geometry/torus-geometry.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/graph-node.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/graphics/env-lighting.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/graphics/light-cube.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/graphics/lightmap-cache.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/graphics/noise-textures.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/graphics/quad-render-utils.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/graphics/quad-render.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/graphics/render-pass-color-grab.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/graphics/render-pass-depth-grab.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/graphics/render-pass-depth.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/graphics/render-pass-quad.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/graphics/reproject-texture.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/gsplat/gsplat-compressed-data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/gsplat/gsplat-compressed-material.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/gsplat/gsplat-compressed.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/gsplat/gsplat-data.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/gsplat/gsplat-instance.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/gsplat/gsplat-material.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/gsplat/gsplat-sorter.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/gsplat/gsplat.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/gsplat/shader-generator-gsplat.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/immediate/immediate-batch.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/immediate/immediate-batches.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/immediate/immediate.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/layer.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/light.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/lighting/light-texture-atlas.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/lighting/lighting-params.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/lighting/lights-buffer.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/lighting/world-clusters.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/materials/basic-material.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/materials/default-material.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/materials/lit-material-options-builder.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/materials/material.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/materials/standard-material-options-builder.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/materials/standard-material-options.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/materials/standard-material-parameters.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/materials/standard-material-validator.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/materials/standard-material.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/mesh-instance.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/mesh.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/model.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/morph-instance.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/morph-target.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/morph.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/particle-system/cpu-updater.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/particle-system/gpu-updater.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/particle-system/particle-emitter.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/render.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/renderer/forward-renderer.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/renderer/light-camera.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/renderer/render-pass-cookie-renderer.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/renderer/render-pass-forward.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/renderer/render-pass-postprocessing.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/renderer/render-pass-shadow-directional.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/renderer/render-pass-shadow-local-clustered.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/renderer/render-pass-shadow-local-non-clustered.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/renderer/render-pass-update-clustered.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/renderer/renderer.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/renderer/shadow-map-cache.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/renderer/shadow-map.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/renderer/shadow-renderer-directional.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/renderer/shadow-renderer-local.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/renderer/shadow-renderer.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/renderer/world-clusters-allocator.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/scene.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunk-builder.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunk-utils.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/chunks-lightmapper.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/chunks.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/bayer.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/decode.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/encode.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/envAtlas.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/envConst.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/envMultiply.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/fixCubemapSeamsNone.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/fixCubemapSeamsStretch.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/fullscreenQuad.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/gamma1_0.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/gamma2_2.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/linearizeDepth.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/msdf.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/outputTex2D.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/packDepth.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/reproject.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/sampleCatmullRom.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/screenDepth.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/spherical.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/tonemappingAces.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/tonemappingAces2.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/tonemappingFilmic.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/tonemappingHejl.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/tonemappingLinear.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/tonemappingNeutral.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/frag/tonemappingNone.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/vert/fullscreenQuad.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/vert/msdf.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/vert/skinBatchConst.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/vert/skinBatchTex.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/vert/skinConst.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/vert/skinTex.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/vert/transform.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/common/vert/transformDecl.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lightmapper/frag/bakeDirLmEnd.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lightmapper/frag/bakeLmEnd.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lightmapper/frag/bilateralDeNoise.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lightmapper/frag/dilate.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/TBN.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/TBNObjectSpace.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/TBNderivative.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/TBNfast.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/ambientConstant.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/ambientEnv.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/ambientSH.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/aoDiffuseOcc.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/aoSpecOcc.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/aoSpecOccConst.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/aoSpecOccConstSimple.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/aoSpecOccSimple.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/base.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/baseNineSliced.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/baseNineSlicedTiled.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/biasConst.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/blurVSM.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/clusteredLight.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/clusteredLightCookies.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/clusteredLightShadows.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/clusteredLightUtils.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/combine.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/cookie.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/cubeMapProjectBox.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/cubeMapProjectNone.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/cubeMapRotate.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/debug-output.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/debug-process-frontend.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/end.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/extension.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/falloffInvSquared.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/falloffLinear.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/float-unpacking.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/fogExp.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/fogExp2.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/fogLinear.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/fogNone.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/fresnelSchlick.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/iridescenceDiffraction.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/lightDiffuseLambert.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/lightDirPoint.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/lightSheen.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/lightSpecularAnisoGGX.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/lightSpecularBlinn.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/lightSpecularPhong.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/lightmapAdd.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/lightmapDirAdd.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/ltc.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/metalnessModulate.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/output.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/outputAlpha.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/outputAlphaOpaque.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/outputAlphaPremul.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/reflDir.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/reflDirAniso.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/reflectionCC.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/reflectionCube.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/reflectionEnv.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/reflectionEnvHQ.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/reflectionSheen.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/reflectionSphere.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/refractionCube.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/refractionDynamic.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/shadowCascades.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/shadowEVSM.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/shadowEVSMn.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/shadowPCSS.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/shadowSampleCoord.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/shadowStandard.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/shadowStandardGL2.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/shadowVSM8.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/shadowVSM_common.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/spot.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/start.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/startNineSliced.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/startNineSlicedTiled.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/storeEVSM.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/twoSidedLighting.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/frag/viewDir.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/vert/base.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/vert/baseNineSliced.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/vert/end.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/vert/extension.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/vert/instancing.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/vert/normal.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/vert/normalInstanced.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/vert/normalSkinned.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/vert/start.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/vert/tangentBinormal.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/vert/uv0.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/vert/uv1.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/lit/vert/viewNormal.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particle.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleInputFloat.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleInputRgba8.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleOutputFloat.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleOutputRgba8.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleUpdaterAABB.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleUpdaterEnd.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleUpdaterInit.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleUpdaterNoRespawn.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleUpdaterOnStop.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleUpdaterRespawn.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleUpdaterSphere.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particleUpdaterStart.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particle_blendAdd.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particle_blendMultiply.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particle_blendNormal.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particle_end.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particle_halflambert.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particle_lambert.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particle_lighting.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particle_normalMap.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/frag/particle_soft.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particleAnimFrameClamp.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particleAnimFrameLoop.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particleAnimTex.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_TBN.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_billboard.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_cpu.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_cpu_end.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_customFace.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_end.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_init.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_localShift.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_mesh.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_normal.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_pointAlong.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_soft.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_stretch.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/particle/vert/particle_wrap.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/skybox/frag/skyboxEnv.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/skybox/frag/skyboxHDR.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/skybox/vert/skybox.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/alphaTest.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/ao.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/aoDetailMap.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/clearCoat.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/clearCoatGloss.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/clearCoatNormal.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/detailModes.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/diffuse.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/diffuseDetailMap.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/emissive.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/gloss.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/ior.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/iridescence.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/iridescenceThickness.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/lightmapDir.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/lightmapSingle.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/litShaderArgs.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/metalness.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/normalDetailMap.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/normalMap.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/normalXY.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/normalXYZ.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/opacity-dither.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/opacity.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/parallax.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/sheen.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/sheenGloss.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/specular.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/specularityFactor.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/textureSample.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/thickness.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/chunks/standard/frag/transmission.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/get-program-library.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/program-library.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/programs/basic.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/programs/lit-options-utils.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/programs/lit-shader-options.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/programs/lit-shader.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/programs/particle.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/programs/shader-generator.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/programs/skybox.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/programs/standard.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-lib/utils.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/shader-pass.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/skin-instance-cache.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/skin-instance.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/skin.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/skybox/sky-geometry.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/skybox/sky-mesh.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/skybox/sky.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/sprite.js","webpack://BuilderBee/./node_modules/playcanvas/build/playcanvas/src/scene/texture-atlas.js","webpack://BuilderBee/./src/renderer/editor/Editor.ts","webpack://BuilderBee/./src/renderer/editor/FileManager.ts","webpack://BuilderBee/./src/renderer/editor/MenuManager.ts","webpack://BuilderBee/./src/renderer/editor/SceneView.ts","webpack://BuilderBee/./src/renderer/editor/grid-factory.ts","webpack://BuilderBee/./src/renderer/editor/orbit-camera-input.ts","webpack://BuilderBee/./src/renderer/index.ts","webpack://BuilderBee/webpack/bootstrap","webpack://BuilderBee/webpack/runtime/define property getters","webpack://BuilderBee/webpack/runtime/get javascript update chunk filename","webpack://BuilderBee/webpack/runtime/get update manifest filename","webpack://BuilderBee/webpack/runtime/getFullHash","webpack://BuilderBee/webpack/runtime/hasOwnProperty shorthand","webpack://BuilderBee/webpack/runtime/load script","webpack://BuilderBee/webpack/runtime/make namespace object","webpack://BuilderBee/webpack/runtime/hot module replacement","webpack://BuilderBee/webpack/runtime/publicPath","webpack://BuilderBee/webpack/runtime/jsonp chunk loading","webpack://BuilderBee/webpack/before-startup","webpack://BuilderBee/webpack/startup","webpack://BuilderBee/webpack/after-startup"],"sourcesContent":["function _extends() {\n  return _extends = Object.assign ? Object.assign.bind() : function (n) {\n    for (var e = 1; e < arguments.length; e++) {\n      var t = arguments[e];\n      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n    }\n    return n;\n  }, _extends.apply(null, arguments);\n}\n\nexport { _extends as extends };\n","const TRACEID_RENDER_FRAME = 'RenderFrame';\nconst TRACEID_RENDER_FRAME_TIME = 'RenderFrameTime';\nconst TRACEID_RENDER_PASS = 'RenderPass';\nconst TRACEID_RENDER_PASS_DETAIL = 'RenderPassDetail';\nconst TRACEID_RENDER_ACTION = 'RenderAction';\nconst TRACEID_RENDER_TARGET_ALLOC = 'RenderTargetAlloc';\nconst TRACEID_TEXTURE_ALLOC = 'TextureAlloc';\nconst TRACEID_SHADER_ALLOC = 'ShaderAlloc';\nconst TRACEID_SHADER_COMPILE = 'ShaderCompile';\nconst TRACEID_VRAM_TEXTURE = 'VRAM.Texture';\nconst TRACEID_VRAM_VB = 'VRAM.Vb';\nconst TRACEID_VRAM_IB = 'VRAM.Ib';\nconst TRACEID_VRAM_SB = 'VRAM.Sb';\nconst TRACEID_BINDGROUP_ALLOC = 'BindGroupAlloc';\nconst TRACEID_BINDGROUPFORMAT_ALLOC = 'BindGroupFormatAlloc';\nconst TRACEID_RENDERPIPELINE_ALLOC = 'RenderPipelineAlloc';\nconst TRACEID_COMPUTEPIPELINE_ALLOC = 'ComputePipelineAlloc';\nconst TRACEID_PIPELINELAYOUT_ALLOC = 'PipelineLayoutAlloc';\nconst TRACE_ID_ELEMENT = 'Element';\nconst TRACEID_TEXTURES = 'Textures';\nconst TRACEID_RENDER_QUEUE = 'RenderQueue';\nconst TRACEID_GPU_TIMINGS = 'GpuTimings';\n\nexport { TRACEID_BINDGROUPFORMAT_ALLOC, TRACEID_BINDGROUP_ALLOC, TRACEID_COMPUTEPIPELINE_ALLOC, TRACEID_GPU_TIMINGS, TRACEID_PIPELINELAYOUT_ALLOC, TRACEID_RENDERPIPELINE_ALLOC, TRACEID_RENDER_ACTION, TRACEID_RENDER_FRAME, TRACEID_RENDER_FRAME_TIME, TRACEID_RENDER_PASS, TRACEID_RENDER_PASS_DETAIL, TRACEID_RENDER_QUEUE, TRACEID_RENDER_TARGET_ALLOC, TRACEID_SHADER_ALLOC, TRACEID_SHADER_COMPILE, TRACEID_TEXTURES, TRACEID_TEXTURE_ALLOC, TRACEID_VRAM_IB, TRACEID_VRAM_SB, TRACEID_VRAM_TEXTURE, TRACEID_VRAM_VB, TRACE_ID_ELEMENT };\n","const version = '1.77.0';\nconst revision = 'f90da0d';\nconst config = {};\nconst common = {};\nconst apps = {};\nconst data = {};\nconst typeofs = ['undefined', 'number', 'string', 'boolean'];\nconst objectTypes = {\n\t'[object Array]': 'array',\n\t'[object Object]': 'object',\n\t'[object Function]': 'function',\n\t'[object Date]': 'date',\n\t'[object RegExp]': 'regexp',\n\t'[object Float32Array]': 'float32array'\n};\nfunction type(obj) {\n\tif (obj === null) {\n\t\treturn 'null';\n\t}\n\tconst typeString = typeof obj;\n\tif (typeofs.includes(typeString)) {\n\t\treturn typeString;\n\t}\n\treturn objectTypes[Object.prototype.toString.call(obj)];\n}\nfunction extend(target, ex) {\n\tfor (const prop in ex) {\n\t\tconst copy = ex[prop];\n\t\tif (type(copy) === 'object') {\n\t\t\ttarget[prop] = extend({}, copy);\n\t\t} else if (type(copy) === 'array') {\n\t\t\ttarget[prop] = extend([], copy);\n\t\t} else {\n\t\t\ttarget[prop] = copy;\n\t\t}\n\t}\n\treturn target;\n}\n\nexport { apps, common, config, data, extend, revision, type, version };\n","class EventHandle {\n\tconstructor(handler, name, callback, scope, once = false) {\n\t\tthis.handler = void 0;\n\t\tthis.name = void 0;\n\t\tthis.callback = void 0;\n\t\tthis.scope = void 0;\n\t\tthis._once = void 0;\n\t\tthis._removed = false;\n\t\tthis.handler = handler;\n\t\tthis.name = name;\n\t\tthis.callback = callback;\n\t\tthis.scope = scope;\n\t\tthis._once = once;\n\t}\n\toff() {\n\t\tif (this._removed) return;\n\t\tthis.handler.offByHandle(this);\n\t}\n\ton(name, callback, scope = this) {\n\t\treturn this.handler._addCallback(name, callback, scope, false);\n\t}\n\tonce(name, callback, scope = this) {\n\t\treturn this.handler._addCallback(name, callback, scope, true);\n\t}\n\tset removed(value) {\n\t\tif (!value) return;\n\t\tthis._removed = true;\n\t}\n\tget removed() {\n\t\treturn this._removed;\n\t}\n}\n\nexport { EventHandle };\n","import { EventHandle } from './event-handle.js';\n\nclass EventHandler {\n\tconstructor() {\n\t\tthis._callbacks = new Map();\n\t\tthis._callbackActive = new Map();\n\t}\n\tinitEventHandler() {\n\t\tthis._callbacks = new Map();\n\t\tthis._callbackActive = new Map();\n\t}\n\t_addCallback(name, callback, scope, once) {\n\t\tif (!this._callbacks.has(name)) {\n\t\t\tthis._callbacks.set(name, []);\n\t\t}\n\t\tif (this._callbackActive.has(name)) {\n\t\t\tconst callbackActive = this._callbackActive.get(name);\n\t\t\tif (callbackActive && callbackActive === this._callbacks.get(name)) {\n\t\t\t\tthis._callbackActive.set(name, callbackActive.slice());\n\t\t\t}\n\t\t}\n\t\tconst evt = new EventHandle(this, name, callback, scope, once);\n\t\tthis._callbacks.get(name).push(evt);\n\t\treturn evt;\n\t}\n\ton(name, callback, scope = this) {\n\t\treturn this._addCallback(name, callback, scope, false);\n\t}\n\tonce(name, callback, scope = this) {\n\t\treturn this._addCallback(name, callback, scope, true);\n\t}\n\toff(name, callback, scope) {\n\t\tif (name) {\n\t\t\tif (this._callbackActive.has(name) && this._callbackActive.get(name) === this._callbacks.get(name)) {\n\t\t\t\tthis._callbackActive.set(name, this._callbackActive.get(name).slice());\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const [key, callbacks] of this._callbackActive) {\n\t\t\t\tif (!this._callbacks.has(key)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (this._callbacks.get(key) !== callbacks) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tthis._callbackActive.set(key, callbacks.slice());\n\t\t\t}\n\t\t}\n\t\tif (!name) {\n\t\t\tfor (const callbacks of this._callbacks.values()) {\n\t\t\t\tfor (let i = 0; i < callbacks.length; i++) {\n\t\t\t\t\tcallbacks[i].removed = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._callbacks.clear();\n\t\t} else if (!callback) {\n\t\t\tconst callbacks = this._callbacks.get(name);\n\t\t\tif (callbacks) {\n\t\t\t\tfor (let i = 0; i < callbacks.length; i++) {\n\t\t\t\t\tcallbacks[i].removed = true;\n\t\t\t\t}\n\t\t\t\tthis._callbacks.delete(name);\n\t\t\t}\n\t\t} else {\n\t\t\tconst callbacks = this._callbacks.get(name);\n\t\t\tif (!callbacks) {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t\tfor (let i = 0; i < callbacks.length; i++) {\n\t\t\t\tif (callbacks[i].callback !== callback) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (scope && callbacks[i].scope !== scope) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcallbacks[i].removed = true;\n\t\t\t\tcallbacks.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tif (callbacks.length === 0) {\n\t\t\t\tthis._callbacks.delete(name);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\toffByHandle(handle) {\n\t\tconst name = handle.name;\n\t\thandle.removed = true;\n\t\tif (this._callbackActive.has(name) && this._callbackActive.get(name) === this._callbacks.get(name)) {\n\t\t\tthis._callbackActive.set(name, this._callbackActive.get(name).slice());\n\t\t}\n\t\tconst callbacks = this._callbacks.get(name);\n\t\tif (!callbacks) {\n\t\t\treturn this;\n\t\t}\n\t\tconst ind = callbacks.indexOf(handle);\n\t\tif (ind !== -1) {\n\t\t\tcallbacks.splice(ind, 1);\n\t\t\tif (callbacks.length === 0) {\n\t\t\t\tthis._callbacks.delete(name);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\tfire(name, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {\n\t\tif (!name) {\n\t\t\treturn this;\n\t\t}\n\t\tconst callbacksInitial = this._callbacks.get(name);\n\t\tif (!callbacksInitial) {\n\t\t\treturn this;\n\t\t}\n\t\tlet callbacks;\n\t\tif (!this._callbackActive.has(name)) {\n\t\t\tthis._callbackActive.set(name, callbacksInitial);\n\t\t} else if (this._callbackActive.get(name) !== callbacksInitial) {\n\t\t\tcallbacks = callbacksInitial.slice();\n\t\t}\n\t\tfor (let i = 0; (callbacks || this._callbackActive.get(name)) && i < (callbacks || this._callbackActive.get(name)).length; i++) {\n\t\t\tconst evt = (callbacks || this._callbackActive.get(name))[i];\n\t\t\tif (!evt.callback) continue;\n\t\t\tevt.callback.call(evt.scope, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);\n\t\t\tif (evt._once) {\n\t\t\t\tconst existingCallback = this._callbacks.get(name);\n\t\t\t\tconst ind = existingCallback ? existingCallback.indexOf(evt) : -1;\n\t\t\t\tif (ind !== -1) {\n\t\t\t\t\tif (this._callbackActive.get(name) === existingCallback) {\n\t\t\t\t\t\tthis._callbackActive.set(name, this._callbackActive.get(name).slice());\n\t\t\t\t\t}\n\t\t\t\t\tconst _callbacks = this._callbacks.get(name);\n\t\t\t\t\tif (!_callbacks) continue;\n\t\t\t\t\t_callbacks[ind].removed = true;\n\t\t\t\t\t_callbacks.splice(ind, 1);\n\t\t\t\t\tif (_callbacks.length === 0) {\n\t\t\t\t\t\tthis._callbacks.delete(name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!callbacks) {\n\t\t\tthis._callbackActive.delete(name);\n\t\t}\n\t\treturn this;\n\t}\n\thasEvent(name) {\n\t\tvar _this$_callbacks$get;\n\t\treturn !!((_this$_callbacks$get = this._callbacks.get(name)) != null && _this$_callbacks$get.length);\n\t}\n}\n\nexport { EventHandler };\n","import { EventHandler } from './event-handler.js';\n\nconst events = {\n\tattach(target) {\n\t\tconst ev = events;\n\t\ttarget._addCallback = ev._addCallback;\n\t\ttarget.on = ev.on;\n\t\ttarget.off = ev.off;\n\t\ttarget.fire = ev.fire;\n\t\ttarget.once = ev.once;\n\t\ttarget.hasEvent = ev.hasEvent;\n\t\tEventHandler.prototype.initEventHandler.call(target);\n\t\treturn target;\n\t},\n\t_addCallback: EventHandler.prototype._addCallback,\n\ton: EventHandler.prototype.on,\n\toff: EventHandler.prototype.off,\n\tfire: EventHandler.prototype.fire,\n\tonce: EventHandler.prototype.once,\n\thasEvent: EventHandler.prototype.hasEvent\n};\n\nexport { events };\n","const guid = {\n\tcreate() {\n\t\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n\t\t\tconst r = Math.random() * 16 | 0;\n\t\t\tconst v = c === 'x' ? r : r & 0x3 | 0x8;\n\t\t\treturn v.toString(16);\n\t\t});\n\t}\n};\n\nexport { guid };\n","function hashCode(str) {\n\tlet hash = 0;\n\tfor (let i = 0, len = str.length; i < len; i++) {\n\t\thash = (hash << 5) - hash + str.charCodeAt(i);\n\t\thash |= 0;\n\t}\n\treturn hash;\n}\nfunction hash32Fnv1a(array) {\n\tconst prime = 16777619;\n\tlet hash = 2166136261;\n\tfor (let i = 0; i < array.length; i++) {\n\t\thash ^= array[i];\n\t\thash *= prime;\n\t}\n\treturn hash >>> 0;\n}\n\nexport { hash32Fnv1a, hashCode };\n","class IndexedList {\n\tconstructor() {\n\t\tthis._list = [];\n\t\tthis._index = {};\n\t}\n\tpush(key, item) {\n\t\tif (this._index[key]) {\n\t\t\tthrow Error(`Key already in index ${key}`);\n\t\t}\n\t\tconst location = this._list.push(item) - 1;\n\t\tthis._index[key] = location;\n\t}\n\thas(key) {\n\t\treturn this._index[key] !== undefined;\n\t}\n\tget(key) {\n\t\tconst location = this._index[key];\n\t\tif (location !== undefined) {\n\t\t\treturn this._list[location];\n\t\t}\n\t\treturn null;\n\t}\n\tremove(key) {\n\t\tconst location = this._index[key];\n\t\tif (location !== undefined) {\n\t\t\tthis._list.splice(location, 1);\n\t\t\tdelete this._index[key];\n\t\t\tfor (key in this._index) {\n\t\t\t\tconst idx = this._index[key];\n\t\t\t\tif (idx > location) {\n\t\t\t\t\tthis._index[key] = idx - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tlist() {\n\t\treturn this._list;\n\t}\n\tclear() {\n\t\tthis._list.length = 0;\n\t\tfor (const prop in this._index) {\n\t\t\tdelete this._index[prop];\n\t\t}\n\t}\n}\n\nexport { IndexedList };\n","const BitPacking = {\n\tset(storage, value, shift, mask = 1) {\n\t\tconst data = storage & ~(mask << shift);\n\t\treturn data | value << shift;\n\t},\n\tget(storage, shift, mask = 1) {\n\t\treturn storage >> shift & mask;\n\t},\n\tall(storage, shift, mask = 1) {\n\t\tconst shifted = mask << shift;\n\t\treturn (storage & shifted) === shifted;\n\t},\n\tany(storage, shift, mask = 1) {\n\t\treturn (storage & mask << shift) !== 0;\n\t}\n};\n\nexport { BitPacking };\n","import { Vec4 } from './vec4.js';\n\nconst base64String = 'muPIHORMLNDCz4DxVR/ZvYfAUVEFR47KRIC4nwAAAAAP7WxlhD6Ci+2HCe7BF8jRAPZwdH2UPpI5PdLCJdkvG4UTaNDJ/0crAzne71GCrb4kbdMjjCEGzdX6fNxDMLJq5xkeoIVTdfiZkodEeArmZmp/FQzFjD4x8iOW7Dg64n+3mWqyEwLxXT8zoJXfbw8QJKDCaarUYyTlMzNFHbgUe9IQV7g4YOgtSKpIFZJ0qERm7u4PpmiF89ktHWCywaGmD6h+hfh2/Zd8KYlKqqo4Cem4T42bT/Z9FpCQF1hhSjfBzZ5XFn/y3jegWC6u86KuELRundQS/1Rp+XuKKGIgRv3CvP5y749yqLlFO495JOT3+f2CXgd71npU0/KjjpkZucbJ5m78IVyuSrSozc9jgBUhDrz0hFsyb7LFUH9//wJbBgLdNWJZObfKxrNt8TliLA9w9sXFv6g26iXpf6r/BqcAusj/QzGBZuoUGeEtw8BCXCZ3jUiw4hvM18ZVqlUD3C40LAFXW6FRjuAZGRNstb0/qVk4skwyT+MHrvRorI4rKHVMWZmKyAkzL/78u/9pMQuX14pZN50b2PHn6fRxeaCQLsfT4dpvIkWWFuFVENZIh+8xgR6lU+85W0PPdAu1j99kcCG40JBQa4JMyRzq6qriOBLtqF87vpCJan0WEduVr/mOYkS00urVA0mA6M3031+GmGmW48PaJDYOEIb3bIXWPaLoAOEinX1TN3+/vwhG6nqJu0TdHpedS7QsGZIoxH3nQYYjQP1jmbahlbNngw5ogsGk1y50XZyUmQBY+/JBJ3Unu4dApm+WmPwHPU9gLb+4mHh4BiY6M86pq+WeTyWdI3s0CXPEtHGXZ8zMZgUoyRomBi1VdazzuN+WOmQ9Pa0Z0tlNopUi8AJ4x2Xn4mmOKEbXLxlbVsWu8XhuDGYFOGCRVdSqDPXrHU5SDdUlti3k5///SBwzTMwK3L4a1H7w4lnpEas6////AfX8asyIBfeFXVJ3tgvxQ/blZuUKyIODIfr/UzdWNu7pciLBpdZRZ4pIfZ1R6szq+XNxkGG///8EZFpu7VHAhFWqHEOrB9unw+YQa5o8/9IR/V5/zq+986rJSyfgJKt2u9hxU1wzyQWPjJGvzG9+eWWxGFOHVKqI4jBQALwZZswesnvZ2UmmkEXdiRpz8B+oWE7PY70ZTMndisYSXg2TqoI+3y9BxbnY2Y4EfbdcRhAvG59NqDENNYbxKvK5HJfPG5M+Wi2AcpLVJrD6caiEOzgSoVNSgQK8fm2M3zGcF4xtClv/8Hs9oD7C3jitTATYNQxmKqKf1LhIxzf1bmfiNn7UKFmcJu4sLqVLwxGSue3taBEyknkw5hXTsUCvqmmL/f8n/w0giR7Hu/9EHvpkz3yuu64TioMkzdTJ30i0+hFnQqW1+v9mMwq+z9qGX0UFu9MomvVG2xod6vc12AAAAACq7sGa5qptFR0jF3nQt/D+7PibKYahaxP3hEixPbGi9nwNf2LAa7LkEZRKxzXeCD64Xpii5n+8Kpg8eHIv7AWXZltgMoGltmoJ0XGdOCL8WkzphvR9N2o3ARSZ42l5e5Pe4B58MCRlP3EKv+mcloknH+fto5BWsmEutW6KvjOVsznFCktkSczVk4aGvj9VXlRcLeDoKG8RkBgdcNG2bf8HUL4MT2DM+ar7NImJhKpxakX4Vk0CnP+/XNhl5UsP0lXgeZXPoDBMSW5An+DXlTCO5FQGwSPYwHLKYVIimEdAoVe49rQLaaNcye5LxU2/c5TijTgJtD5eQQIe1snxauj5jZsxJBUJdoP/zqpjqv8qBruoPsVsP8N44PCUW5Dd0DzqjSS/Dl5mI9cn1w2ndN/0KAEm1QAAAACwu6KM/083IBbH5bPa/9oHUwcU8I9v3j6/v18QYammrf+P6VL///8BrpuM3fOLCxaLNOFNF1zPbPYTP65ni6njft4eVcyrVXRQFrs52tr35StiSp55edVDCBC0H5rIfac6nzUwxQSt7y15QoKb+5zebEQUmVbrPjXuUa19Ey7sqXMiSUKHaw72PJKDdrutJoQr3u6lEYJ8K0MakWKj9zjTFi4X94TsKYco0GrLeB60M6D8M/80rhXUW8iMequg8y5F838WI0+gp3GBN5Kj/xIOxTWQuUaPV/LwvARr1VH93BFgGZR1MFW0Ua30GbYmdnAgo9VWy8SQtpDUgGE2r2zq2eTEMCL7sMKmE1hchVhuF/TCq9iXKEm86kzOf3Rp9ZnCxbpDUj+FKNxVyXe6pVZkRXv/m95SnB/EB8aME29N85MtAcDoXWlor8De2Q5Dg1tar+8wgiZufbMam81j//ASUohoR/zSh2KG4bvT6mkIPz6C5/98DC3LaWlaEZ1zA5JORZRu6J/a0GY285sEYzw71YqOT1ihAG0z5SDt1xNiDQWZdFpndArp6xWhqSDkRb4kSJEHb9liPvw7uLV/6i5MVf//A9Qjr8xkAEUh+KDI+zdtJ68d6MBOktg1iyp/SCq8O9f5pbamn1VVVQPRTWqNBvhQKa07s6P0lc9Luu/3gw4HeyOUfz8MxMwV4UQhua+t9cr4bz/nIB2wnDSK1K7I94M+s6C84htaX/CNlMQUSs2KJO+yaebfTbkNX5yWcqEJevo0vbKUiETuFXiL019A3E+lmsyZMwXrXLLiQAZ5t9+jI3JobhJTMiDH5ZOQ+8Jau5555NMjHSscP9qCVaa40doh+1a3Ukf6jqBmLddgh79/fwTfCyqiuldNkUoy+nUp+4nerwg0OjtGv2x485PJOJvUEokNhYIdWjpx7BWk0VZGWOp3jSFTJ2bnu6KCduZtG/UcBC9RZ3W/jMSfSMw4Etr/DoD/XYP2V5Ovw+YoM3F5g2dGLdvuG6ZkVGLE6Dk5Zr+sdSyGliJP1y2OFf/KFO0RWO+3gsGhesTnfZVpTd8/HwgO216gwaqo+vY3TljfJWowY+i0p0Os4SLn/1wLqDHMlszggmT/D8MRFzs+pLv6LNJSsNZ/r41mWi/rF6ZcKp/yzJdK0VU44hskq3RGpgO6mIpJDsf/mZkFrz0yYOMLbuaj/wp1v7JMFM5eqvBhmTd7U8frQAtHtys4zgpjZmzUhOVTfNNLifElGXADlqHGKrkBT/nYwX8ZRm3RjvyPvjKyEqEGKUpVnvOGx+NKPHiWM//ZDpDVGvvrjmk8RPF/wiYZD3+Us8YCXjrVOfjdd1UPAfjLp8jgSn4me7DPTpz1Ggy9XL80guFO7ECT10AvILKfD18Qx+KY/f8aRqu0oOO8hfKRFZa9PUJwCsp6VdZz6LFkm2b9Pl2LIifCwzRy7TpdG2uAtOxP2OemY26bJMa9ZGSLIRlMsgpDpnDJwd0oa5pQ13x1hrHf52HpulUWonGWsfXZbSQYKu9bnEN76ciQih0opN3deDVrbrxorfVlnCmL1R9zq3ePGWIv21c7pW8kEiFTM5JX8dAw867s/60cf79/BH+MDFCZBHlz1L+qGOJf/1txhhmrf3//As+RIJwevDb+fgNXVeHw67QptZegayhrEwr5Gy+EPo1RLaMtPbqOZYoVzXzwzjMFWZxyUG9YUIf6////AQWy84iAygLk9COtXt92+0mT/xg0zMzMBeLkb8y9SL2TDXgSX422hDgpGNLJyuPioA+YJ91G8znrpNqHkwYyscaJDEc9Vc+j4cXle3hvcd2JqDQH2lBZxDn6mUTs0b75raMvbs727codX01Anj8f3wir9P2xQaQ22v/TxCMglKDFoTjaP01XTLgxnTvPv02JgEUrW6UDgOnobFpLdvKdlypgIzPcq14fgXU5tvVW0FEs7VRlsG1IyA69fN4n+awHhT34cE+xUvdj86C8LgAsFheTjI9Ht9EyYAAAAAAVBVKRx2wLgUTI0/2QfyJo2riRw3JDqzEShmx/Lifo6mRkQVbS7X53t+EvKxcXogtdts31e9MRHdcHgsA8rt4/mt2unlzQ/wsU8Gu7+W6Oj7eD8EQdDp5XlCsVaS/AV/t5ZpPOHR3rGpyAJe9IPV+xMrBL1Oz/8MQhFs31h0N1cVnq371uqIJYHyafKH1jteAK3VpMXBcuC+yt0ZeKyRUY4QhdrJJ4tJ1wg3Hu6kDsbovxupTMkGdRrm8oZSoYPbJ+PwH/xotgTdkA1205vUEfnqkI04T/fnnd1fiZW5AwNcggd7fi4j5zasmcntZexIxqFZQMzMJpfndmI5jn17cgn5EV5t9XN0C///8Q9wlJpMGXdoiaMTG2sVyHQsn8mWRISCLNG777S0OuDRP2GlLcJ2UeOg7Fo8hTNPeJ//iTJhyqxhKRUntdXOihq2wfKfH///8B0GGrwT+fSOQRdctKxjjGCSS11d6BlQ9BDfE0J6Z25FaNTKGpFKNCMr2G/041KpWwBLVe1k08vncseQbKZdXi8x1t9XA45U/Wd43D9wAh3Tal0aiLVzGPusOZ1F+W3TWoqlX/A95+dNef11TsuGful+ctGssldk3fqpfqh+43XTxL42+leSHoF/dWHYGX6maqUEuLX7UB+r/6Llr4LKocbVIeu+hB9QTPfz9fCP8RyWmX4SmbhMFsNtCijV7lVcwejLKlvl0GfCndnWV7/39VBrtTRuUx92oke3GBgKkC5fdGK0YvNK+xenKaDmsHDjNFUM3NMz3ZiXXFuLgojosPVCDEl2W5BjX3Ms+j0GSqACHmh0+RPWyuNm/Qe8vFf9AW7N1uRaxWirrUytqEJnJ4/Flm8hSoiZ2NQBsS6w/yQlC4gCaFo8q4nyY6AFdo4hiwhBXzbNKKvZvktCjSCukRR/BbYVbNwZi2Yh3hGodEacLW8qijiWJODf0P2bhfaiPspPT4lYJBgi/KfcFwCfvyUIgkJOv///8CG/JEepRBLaMFE+2TgrqsJXOVOWHt6g/bFwVLLMVBsMR50dis/39/AlBX+/rMTJkUQrnlxpR2iu0Tp8tATkRYGmDIrcAiRP8PjoWIlb7/0ecTdSCE9Y58+a+n/FovJQTVF4F2jAxMZhTgrM/KVS5BQu6bVbkWY5HXnxRshks3urDdW4RkWp4M4TeLmFK5KF/uHkkiO5Kv96RioH984v/CSDBnG+BwlnU9B+o7Y+0X0Nob+0pLsStxjvPXMy2eCpzhOWV4XbObBHN4UE2sLQ/DIqXhOzxVf38GlTi6aG7EnePO7TRJm9yOfUUcqq1I2iQHrVDqn3TUNRi/lMw8KbMW/3/nqCz/Ef8PoW5Qxcz2yHR/f78EPB2Stbd+ZFmfNTUYILzsb9YNhpaHcaymYrBiNHmFE3Y4ccYJ25Prqm7zHobGHED8/93ZNlWro9vcKivGZs31UiK1k5zjUhexUgbqJb+fUTjxce/7Zly8a5KMC1fX5nfjPgibdvzbXV1jRT2asXvmSAusaLdq1TSIJ8fXINk5AtT34EWPAsfP9IFQqM5K11O6saoHJA==';\nlet data = null;\nconst initData = () => {\n\tif (!data) {\n\t\tconst binaryString = atob(base64String);\n\t\tdata = Uint8Array.from(binaryString, char => char.charCodeAt(0));\n\t}\n};\nconst blueNoiseData = () => {\n\tinitData();\n\treturn data;\n};\nclass BlueNoise {\n\tconstructor(seed = 0) {\n\t\tthis.seed = 0;\n\t\tthis.seed = seed * 4;\n\t\tinitData();\n\t}\n\t_next() {\n\t\tthis.seed = (this.seed + 4) % data.length;\n\t}\n\tvalue() {\n\t\tthis._next();\n\t\treturn data[this.seed] / 255;\n\t}\n\tvec4(dest = new Vec4()) {\n\t\tthis._next();\n\t\treturn dest.set(data[this.seed], data[this.seed + 1], data[this.seed + 2], data[this.seed + 3]).mulScalar(1 / 255);\n\t}\n}\n\nexport { BlueNoise, blueNoiseData };\n","import { math } from './math.js';\n\nvar _Color;\nclass Color {\n\tconstructor(r = 0, g = 0, b = 0, a = 1) {\n\t\tthis.r = void 0;\n\t\tthis.g = void 0;\n\t\tthis.b = void 0;\n\t\tthis.a = void 0;\n\t\tconst length = r.length;\n\t\tif (length === 3 || length === 4) {\n\t\t\tthis.r = r[0];\n\t\t\tthis.g = r[1];\n\t\t\tthis.b = r[2];\n\t\t\tthis.a = r[3] !== undefined ? r[3] : 1;\n\t\t} else {\n\t\t\tthis.r = r;\n\t\t\tthis.g = g;\n\t\t\tthis.b = b;\n\t\t\tthis.a = a;\n\t\t}\n\t}\n\tclone() {\n\t\tconst cstr = this.constructor;\n\t\treturn new cstr(this.r, this.g, this.b, this.a);\n\t}\n\tcopy(rhs) {\n\t\tthis.r = rhs.r;\n\t\tthis.g = rhs.g;\n\t\tthis.b = rhs.b;\n\t\tthis.a = rhs.a;\n\t\treturn this;\n\t}\n\tequals(rhs) {\n\t\treturn this.r === rhs.r && this.g === rhs.g && this.b === rhs.b && this.a === rhs.a;\n\t}\n\tset(r, g, b, a = 1) {\n\t\tthis.r = r;\n\t\tthis.g = g;\n\t\tthis.b = b;\n\t\tthis.a = a;\n\t\treturn this;\n\t}\n\tlerp(lhs, rhs, alpha) {\n\t\tthis.r = lhs.r + alpha * (rhs.r - lhs.r);\n\t\tthis.g = lhs.g + alpha * (rhs.g - lhs.g);\n\t\tthis.b = lhs.b + alpha * (rhs.b - lhs.b);\n\t\tthis.a = lhs.a + alpha * (rhs.a - lhs.a);\n\t\treturn this;\n\t}\n\tfromString(hex) {\n\t\tconst i = parseInt(hex.replace('#', '0x'), 16);\n\t\tlet bytes;\n\t\tif (hex.length > 7) {\n\t\t\tbytes = math.intToBytes32(i);\n\t\t} else {\n\t\t\tbytes = math.intToBytes24(i);\n\t\t\tbytes[3] = 255;\n\t\t}\n\t\tthis.set(bytes[0] / 255, bytes[1] / 255, bytes[2] / 255, bytes[3] / 255);\n\t\treturn this;\n\t}\n\tfromArray(arr, offset = 0) {\n\t\tvar _arr$offset, _arr, _arr2, _arr3;\n\t\tthis.r = (_arr$offset = arr[offset]) != null ? _arr$offset : this.r;\n\t\tthis.g = (_arr = arr[offset + 1]) != null ? _arr : this.g;\n\t\tthis.b = (_arr2 = arr[offset + 2]) != null ? _arr2 : this.b;\n\t\tthis.a = (_arr3 = arr[offset + 3]) != null ? _arr3 : this.a;\n\t\treturn this;\n\t}\n\ttoString(alpha) {\n\t\tlet s = `#${((1 << 24) + (Math.round(this.r * 255) << 16) + (Math.round(this.g * 255) << 8) + Math.round(this.b * 255)).toString(16).slice(1)}`;\n\t\tif (alpha === true) {\n\t\t\tconst a = Math.round(this.a * 255).toString(16);\n\t\t\tif (this.a < 16 / 255) {\n\t\t\t\ts += `0${a}`;\n\t\t\t} else {\n\t\t\t\ts += a;\n\t\t\t}\n\t\t}\n\t\treturn s;\n\t}\n\ttoArray(arr = [], offset = 0, alpha = true) {\n\t\tarr[offset] = this.r;\n\t\tarr[offset + 1] = this.g;\n\t\tarr[offset + 2] = this.b;\n\t\tif (alpha) {\n\t\t\tarr[offset + 3] = this.a;\n\t\t}\n\t\treturn arr;\n\t}\n}\n_Color = Color;\nColor.BLACK = Object.freeze(new _Color(0, 0, 0, 1));\nColor.BLUE = Object.freeze(new _Color(0, 0, 1, 1));\nColor.CYAN = Object.freeze(new _Color(0, 1, 1, 1));\nColor.GRAY = Object.freeze(new _Color(0.5, 0.5, 0.5, 1));\nColor.GREEN = Object.freeze(new _Color(0, 1, 0, 1));\nColor.MAGENTA = Object.freeze(new _Color(1, 0, 1, 1));\nColor.RED = Object.freeze(new _Color(1, 0, 0, 1));\nColor.WHITE = Object.freeze(new _Color(1, 1, 1, 1));\nColor.YELLOW = Object.freeze(new _Color(1, 1, 0, 1));\n\nexport { Color };\n","const CURVE_LINEAR = 0;\nconst CURVE_SMOOTHSTEP = 1;\nconst CURVE_CATMULL = 2;\nconst CURVE_CARDINAL = 3;\nconst CURVE_SPLINE = 4;\nconst CURVE_STEP = 5;\n\nexport { CURVE_CARDINAL, CURVE_CATMULL, CURVE_LINEAR, CURVE_SMOOTHSTEP, CURVE_SPLINE, CURVE_STEP };\n","import { CURVE_STEP, CURVE_LINEAR, CURVE_SMOOTHSTEP, CURVE_CATMULL, CURVE_CARDINAL, CURVE_SPLINE } from './constants.js';\nimport { math } from './math.js';\n\nclass CurveEvaluator {\n\tconstructor(curve, time = 0) {\n\t\tthis._curve = void 0;\n\t\tthis._left = -Infinity;\n\t\tthis._right = Infinity;\n\t\tthis._recip = 0;\n\t\tthis._p0 = 0;\n\t\tthis._p1 = 0;\n\t\tthis._m0 = 0;\n\t\tthis._m1 = 0;\n\t\tthis._curve = curve;\n\t\tthis._reset(time);\n\t}\n\tevaluate(time, forceReset = false) {\n\t\tif (forceReset || time < this._left || time >= this._right) {\n\t\t\tthis._reset(time);\n\t\t}\n\t\tlet result;\n\t\tconst type = this._curve.type;\n\t\tif (type === CURVE_STEP) {\n\t\t\tresult = this._p0;\n\t\t} else {\n\t\t\tconst t = this._recip === 0 ? 0 : (time - this._left) * this._recip;\n\t\t\tif (type === CURVE_LINEAR) {\n\t\t\t\tresult = math.lerp(this._p0, this._p1, t);\n\t\t\t} else if (type === CURVE_SMOOTHSTEP) {\n\t\t\t\tresult = math.lerp(this._p0, this._p1, t * t * (3 - 2 * t));\n\t\t\t} else {\n\t\t\t\tresult = this._evaluateHermite(this._p0, this._p1, this._m0, this._m1, t);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t_reset(time) {\n\t\tconst keys = this._curve.keys;\n\t\tconst len = keys.length;\n\t\tif (!len) {\n\t\t\tthis._left = -Infinity;\n\t\t\tthis._right = Infinity;\n\t\t\tthis._recip = 0;\n\t\t\tthis._p0 = this._p1 = this._m0 = this._m1 = 0;\n\t\t} else {\n\t\t\tif (time < keys[0][0]) {\n\t\t\t\tthis._left = -Infinity;\n\t\t\t\tthis._right = keys[0][0];\n\t\t\t\tthis._recip = 0;\n\t\t\t\tthis._p0 = this._p1 = keys[0][1];\n\t\t\t\tthis._m0 = this._m1 = 0;\n\t\t\t} else if (time >= keys[len - 1][0]) {\n\t\t\t\tthis._left = keys[len - 1][0];\n\t\t\t\tthis._right = Infinity;\n\t\t\t\tthis._recip = 0;\n\t\t\t\tthis._p0 = this._p1 = keys[len - 1][1];\n\t\t\t\tthis._m0 = this._m1 = 0;\n\t\t\t} else {\n\t\t\t\tlet index = 0;\n\t\t\t\twhile (time >= keys[index + 1][0]) {\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t\tthis._left = keys[index][0];\n\t\t\t\tthis._right = keys[index + 1][0];\n\t\t\t\tconst diff = 1.0 / (this._right - this._left);\n\t\t\t\tthis._recip = isFinite(diff) ? diff : 0;\n\t\t\t\tthis._p0 = keys[index][1];\n\t\t\t\tthis._p1 = keys[index + 1][1];\n\t\t\t\tif (this._isHermite()) {\n\t\t\t\t\tthis._calcTangents(keys, index);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t_isHermite() {\n\t\treturn this._curve.type === CURVE_CATMULL || this._curve.type === CURVE_CARDINAL || this._curve.type === CURVE_SPLINE;\n\t}\n\t_calcTangents(keys, index) {\n\t\tlet a;\n\t\tconst b = keys[index];\n\t\tconst c = keys[index + 1];\n\t\tlet d;\n\t\tif (index === 0) {\n\t\t\ta = [keys[0][0] + (keys[0][0] - keys[1][0]), keys[0][1] + (keys[0][1] - keys[1][1])];\n\t\t} else {\n\t\t\ta = keys[index - 1];\n\t\t}\n\t\tif (index === keys.length - 2) {\n\t\t\td = [keys[index + 1][0] + (keys[index + 1][0] - keys[index][0]), keys[index + 1][1] + (keys[index + 1][1] - keys[index][1])];\n\t\t} else {\n\t\t\td = keys[index + 2];\n\t\t}\n\t\tif (this._curve.type === CURVE_SPLINE) {\n\t\t\tconst s1_ = 2 * (c[0] - b[0]) / (c[0] - a[0]);\n\t\t\tconst s2_ = 2 * (c[0] - b[0]) / (d[0] - b[0]);\n\t\t\tthis._m0 = this._curve.tension * (isFinite(s1_) ? s1_ : 0) * (c[1] - a[1]);\n\t\t\tthis._m1 = this._curve.tension * (isFinite(s2_) ? s2_ : 0) * (d[1] - b[1]);\n\t\t} else {\n\t\t\tconst s1 = (c[0] - b[0]) / (b[0] - a[0]);\n\t\t\tconst s2 = (c[0] - b[0]) / (d[0] - c[0]);\n\t\t\tconst a_ = b[1] + (a[1] - b[1]) * (isFinite(s1) ? s1 : 0);\n\t\t\tconst d_ = c[1] + (d[1] - c[1]) * (isFinite(s2) ? s2 : 0);\n\t\t\tconst tension = this._curve.type === CURVE_CATMULL ? 0.5 : this._curve.tension;\n\t\t\tthis._m0 = tension * (c[1] - a_);\n\t\t\tthis._m1 = tension * (d_ - b[1]);\n\t\t}\n\t}\n\t_evaluateHermite(p0, p1, m0, m1, t) {\n\t\tconst t2 = t * t;\n\t\tconst twot = t + t;\n\t\tconst omt = 1 - t;\n\t\tconst omt2 = omt * omt;\n\t\treturn p0 * ((1 + twot) * omt2) + m0 * (t * omt2) + p1 * (t2 * (3 - twot)) + m1 * (t2 * (t - 1));\n\t}\n}\n\nexport { CurveEvaluator };\n","import { CURVE_SMOOTHSTEP } from './constants.js';\nimport { Curve } from './curve.js';\nimport { CurveEvaluator } from './curve-evaluator.js';\n\nclass CurveSet {\n\tconstructor() {\n\t\tthis.curves = [];\n\t\tthis._type = CURVE_SMOOTHSTEP;\n\t\tif (arguments.length > 1) {\n\t\t\tfor (let i = 0; i < arguments.length; i++) {\n\t\t\t\tthis.curves.push(new Curve(arguments[i]));\n\t\t\t}\n\t\t} else {\n\t\t\tif (arguments.length === 0) {\n\t\t\t\tthis.curves.push(new Curve());\n\t\t\t} else {\n\t\t\t\tconst arg = arguments[0];\n\t\t\t\tif (typeof arg === 'number') {\n\t\t\t\t\tfor (let i = 0; i < arg; i++) {\n\t\t\t\t\t\tthis.curves.push(new Curve());\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (let i = 0; i < arg.length; i++) {\n\t\t\t\t\t\tthis.curves.push(new Curve(arg[i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tget length() {\n\t\treturn this.curves.length;\n\t}\n\tset type(value) {\n\t\tthis._type = value;\n\t\tfor (let i = 0; i < this.curves.length; i++) {\n\t\t\tthis.curves[i].type = value;\n\t\t}\n\t}\n\tget type() {\n\t\treturn this._type;\n\t}\n\tget(index) {\n\t\treturn this.curves[index];\n\t}\n\tvalue(time, result = []) {\n\t\tconst length = this.curves.length;\n\t\tresult.length = length;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult[i] = this.curves[i].value(time);\n\t\t}\n\t\treturn result;\n\t}\n\tclone() {\n\t\tconst result = new this.constructor();\n\t\tresult.curves = [];\n\t\tfor (let i = 0; i < this.curves.length; i++) {\n\t\t\tresult.curves.push(this.curves[i].clone());\n\t\t}\n\t\tresult._type = this._type;\n\t\treturn result;\n\t}\n\tquantize(precision) {\n\t\tprecision = Math.max(precision, 2);\n\t\tconst numCurves = this.curves.length;\n\t\tconst values = new Float32Array(precision * numCurves);\n\t\tconst step = 1.0 / (precision - 1);\n\t\tfor (let c = 0; c < numCurves; c++) {\n\t\t\tconst ev = new CurveEvaluator(this.curves[c]);\n\t\t\tfor (let i = 0; i < precision; i++) {\n\t\t\t\tvalues[i * numCurves + c] = ev.evaluate(step * i);\n\t\t\t}\n\t\t}\n\t\treturn values;\n\t}\n\tquantizeClamped(precision, min, max) {\n\t\tconst result = this.quantize(precision);\n\t\tfor (let i = 0; i < result.length; ++i) {\n\t\t\tresult[i] = Math.min(max, Math.max(min, result[i]));\n\t\t}\n\t\treturn result;\n\t}\n}\n\nexport { CurveSet };\n","import { CURVE_SMOOTHSTEP } from './constants.js';\nimport { CurveEvaluator } from './curve-evaluator.js';\n\nclass Curve {\n\tconstructor(data) {\n\t\tthis.keys = [];\n\t\tthis.type = CURVE_SMOOTHSTEP;\n\t\tthis.tension = 0.5;\n\t\tthis._eval = new CurveEvaluator(this);\n\t\tif (data) {\n\t\t\tfor (let i = 0; i < data.length - 1; i += 2) {\n\t\t\t\tthis.keys.push([data[i], data[i + 1]]);\n\t\t\t}\n\t\t}\n\t\tthis.sort();\n\t}\n\tget length() {\n\t\treturn this.keys.length;\n\t}\n\tadd(time, value) {\n\t\tconst keys = this.keys;\n\t\tconst len = keys.length;\n\t\tlet i = 0;\n\t\tfor (; i < len; i++) {\n\t\t\tif (keys[i][0] > time) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tconst key = [time, value];\n\t\tthis.keys.splice(i, 0, key);\n\t\treturn key;\n\t}\n\tget(index) {\n\t\treturn this.keys[index];\n\t}\n\tsort() {\n\t\tthis.keys.sort((a, b) => a[0] - b[0]);\n\t}\n\tvalue(time) {\n\t\treturn this._eval.evaluate(time, true);\n\t}\n\tclosest(time) {\n\t\tconst keys = this.keys;\n\t\tconst length = keys.length;\n\t\tlet min = 2;\n\t\tlet result = null;\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tconst diff = Math.abs(time - keys[i][0]);\n\t\t\tif (min >= diff) {\n\t\t\t\tmin = diff;\n\t\t\t\tresult = keys[i];\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tclone() {\n\t\tconst result = new this.constructor();\n\t\tresult.keys = this.keys.map(key => [...key]);\n\t\tresult.type = this.type;\n\t\tresult.tension = this.tension;\n\t\treturn result;\n\t}\n\tquantize(precision) {\n\t\tprecision = Math.max(precision, 2);\n\t\tconst values = new Float32Array(precision);\n\t\tconst step = 1.0 / (precision - 1);\n\t\tvalues[0] = this._eval.evaluate(0, true);\n\t\tfor (let i = 1; i < precision; i++) {\n\t\t\tvalues[i] = this._eval.evaluate(step * i);\n\t\t}\n\t\treturn values;\n\t}\n\tquantizeClamped(precision, min, max) {\n\t\tconst result = this.quantize(precision);\n\t\tfor (let i = 0; i < result.length; ++i) {\n\t\t\tresult[i] = Math.min(max, Math.max(min, result[i]));\n\t\t}\n\t\treturn result;\n\t}\n}\n\nexport { Curve };\n","import { math } from './math.js';\n\nconst oneDiv255 = 1 / 255;\nconst floatView = new Float32Array(1);\nconst int32View = new Int32Array(floatView.buffer);\nclass FloatPacking {\n\tstatic float2Half(value) {\n\t\tfloatView[0] = value;\n\t\tconst x = int32View[0];\n\t\tlet bits = x >> 16 & 0x8000;\n\t\tlet m = x >> 12 & 0x07ff;\n\t\tconst e = x >> 23 & 0xff;\n\t\tif (e < 103) {\n\t\t\treturn bits;\n\t\t}\n\t\tif (e > 142) {\n\t\t\tbits |= 0x7c00;\n\t\t\tbits |= (e === 255 ? 0 : 1) && x & 0x007fffff;\n\t\t\treturn bits;\n\t\t}\n\t\tif (e < 113) {\n\t\t\tm |= 0x0800;\n\t\t\tbits |= (m >> 114 - e) + (m >> 113 - e & 1);\n\t\t\treturn bits;\n\t\t}\n\t\tbits |= e - 112 << 10 | m >> 1;\n\t\tbits += m & 1;\n\t\treturn bits;\n\t}\n\tstatic float2Bytes(value, array, offset, numBytes) {\n\t\tconst enc1 = 255.0 * value % 1;\n\t\tarray[offset + 0] = Math.round((value % 1 - oneDiv255 * enc1) * 255);\n\t\tif (numBytes > 1) {\n\t\t\tconst enc2 = 65025.0 * value % 1;\n\t\t\tarray[offset + 1] = Math.round((enc1 - oneDiv255 * enc2) * 255);\n\t\t\tif (numBytes > 2) {\n\t\t\t\tconst enc3 = 16581375.0 * value % 1;\n\t\t\t\tarray[offset + 2] = Math.round((enc2 - oneDiv255 * enc3) * 255);\n\t\t\t\tif (numBytes > 3) {\n\t\t\t\t\tarray[offset + 3] = Math.round(enc3 * 255);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic float2BytesRange(value, array, offset, min, max, numBytes) {\n\t\tvalue = math.clamp((value - min) / (max - min), 0, 1);\n\t\tFloatPacking.float2Bytes(value, array, offset, numBytes);\n\t}\n\tstatic float2MantissaExponent(value, array, offset, numBytes) {\n\t\tconst exponent = Math.floor(Math.log2(Math.abs(value))) + 1;\n\t\tvalue /= Math.pow(2, exponent);\n\t\tFloatPacking.float2BytesRange(value, array, offset, -1, 1, numBytes - 1);\n\t\tarray[offset + numBytes - 1] = Math.round(exponent + 127);\n\t}\n}\n\nexport { FloatPacking };\n","import { Vec3 } from './vec3.js';\n\nvar _Mat;\nclass Mat3 {\n\tconstructor() {\n\t\tthis.data = new Float32Array(9);\n\t\tthis.data[0] = this.data[4] = this.data[8] = 1;\n\t}\n\tclone() {\n\t\tconst cstr = this.constructor;\n\t\treturn new cstr().copy(this);\n\t}\n\tcopy(rhs) {\n\t\tconst src = rhs.data;\n\t\tconst dst = this.data;\n\t\tdst[0] = src[0];\n\t\tdst[1] = src[1];\n\t\tdst[2] = src[2];\n\t\tdst[3] = src[3];\n\t\tdst[4] = src[4];\n\t\tdst[5] = src[5];\n\t\tdst[6] = src[6];\n\t\tdst[7] = src[7];\n\t\tdst[8] = src[8];\n\t\treturn this;\n\t}\n\tset(src) {\n\t\tconst dst = this.data;\n\t\tdst[0] = src[0];\n\t\tdst[1] = src[1];\n\t\tdst[2] = src[2];\n\t\tdst[3] = src[3];\n\t\tdst[4] = src[4];\n\t\tdst[5] = src[5];\n\t\tdst[6] = src[6];\n\t\tdst[7] = src[7];\n\t\tdst[8] = src[8];\n\t\treturn this;\n\t}\n\tgetX(x = new Vec3()) {\n\t\treturn x.set(this.data[0], this.data[1], this.data[2]);\n\t}\n\tgetY(y = new Vec3()) {\n\t\treturn y.set(this.data[3], this.data[4], this.data[5]);\n\t}\n\tgetZ(z = new Vec3()) {\n\t\treturn z.set(this.data[6], this.data[7], this.data[8]);\n\t}\n\tequals(rhs) {\n\t\tconst l = this.data;\n\t\tconst r = rhs.data;\n\t\treturn l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8];\n\t}\n\tisIdentity() {\n\t\tconst m = this.data;\n\t\treturn m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 1 && m[5] === 0 && m[6] === 0 && m[7] === 0 && m[8] === 1;\n\t}\n\tsetIdentity() {\n\t\tconst m = this.data;\n\t\tm[0] = 1;\n\t\tm[1] = 0;\n\t\tm[2] = 0;\n\t\tm[3] = 0;\n\t\tm[4] = 1;\n\t\tm[5] = 0;\n\t\tm[6] = 0;\n\t\tm[7] = 0;\n\t\tm[8] = 1;\n\t\treturn this;\n\t}\n\ttoString() {\n\t\treturn `[${this.data.join(', ')}]`;\n\t}\n\ttranspose(src = this) {\n\t\tconst s = src.data;\n\t\tconst t = this.data;\n\t\tif (s === t) {\n\t\t\tlet tmp;\n\t\t\ttmp = s[1];\n\t\t\tt[1] = s[3];\n\t\t\tt[3] = tmp;\n\t\t\ttmp = s[2];\n\t\t\tt[2] = s[6];\n\t\t\tt[6] = tmp;\n\t\t\ttmp = s[5];\n\t\t\tt[5] = s[7];\n\t\t\tt[7] = tmp;\n\t\t} else {\n\t\t\tt[0] = s[0];\n\t\t\tt[1] = s[3];\n\t\t\tt[2] = s[6];\n\t\t\tt[3] = s[1];\n\t\t\tt[4] = s[4];\n\t\t\tt[5] = s[7];\n\t\t\tt[6] = s[2];\n\t\t\tt[7] = s[5];\n\t\t\tt[8] = s[8];\n\t\t}\n\t\treturn this;\n\t}\n\tsetFromMat4(m) {\n\t\tconst src = m.data;\n\t\tconst dst = this.data;\n\t\tdst[0] = src[0];\n\t\tdst[1] = src[1];\n\t\tdst[2] = src[2];\n\t\tdst[3] = src[4];\n\t\tdst[4] = src[5];\n\t\tdst[5] = src[6];\n\t\tdst[6] = src[8];\n\t\tdst[7] = src[9];\n\t\tdst[8] = src[10];\n\t\treturn this;\n\t}\n\tsetFromQuat(r) {\n\t\tconst qx = r.x;\n\t\tconst qy = r.y;\n\t\tconst qz = r.z;\n\t\tconst qw = r.w;\n\t\tconst x2 = qx + qx;\n\t\tconst y2 = qy + qy;\n\t\tconst z2 = qz + qz;\n\t\tconst xx = qx * x2;\n\t\tconst xy = qx * y2;\n\t\tconst xz = qx * z2;\n\t\tconst yy = qy * y2;\n\t\tconst yz = qy * z2;\n\t\tconst zz = qz * z2;\n\t\tconst wx = qw * x2;\n\t\tconst wy = qw * y2;\n\t\tconst wz = qw * z2;\n\t\tconst m = this.data;\n\t\tm[0] = 1 - (yy + zz);\n\t\tm[1] = xy + wz;\n\t\tm[2] = xz - wy;\n\t\tm[3] = xy - wz;\n\t\tm[4] = 1 - (xx + zz);\n\t\tm[5] = yz + wx;\n\t\tm[6] = xz + wy;\n\t\tm[7] = yz - wx;\n\t\tm[8] = 1 - (xx + yy);\n\t\treturn this;\n\t}\n\tinvertMat4(src) {\n\t\tconst s = src.data;\n\t\tconst a0 = s[0];\n\t\tconst a1 = s[1];\n\t\tconst a2 = s[2];\n\t\tconst a4 = s[4];\n\t\tconst a5 = s[5];\n\t\tconst a6 = s[6];\n\t\tconst a8 = s[8];\n\t\tconst a9 = s[9];\n\t\tconst a10 = s[10];\n\t\tconst b11 = a10 * a5 - a6 * a9;\n\t\tconst b21 = -a10 * a1 + a2 * a9;\n\t\tconst b31 = a6 * a1 - a2 * a5;\n\t\tconst b12 = -a10 * a4 + a6 * a8;\n\t\tconst b22 = a10 * a0 - a2 * a8;\n\t\tconst b32 = -a6 * a0 + a2 * a4;\n\t\tconst b13 = a9 * a4 - a5 * a8;\n\t\tconst b23 = -a9 * a0 + a1 * a8;\n\t\tconst b33 = a5 * a0 - a1 * a4;\n\t\tconst det = a0 * b11 + a1 * b12 + a2 * b13;\n\t\tif (det === 0) {\n\t\t\tthis.setIdentity();\n\t\t} else {\n\t\t\tconst invDet = 1 / det;\n\t\t\tconst t = this.data;\n\t\t\tt[0] = b11 * invDet;\n\t\t\tt[1] = b21 * invDet;\n\t\t\tt[2] = b31 * invDet;\n\t\t\tt[3] = b12 * invDet;\n\t\t\tt[4] = b22 * invDet;\n\t\t\tt[5] = b32 * invDet;\n\t\t\tt[6] = b13 * invDet;\n\t\t\tt[7] = b23 * invDet;\n\t\t\tt[8] = b33 * invDet;\n\t\t}\n\t\treturn this;\n\t}\n\ttransformVector(vec, res = new Vec3()) {\n\t\tconst m = this.data;\n\t\tconst {\n\t\t\tx,\n\t\t\ty,\n\t\t\tz\n\t\t} = vec;\n\t\tres.x = x * m[0] + y * m[3] + z * m[6];\n\t\tres.y = x * m[1] + y * m[4] + z * m[7];\n\t\tres.z = x * m[2] + y * m[5] + z * m[8];\n\t\treturn res;\n\t}\n}\n_Mat = Mat3;\nMat3.IDENTITY = Object.freeze(new _Mat());\nMat3.ZERO = Object.freeze(new _Mat().set([0, 0, 0, 0, 0, 0, 0, 0, 0]));\n\nexport { Mat3 };\n","import { math } from './math.js';\nimport { Vec2 } from './vec2.js';\nimport { Vec3 } from './vec3.js';\nimport { Vec4 } from './vec4.js';\n\nvar _Mat;\nconst _halfSize = new Vec2();\nconst x = new Vec3();\nconst y = new Vec3();\nconst z = new Vec3();\nconst scale = new Vec3();\nclass Mat4 {\n\tconstructor() {\n\t\tthis.data = new Float32Array(16);\n\t\tthis.data[0] = this.data[5] = this.data[10] = this.data[15] = 1;\n\t}\n\tstatic _getPerspectiveHalfSize(halfSize, fov, aspect, znear, fovIsHorizontal) {\n\t\tif (fovIsHorizontal) {\n\t\t\thalfSize.x = znear * Math.tan(fov * Math.PI / 360);\n\t\t\thalfSize.y = halfSize.x / aspect;\n\t\t} else {\n\t\t\thalfSize.y = znear * Math.tan(fov * Math.PI / 360);\n\t\t\thalfSize.x = halfSize.y * aspect;\n\t\t}\n\t}\n\tadd2(lhs, rhs) {\n\t\tconst a = lhs.data,\n\t\t\tb = rhs.data,\n\t\t\tr = this.data;\n\t\tr[0] = a[0] + b[0];\n\t\tr[1] = a[1] + b[1];\n\t\tr[2] = a[2] + b[2];\n\t\tr[3] = a[3] + b[3];\n\t\tr[4] = a[4] + b[4];\n\t\tr[5] = a[5] + b[5];\n\t\tr[6] = a[6] + b[6];\n\t\tr[7] = a[7] + b[7];\n\t\tr[8] = a[8] + b[8];\n\t\tr[9] = a[9] + b[9];\n\t\tr[10] = a[10] + b[10];\n\t\tr[11] = a[11] + b[11];\n\t\tr[12] = a[12] + b[12];\n\t\tr[13] = a[13] + b[13];\n\t\tr[14] = a[14] + b[14];\n\t\tr[15] = a[15] + b[15];\n\t\treturn this;\n\t}\n\tadd(rhs) {\n\t\treturn this.add2(this, rhs);\n\t}\n\tclone() {\n\t\tconst cstr = this.constructor;\n\t\treturn new cstr().copy(this);\n\t}\n\tcopy(rhs) {\n\t\tconst src = rhs.data,\n\t\t\tdst = this.data;\n\t\tdst[0] = src[0];\n\t\tdst[1] = src[1];\n\t\tdst[2] = src[2];\n\t\tdst[3] = src[3];\n\t\tdst[4] = src[4];\n\t\tdst[5] = src[5];\n\t\tdst[6] = src[6];\n\t\tdst[7] = src[7];\n\t\tdst[8] = src[8];\n\t\tdst[9] = src[9];\n\t\tdst[10] = src[10];\n\t\tdst[11] = src[11];\n\t\tdst[12] = src[12];\n\t\tdst[13] = src[13];\n\t\tdst[14] = src[14];\n\t\tdst[15] = src[15];\n\t\treturn this;\n\t}\n\tequals(rhs) {\n\t\tconst l = this.data,\n\t\t\tr = rhs.data;\n\t\treturn l[0] === r[0] && l[1] === r[1] && l[2] === r[2] && l[3] === r[3] && l[4] === r[4] && l[5] === r[5] && l[6] === r[6] && l[7] === r[7] && l[8] === r[8] && l[9] === r[9] && l[10] === r[10] && l[11] === r[11] && l[12] === r[12] && l[13] === r[13] && l[14] === r[14] && l[15] === r[15];\n\t}\n\tisIdentity() {\n\t\tconst m = this.data;\n\t\treturn m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;\n\t}\n\tmul2(lhs, rhs) {\n\t\tconst a = lhs.data;\n\t\tconst b = rhs.data;\n\t\tconst r = this.data;\n\t\tconst a00 = a[0];\n\t\tconst a01 = a[1];\n\t\tconst a02 = a[2];\n\t\tconst a03 = a[3];\n\t\tconst a10 = a[4];\n\t\tconst a11 = a[5];\n\t\tconst a12 = a[6];\n\t\tconst a13 = a[7];\n\t\tconst a20 = a[8];\n\t\tconst a21 = a[9];\n\t\tconst a22 = a[10];\n\t\tconst a23 = a[11];\n\t\tconst a30 = a[12];\n\t\tconst a31 = a[13];\n\t\tconst a32 = a[14];\n\t\tconst a33 = a[15];\n\t\tlet b0, b1, b2, b3;\n\t\tb0 = b[0];\n\t\tb1 = b[1];\n\t\tb2 = b[2];\n\t\tb3 = b[3];\n\t\tr[0] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n\t\tr[1] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n\t\tr[2] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n\t\tr[3] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n\t\tb0 = b[4];\n\t\tb1 = b[5];\n\t\tb2 = b[6];\n\t\tb3 = b[7];\n\t\tr[4] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n\t\tr[5] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n\t\tr[6] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n\t\tr[7] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n\t\tb0 = b[8];\n\t\tb1 = b[9];\n\t\tb2 = b[10];\n\t\tb3 = b[11];\n\t\tr[8] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n\t\tr[9] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n\t\tr[10] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n\t\tr[11] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n\t\tb0 = b[12];\n\t\tb1 = b[13];\n\t\tb2 = b[14];\n\t\tb3 = b[15];\n\t\tr[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30 * b3;\n\t\tr[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31 * b3;\n\t\tr[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32 * b3;\n\t\tr[15] = a03 * b0 + a13 * b1 + a23 * b2 + a33 * b3;\n\t\treturn this;\n\t}\n\tmulAffine2(lhs, rhs) {\n\t\tconst a = lhs.data;\n\t\tconst b = rhs.data;\n\t\tconst r = this.data;\n\t\tconst a00 = a[0];\n\t\tconst a01 = a[1];\n\t\tconst a02 = a[2];\n\t\tconst a10 = a[4];\n\t\tconst a11 = a[5];\n\t\tconst a12 = a[6];\n\t\tconst a20 = a[8];\n\t\tconst a21 = a[9];\n\t\tconst a22 = a[10];\n\t\tconst a30 = a[12];\n\t\tconst a31 = a[13];\n\t\tconst a32 = a[14];\n\t\tlet b0, b1, b2;\n\t\tb0 = b[0];\n\t\tb1 = b[1];\n\t\tb2 = b[2];\n\t\tr[0] = a00 * b0 + a10 * b1 + a20 * b2;\n\t\tr[1] = a01 * b0 + a11 * b1 + a21 * b2;\n\t\tr[2] = a02 * b0 + a12 * b1 + a22 * b2;\n\t\tr[3] = 0;\n\t\tb0 = b[4];\n\t\tb1 = b[5];\n\t\tb2 = b[6];\n\t\tr[4] = a00 * b0 + a10 * b1 + a20 * b2;\n\t\tr[5] = a01 * b0 + a11 * b1 + a21 * b2;\n\t\tr[6] = a02 * b0 + a12 * b1 + a22 * b2;\n\t\tr[7] = 0;\n\t\tb0 = b[8];\n\t\tb1 = b[9];\n\t\tb2 = b[10];\n\t\tr[8] = a00 * b0 + a10 * b1 + a20 * b2;\n\t\tr[9] = a01 * b0 + a11 * b1 + a21 * b2;\n\t\tr[10] = a02 * b0 + a12 * b1 + a22 * b2;\n\t\tr[11] = 0;\n\t\tb0 = b[12];\n\t\tb1 = b[13];\n\t\tb2 = b[14];\n\t\tr[12] = a00 * b0 + a10 * b1 + a20 * b2 + a30;\n\t\tr[13] = a01 * b0 + a11 * b1 + a21 * b2 + a31;\n\t\tr[14] = a02 * b0 + a12 * b1 + a22 * b2 + a32;\n\t\tr[15] = 1;\n\t\treturn this;\n\t}\n\tmul(rhs) {\n\t\treturn this.mul2(this, rhs);\n\t}\n\ttransformPoint(vec, res = new Vec3()) {\n\t\tconst m = this.data;\n\t\tconst {\n\t\t\tx,\n\t\t\ty,\n\t\t\tz\n\t\t} = vec;\n\t\tres.x = x * m[0] + y * m[4] + z * m[8] + m[12];\n\t\tres.y = x * m[1] + y * m[5] + z * m[9] + m[13];\n\t\tres.z = x * m[2] + y * m[6] + z * m[10] + m[14];\n\t\treturn res;\n\t}\n\ttransformVector(vec, res = new Vec3()) {\n\t\tconst m = this.data;\n\t\tconst {\n\t\t\tx,\n\t\t\ty,\n\t\t\tz\n\t\t} = vec;\n\t\tres.x = x * m[0] + y * m[4] + z * m[8];\n\t\tres.y = x * m[1] + y * m[5] + z * m[9];\n\t\tres.z = x * m[2] + y * m[6] + z * m[10];\n\t\treturn res;\n\t}\n\ttransformVec4(vec, res = new Vec4()) {\n\t\tconst m = this.data;\n\t\tconst {\n\t\t\tx,\n\t\t\ty,\n\t\t\tz,\n\t\t\tw\n\t\t} = vec;\n\t\tres.x = x * m[0] + y * m[4] + z * m[8] + w * m[12];\n\t\tres.y = x * m[1] + y * m[5] + z * m[9] + w * m[13];\n\t\tres.z = x * m[2] + y * m[6] + z * m[10] + w * m[14];\n\t\tres.w = x * m[3] + y * m[7] + z * m[11] + w * m[15];\n\t\treturn res;\n\t}\n\tsetLookAt(position, target, up) {\n\t\tz.sub2(position, target).normalize();\n\t\ty.copy(up).normalize();\n\t\tx.cross(y, z).normalize();\n\t\ty.cross(z, x);\n\t\tconst r = this.data;\n\t\tr[0] = x.x;\n\t\tr[1] = x.y;\n\t\tr[2] = x.z;\n\t\tr[3] = 0;\n\t\tr[4] = y.x;\n\t\tr[5] = y.y;\n\t\tr[6] = y.z;\n\t\tr[7] = 0;\n\t\tr[8] = z.x;\n\t\tr[9] = z.y;\n\t\tr[10] = z.z;\n\t\tr[11] = 0;\n\t\tr[12] = position.x;\n\t\tr[13] = position.y;\n\t\tr[14] = position.z;\n\t\tr[15] = 1;\n\t\treturn this;\n\t}\n\tsetFrustum(left, right, bottom, top, znear, zfar) {\n\t\tconst temp1 = 2 * znear;\n\t\tconst temp2 = right - left;\n\t\tconst temp3 = top - bottom;\n\t\tconst temp4 = zfar - znear;\n\t\tconst r = this.data;\n\t\tr[0] = temp1 / temp2;\n\t\tr[1] = 0;\n\t\tr[2] = 0;\n\t\tr[3] = 0;\n\t\tr[4] = 0;\n\t\tr[5] = temp1 / temp3;\n\t\tr[6] = 0;\n\t\tr[7] = 0;\n\t\tr[8] = (right + left) / temp2;\n\t\tr[9] = (top + bottom) / temp3;\n\t\tr[10] = (-zfar - znear) / temp4;\n\t\tr[11] = -1;\n\t\tr[12] = 0;\n\t\tr[13] = 0;\n\t\tr[14] = -temp1 * zfar / temp4;\n\t\tr[15] = 0;\n\t\treturn this;\n\t}\n\tsetPerspective(fov, aspect, znear, zfar, fovIsHorizontal) {\n\t\tMat4._getPerspectiveHalfSize(_halfSize, fov, aspect, znear, fovIsHorizontal);\n\t\treturn this.setFrustum(-_halfSize.x, _halfSize.x, -_halfSize.y, _halfSize.y, znear, zfar);\n\t}\n\tsetOrtho(left, right, bottom, top, near, far) {\n\t\tconst r = this.data;\n\t\tr[0] = 2 / (right - left);\n\t\tr[1] = 0;\n\t\tr[2] = 0;\n\t\tr[3] = 0;\n\t\tr[4] = 0;\n\t\tr[5] = 2 / (top - bottom);\n\t\tr[6] = 0;\n\t\tr[7] = 0;\n\t\tr[8] = 0;\n\t\tr[9] = 0;\n\t\tr[10] = -2 / (far - near);\n\t\tr[11] = 0;\n\t\tr[12] = -(right + left) / (right - left);\n\t\tr[13] = -(top + bottom) / (top - bottom);\n\t\tr[14] = -(far + near) / (far - near);\n\t\tr[15] = 1;\n\t\treturn this;\n\t}\n\tsetFromAxisAngle(axis, angle) {\n\t\tangle *= math.DEG_TO_RAD;\n\t\tconst {\n\t\t\tx,\n\t\t\ty,\n\t\t\tz\n\t\t} = axis;\n\t\tconst c = Math.cos(angle);\n\t\tconst s = Math.sin(angle);\n\t\tconst t = 1 - c;\n\t\tconst tx = t * x;\n\t\tconst ty = t * y;\n\t\tconst m = this.data;\n\t\tm[0] = tx * x + c;\n\t\tm[1] = tx * y + s * z;\n\t\tm[2] = tx * z - s * y;\n\t\tm[3] = 0;\n\t\tm[4] = tx * y - s * z;\n\t\tm[5] = ty * y + c;\n\t\tm[6] = ty * z + s * x;\n\t\tm[7] = 0;\n\t\tm[8] = tx * z + s * y;\n\t\tm[9] = ty * z - x * s;\n\t\tm[10] = t * z * z + c;\n\t\tm[11] = 0;\n\t\tm[12] = 0;\n\t\tm[13] = 0;\n\t\tm[14] = 0;\n\t\tm[15] = 1;\n\t\treturn this;\n\t}\n\tsetTranslate(x, y, z) {\n\t\tconst m = this.data;\n\t\tm[0] = 1;\n\t\tm[1] = 0;\n\t\tm[2] = 0;\n\t\tm[3] = 0;\n\t\tm[4] = 0;\n\t\tm[5] = 1;\n\t\tm[6] = 0;\n\t\tm[7] = 0;\n\t\tm[8] = 0;\n\t\tm[9] = 0;\n\t\tm[10] = 1;\n\t\tm[11] = 0;\n\t\tm[12] = x;\n\t\tm[13] = y;\n\t\tm[14] = z;\n\t\tm[15] = 1;\n\t\treturn this;\n\t}\n\tsetScale(x, y, z) {\n\t\tconst m = this.data;\n\t\tm[0] = x;\n\t\tm[1] = 0;\n\t\tm[2] = 0;\n\t\tm[3] = 0;\n\t\tm[4] = 0;\n\t\tm[5] = y;\n\t\tm[6] = 0;\n\t\tm[7] = 0;\n\t\tm[8] = 0;\n\t\tm[9] = 0;\n\t\tm[10] = z;\n\t\tm[11] = 0;\n\t\tm[12] = 0;\n\t\tm[13] = 0;\n\t\tm[14] = 0;\n\t\tm[15] = 1;\n\t\treturn this;\n\t}\n\tsetViewport(x, y, width, height) {\n\t\tconst m = this.data;\n\t\tm[0] = width * 0.5;\n\t\tm[1] = 0;\n\t\tm[2] = 0;\n\t\tm[3] = 0;\n\t\tm[4] = 0;\n\t\tm[5] = height * 0.5;\n\t\tm[6] = 0;\n\t\tm[7] = 0;\n\t\tm[8] = 0;\n\t\tm[9] = 0;\n\t\tm[10] = 0.5;\n\t\tm[11] = 0;\n\t\tm[12] = x + width * 0.5;\n\t\tm[13] = y + height * 0.5;\n\t\tm[14] = 0.5;\n\t\tm[15] = 1;\n\t\treturn this;\n\t}\n\tsetReflection(normal, distance) {\n\t\tconst a = normal.x;\n\t\tconst b = normal.y;\n\t\tconst c = normal.z;\n\t\tconst data = this.data;\n\t\tdata[0] = 1.0 - 2 * a * a;\n\t\tdata[1] = -2 * a * b;\n\t\tdata[2] = -2 * a * c;\n\t\tdata[3] = 0;\n\t\tdata[4] = -2 * a * b;\n\t\tdata[5] = 1.0 - 2 * b * b;\n\t\tdata[6] = -2 * b * c;\n\t\tdata[7] = 0;\n\t\tdata[8] = -2 * a * c;\n\t\tdata[9] = -2 * b * c;\n\t\tdata[10] = 1.0 - 2 * c * c;\n\t\tdata[11] = 0;\n\t\tdata[12] = -2 * a * distance;\n\t\tdata[13] = -2 * b * distance;\n\t\tdata[14] = -2 * c * distance;\n\t\tdata[15] = 1;\n\t\treturn this;\n\t}\n\tinvert(src = this) {\n\t\tconst s = src.data;\n\t\tconst a00 = s[0];\n\t\tconst a01 = s[1];\n\t\tconst a02 = s[2];\n\t\tconst a03 = s[3];\n\t\tconst a10 = s[4];\n\t\tconst a11 = s[5];\n\t\tconst a12 = s[6];\n\t\tconst a13 = s[7];\n\t\tconst a20 = s[8];\n\t\tconst a21 = s[9];\n\t\tconst a22 = s[10];\n\t\tconst a23 = s[11];\n\t\tconst a30 = s[12];\n\t\tconst a31 = s[13];\n\t\tconst a32 = s[14];\n\t\tconst a33 = s[15];\n\t\tconst b00 = a00 * a11 - a01 * a10;\n\t\tconst b01 = a00 * a12 - a02 * a10;\n\t\tconst b02 = a00 * a13 - a03 * a10;\n\t\tconst b03 = a01 * a12 - a02 * a11;\n\t\tconst b04 = a01 * a13 - a03 * a11;\n\t\tconst b05 = a02 * a13 - a03 * a12;\n\t\tconst b06 = a20 * a31 - a21 * a30;\n\t\tconst b07 = a20 * a32 - a22 * a30;\n\t\tconst b08 = a20 * a33 - a23 * a30;\n\t\tconst b09 = a21 * a32 - a22 * a31;\n\t\tconst b10 = a21 * a33 - a23 * a31;\n\t\tconst b11 = a22 * a33 - a23 * a32;\n\t\tconst det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\t\tif (det === 0) {\n\t\t\tthis.setIdentity();\n\t\t} else {\n\t\t\tconst invDet = 1 / det;\n\t\t\tconst t = this.data;\n\t\t\tt[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;\n\t\t\tt[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;\n\t\t\tt[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;\n\t\t\tt[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;\n\t\t\tt[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;\n\t\t\tt[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;\n\t\t\tt[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;\n\t\t\tt[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;\n\t\t\tt[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;\n\t\t\tt[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;\n\t\t\tt[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;\n\t\t\tt[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;\n\t\t\tt[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;\n\t\t\tt[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;\n\t\t\tt[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;\n\t\t\tt[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;\n\t\t}\n\t\treturn this;\n\t}\n\tset(src) {\n\t\tconst dst = this.data;\n\t\tdst[0] = src[0];\n\t\tdst[1] = src[1];\n\t\tdst[2] = src[2];\n\t\tdst[3] = src[3];\n\t\tdst[4] = src[4];\n\t\tdst[5] = src[5];\n\t\tdst[6] = src[6];\n\t\tdst[7] = src[7];\n\t\tdst[8] = src[8];\n\t\tdst[9] = src[9];\n\t\tdst[10] = src[10];\n\t\tdst[11] = src[11];\n\t\tdst[12] = src[12];\n\t\tdst[13] = src[13];\n\t\tdst[14] = src[14];\n\t\tdst[15] = src[15];\n\t\treturn this;\n\t}\n\tsetIdentity() {\n\t\tconst m = this.data;\n\t\tm[0] = 1;\n\t\tm[1] = 0;\n\t\tm[2] = 0;\n\t\tm[3] = 0;\n\t\tm[4] = 0;\n\t\tm[5] = 1;\n\t\tm[6] = 0;\n\t\tm[7] = 0;\n\t\tm[8] = 0;\n\t\tm[9] = 0;\n\t\tm[10] = 1;\n\t\tm[11] = 0;\n\t\tm[12] = 0;\n\t\tm[13] = 0;\n\t\tm[14] = 0;\n\t\tm[15] = 1;\n\t\treturn this;\n\t}\n\tsetTRS(t, r, s) {\n\t\tconst qx = r.x;\n\t\tconst qy = r.y;\n\t\tconst qz = r.z;\n\t\tconst qw = r.w;\n\t\tconst sx = s.x;\n\t\tconst sy = s.y;\n\t\tconst sz = s.z;\n\t\tconst x2 = qx + qx;\n\t\tconst y2 = qy + qy;\n\t\tconst z2 = qz + qz;\n\t\tconst xx = qx * x2;\n\t\tconst xy = qx * y2;\n\t\tconst xz = qx * z2;\n\t\tconst yy = qy * y2;\n\t\tconst yz = qy * z2;\n\t\tconst zz = qz * z2;\n\t\tconst wx = qw * x2;\n\t\tconst wy = qw * y2;\n\t\tconst wz = qw * z2;\n\t\tconst m = this.data;\n\t\tm[0] = (1 - (yy + zz)) * sx;\n\t\tm[1] = (xy + wz) * sx;\n\t\tm[2] = (xz - wy) * sx;\n\t\tm[3] = 0;\n\t\tm[4] = (xy - wz) * sy;\n\t\tm[5] = (1 - (xx + zz)) * sy;\n\t\tm[6] = (yz + wx) * sy;\n\t\tm[7] = 0;\n\t\tm[8] = (xz + wy) * sz;\n\t\tm[9] = (yz - wx) * sz;\n\t\tm[10] = (1 - (xx + yy)) * sz;\n\t\tm[11] = 0;\n\t\tm[12] = t.x;\n\t\tm[13] = t.y;\n\t\tm[14] = t.z;\n\t\tm[15] = 1;\n\t\treturn this;\n\t}\n\ttranspose(src = this) {\n\t\tconst s = src.data;\n\t\tconst t = this.data;\n\t\tif (s === t) {\n\t\t\tlet tmp;\n\t\t\ttmp = s[1];\n\t\t\tt[1] = s[4];\n\t\t\tt[4] = tmp;\n\t\t\ttmp = s[2];\n\t\t\tt[2] = s[8];\n\t\t\tt[8] = tmp;\n\t\t\ttmp = s[3];\n\t\t\tt[3] = s[12];\n\t\t\tt[12] = tmp;\n\t\t\ttmp = s[6];\n\t\t\tt[6] = s[9];\n\t\t\tt[9] = tmp;\n\t\t\ttmp = s[7];\n\t\t\tt[7] = s[13];\n\t\t\tt[13] = tmp;\n\t\t\ttmp = s[11];\n\t\t\tt[11] = s[14];\n\t\t\tt[14] = tmp;\n\t\t} else {\n\t\t\tt[0] = s[0];\n\t\t\tt[1] = s[4];\n\t\t\tt[2] = s[8];\n\t\t\tt[3] = s[12];\n\t\t\tt[4] = s[1];\n\t\t\tt[5] = s[5];\n\t\t\tt[6] = s[9];\n\t\t\tt[7] = s[13];\n\t\t\tt[8] = s[2];\n\t\t\tt[9] = s[6];\n\t\t\tt[10] = s[10];\n\t\t\tt[11] = s[14];\n\t\t\tt[12] = s[3];\n\t\t\tt[13] = s[7];\n\t\t\tt[14] = s[11];\n\t\t\tt[15] = s[15];\n\t\t}\n\t\treturn this;\n\t}\n\tgetTranslation(t = new Vec3()) {\n\t\treturn t.set(this.data[12], this.data[13], this.data[14]);\n\t}\n\tgetX(x = new Vec3()) {\n\t\treturn x.set(this.data[0], this.data[1], this.data[2]);\n\t}\n\tgetY(y = new Vec3()) {\n\t\treturn y.set(this.data[4], this.data[5], this.data[6]);\n\t}\n\tgetZ(z = new Vec3()) {\n\t\treturn z.set(this.data[8], this.data[9], this.data[10]);\n\t}\n\tgetScale(scale = new Vec3()) {\n\t\tthis.getX(x);\n\t\tthis.getY(y);\n\t\tthis.getZ(z);\n\t\tscale.set(x.length(), y.length(), z.length());\n\t\treturn scale;\n\t}\n\tget scaleSign() {\n\t\tthis.getX(x);\n\t\tthis.getY(y);\n\t\tthis.getZ(z);\n\t\tx.cross(x, y);\n\t\treturn x.dot(z) < 0 ? -1 : 1;\n\t}\n\tsetFromEulerAngles(ex, ey, ez) {\n\t\tex *= math.DEG_TO_RAD;\n\t\tey *= math.DEG_TO_RAD;\n\t\tez *= math.DEG_TO_RAD;\n\t\tconst s1 = Math.sin(-ex);\n\t\tconst c1 = Math.cos(-ex);\n\t\tconst s2 = Math.sin(-ey);\n\t\tconst c2 = Math.cos(-ey);\n\t\tconst s3 = Math.sin(-ez);\n\t\tconst c3 = Math.cos(-ez);\n\t\tconst m = this.data;\n\t\tm[0] = c2 * c3;\n\t\tm[1] = -c2 * s3;\n\t\tm[2] = s2;\n\t\tm[3] = 0;\n\t\tm[4] = c1 * s3 + c3 * s1 * s2;\n\t\tm[5] = c1 * c3 - s1 * s2 * s3;\n\t\tm[6] = -c2 * s1;\n\t\tm[7] = 0;\n\t\tm[8] = s1 * s3 - c1 * c3 * s2;\n\t\tm[9] = c3 * s1 + c1 * s2 * s3;\n\t\tm[10] = c1 * c2;\n\t\tm[11] = 0;\n\t\tm[12] = 0;\n\t\tm[13] = 0;\n\t\tm[14] = 0;\n\t\tm[15] = 1;\n\t\treturn this;\n\t}\n\tgetEulerAngles(eulers = new Vec3()) {\n\t\tthis.getScale(scale);\n\t\tconst sx = scale.x;\n\t\tconst sy = scale.y;\n\t\tconst sz = scale.z;\n\t\tif (sx === 0 || sy === 0 || sz === 0) {\n\t\t\treturn eulers.set(0, 0, 0);\n\t\t}\n\t\tconst m = this.data;\n\t\tconst y = Math.asin(-m[2] / sx);\n\t\tconst halfPi = Math.PI * 0.5;\n\t\tlet x, z;\n\t\tif (y < halfPi) {\n\t\t\tif (y > -halfPi) {\n\t\t\t\tx = Math.atan2(m[6] / sy, m[10] / sz);\n\t\t\t\tz = Math.atan2(m[1] / sx, m[0] / sx);\n\t\t\t} else {\n\t\t\t\tz = 0;\n\t\t\t\tx = -Math.atan2(m[4] / sy, m[5] / sy);\n\t\t\t}\n\t\t} else {\n\t\t\tz = 0;\n\t\t\tx = Math.atan2(m[4] / sy, m[5] / sy);\n\t\t}\n\t\treturn eulers.set(x, y, z).mulScalar(math.RAD_TO_DEG);\n\t}\n\ttoString() {\n\t\treturn `[${this.data.join(', ')}]`;\n\t}\n}\n_Mat = Mat4;\nMat4.IDENTITY = Object.freeze(new _Mat());\nMat4.ZERO = Object.freeze(new _Mat().set([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]));\n\nexport { Mat4 };\n","const math = {\n\tDEG_TO_RAD: Math.PI / 180,\n\tRAD_TO_DEG: 180 / Math.PI,\n\tclamp(value, min, max) {\n\t\tif (value >= max) return max;\n\t\tif (value <= min) return min;\n\t\treturn value;\n\t},\n\tintToBytes24(i) {\n\t\tconst r = i >> 16 & 0xff;\n\t\tconst g = i >> 8 & 0xff;\n\t\tconst b = i & 0xff;\n\t\treturn [r, g, b];\n\t},\n\tintToBytes32(i) {\n\t\tconst r = i >> 24 & 0xff;\n\t\tconst g = i >> 16 & 0xff;\n\t\tconst b = i >> 8 & 0xff;\n\t\tconst a = i & 0xff;\n\t\treturn [r, g, b, a];\n\t},\n\tbytesToInt24(r, g, b) {\n\t\tif (r.length) {\n\t\t\tb = r[2];\n\t\t\tg = r[1];\n\t\t\tr = r[0];\n\t\t}\n\t\treturn r << 16 | g << 8 | b;\n\t},\n\tbytesToInt32(r, g, b, a) {\n\t\tif (r.length) {\n\t\t\ta = r[3];\n\t\t\tb = r[2];\n\t\t\tg = r[1];\n\t\t\tr = r[0];\n\t\t}\n\t\treturn (r << 24 | g << 16 | b << 8 | a) >>> 0;\n\t},\n\tlerp(a, b, alpha) {\n\t\treturn a + (b - a) * math.clamp(alpha, 0, 1);\n\t},\n\tlerpAngle(a, b, alpha) {\n\t\tif (b - a > 180) {\n\t\t\tb -= 360;\n\t\t}\n\t\tif (b - a < -180) {\n\t\t\tb += 360;\n\t\t}\n\t\treturn math.lerp(a, b, math.clamp(alpha, 0, 1));\n\t},\n\tpowerOfTwo(x) {\n\t\treturn x !== 0 && !(x & x - 1);\n\t},\n\tnextPowerOfTwo(val) {\n\t\tval--;\n\t\tval |= val >> 1;\n\t\tval |= val >> 2;\n\t\tval |= val >> 4;\n\t\tval |= val >> 8;\n\t\tval |= val >> 16;\n\t\tval++;\n\t\treturn val;\n\t},\n\tnearestPowerOfTwo(val) {\n\t\treturn Math.pow(2, Math.round(Math.log(val) / Math.log(2)));\n\t},\n\trandom(min, max) {\n\t\tconst diff = max - min;\n\t\treturn Math.random() * diff + min;\n\t},\n\tsmoothstep(min, max, x) {\n\t\tif (x <= min) return 0;\n\t\tif (x >= max) return 1;\n\t\tx = (x - min) / (max - min);\n\t\treturn x * x * (3 - 2 * x);\n\t},\n\tsmootherstep(min, max, x) {\n\t\tif (x <= min) return 0;\n\t\tif (x >= max) return 1;\n\t\tx = (x - min) / (max - min);\n\t\treturn x * x * x * (x * (x * 6 - 15) + 10);\n\t},\n\troundUp(numToRound, multiple) {\n\t\tif (multiple === 0) {\n\t\t\treturn numToRound;\n\t\t}\n\t\treturn Math.ceil(numToRound / multiple) * multiple;\n\t},\n\tbetween(num, a, b, inclusive) {\n\t\tconst min = Math.min(a, b);\n\t\tconst max = Math.max(a, b);\n\t\treturn inclusive ? num >= min && num <= max : num > min && num < max;\n\t}\n};\n\nexport { math };\n","import { math } from './math.js';\nimport { Vec3 } from './vec3.js';\n\nvar _Quat;\nclass Quat {\n\tconstructor(x = 0, y = 0, z = 0, w = 1) {\n\t\tthis.x = void 0;\n\t\tthis.y = void 0;\n\t\tthis.z = void 0;\n\t\tthis.w = void 0;\n\t\tif (x.length === 4) {\n\t\t\tthis.x = x[0];\n\t\t\tthis.y = x[1];\n\t\t\tthis.z = x[2];\n\t\t\tthis.w = x[3];\n\t\t} else {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\tclone() {\n\t\tconst cstr = this.constructor;\n\t\treturn new cstr(this.x, this.y, this.z, this.w);\n\t}\n\tconjugate(src = this) {\n\t\tthis.x = src.x * -1;\n\t\tthis.y = src.y * -1;\n\t\tthis.z = src.z * -1;\n\t\tthis.w = src.w;\n\t\treturn this;\n\t}\n\tcopy(rhs) {\n\t\tthis.x = rhs.x;\n\t\tthis.y = rhs.y;\n\t\tthis.z = rhs.z;\n\t\tthis.w = rhs.w;\n\t\treturn this;\n\t}\n\tequals(rhs) {\n\t\treturn this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;\n\t}\n\tequalsApprox(rhs, epsilon = 1e-6) {\n\t\treturn Math.abs(this.x - rhs.x) < epsilon && Math.abs(this.y - rhs.y) < epsilon && Math.abs(this.z - rhs.z) < epsilon && Math.abs(this.w - rhs.w) < epsilon;\n\t}\n\tgetAxisAngle(axis) {\n\t\tlet rad = Math.acos(this.w) * 2;\n\t\tconst s = Math.sin(rad / 2);\n\t\tif (s !== 0) {\n\t\t\taxis.x = this.x / s;\n\t\t\taxis.y = this.y / s;\n\t\t\taxis.z = this.z / s;\n\t\t\tif (axis.x < 0 || axis.y < 0 || axis.z < 0) {\n\t\t\t\taxis.x *= -1;\n\t\t\t\taxis.y *= -1;\n\t\t\t\taxis.z *= -1;\n\t\t\t\trad *= -1;\n\t\t\t}\n\t\t} else {\n\t\t\taxis.x = 1;\n\t\t\taxis.y = 0;\n\t\t\taxis.z = 0;\n\t\t}\n\t\treturn rad * math.RAD_TO_DEG;\n\t}\n\tgetEulerAngles(eulers = new Vec3()) {\n\t\tlet x, y, z;\n\t\tconst qx = this.x;\n\t\tconst qy = this.y;\n\t\tconst qz = this.z;\n\t\tconst qw = this.w;\n\t\tconst a2 = 2 * (qw * qy - qx * qz);\n\t\tif (a2 <= -0.99999) {\n\t\t\tx = 2 * Math.atan2(qx, qw);\n\t\t\ty = -Math.PI / 2;\n\t\t\tz = 0;\n\t\t} else if (a2 >= 0.99999) {\n\t\t\tx = 2 * Math.atan2(qx, qw);\n\t\t\ty = Math.PI / 2;\n\t\t\tz = 0;\n\t\t} else {\n\t\t\tx = Math.atan2(2 * (qw * qx + qy * qz), 1 - 2 * (qx * qx + qy * qy));\n\t\t\ty = Math.asin(a2);\n\t\t\tz = Math.atan2(2 * (qw * qz + qx * qy), 1 - 2 * (qy * qy + qz * qz));\n\t\t}\n\t\treturn eulers.set(x, y, z).mulScalar(math.RAD_TO_DEG);\n\t}\n\tinvert(src = this) {\n\t\treturn this.conjugate(src).normalize();\n\t}\n\tlength() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n\t}\n\tlengthSq() {\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\t}\n\tmul(rhs) {\n\t\tconst q1x = this.x;\n\t\tconst q1y = this.y;\n\t\tconst q1z = this.z;\n\t\tconst q1w = this.w;\n\t\tconst q2x = rhs.x;\n\t\tconst q2y = rhs.y;\n\t\tconst q2z = rhs.z;\n\t\tconst q2w = rhs.w;\n\t\tthis.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;\n\t\tthis.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;\n\t\tthis.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;\n\t\tthis.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;\n\t\treturn this;\n\t}\n\tmulScalar(scalar, src = this) {\n\t\tthis.x = src.x * scalar;\n\t\tthis.y = src.y * scalar;\n\t\tthis.z = src.z * scalar;\n\t\tthis.w = src.w * scalar;\n\t\treturn this;\n\t}\n\tmul2(lhs, rhs) {\n\t\tconst q1x = lhs.x;\n\t\tconst q1y = lhs.y;\n\t\tconst q1z = lhs.z;\n\t\tconst q1w = lhs.w;\n\t\tconst q2x = rhs.x;\n\t\tconst q2y = rhs.y;\n\t\tconst q2z = rhs.z;\n\t\tconst q2w = rhs.w;\n\t\tthis.x = q1w * q2x + q1x * q2w + q1y * q2z - q1z * q2y;\n\t\tthis.y = q1w * q2y + q1y * q2w + q1z * q2x - q1x * q2z;\n\t\tthis.z = q1w * q2z + q1z * q2w + q1x * q2y - q1y * q2x;\n\t\tthis.w = q1w * q2w - q1x * q2x - q1y * q2y - q1z * q2z;\n\t\treturn this;\n\t}\n\tnormalize(src = this) {\n\t\tlet len = src.length();\n\t\tif (len === 0) {\n\t\t\tthis.x = this.y = this.z = 0;\n\t\t\tthis.w = 1;\n\t\t} else {\n\t\t\tlen = 1 / len;\n\t\t\tthis.x = src.x * len;\n\t\t\tthis.y = src.y * len;\n\t\t\tthis.z = src.z * len;\n\t\t\tthis.w = src.w * len;\n\t\t}\n\t\treturn this;\n\t}\n\tset(x, y, z, w) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\t\treturn this;\n\t}\n\tsetFromAxisAngle(axis, angle) {\n\t\tangle *= 0.5 * math.DEG_TO_RAD;\n\t\tconst sa = Math.sin(angle);\n\t\tconst ca = Math.cos(angle);\n\t\tthis.x = sa * axis.x;\n\t\tthis.y = sa * axis.y;\n\t\tthis.z = sa * axis.z;\n\t\tthis.w = ca;\n\t\treturn this;\n\t}\n\tsetFromEulerAngles(ex, ey, ez) {\n\t\tif (ex instanceof Vec3) {\n\t\t\tconst vec = ex;\n\t\t\tex = vec.x;\n\t\t\tey = vec.y;\n\t\t\tez = vec.z;\n\t\t}\n\t\tconst halfToRad = 0.5 * math.DEG_TO_RAD;\n\t\tex *= halfToRad;\n\t\tey *= halfToRad;\n\t\tez *= halfToRad;\n\t\tconst sx = Math.sin(ex);\n\t\tconst cx = Math.cos(ex);\n\t\tconst sy = Math.sin(ey);\n\t\tconst cy = Math.cos(ey);\n\t\tconst sz = Math.sin(ez);\n\t\tconst cz = Math.cos(ez);\n\t\tthis.x = sx * cy * cz - cx * sy * sz;\n\t\tthis.y = cx * sy * cz + sx * cy * sz;\n\t\tthis.z = cx * cy * sz - sx * sy * cz;\n\t\tthis.w = cx * cy * cz + sx * sy * sz;\n\t\treturn this;\n\t}\n\tsetFromMat4(m) {\n\t\tconst d = m.data;\n\t\tlet m00 = d[0];\n\t\tlet m01 = d[1];\n\t\tlet m02 = d[2];\n\t\tlet m10 = d[4];\n\t\tlet m11 = d[5];\n\t\tlet m12 = d[6];\n\t\tlet m20 = d[8];\n\t\tlet m21 = d[9];\n\t\tlet m22 = d[10];\n\t\tlet l;\n\t\tl = m00 * m00 + m01 * m01 + m02 * m02;\n\t\tif (l === 0) return this.set(0, 0, 0, 1);\n\t\tl = 1 / Math.sqrt(l);\n\t\tm00 *= l;\n\t\tm01 *= l;\n\t\tm02 *= l;\n\t\tl = m10 * m10 + m11 * m11 + m12 * m12;\n\t\tif (l === 0) return this.set(0, 0, 0, 1);\n\t\tl = 1 / Math.sqrt(l);\n\t\tm10 *= l;\n\t\tm11 *= l;\n\t\tm12 *= l;\n\t\tl = m20 * m20 + m21 * m21 + m22 * m22;\n\t\tif (l === 0) return this.set(0, 0, 0, 1);\n\t\tl = 1 / Math.sqrt(l);\n\t\tm20 *= l;\n\t\tm21 *= l;\n\t\tm22 *= l;\n\t\tif (m22 < 0) {\n\t\t\tif (m00 > m11) {\n\t\t\t\tthis.set(1 + m00 - m11 - m22, m01 + m10, m20 + m02, m12 - m21);\n\t\t\t} else {\n\t\t\t\tthis.set(m01 + m10, 1 - m00 + m11 - m22, m12 + m21, m20 - m02);\n\t\t\t}\n\t\t} else {\n\t\t\tif (m00 < -m11) {\n\t\t\t\tthis.set(m20 + m02, m12 + m21, 1 - m00 - m11 + m22, m01 - m10);\n\t\t\t} else {\n\t\t\t\tthis.set(m12 - m21, m20 - m02, m01 - m10, 1 + m00 + m11 + m22);\n\t\t\t}\n\t\t}\n\t\treturn this.mulScalar(1.0 / this.length());\n\t}\n\tsetFromDirections(from, to) {\n\t\tconst dotProduct = 1 + from.dot(to);\n\t\tif (dotProduct < Number.EPSILON) {\n\t\t\tif (Math.abs(from.x) > Math.abs(from.y)) {\n\t\t\t\tthis.x = -from.z;\n\t\t\t\tthis.y = 0;\n\t\t\t\tthis.z = from.x;\n\t\t\t\tthis.w = 0;\n\t\t\t} else {\n\t\t\t\tthis.x = 0;\n\t\t\t\tthis.y = -from.z;\n\t\t\t\tthis.z = from.y;\n\t\t\t\tthis.w = 0;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.x = from.y * to.z - from.z * to.y;\n\t\t\tthis.y = from.z * to.x - from.x * to.z;\n\t\t\tthis.z = from.x * to.y - from.y * to.x;\n\t\t\tthis.w = dotProduct;\n\t\t}\n\t\treturn this.normalize();\n\t}\n\tslerp(lhs, rhs, alpha) {\n\t\tconst lx = lhs.x;\n\t\tconst ly = lhs.y;\n\t\tconst lz = lhs.z;\n\t\tconst lw = lhs.w;\n\t\tlet rx = rhs.x;\n\t\tlet ry = rhs.y;\n\t\tlet rz = rhs.z;\n\t\tlet rw = rhs.w;\n\t\tlet cosHalfTheta = lw * rw + lx * rx + ly * ry + lz * rz;\n\t\tif (cosHalfTheta < 0) {\n\t\t\trw = -rw;\n\t\t\trx = -rx;\n\t\t\try = -ry;\n\t\t\trz = -rz;\n\t\t\tcosHalfTheta = -cosHalfTheta;\n\t\t}\n\t\tif (Math.abs(cosHalfTheta) >= 1) {\n\t\t\tthis.w = lw;\n\t\t\tthis.x = lx;\n\t\t\tthis.y = ly;\n\t\t\tthis.z = lz;\n\t\t\treturn this;\n\t\t}\n\t\tconst halfTheta = Math.acos(cosHalfTheta);\n\t\tconst sinHalfTheta = Math.sqrt(1 - cosHalfTheta * cosHalfTheta);\n\t\tif (Math.abs(sinHalfTheta) < 0.001) {\n\t\t\tthis.w = lw * 0.5 + rw * 0.5;\n\t\t\tthis.x = lx * 0.5 + rx * 0.5;\n\t\t\tthis.y = ly * 0.5 + ry * 0.5;\n\t\t\tthis.z = lz * 0.5 + rz * 0.5;\n\t\t\treturn this;\n\t\t}\n\t\tconst ratioA = Math.sin((1 - alpha) * halfTheta) / sinHalfTheta;\n\t\tconst ratioB = Math.sin(alpha * halfTheta) / sinHalfTheta;\n\t\tthis.w = lw * ratioA + rw * ratioB;\n\t\tthis.x = lx * ratioA + rx * ratioB;\n\t\tthis.y = ly * ratioA + ry * ratioB;\n\t\tthis.z = lz * ratioA + rz * ratioB;\n\t\treturn this;\n\t}\n\ttransformVector(vec, res = new Vec3()) {\n\t\tconst x = vec.x,\n\t\t\ty = vec.y,\n\t\t\tz = vec.z;\n\t\tconst qx = this.x,\n\t\t\tqy = this.y,\n\t\t\tqz = this.z,\n\t\t\tqw = this.w;\n\t\tconst ix = qw * x + qy * z - qz * y;\n\t\tconst iy = qw * y + qz * x - qx * z;\n\t\tconst iz = qw * z + qx * y - qy * x;\n\t\tconst iw = -qx * x - qy * y - qz * z;\n\t\tres.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n\t\tres.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n\t\tres.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\t\treturn res;\n\t}\n\ttoString() {\n\t\treturn `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;\n\t}\n}\n_Quat = Quat;\nQuat.IDENTITY = Object.freeze(new _Quat(0, 0, 0, 1));\nQuat.ZERO = Object.freeze(new _Quat(0, 0, 0, 0));\n\nexport { Quat };\n","import { math } from './math.js';\n\nconst _goldenAngle = 2.399963229728653;\nconst random = {\n\tcirclePoint(point) {\n\t\tconst r = Math.sqrt(Math.random());\n\t\tconst theta = Math.random() * 2 * Math.PI;\n\t\tpoint.x = r * Math.cos(theta);\n\t\tpoint.y = r * Math.sin(theta);\n\t},\n\tcirclePointDeterministic(point, index, numPoints) {\n\t\tconst theta = index * _goldenAngle;\n\t\tconst r = Math.sqrt(index) / Math.sqrt(numPoints);\n\t\tpoint.x = r * Math.cos(theta);\n\t\tpoint.y = r * Math.sin(theta);\n\t},\n\tspherePointDeterministic(point, index, numPoints, start = 0, end = 1) {\n\t\tstart = 1 - 2 * start;\n\t\tend = 1 - 2 * end;\n\t\tconst y = math.lerp(start, end, index / numPoints);\n\t\tconst radius = Math.sqrt(1 - y * y);\n\t\tconst theta = _goldenAngle * index;\n\t\tpoint.x = Math.cos(theta) * radius;\n\t\tpoint.y = y;\n\t\tpoint.z = Math.sin(theta) * radius;\n\t},\n\tradicalInverse(i) {\n\t\tlet bits = (i << 16 | i >>> 16) >>> 0;\n\t\tbits = ((bits & 0x55555555) << 1 | (bits & 0xAAAAAAAA) >>> 1) >>> 0;\n\t\tbits = ((bits & 0x33333333) << 2 | (bits & 0xCCCCCCCC) >>> 2) >>> 0;\n\t\tbits = ((bits & 0x0F0F0F0F) << 4 | (bits & 0xF0F0F0F0) >>> 4) >>> 0;\n\t\tbits = ((bits & 0x00FF00FF) << 8 | (bits & 0xFF00FF00) >>> 8) >>> 0;\n\t\treturn bits * 2.3283064365386963e-10;\n\t}\n};\n\nexport { random };\n","import { math } from './math.js';\n\nvar _Vec;\nclass Vec2 {\n\tconstructor(x = 0, y = 0) {\n\t\tthis.x = void 0;\n\t\tthis.y = void 0;\n\t\tif (x.length === 2) {\n\t\t\tthis.x = x[0];\n\t\t\tthis.y = x[1];\n\t\t} else {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\tadd(rhs) {\n\t\tthis.x += rhs.x;\n\t\tthis.y += rhs.y;\n\t\treturn this;\n\t}\n\tadd2(lhs, rhs) {\n\t\tthis.x = lhs.x + rhs.x;\n\t\tthis.y = lhs.y + rhs.y;\n\t\treturn this;\n\t}\n\taddScalar(scalar) {\n\t\tthis.x += scalar;\n\t\tthis.y += scalar;\n\t\treturn this;\n\t}\n\taddScaled(rhs, scalar) {\n\t\tthis.x += rhs.x * scalar;\n\t\tthis.y += rhs.y * scalar;\n\t\treturn this;\n\t}\n\tclone() {\n\t\tconst cstr = this.constructor;\n\t\treturn new cstr(this.x, this.y);\n\t}\n\tcopy(rhs) {\n\t\tthis.x = rhs.x;\n\t\tthis.y = rhs.y;\n\t\treturn this;\n\t}\n\tcross(rhs) {\n\t\treturn this.x * rhs.y - this.y * rhs.x;\n\t}\n\tdistance(rhs) {\n\t\tconst x = this.x - rhs.x;\n\t\tconst y = this.y - rhs.y;\n\t\treturn Math.sqrt(x * x + y * y);\n\t}\n\tdiv(rhs) {\n\t\tthis.x /= rhs.x;\n\t\tthis.y /= rhs.y;\n\t\treturn this;\n\t}\n\tdiv2(lhs, rhs) {\n\t\tthis.x = lhs.x / rhs.x;\n\t\tthis.y = lhs.y / rhs.y;\n\t\treturn this;\n\t}\n\tdivScalar(scalar) {\n\t\tthis.x /= scalar;\n\t\tthis.y /= scalar;\n\t\treturn this;\n\t}\n\tdot(rhs) {\n\t\treturn this.x * rhs.x + this.y * rhs.y;\n\t}\n\tequals(rhs) {\n\t\treturn this.x === rhs.x && this.y === rhs.y;\n\t}\n\tequalsApprox(rhs, epsilon = 1e-6) {\n\t\treturn Math.abs(this.x - rhs.x) < epsilon && Math.abs(this.y - rhs.y) < epsilon;\n\t}\n\tlength() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\n\t}\n\tlengthSq() {\n\t\treturn this.x * this.x + this.y * this.y;\n\t}\n\tlerp(lhs, rhs, alpha) {\n\t\tthis.x = lhs.x + alpha * (rhs.x - lhs.x);\n\t\tthis.y = lhs.y + alpha * (rhs.y - lhs.y);\n\t\treturn this;\n\t}\n\tmul(rhs) {\n\t\tthis.x *= rhs.x;\n\t\tthis.y *= rhs.y;\n\t\treturn this;\n\t}\n\tmul2(lhs, rhs) {\n\t\tthis.x = lhs.x * rhs.x;\n\t\tthis.y = lhs.y * rhs.y;\n\t\treturn this;\n\t}\n\tmulScalar(scalar) {\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\treturn this;\n\t}\n\tnormalize(src = this) {\n\t\tconst lengthSq = src.x * src.x + src.y * src.y;\n\t\tif (lengthSq > 0) {\n\t\t\tconst invLength = 1 / Math.sqrt(lengthSq);\n\t\t\tthis.x = src.x * invLength;\n\t\t\tthis.y = src.y * invLength;\n\t\t}\n\t\treturn this;\n\t}\n\trotate(degrees) {\n\t\tconst angle = Math.atan2(this.x, this.y) + degrees * math.DEG_TO_RAD;\n\t\tconst len = Math.sqrt(this.x * this.x + this.y * this.y);\n\t\tthis.x = Math.sin(angle) * len;\n\t\tthis.y = Math.cos(angle) * len;\n\t\treturn this;\n\t}\n\tangle() {\n\t\treturn Math.atan2(this.x, this.y) * math.RAD_TO_DEG;\n\t}\n\tangleTo(rhs) {\n\t\treturn Math.atan2(this.x * rhs.y + this.y * rhs.x, this.x * rhs.x + this.y * rhs.y) * math.RAD_TO_DEG;\n\t}\n\tfloor(src = this) {\n\t\tthis.x = Math.floor(src.x);\n\t\tthis.y = Math.floor(src.y);\n\t\treturn this;\n\t}\n\tceil(src = this) {\n\t\tthis.x = Math.ceil(src.x);\n\t\tthis.y = Math.ceil(src.y);\n\t\treturn this;\n\t}\n\tround(src = this) {\n\t\tthis.x = Math.round(src.x);\n\t\tthis.y = Math.round(src.y);\n\t\treturn this;\n\t}\n\tmin(rhs) {\n\t\tif (rhs.x < this.x) this.x = rhs.x;\n\t\tif (rhs.y < this.y) this.y = rhs.y;\n\t\treturn this;\n\t}\n\tmax(rhs) {\n\t\tif (rhs.x > this.x) this.x = rhs.x;\n\t\tif (rhs.y > this.y) this.y = rhs.y;\n\t\treturn this;\n\t}\n\tset(x, y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\treturn this;\n\t}\n\tsub(rhs) {\n\t\tthis.x -= rhs.x;\n\t\tthis.y -= rhs.y;\n\t\treturn this;\n\t}\n\tsub2(lhs, rhs) {\n\t\tthis.x = lhs.x - rhs.x;\n\t\tthis.y = lhs.y - rhs.y;\n\t\treturn this;\n\t}\n\tsubScalar(scalar) {\n\t\tthis.x -= scalar;\n\t\tthis.y -= scalar;\n\t\treturn this;\n\t}\n\tfromArray(arr, offset = 0) {\n\t\tvar _arr$offset, _arr;\n\t\tthis.x = (_arr$offset = arr[offset]) != null ? _arr$offset : this.x;\n\t\tthis.y = (_arr = arr[offset + 1]) != null ? _arr : this.y;\n\t\treturn this;\n\t}\n\ttoString() {\n\t\treturn `[${this.x}, ${this.y}]`;\n\t}\n\ttoArray(arr = [], offset = 0) {\n\t\tarr[offset] = this.x;\n\t\tarr[offset + 1] = this.y;\n\t\treturn arr;\n\t}\n\tstatic angleRad(lhs, rhs) {\n\t\treturn Math.atan2(lhs.x * rhs.y - lhs.y * rhs.x, lhs.x * rhs.x + lhs.y * rhs.y);\n\t}\n}\n_Vec = Vec2;\nVec2.ZERO = Object.freeze(new _Vec(0, 0));\nVec2.ONE = Object.freeze(new _Vec(1, 1));\nVec2.UP = Object.freeze(new _Vec(0, 1));\nVec2.DOWN = Object.freeze(new _Vec(0, -1));\nVec2.RIGHT = Object.freeze(new _Vec(1, 0));\nVec2.LEFT = Object.freeze(new _Vec(-1, 0));\n\nexport { Vec2 };\n","var _Vec;\nclass Vec3 {\n\tconstructor(x = 0, y = 0, z = 0) {\n\t\tthis.x = void 0;\n\t\tthis.y = void 0;\n\t\tthis.z = void 0;\n\t\tif (x.length === 3) {\n\t\t\tthis.x = x[0];\n\t\t\tthis.y = x[1];\n\t\t\tthis.z = x[2];\n\t\t} else {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\t}\n\tadd(rhs) {\n\t\tthis.x += rhs.x;\n\t\tthis.y += rhs.y;\n\t\tthis.z += rhs.z;\n\t\treturn this;\n\t}\n\tadd2(lhs, rhs) {\n\t\tthis.x = lhs.x + rhs.x;\n\t\tthis.y = lhs.y + rhs.y;\n\t\tthis.z = lhs.z + rhs.z;\n\t\treturn this;\n\t}\n\taddScalar(scalar) {\n\t\tthis.x += scalar;\n\t\tthis.y += scalar;\n\t\tthis.z += scalar;\n\t\treturn this;\n\t}\n\taddScaled(rhs, scalar) {\n\t\tthis.x += rhs.x * scalar;\n\t\tthis.y += rhs.y * scalar;\n\t\tthis.z += rhs.z * scalar;\n\t\treturn this;\n\t}\n\tclone() {\n\t\tconst cstr = this.constructor;\n\t\treturn new cstr(this.x, this.y, this.z);\n\t}\n\tcopy(rhs) {\n\t\tthis.x = rhs.x;\n\t\tthis.y = rhs.y;\n\t\tthis.z = rhs.z;\n\t\treturn this;\n\t}\n\tcross(lhs, rhs) {\n\t\tconst lx = lhs.x;\n\t\tconst ly = lhs.y;\n\t\tconst lz = lhs.z;\n\t\tconst rx = rhs.x;\n\t\tconst ry = rhs.y;\n\t\tconst rz = rhs.z;\n\t\tthis.x = ly * rz - ry * lz;\n\t\tthis.y = lz * rx - rz * lx;\n\t\tthis.z = lx * ry - rx * ly;\n\t\treturn this;\n\t}\n\tdistance(rhs) {\n\t\tconst x = this.x - rhs.x;\n\t\tconst y = this.y - rhs.y;\n\t\tconst z = this.z - rhs.z;\n\t\treturn Math.sqrt(x * x + y * y + z * z);\n\t}\n\tdiv(rhs) {\n\t\tthis.x /= rhs.x;\n\t\tthis.y /= rhs.y;\n\t\tthis.z /= rhs.z;\n\t\treturn this;\n\t}\n\tdiv2(lhs, rhs) {\n\t\tthis.x = lhs.x / rhs.x;\n\t\tthis.y = lhs.y / rhs.y;\n\t\tthis.z = lhs.z / rhs.z;\n\t\treturn this;\n\t}\n\tdivScalar(scalar) {\n\t\tthis.x /= scalar;\n\t\tthis.y /= scalar;\n\t\tthis.z /= scalar;\n\t\treturn this;\n\t}\n\tdot(rhs) {\n\t\treturn this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;\n\t}\n\tequals(rhs) {\n\t\treturn this.x === rhs.x && this.y === rhs.y && this.z === rhs.z;\n\t}\n\tequalsApprox(rhs, epsilon = 1e-6) {\n\t\treturn Math.abs(this.x - rhs.x) < epsilon && Math.abs(this.y - rhs.y) < epsilon && Math.abs(this.z - rhs.z) < epsilon;\n\t}\n\tlength() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n\t}\n\tlengthSq() {\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\n\t}\n\tlerp(lhs, rhs, alpha) {\n\t\tthis.x = lhs.x + alpha * (rhs.x - lhs.x);\n\t\tthis.y = lhs.y + alpha * (rhs.y - lhs.y);\n\t\tthis.z = lhs.z + alpha * (rhs.z - lhs.z);\n\t\treturn this;\n\t}\n\tmul(rhs) {\n\t\tthis.x *= rhs.x;\n\t\tthis.y *= rhs.y;\n\t\tthis.z *= rhs.z;\n\t\treturn this;\n\t}\n\tmul2(lhs, rhs) {\n\t\tthis.x = lhs.x * rhs.x;\n\t\tthis.y = lhs.y * rhs.y;\n\t\tthis.z = lhs.z * rhs.z;\n\t\treturn this;\n\t}\n\tmulScalar(scalar) {\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\t\treturn this;\n\t}\n\tnormalize(src = this) {\n\t\tconst lengthSq = src.x * src.x + src.y * src.y + src.z * src.z;\n\t\tif (lengthSq > 0) {\n\t\t\tconst invLength = 1 / Math.sqrt(lengthSq);\n\t\t\tthis.x = src.x * invLength;\n\t\t\tthis.y = src.y * invLength;\n\t\t\tthis.z = src.z * invLength;\n\t\t}\n\t\treturn this;\n\t}\n\tfloor(src = this) {\n\t\tthis.x = Math.floor(src.x);\n\t\tthis.y = Math.floor(src.y);\n\t\tthis.z = Math.floor(src.z);\n\t\treturn this;\n\t}\n\tceil(src = this) {\n\t\tthis.x = Math.ceil(src.x);\n\t\tthis.y = Math.ceil(src.y);\n\t\tthis.z = Math.ceil(src.z);\n\t\treturn this;\n\t}\n\tround(src = this) {\n\t\tthis.x = Math.round(src.x);\n\t\tthis.y = Math.round(src.y);\n\t\tthis.z = Math.round(src.z);\n\t\treturn this;\n\t}\n\tmin(rhs) {\n\t\tif (rhs.x < this.x) this.x = rhs.x;\n\t\tif (rhs.y < this.y) this.y = rhs.y;\n\t\tif (rhs.z < this.z) this.z = rhs.z;\n\t\treturn this;\n\t}\n\tmax(rhs) {\n\t\tif (rhs.x > this.x) this.x = rhs.x;\n\t\tif (rhs.y > this.y) this.y = rhs.y;\n\t\tif (rhs.z > this.z) this.z = rhs.z;\n\t\treturn this;\n\t}\n\tproject(rhs) {\n\t\tconst a_dot_b = this.x * rhs.x + this.y * rhs.y + this.z * rhs.z;\n\t\tconst b_dot_b = rhs.x * rhs.x + rhs.y * rhs.y + rhs.z * rhs.z;\n\t\tconst s = a_dot_b / b_dot_b;\n\t\tthis.x = rhs.x * s;\n\t\tthis.y = rhs.y * s;\n\t\tthis.z = rhs.z * s;\n\t\treturn this;\n\t}\n\tset(x, y, z) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\treturn this;\n\t}\n\tsub(rhs) {\n\t\tthis.x -= rhs.x;\n\t\tthis.y -= rhs.y;\n\t\tthis.z -= rhs.z;\n\t\treturn this;\n\t}\n\tsub2(lhs, rhs) {\n\t\tthis.x = lhs.x - rhs.x;\n\t\tthis.y = lhs.y - rhs.y;\n\t\tthis.z = lhs.z - rhs.z;\n\t\treturn this;\n\t}\n\tsubScalar(scalar) {\n\t\tthis.x -= scalar;\n\t\tthis.y -= scalar;\n\t\tthis.z -= scalar;\n\t\treturn this;\n\t}\n\tfromArray(arr, offset = 0) {\n\t\tvar _arr$offset, _arr, _arr2;\n\t\tthis.x = (_arr$offset = arr[offset]) != null ? _arr$offset : this.x;\n\t\tthis.y = (_arr = arr[offset + 1]) != null ? _arr : this.y;\n\t\tthis.z = (_arr2 = arr[offset + 2]) != null ? _arr2 : this.z;\n\t\treturn this;\n\t}\n\ttoString() {\n\t\treturn `[${this.x}, ${this.y}, ${this.z}]`;\n\t}\n\ttoArray(arr = [], offset = 0) {\n\t\tarr[offset] = this.x;\n\t\tarr[offset + 1] = this.y;\n\t\tarr[offset + 2] = this.z;\n\t\treturn arr;\n\t}\n}\n_Vec = Vec3;\nVec3.ZERO = Object.freeze(new _Vec(0, 0, 0));\nVec3.ONE = Object.freeze(new _Vec(1, 1, 1));\nVec3.UP = Object.freeze(new _Vec(0, 1, 0));\nVec3.DOWN = Object.freeze(new _Vec(0, -1, 0));\nVec3.RIGHT = Object.freeze(new _Vec(1, 0, 0));\nVec3.LEFT = Object.freeze(new _Vec(-1, 0, 0));\nVec3.FORWARD = Object.freeze(new _Vec(0, 0, -1));\nVec3.BACK = Object.freeze(new _Vec(0, 0, 1));\n\nexport { Vec3 };\n","var _Vec;\nclass Vec4 {\n\tconstructor(x = 0, y = 0, z = 0, w = 0) {\n\t\tthis.x = void 0;\n\t\tthis.y = void 0;\n\t\tthis.z = void 0;\n\t\tthis.w = void 0;\n\t\tif (x.length === 4) {\n\t\t\tthis.x = x[0];\n\t\t\tthis.y = x[1];\n\t\t\tthis.z = x[2];\n\t\t\tthis.w = x[3];\n\t\t} else {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t\tthis.w = w;\n\t\t}\n\t}\n\tadd(rhs) {\n\t\tthis.x += rhs.x;\n\t\tthis.y += rhs.y;\n\t\tthis.z += rhs.z;\n\t\tthis.w += rhs.w;\n\t\treturn this;\n\t}\n\tadd2(lhs, rhs) {\n\t\tthis.x = lhs.x + rhs.x;\n\t\tthis.y = lhs.y + rhs.y;\n\t\tthis.z = lhs.z + rhs.z;\n\t\tthis.w = lhs.w + rhs.w;\n\t\treturn this;\n\t}\n\taddScalar(scalar) {\n\t\tthis.x += scalar;\n\t\tthis.y += scalar;\n\t\tthis.z += scalar;\n\t\tthis.w += scalar;\n\t\treturn this;\n\t}\n\taddScaled(rhs, scalar) {\n\t\tthis.x += rhs.x * scalar;\n\t\tthis.y += rhs.y * scalar;\n\t\tthis.z += rhs.z * scalar;\n\t\tthis.w += rhs.w * scalar;\n\t\treturn this;\n\t}\n\tclone() {\n\t\tconst cstr = this.constructor;\n\t\treturn new cstr(this.x, this.y, this.z, this.w);\n\t}\n\tcopy(rhs) {\n\t\tthis.x = rhs.x;\n\t\tthis.y = rhs.y;\n\t\tthis.z = rhs.z;\n\t\tthis.w = rhs.w;\n\t\treturn this;\n\t}\n\tdiv(rhs) {\n\t\tthis.x /= rhs.x;\n\t\tthis.y /= rhs.y;\n\t\tthis.z /= rhs.z;\n\t\tthis.w /= rhs.w;\n\t\treturn this;\n\t}\n\tdiv2(lhs, rhs) {\n\t\tthis.x = lhs.x / rhs.x;\n\t\tthis.y = lhs.y / rhs.y;\n\t\tthis.z = lhs.z / rhs.z;\n\t\tthis.w = lhs.w / rhs.w;\n\t\treturn this;\n\t}\n\tdivScalar(scalar) {\n\t\tthis.x /= scalar;\n\t\tthis.y /= scalar;\n\t\tthis.z /= scalar;\n\t\tthis.w /= scalar;\n\t\treturn this;\n\t}\n\tdot(rhs) {\n\t\treturn this.x * rhs.x + this.y * rhs.y + this.z * rhs.z + this.w * rhs.w;\n\t}\n\tequals(rhs) {\n\t\treturn this.x === rhs.x && this.y === rhs.y && this.z === rhs.z && this.w === rhs.w;\n\t}\n\tequalsApprox(rhs, epsilon = 1e-6) {\n\t\treturn Math.abs(this.x - rhs.x) < epsilon && Math.abs(this.y - rhs.y) < epsilon && Math.abs(this.z - rhs.z) < epsilon && Math.abs(this.w - rhs.w) < epsilon;\n\t}\n\tlength() {\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n\t}\n\tlengthSq() {\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n\t}\n\tlerp(lhs, rhs, alpha) {\n\t\tthis.x = lhs.x + alpha * (rhs.x - lhs.x);\n\t\tthis.y = lhs.y + alpha * (rhs.y - lhs.y);\n\t\tthis.z = lhs.z + alpha * (rhs.z - lhs.z);\n\t\tthis.w = lhs.w + alpha * (rhs.w - lhs.w);\n\t\treturn this;\n\t}\n\tmul(rhs) {\n\t\tthis.x *= rhs.x;\n\t\tthis.y *= rhs.y;\n\t\tthis.z *= rhs.z;\n\t\tthis.w *= rhs.w;\n\t\treturn this;\n\t}\n\tmul2(lhs, rhs) {\n\t\tthis.x = lhs.x * rhs.x;\n\t\tthis.y = lhs.y * rhs.y;\n\t\tthis.z = lhs.z * rhs.z;\n\t\tthis.w = lhs.w * rhs.w;\n\t\treturn this;\n\t}\n\tmulScalar(scalar) {\n\t\tthis.x *= scalar;\n\t\tthis.y *= scalar;\n\t\tthis.z *= scalar;\n\t\tthis.w *= scalar;\n\t\treturn this;\n\t}\n\tnormalize(src = this) {\n\t\tconst lengthSq = src.x * src.x + src.y * src.y + src.z * src.z + src.w * src.w;\n\t\tif (lengthSq > 0) {\n\t\t\tconst invLength = 1 / Math.sqrt(lengthSq);\n\t\t\tthis.x = src.x * invLength;\n\t\t\tthis.y = src.y * invLength;\n\t\t\tthis.z = src.z * invLength;\n\t\t\tthis.w = src.w * invLength;\n\t\t}\n\t\treturn this;\n\t}\n\tfloor(src = this) {\n\t\tthis.x = Math.floor(src.x);\n\t\tthis.y = Math.floor(src.y);\n\t\tthis.z = Math.floor(src.z);\n\t\tthis.w = Math.floor(src.w);\n\t\treturn this;\n\t}\n\tceil(src = this) {\n\t\tthis.x = Math.ceil(src.x);\n\t\tthis.y = Math.ceil(src.y);\n\t\tthis.z = Math.ceil(src.z);\n\t\tthis.w = Math.ceil(src.w);\n\t\treturn this;\n\t}\n\tround(src = this) {\n\t\tthis.x = Math.round(src.x);\n\t\tthis.y = Math.round(src.y);\n\t\tthis.z = Math.round(src.z);\n\t\tthis.w = Math.round(src.w);\n\t\treturn this;\n\t}\n\tmin(rhs) {\n\t\tif (rhs.x < this.x) this.x = rhs.x;\n\t\tif (rhs.y < this.y) this.y = rhs.y;\n\t\tif (rhs.z < this.z) this.z = rhs.z;\n\t\tif (rhs.w < this.w) this.w = rhs.w;\n\t\treturn this;\n\t}\n\tmax(rhs) {\n\t\tif (rhs.x > this.x) this.x = rhs.x;\n\t\tif (rhs.y > this.y) this.y = rhs.y;\n\t\tif (rhs.z > this.z) this.z = rhs.z;\n\t\tif (rhs.w > this.w) this.w = rhs.w;\n\t\treturn this;\n\t}\n\tset(x, y, z, w) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.z = z;\n\t\tthis.w = w;\n\t\treturn this;\n\t}\n\tsub(rhs) {\n\t\tthis.x -= rhs.x;\n\t\tthis.y -= rhs.y;\n\t\tthis.z -= rhs.z;\n\t\tthis.w -= rhs.w;\n\t\treturn this;\n\t}\n\tsub2(lhs, rhs) {\n\t\tthis.x = lhs.x - rhs.x;\n\t\tthis.y = lhs.y - rhs.y;\n\t\tthis.z = lhs.z - rhs.z;\n\t\tthis.w = lhs.w - rhs.w;\n\t\treturn this;\n\t}\n\tsubScalar(scalar) {\n\t\tthis.x -= scalar;\n\t\tthis.y -= scalar;\n\t\tthis.z -= scalar;\n\t\tthis.w -= scalar;\n\t\treturn this;\n\t}\n\tfromArray(arr, offset = 0) {\n\t\tvar _arr$offset, _arr, _arr2, _arr3;\n\t\tthis.x = (_arr$offset = arr[offset]) != null ? _arr$offset : this.x;\n\t\tthis.y = (_arr = arr[offset + 1]) != null ? _arr : this.y;\n\t\tthis.z = (_arr2 = arr[offset + 2]) != null ? _arr2 : this.z;\n\t\tthis.w = (_arr3 = arr[offset + 3]) != null ? _arr3 : this.w;\n\t\treturn this;\n\t}\n\ttoString() {\n\t\treturn `[${this.x}, ${this.y}, ${this.z}, ${this.w}]`;\n\t}\n\ttoArray(arr = [], offset = 0) {\n\t\tarr[offset] = this.x;\n\t\tarr[offset + 1] = this.y;\n\t\tarr[offset + 2] = this.z;\n\t\tarr[offset + 3] = this.w;\n\t\treturn arr;\n\t}\n}\n_Vec = Vec4;\nVec4.ZERO = Object.freeze(new _Vec(0, 0, 0, 0));\nVec4.ONE = Object.freeze(new _Vec(1, 1, 1, 1));\n\nexport { Vec4 };\n","class ObjectPool {\n\tconstructor(constructorFunc, size) {\n\t\tthis._constructor = void 0;\n\t\tthis._pool = [];\n\t\tthis._count = 0;\n\t\tthis._constructor = constructorFunc;\n\t\tthis._resize(size);\n\t}\n\t_resize(size) {\n\t\tif (size > this._pool.length) {\n\t\t\tfor (let i = this._pool.length; i < size; i++) {\n\t\t\t\tthis._pool[i] = new this._constructor();\n\t\t\t}\n\t\t}\n\t}\n\tallocate() {\n\t\tif (this._count >= this._pool.length) {\n\t\t\tthis._resize(this._pool.length * 2);\n\t\t}\n\t\treturn this._pool[this._count++];\n\t}\n\tfreeAll() {\n\t\tthis._count = 0;\n\t}\n}\n\nexport { ObjectPool };\n","const path = {\n\tdelimiter: '/',\n\tjoin(...sections) {\n\t\tlet result = sections[0];\n\t\tfor (let i = 0; i < sections.length - 1; i++) {\n\t\t\tconst one = sections[i];\n\t\t\tconst two = sections[i + 1];\n\t\t\tif (two[0] === path.delimiter) {\n\t\t\t\tresult = two;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (one && two && one[one.length - 1] !== path.delimiter && two[0] !== path.delimiter) {\n\t\t\t\tresult += path.delimiter + two;\n\t\t\t} else {\n\t\t\t\tresult += two;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t},\n\tnormalize(pathname) {\n\t\tconst lead = pathname.startsWith(path.delimiter);\n\t\tconst trail = pathname.endsWith(path.delimiter);\n\t\tconst parts = pathname.split('/');\n\t\tlet result = '';\n\t\tlet cleaned = [];\n\t\tfor (let i = 0; i < parts.length; i++) {\n\t\t\tif (parts[i] === '') continue;\n\t\t\tif (parts[i] === '.') continue;\n\t\t\tif (parts[i] === '..' && cleaned.length > 0) {\n\t\t\t\tcleaned = cleaned.slice(0, cleaned.length - 2);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (i > 0) cleaned.push(path.delimiter);\n\t\t\tcleaned.push(parts[i]);\n\t\t}\n\t\tresult = cleaned.join('');\n\t\tif (!lead && result[0] === path.delimiter) {\n\t\t\tresult = result.slice(1);\n\t\t}\n\t\tif (trail && result[result.length - 1] !== path.delimiter) {\n\t\t\tresult += path.delimiter;\n\t\t}\n\t\treturn result;\n\t},\n\tsplit(pathname) {\n\t\tconst lastDelimiterIndex = pathname.lastIndexOf(path.delimiter);\n\t\tif (lastDelimiterIndex !== -1) {\n\t\t\treturn [pathname.substring(0, lastDelimiterIndex), pathname.substring(lastDelimiterIndex + 1)];\n\t\t}\n\t\treturn ['', pathname];\n\t},\n\tgetBasename(pathname) {\n\t\treturn path.split(pathname)[1];\n\t},\n\tgetDirectory(pathname) {\n\t\treturn path.split(pathname)[0];\n\t},\n\tgetExtension(pathname) {\n\t\tconst ext = pathname.split('?')[0].split('.').pop();\n\t\tif (ext !== pathname) {\n\t\t\treturn `.${ext}`;\n\t\t}\n\t\treturn '';\n\t},\n\tisRelativePath(pathname) {\n\t\treturn pathname.charAt(0) !== '/' && pathname.match(/:\\/\\//) === null;\n\t},\n\textractPath(pathname) {\n\t\tlet result = '';\n\t\tconst parts = pathname.split('/');\n\t\tlet i = 0;\n\t\tif (parts.length > 1) {\n\t\t\tif (path.isRelativePath(pathname)) {\n\t\t\t\tif (parts[0] === '.') {\n\t\t\t\t\tfor (i = 0; i < parts.length - 1; ++i) {\n\t\t\t\t\t\tresult += i === 0 ? parts[i] : `/${parts[i]}`;\n\t\t\t\t\t}\n\t\t\t\t} else if (parts[0] === '..') {\n\t\t\t\t\tfor (i = 0; i < parts.length - 1; ++i) {\n\t\t\t\t\t\tresult += i === 0 ? parts[i] : `/${parts[i]}`;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresult = '.';\n\t\t\t\t\tfor (i = 0; i < parts.length - 1; ++i) {\n\t\t\t\t\t\tresult += `/${parts[i]}`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (i = 0; i < parts.length - 1; ++i) {\n\t\t\t\t\tresult += i === 0 ? parts[i] : `/${parts[i]}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n};\n\nexport { path };\n","var _ref, _ref2, _ref3;\nconst detectPassiveEvents = () => {\n\tlet result = false;\n\ttry {\n\t\tconst opts = Object.defineProperty({}, 'passive', {\n\t\t\tget: function () {\n\t\t\t\tresult = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\t\twindow.addEventListener('testpassive', null, opts);\n\t\twindow.removeEventListener('testpassive', null, opts);\n\t} catch (e) {}\n\treturn result;\n};\nconst ua = typeof navigator !== 'undefined' ? navigator.userAgent : '';\nconst environment = typeof window !== 'undefined' ? 'browser' : typeof global !== 'undefined' ? 'node' : 'worker';\nconst platformName = /android/i.test(ua) ? 'android' : /ip(?:[ao]d|hone)/i.test(ua) ? 'ios' : /windows/i.test(ua) ? 'windows' : /mac os/i.test(ua) ? 'osx' : /linux/i.test(ua) ? 'linux' : /cros/i.test(ua) ? 'cros' : null;\nconst browserName = environment !== 'browser' ? null : /Chrome\\/|Chromium\\/|Edg.*\\//.test(ua) ? 'chrome' : /Safari\\//.test(ua) ? 'safari' : /Firefox\\//.test(ua) ? 'firefox' : 'other';\nconst xbox = /xbox/i.test(ua);\nconst touch = environment === 'browser' && ('ontouchstart' in window || 'maxTouchPoints' in navigator && navigator.maxTouchPoints > 0);\nconst gamepads = environment === 'browser' && (!!navigator.getGamepads || !!navigator.webkitGetGamepads);\nconst workers = typeof Worker !== 'undefined';\nconst passiveEvents = detectPassiveEvents();\nconst platform = {\n\tname: platformName,\n\tenvironment: environment,\n\tglobal: (_ref = (_ref2 = (_ref3 = typeof globalThis !== 'undefined' && globalThis) != null ? _ref3 : environment === 'browser' && window) != null ? _ref2 : environment === 'node' && global) != null ? _ref : environment === 'worker' && self,\n\tbrowser: environment === 'browser',\n\tworker: environment === 'worker',\n\tdesktop: ['windows', 'osx', 'linux', 'cros'].includes(platformName),\n\tmobile: ['android', 'ios'].includes(platformName),\n\tios: platformName === 'ios',\n\tandroid: platformName === 'android',\n\txbox: xbox,\n\tgamepads: gamepads,\n\ttouch: touch,\n\tworkers: workers,\n\tpassiveEvents: passiveEvents,\n\tbrowserName: browserName\n};\n\nexport { platform };\n","const KEYWORD = /[ \\t]*#(ifn?def|if|endif|else|elif|define|undef|extension|include)/g;\nconst DEFINE = /define[ \\t]+([^\\n]+)\\r?(?:\\n|$)/g;\nconst EXTENSION = /extension[ \\t]+([\\w-]+)[ \\t]*:[ \\t]*(enable|require)/g;\nconst UNDEF = /undef[ \\t]+([^\\n]+)\\r?(?:\\n|$)/g;\nconst IF = /(ifdef|ifndef|if)[ \\t]*([^\\r\\n]+)\\r?\\n/g;\nconst ENDIF = /(endif|else|elif)([ \\t][^\\r\\n]+)?\\r?(?:\\n|$)/g;\nconst IDENTIFIER = /([\\w-]+)/;\nconst DEFINED = /(!|\\s)?defined\\(([\\w-]+)\\)/;\nconst INVALID = /[><=|&+-]/g;\nconst INCLUDE = /include[ \\t]+\"([\\w-]+)\"\\r?(?:\\n|$)/g;\nclass Preprocessor {\n\tstatic run(source, includes = new Map(), stripUnusedColorAttachments = false) {\n\t\tsource = source.replace(/\\/\\*[\\s\\S]*?\\*\\/|([^\\\\:]|^)\\/\\/.*$/gm, '$1');\n\t\tsource = source.split(/\\r?\\n/).map(line => line.trimEnd()).join('\\n');\n\t\tconst defines = new Map();\n\t\tif (stripUnusedColorAttachments) {\n\t\t\tconst counts = new Map();\n\t\t\tconst regex = /(pcFragColor[1-8])\\b/g;\n\t\t\tconst matches = source.match(regex);\n\t\t\tmatches == null || matches.forEach(match => {\n\t\t\t\tvar _counts$get;\n\t\t\t\tconst index = parseInt(match.charAt(match.length - 1), 10);\n\t\t\t\tcounts.set(index, ((_counts$get = counts.get(index)) != null ? _counts$get : 0) + 1);\n\t\t\t});\n\t\t\tcounts.forEach((count, index) => {\n\t\t\t\tif (count === 1) {\n\t\t\t\t\tdefines.set(`REMOVE_COLOR_ATTACHMENT_${index}`, '');\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tsource = this._preprocess(source, defines, includes);\n\t\tconst intDefines = new Map();\n\t\tdefines.forEach((value, key) => {\n\t\t\tif (Number.isInteger(parseFloat(value)) && !value.includes('.')) {\n\t\t\t\tintDefines.set(key, value);\n\t\t\t}\n\t\t});\n\t\tsource = this.RemoveEmptyLines(source);\n\t\tsource = this.processArraySize(source, intDefines);\n\t\treturn source;\n\t}\n\tstatic processArraySize(source, intDefines) {\n\t\tif (source !== null) {\n\t\t\tintDefines.forEach((value, key) => {\n\t\t\t\tsource = source.replace(new RegExp(`\\\\[${key}\\\\]`, 'g'), `[${value}]`);\n\t\t\t});\n\t\t}\n\t\treturn source;\n\t}\n\tstatic RemoveEmptyLines(source) {\n\t\tif (source !== null) {\n\t\t\tsource = source.split(/\\r?\\n/).map(line => line.trim() === '' ? '' : line).join('\\n');\n\t\t\tsource = source.replace(/(\\n\\n){3,}/g, '\\n\\n');\n\t\t}\n\t\treturn source;\n\t}\n\tstatic _preprocess(source, defines = new Map(), includes) {\n\t\tconst originalSource = source;\n\t\tconst stack = [];\n\t\tlet error = false;\n\t\tlet match;\n\t\twhile ((match = KEYWORD.exec(source)) !== null) {\n\t\t\tconst keyword = match[1];\n\t\t\tswitch (keyword) {\n\t\t\t\tcase 'define':\n\t\t\t\t\t{\n\t\t\t\t\t\tDEFINE.lastIndex = match.index;\n\t\t\t\t\t\tconst define = DEFINE.exec(source);\n\t\t\t\t\t\terror || (error = define === null);\n\t\t\t\t\t\tconst expression = define[1];\n\t\t\t\t\t\tIDENTIFIER.lastIndex = define.index;\n\t\t\t\t\t\tconst identifierValue = IDENTIFIER.exec(expression);\n\t\t\t\t\t\tconst identifier = identifierValue[1];\n\t\t\t\t\t\tlet value = expression.substring(identifier.length).trim();\n\t\t\t\t\t\tif (value === '') value = 'true';\n\t\t\t\t\t\tconst keep = Preprocessor._keep(stack);\n\t\t\t\t\t\tif (keep) {\n\t\t\t\t\t\t\tdefines.set(identifier, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tKEYWORD.lastIndex = define.index + define[0].length;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tcase 'undef':\n\t\t\t\t\t{\n\t\t\t\t\t\tUNDEF.lastIndex = match.index;\n\t\t\t\t\t\tconst undef = UNDEF.exec(source);\n\t\t\t\t\t\tconst identifier = undef[1].trim();\n\t\t\t\t\t\tconst keep = Preprocessor._keep(stack);\n\t\t\t\t\t\tif (keep) {\n\t\t\t\t\t\t\tdefines.delete(identifier);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tKEYWORD.lastIndex = undef.index + undef[0].length;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tcase 'extension':\n\t\t\t\t\t{\n\t\t\t\t\t\tEXTENSION.lastIndex = match.index;\n\t\t\t\t\t\tconst extension = EXTENSION.exec(source);\n\t\t\t\t\t\terror || (error = extension === null);\n\t\t\t\t\t\tif (extension) {\n\t\t\t\t\t\t\tconst identifier = extension[1];\n\t\t\t\t\t\t\tconst keep = Preprocessor._keep(stack);\n\t\t\t\t\t\t\tif (keep) {\n\t\t\t\t\t\t\t\tdefines.set(identifier, 'true');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tKEYWORD.lastIndex = extension.index + extension[0].length;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tcase 'ifdef':\n\t\t\t\tcase 'ifndef':\n\t\t\t\tcase 'if':\n\t\t\t\t\t{\n\t\t\t\t\t\tIF.lastIndex = match.index;\n\t\t\t\t\t\tconst iff = IF.exec(source);\n\t\t\t\t\t\tconst expression = iff[2];\n\t\t\t\t\t\tconst evaluated = Preprocessor.evaluate(expression, defines);\n\t\t\t\t\t\terror || (error = evaluated.error);\n\t\t\t\t\t\tlet result = evaluated.result;\n\t\t\t\t\t\tif (keyword === 'ifndef') {\n\t\t\t\t\t\t\tresult = !result;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstack.push({\n\t\t\t\t\t\t\tanyKeep: result,\n\t\t\t\t\t\t\tkeep: result,\n\t\t\t\t\t\t\tstart: match.index,\n\t\t\t\t\t\t\tend: IF.lastIndex\n\t\t\t\t\t\t});\n\t\t\t\t\t\tKEYWORD.lastIndex = iff.index + iff[0].length;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tcase 'endif':\n\t\t\t\tcase 'else':\n\t\t\t\tcase 'elif':\n\t\t\t\t\t{\n\t\t\t\t\t\tENDIF.lastIndex = match.index;\n\t\t\t\t\t\tconst endif = ENDIF.exec(source);\n\t\t\t\t\t\tconst blockInfo = stack.pop();\n\t\t\t\t\t\tconst blockCode = blockInfo.keep ? source.substring(blockInfo.end, match.index) : '';\n\t\t\t\t\t\tsource = source.substring(0, blockInfo.start) + blockCode + source.substring(ENDIF.lastIndex);\n\t\t\t\t\t\tKEYWORD.lastIndex = blockInfo.start + blockCode.length;\n\t\t\t\t\t\tconst endifCommand = endif[1];\n\t\t\t\t\t\tif (endifCommand === 'else' || endifCommand === 'elif') {\n\t\t\t\t\t\t\tlet result = false;\n\t\t\t\t\t\t\tif (!blockInfo.anyKeep) {\n\t\t\t\t\t\t\t\tif (endifCommand === 'else') {\n\t\t\t\t\t\t\t\t\tresult = !blockInfo.keep;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tconst evaluated = Preprocessor.evaluate(endif[2], defines);\n\t\t\t\t\t\t\t\t\tresult = evaluated.result;\n\t\t\t\t\t\t\t\t\terror || (error = evaluated.error);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstack.push({\n\t\t\t\t\t\t\t\tanyKeep: blockInfo.anyKeep || result,\n\t\t\t\t\t\t\t\tkeep: result,\n\t\t\t\t\t\t\t\tstart: KEYWORD.lastIndex,\n\t\t\t\t\t\t\t\tend: KEYWORD.lastIndex\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tcase 'include':\n\t\t\t\t\t{\n\t\t\t\t\t\tINCLUDE.lastIndex = match.index;\n\t\t\t\t\t\tconst include = INCLUDE.exec(source);\n\t\t\t\t\t\terror || (error = include === null);\n\t\t\t\t\t\tconst identifier = include[1].trim();\n\t\t\t\t\t\tconst keep = Preprocessor._keep(stack);\n\t\t\t\t\t\tif (keep) {\n\t\t\t\t\t\t\tconst includeSource = includes == null ? void 0 : includes.get(identifier);\n\t\t\t\t\t\t\tif (includeSource) {\n\t\t\t\t\t\t\t\tsource = source.substring(0, include.index - 1) + includeSource + source.substring(INCLUDE.lastIndex);\n\t\t\t\t\t\t\t\tKEYWORD.lastIndex = include.index;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconsole.error(`Include not found: ${identifier}`);\n\t\t\t\t\t\t\t\terror = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (error) {\n\t\t\tconsole.warn('Failed to preprocess shader: ', {\n\t\t\t\tsource: originalSource\n\t\t\t});\n\t\t\treturn originalSource;\n\t\t}\n\t\treturn source;\n\t}\n\tstatic _keep(stack) {\n\t\tfor (let i = 0; i < stack.length; i++) {\n\t\t\tif (!stack[i].keep) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tstatic evaluate(expression, defines) {\n\t\tconst correct = INVALID.exec(expression) === null;\n\t\tlet invert = false;\n\t\tconst defined = DEFINED.exec(expression);\n\t\tif (defined) {\n\t\t\tinvert = defined[1] === '!';\n\t\t\texpression = defined[2];\n\t\t}\n\t\texpression = expression.trim();\n\t\tlet exists = defines.has(expression);\n\t\tif (invert) {\n\t\t\texists = !exists;\n\t\t}\n\t\treturn {\n\t\t\tresult: exists,\n\t\t\terror: !correct\n\t\t};\n\t}\n}\n\nexport { Preprocessor };\n","class ReadStream {\n\tconstructor(arraybuffer) {\n\t\tthis.arraybuffer = void 0;\n\t\tthis.dataView = void 0;\n\t\tthis.offset = 0;\n\t\tthis.arraybuffer = arraybuffer;\n\t\tthis.dataView = new DataView(arraybuffer);\n\t}\n\tget remainingBytes() {\n\t\treturn this.dataView.byteLength - this.offset;\n\t}\n\treset(offset = 0) {\n\t\tthis.offset = offset;\n\t}\n\tskip(bytes) {\n\t\tthis.offset += bytes;\n\t}\n\talign(bytes) {\n\t\tthis.offset = this.offset + bytes - 1 & ~(bytes - 1);\n\t}\n\t_inc(amount) {\n\t\tthis.offset += amount;\n\t\treturn this.offset - amount;\n\t}\n\treadChar() {\n\t\treturn String.fromCharCode(this.dataView.getUint8(this.offset++));\n\t}\n\treadChars(numChars) {\n\t\tlet result = '';\n\t\tfor (let i = 0; i < numChars; ++i) {\n\t\t\tresult += this.readChar();\n\t\t}\n\t\treturn result;\n\t}\n\treadU8() {\n\t\treturn this.dataView.getUint8(this.offset++);\n\t}\n\treadU16() {\n\t\treturn this.dataView.getUint16(this._inc(2), true);\n\t}\n\treadU32() {\n\t\treturn this.dataView.getUint32(this._inc(4), true);\n\t}\n\treadU64() {\n\t\treturn this.readU32() + 2 ** 32 * this.readU32();\n\t}\n\treadU32be() {\n\t\treturn this.dataView.getUint32(this._inc(4), false);\n\t}\n\treadArray(result) {\n\t\tfor (let i = 0; i < result.length; ++i) {\n\t\t\tresult[i] = this.readU8();\n\t\t}\n\t}\n\treadLine() {\n\t\tconst view = this.dataView;\n\t\tlet result = '';\n\t\twhile (true) {\n\t\t\tif (this.offset >= view.byteLength) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst c = String.fromCharCode(this.readU8());\n\t\t\tif (c === '\\n') {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult += c;\n\t\t}\n\t\treturn result;\n\t}\n}\n\nexport { ReadStream };\n","class RefCountedCache {\n\tconstructor() {\n\t\tthis.cache = new Map();\n\t}\n\tdestroy() {\n\t\tthis.cache.forEach((refCount, object) => {\n\t\t\tobject.destroy();\n\t\t});\n\t\tthis.cache.clear();\n\t}\n\tincRef(object) {\n\t\tconst refCount = (this.cache.get(object) || 0) + 1;\n\t\tthis.cache.set(object, refCount);\n\t}\n\tdecRef(object) {\n\t\tif (object) {\n\t\t\tlet refCount = this.cache.get(object);\n\t\t\tif (refCount) {\n\t\t\t\trefCount--;\n\t\t\t\tif (refCount === 0) {\n\t\t\t\t\tthis.cache.delete(object);\n\t\t\t\t\tobject.destroy();\n\t\t\t\t} else {\n\t\t\t\t\tthis.cache.set(object, refCount);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { RefCountedCache };\n","class RefCountedObject {\n\tconstructor() {\n\t\tthis._refCount = 0;\n\t}\n\tincRefCount() {\n\t\tthis._refCount++;\n\t}\n\tdecRefCount() {\n\t\tthis._refCount--;\n\t}\n\tget refCount() {\n\t\treturn this._refCount;\n\t}\n}\n\nexport { RefCountedObject };\n","import { Vec3 } from '../math/vec3.js';\n\nconst tmpVecA = new Vec3();\nconst tmpVecB = new Vec3();\nconst tmpVecC = new Vec3();\nconst tmpVecD = new Vec3();\nconst tmpVecE = new Vec3();\nclass BoundingBox {\n\tconstructor(center = new Vec3(), halfExtents = new Vec3(0.5, 0.5, 0.5)) {\n\t\tthis.center = void 0;\n\t\tthis.halfExtents = void 0;\n\t\tthis._min = new Vec3();\n\t\tthis._max = new Vec3();\n\t\tthis.center = center;\n\t\tthis.halfExtents = halfExtents;\n\t}\n\tadd(other) {\n\t\tconst tc = this.center;\n\t\tconst tcx = tc.x;\n\t\tconst tcy = tc.y;\n\t\tconst tcz = tc.z;\n\t\tconst th = this.halfExtents;\n\t\tconst thx = th.x;\n\t\tconst thy = th.y;\n\t\tconst thz = th.z;\n\t\tlet tminx = tcx - thx;\n\t\tlet tmaxx = tcx + thx;\n\t\tlet tminy = tcy - thy;\n\t\tlet tmaxy = tcy + thy;\n\t\tlet tminz = tcz - thz;\n\t\tlet tmaxz = tcz + thz;\n\t\tconst oc = other.center;\n\t\tconst ocx = oc.x;\n\t\tconst ocy = oc.y;\n\t\tconst ocz = oc.z;\n\t\tconst oh = other.halfExtents;\n\t\tconst ohx = oh.x;\n\t\tconst ohy = oh.y;\n\t\tconst ohz = oh.z;\n\t\tconst ominx = ocx - ohx;\n\t\tconst omaxx = ocx + ohx;\n\t\tconst ominy = ocy - ohy;\n\t\tconst omaxy = ocy + ohy;\n\t\tconst ominz = ocz - ohz;\n\t\tconst omaxz = ocz + ohz;\n\t\tif (ominx < tminx) tminx = ominx;\n\t\tif (omaxx > tmaxx) tmaxx = omaxx;\n\t\tif (ominy < tminy) tminy = ominy;\n\t\tif (omaxy > tmaxy) tmaxy = omaxy;\n\t\tif (ominz < tminz) tminz = ominz;\n\t\tif (omaxz > tmaxz) tmaxz = omaxz;\n\t\ttc.x = (tminx + tmaxx) * 0.5;\n\t\ttc.y = (tminy + tmaxy) * 0.5;\n\t\ttc.z = (tminz + tmaxz) * 0.5;\n\t\tth.x = (tmaxx - tminx) * 0.5;\n\t\tth.y = (tmaxy - tminy) * 0.5;\n\t\tth.z = (tmaxz - tminz) * 0.5;\n\t}\n\tcopy(src) {\n\t\tthis.center.copy(src.center);\n\t\tthis.halfExtents.copy(src.halfExtents);\n\t}\n\tclone() {\n\t\treturn new BoundingBox(this.center.clone(), this.halfExtents.clone());\n\t}\n\tintersects(other) {\n\t\tconst aMax = this.getMax();\n\t\tconst aMin = this.getMin();\n\t\tconst bMax = other.getMax();\n\t\tconst bMin = other.getMin();\n\t\treturn aMin.x <= bMax.x && aMax.x >= bMin.x && aMin.y <= bMax.y && aMax.y >= bMin.y && aMin.z <= bMax.z && aMax.z >= bMin.z;\n\t}\n\t_intersectsRay(ray, point) {\n\t\tconst tMin = tmpVecA.copy(this.getMin()).sub(ray.origin);\n\t\tconst tMax = tmpVecB.copy(this.getMax()).sub(ray.origin);\n\t\tconst dir = ray.direction;\n\t\tif (dir.x === 0) {\n\t\t\ttMin.x = tMin.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n\t\t\ttMax.x = tMax.x < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n\t\t} else {\n\t\t\ttMin.x /= dir.x;\n\t\t\ttMax.x /= dir.x;\n\t\t}\n\t\tif (dir.y === 0) {\n\t\t\ttMin.y = tMin.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n\t\t\ttMax.y = tMax.y < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n\t\t} else {\n\t\t\ttMin.y /= dir.y;\n\t\t\ttMax.y /= dir.y;\n\t\t}\n\t\tif (dir.z === 0) {\n\t\t\ttMin.z = tMin.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n\t\t\ttMax.z = tMax.z < 0 ? -Number.MAX_VALUE : Number.MAX_VALUE;\n\t\t} else {\n\t\t\ttMin.z /= dir.z;\n\t\t\ttMax.z /= dir.z;\n\t\t}\n\t\tconst realMin = tmpVecC.set(Math.min(tMin.x, tMax.x), Math.min(tMin.y, tMax.y), Math.min(tMin.z, tMax.z));\n\t\tconst realMax = tmpVecD.set(Math.max(tMin.x, tMax.x), Math.max(tMin.y, tMax.y), Math.max(tMin.z, tMax.z));\n\t\tconst minMax = Math.min(Math.min(realMax.x, realMax.y), realMax.z);\n\t\tconst maxMin = Math.max(Math.max(realMin.x, realMin.y), realMin.z);\n\t\tconst intersects = minMax >= maxMin && maxMin >= 0;\n\t\tif (intersects) {\n\t\t\tpoint.copy(ray.direction).mulScalar(maxMin).add(ray.origin);\n\t\t}\n\t\treturn intersects;\n\t}\n\t_fastIntersectsRay(ray) {\n\t\tconst diff = tmpVecA;\n\t\tconst cross = tmpVecB;\n\t\tconst prod = tmpVecC;\n\t\tconst absDiff = tmpVecD;\n\t\tconst absDir = tmpVecE;\n\t\tconst rayDir = ray.direction;\n\t\tdiff.sub2(ray.origin, this.center);\n\t\tabsDiff.set(Math.abs(diff.x), Math.abs(diff.y), Math.abs(diff.z));\n\t\tprod.mul2(diff, rayDir);\n\t\tif (absDiff.x > this.halfExtents.x && prod.x >= 0) {\n\t\t\treturn false;\n\t\t}\n\t\tif (absDiff.y > this.halfExtents.y && prod.y >= 0) {\n\t\t\treturn false;\n\t\t}\n\t\tif (absDiff.z > this.halfExtents.z && prod.z >= 0) {\n\t\t\treturn false;\n\t\t}\n\t\tabsDir.set(Math.abs(rayDir.x), Math.abs(rayDir.y), Math.abs(rayDir.z));\n\t\tcross.cross(rayDir, diff);\n\t\tcross.set(Math.abs(cross.x), Math.abs(cross.y), Math.abs(cross.z));\n\t\tif (cross.x > this.halfExtents.y * absDir.z + this.halfExtents.z * absDir.y) {\n\t\t\treturn false;\n\t\t}\n\t\tif (cross.y > this.halfExtents.x * absDir.z + this.halfExtents.z * absDir.x) {\n\t\t\treturn false;\n\t\t}\n\t\tif (cross.z > this.halfExtents.x * absDir.y + this.halfExtents.y * absDir.x) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tintersectsRay(ray, point) {\n\t\tif (point) {\n\t\t\treturn this._intersectsRay(ray, point);\n\t\t}\n\t\treturn this._fastIntersectsRay(ray);\n\t}\n\tsetMinMax(min, max) {\n\t\tthis.center.add2(max, min).mulScalar(0.5);\n\t\tthis.halfExtents.sub2(max, min).mulScalar(0.5);\n\t}\n\tgetMin() {\n\t\treturn this._min.copy(this.center).sub(this.halfExtents);\n\t}\n\tgetMax() {\n\t\treturn this._max.copy(this.center).add(this.halfExtents);\n\t}\n\tcontainsPoint(point) {\n\t\tconst min = this.getMin();\n\t\tconst max = this.getMax();\n\t\tif (point.x < min.x || point.x > max.x || point.y < min.y || point.y > max.y || point.z < min.z || point.z > max.z) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tsetFromTransformedAabb(aabb, m, ignoreScale = false) {\n\t\tconst ac = aabb.center;\n\t\tconst ar = aabb.halfExtents;\n\t\tconst d = m.data;\n\t\tlet mx0 = d[0];\n\t\tlet mx1 = d[4];\n\t\tlet mx2 = d[8];\n\t\tlet my0 = d[1];\n\t\tlet my1 = d[5];\n\t\tlet my2 = d[9];\n\t\tlet mz0 = d[2];\n\t\tlet mz1 = d[6];\n\t\tlet mz2 = d[10];\n\t\tif (ignoreScale) {\n\t\t\tlet lengthSq = mx0 * mx0 + mx1 * mx1 + mx2 * mx2;\n\t\t\tif (lengthSq > 0) {\n\t\t\t\tconst invLength = 1 / Math.sqrt(lengthSq);\n\t\t\t\tmx0 *= invLength;\n\t\t\t\tmx1 *= invLength;\n\t\t\t\tmx2 *= invLength;\n\t\t\t}\n\t\t\tlengthSq = my0 * my0 + my1 * my1 + my2 * my2;\n\t\t\tif (lengthSq > 0) {\n\t\t\t\tconst invLength = 1 / Math.sqrt(lengthSq);\n\t\t\t\tmy0 *= invLength;\n\t\t\t\tmy1 *= invLength;\n\t\t\t\tmy2 *= invLength;\n\t\t\t}\n\t\t\tlengthSq = mz0 * mz0 + mz1 * mz1 + mz2 * mz2;\n\t\t\tif (lengthSq > 0) {\n\t\t\t\tconst invLength = 1 / Math.sqrt(lengthSq);\n\t\t\t\tmz0 *= invLength;\n\t\t\t\tmz1 *= invLength;\n\t\t\t\tmz2 *= invLength;\n\t\t\t}\n\t\t}\n\t\tthis.center.set(d[12] + mx0 * ac.x + mx1 * ac.y + mx2 * ac.z, d[13] + my0 * ac.x + my1 * ac.y + my2 * ac.z, d[14] + mz0 * ac.x + mz1 * ac.y + mz2 * ac.z);\n\t\tthis.halfExtents.set(Math.abs(mx0) * ar.x + Math.abs(mx1) * ar.y + Math.abs(mx2) * ar.z, Math.abs(my0) * ar.x + Math.abs(my1) * ar.y + Math.abs(my2) * ar.z, Math.abs(mz0) * ar.x + Math.abs(mz1) * ar.y + Math.abs(mz2) * ar.z);\n\t}\n\tstatic computeMinMax(vertices, min, max, numVerts = vertices.length / 3) {\n\t\tif (numVerts > 0) {\n\t\t\tlet minx = vertices[0];\n\t\t\tlet miny = vertices[1];\n\t\t\tlet minz = vertices[2];\n\t\t\tlet maxx = minx;\n\t\t\tlet maxy = miny;\n\t\t\tlet maxz = minz;\n\t\t\tconst n = numVerts * 3;\n\t\t\tfor (let i = 3; i < n; i += 3) {\n\t\t\t\tconst x = vertices[i];\n\t\t\t\tconst y = vertices[i + 1];\n\t\t\t\tconst z = vertices[i + 2];\n\t\t\t\tif (x < minx) minx = x;\n\t\t\t\tif (y < miny) miny = y;\n\t\t\t\tif (z < minz) minz = z;\n\t\t\t\tif (x > maxx) maxx = x;\n\t\t\t\tif (y > maxy) maxy = y;\n\t\t\t\tif (z > maxz) maxz = z;\n\t\t\t}\n\t\t\tmin.set(minx, miny, minz);\n\t\t\tmax.set(maxx, maxy, maxz);\n\t\t}\n\t}\n\tcompute(vertices, numVerts) {\n\t\tBoundingBox.computeMinMax(vertices, tmpVecA, tmpVecB, numVerts);\n\t\tthis.setMinMax(tmpVecA, tmpVecB);\n\t}\n\tintersectsBoundingSphere(sphere) {\n\t\tconst sq = this._distanceToBoundingSphereSq(sphere);\n\t\tif (sq <= sphere.radius * sphere.radius) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t_distanceToBoundingSphereSq(sphere) {\n\t\tconst boxMin = this.getMin();\n\t\tconst boxMax = this.getMax();\n\t\tlet sq = 0;\n\t\tconst axis = ['x', 'y', 'z'];\n\t\tfor (let i = 0; i < 3; ++i) {\n\t\t\tlet out = 0;\n\t\t\tconst pn = sphere.center[axis[i]];\n\t\t\tconst bMin = boxMin[axis[i]];\n\t\t\tconst bMax = boxMax[axis[i]];\n\t\t\tlet val = 0;\n\t\t\tif (pn < bMin) {\n\t\t\t\tval = bMin - pn;\n\t\t\t\tout += val * val;\n\t\t\t}\n\t\t\tif (pn > bMax) {\n\t\t\t\tval = pn - bMax;\n\t\t\t\tout += val * val;\n\t\t\t}\n\t\t\tsq += out;\n\t\t}\n\t\treturn sq;\n\t}\n\t_expand(expandMin, expandMax) {\n\t\ttmpVecA.add2(this.getMin(), expandMin);\n\t\ttmpVecB.add2(this.getMax(), expandMax);\n\t\tthis.setMinMax(tmpVecA, tmpVecB);\n\t}\n}\n\nexport { BoundingBox };\n","import { Vec3 } from '../math/vec3.js';\n\nconst tmpVecA = new Vec3();\nconst tmpVecB = new Vec3();\nclass BoundingSphere {\n\tconstructor(center = new Vec3(), radius = 0.5) {\n\t\tthis.center = void 0;\n\t\tthis.radius = void 0;\n\t\tthis.center = center;\n\t\tthis.radius = radius;\n\t}\n\tcontainsPoint(point) {\n\t\tconst lenSq = tmpVecA.sub2(point, this.center).lengthSq();\n\t\tconst r = this.radius;\n\t\treturn lenSq < r * r;\n\t}\n\tintersectsRay(ray, point) {\n\t\tconst m = tmpVecA.copy(ray.origin).sub(this.center);\n\t\tconst b = m.dot(tmpVecB.copy(ray.direction).normalize());\n\t\tconst c = m.dot(m) - this.radius * this.radius;\n\t\tif (c > 0 && b > 0) {\n\t\t\treturn false;\n\t\t}\n\t\tconst discr = b * b - c;\n\t\tif (discr < 0) {\n\t\t\treturn false;\n\t\t}\n\t\tconst t = Math.abs(-b - Math.sqrt(discr));\n\t\tif (point) {\n\t\t\tpoint.copy(ray.direction).mulScalar(t).add(ray.origin);\n\t\t}\n\t\treturn true;\n\t}\n\tintersectsBoundingSphere(sphere) {\n\t\ttmpVecA.sub2(sphere.center, this.center);\n\t\tconst totalRadius = sphere.radius + this.radius;\n\t\tif (tmpVecA.lengthSq() <= totalRadius * totalRadius) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nexport { BoundingSphere };\n","class Frustum {\n\tconstructor() {\n\t\tthis.planes = [];\n\t\tfor (let i = 0; i < 6; i++) {\n\t\t\tthis.planes[i] = [];\n\t\t}\n\t}\n\tsetFromMat4(matrix) {\n\t\tconst vpm = matrix.data;\n\t\tlet plane;\n\t\tconst planes = this.planes;\n\t\tplane = planes[0];\n\t\tplane[0] = vpm[3] - vpm[0];\n\t\tplane[1] = vpm[7] - vpm[4];\n\t\tplane[2] = vpm[11] - vpm[8];\n\t\tplane[3] = vpm[15] - vpm[12];\n\t\tlet t = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n\t\tplane[0] /= t;\n\t\tplane[1] /= t;\n\t\tplane[2] /= t;\n\t\tplane[3] /= t;\n\t\tplane = planes[1];\n\t\tplane[0] = vpm[3] + vpm[0];\n\t\tplane[1] = vpm[7] + vpm[4];\n\t\tplane[2] = vpm[11] + vpm[8];\n\t\tplane[3] = vpm[15] + vpm[12];\n\t\tt = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n\t\tplane[0] /= t;\n\t\tplane[1] /= t;\n\t\tplane[2] /= t;\n\t\tplane[3] /= t;\n\t\tplane = planes[2];\n\t\tplane[0] = vpm[3] + vpm[1];\n\t\tplane[1] = vpm[7] + vpm[5];\n\t\tplane[2] = vpm[11] + vpm[9];\n\t\tplane[3] = vpm[15] + vpm[13];\n\t\tt = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n\t\tplane[0] /= t;\n\t\tplane[1] /= t;\n\t\tplane[2] /= t;\n\t\tplane[3] /= t;\n\t\tplane = planes[3];\n\t\tplane[0] = vpm[3] - vpm[1];\n\t\tplane[1] = vpm[7] - vpm[5];\n\t\tplane[2] = vpm[11] - vpm[9];\n\t\tplane[3] = vpm[15] - vpm[13];\n\t\tt = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n\t\tplane[0] /= t;\n\t\tplane[1] /= t;\n\t\tplane[2] /= t;\n\t\tplane[3] /= t;\n\t\tplane = planes[4];\n\t\tplane[0] = vpm[3] - vpm[2];\n\t\tplane[1] = vpm[7] - vpm[6];\n\t\tplane[2] = vpm[11] - vpm[10];\n\t\tplane[3] = vpm[15] - vpm[14];\n\t\tt = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n\t\tplane[0] /= t;\n\t\tplane[1] /= t;\n\t\tplane[2] /= t;\n\t\tplane[3] /= t;\n\t\tplane = planes[5];\n\t\tplane[0] = vpm[3] + vpm[2];\n\t\tplane[1] = vpm[7] + vpm[6];\n\t\tplane[2] = vpm[11] + vpm[10];\n\t\tplane[3] = vpm[15] + vpm[14];\n\t\tt = Math.sqrt(plane[0] * plane[0] + plane[1] * plane[1] + plane[2] * plane[2]);\n\t\tplane[0] /= t;\n\t\tplane[1] /= t;\n\t\tplane[2] /= t;\n\t\tplane[3] /= t;\n\t}\n\tcontainsPoint(point) {\n\t\tlet p, plane;\n\t\tfor (p = 0; p < 6; p++) {\n\t\t\tplane = this.planes[p];\n\t\t\tif (plane[0] * point.x + plane[1] * point.y + plane[2] * point.z + plane[3] <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tcontainsSphere(sphere) {\n\t\tlet c = 0;\n\t\tlet d;\n\t\tlet p;\n\t\tconst sr = sphere.radius;\n\t\tconst sc = sphere.center;\n\t\tconst scx = sc.x;\n\t\tconst scy = sc.y;\n\t\tconst scz = sc.z;\n\t\tconst planes = this.planes;\n\t\tlet plane;\n\t\tfor (p = 0; p < 6; p++) {\n\t\t\tplane = planes[p];\n\t\t\td = plane[0] * scx + plane[1] * scy + plane[2] * scz + plane[3];\n\t\t\tif (d <= -sr) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (d > sr) {\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t\treturn c === 6 ? 2 : 1;\n\t}\n}\n\nexport { Frustum };\n","import { Vec3 } from '../math/vec3.js';\n\nclass Plane {\n\tconstructor(normal = Vec3.UP, distance = 0) {\n\t\tthis.normal = new Vec3();\n\t\tthis.distance = void 0;\n\t\tthis.normal.copy(normal);\n\t\tthis.distance = distance;\n\t}\n\tsetFromPointNormal(point, normal) {\n\t\tthis.normal.copy(normal);\n\t\tthis.distance = -this.normal.dot(point);\n\t\treturn this;\n\t}\n\tintersectsLine(start, end, point) {\n\t\tconst d = this.distance;\n\t\tconst d0 = this.normal.dot(start) + d;\n\t\tconst d1 = this.normal.dot(end) + d;\n\t\tconst t = d0 / (d0 - d1);\n\t\tconst intersects = t >= 0 && t <= 1;\n\t\tif (intersects && point) {\n\t\t\tpoint.lerp(start, end, t);\n\t\t}\n\t\treturn intersects;\n\t}\n\tintersectsRay(ray, point) {\n\t\tconst denominator = this.normal.dot(ray.direction);\n\t\tif (denominator === 0) {\n\t\t\treturn false;\n\t\t}\n\t\tconst t = -(this.normal.dot(ray.origin) + this.distance) / denominator;\n\t\tif (t >= 0 && point) {\n\t\t\tpoint.copy(ray.direction).mulScalar(t).add(ray.origin);\n\t\t}\n\t\treturn t >= 0;\n\t}\n\tcopy(src) {\n\t\tthis.normal.copy(src.normal);\n\t\tthis.distance = src.distance;\n\t\treturn this;\n\t}\n\tclone() {\n\t\tconst cstr = this.constructor;\n\t\treturn new cstr().copy(this);\n\t}\n}\n\nexport { Plane };\n","import { Vec3 } from '../math/vec3.js';\n\nclass Ray {\n\tconstructor(origin, direction) {\n\t\tthis.origin = new Vec3();\n\t\tthis.direction = Vec3.FORWARD.clone();\n\t\tif (origin) {\n\t\t\tthis.origin.copy(origin);\n\t\t}\n\t\tif (direction) {\n\t\t\tthis.direction.copy(direction);\n\t\t}\n\t}\n\tset(origin, direction) {\n\t\tthis.origin.copy(origin);\n\t\tthis.direction.copy(direction);\n\t\treturn this;\n\t}\n\tcopy(src) {\n\t\treturn this.set(src.origin, src.direction);\n\t}\n\tclone() {\n\t\treturn new this.constructor(this.origin, this.direction);\n\t}\n}\n\nexport { Ray };\n","const cmpPriority = (a, b) => a.priority - b.priority;\nconst sortPriority = arr => arr.sort(cmpPriority);\n\nexport { sortPriority };\n","class SortedLoopArray {\n\tconstructor(args) {\n\t\tthis.items = [];\n\t\tthis.length = 0;\n\t\tthis.loopIndex = -1;\n\t\tthis._sortBy = void 0;\n\t\tthis._sortHandler = void 0;\n\t\tthis._sortBy = args.sortBy;\n\t\tthis._sortHandler = this._doSort.bind(this);\n\t}\n\t_binarySearch(item) {\n\t\tlet left = 0;\n\t\tlet right = this.items.length - 1;\n\t\tconst search = item[this._sortBy];\n\t\tlet middle;\n\t\tlet current;\n\t\twhile (left <= right) {\n\t\t\tmiddle = Math.floor((left + right) / 2);\n\t\t\tcurrent = this.items[middle][this._sortBy];\n\t\t\tif (current <= search) {\n\t\t\t\tleft = middle + 1;\n\t\t\t} else if (current > search) {\n\t\t\t\tright = middle - 1;\n\t\t\t}\n\t\t}\n\t\treturn left;\n\t}\n\t_doSort(a, b) {\n\t\tconst sortBy = this._sortBy;\n\t\treturn a[sortBy] - b[sortBy];\n\t}\n\tinsert(item) {\n\t\tconst index = this._binarySearch(item);\n\t\tthis.items.splice(index, 0, item);\n\t\tthis.length++;\n\t\tif (this.loopIndex >= index) {\n\t\t\tthis.loopIndex++;\n\t\t}\n\t}\n\tappend(item) {\n\t\tthis.items.push(item);\n\t\tthis.length++;\n\t}\n\tremove(item) {\n\t\tconst idx = this.items.indexOf(item);\n\t\tif (idx < 0) return;\n\t\tthis.items.splice(idx, 1);\n\t\tthis.length--;\n\t\tif (this.loopIndex >= idx) {\n\t\t\tthis.loopIndex--;\n\t\t}\n\t}\n\tsort() {\n\t\tconst current = this.loopIndex >= 0 ? this.items[this.loopIndex] : null;\n\t\tthis.items.sort(this._sortHandler);\n\t\tif (current !== null) {\n\t\t\tthis.loopIndex = this.items.indexOf(current);\n\t\t}\n\t}\n}\n\nexport { SortedLoopArray };\n","class StringIds {\n\tconstructor() {\n\t\tthis.map = new Map();\n\t\tthis.id = 0;\n\t}\n\tget(name) {\n\t\tlet value = this.map.get(name);\n\t\tif (value === undefined) {\n\t\t\tvalue = this.id++;\n\t\t\tthis.map.set(name, value);\n\t\t}\n\t\treturn value;\n\t}\n}\n\nexport { StringIds };\n","const ASCII_LOWERCASE = 'abcdefghijklmnopqrstuvwxyz';\nconst ASCII_UPPERCASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\nconst ASCII_LETTERS = ASCII_LOWERCASE + ASCII_UPPERCASE;\nconst HIGH_SURROGATE_BEGIN = 0xD800;\nconst HIGH_SURROGATE_END = 0xDBFF;\nconst LOW_SURROGATE_BEGIN = 0xDC00;\nconst LOW_SURROGATE_END = 0xDFFF;\nconst ZERO_WIDTH_JOINER = 0x200D;\nconst REGIONAL_INDICATOR_BEGIN = 0x1F1E6;\nconst REGIONAL_INDICATOR_END = 0x1F1FF;\nconst FITZPATRICK_MODIFIER_BEGIN = 0x1F3FB;\nconst FITZPATRICK_MODIFIER_END = 0x1F3FF;\nconst DIACRITICAL_MARKS_BEGIN = 0x20D0;\nconst DIACRITICAL_MARKS_END = 0x20FF;\nconst VARIATION_MODIFIER_BEGIN = 0xFE00;\nconst VARIATION_MODIFIER_END = 0xFE0F;\nfunction getCodePointData(string, i = 0) {\n\tconst size = string.length;\n\tif (i < 0 || i >= size) {\n\t\treturn null;\n\t}\n\tconst first = string.charCodeAt(i);\n\tif (size > 1 && first >= HIGH_SURROGATE_BEGIN && first <= HIGH_SURROGATE_END) {\n\t\tconst second = string.charCodeAt(i + 1);\n\t\tif (second >= LOW_SURROGATE_BEGIN && second <= LOW_SURROGATE_END) {\n\t\t\treturn {\n\t\t\t\tcode: (first - HIGH_SURROGATE_BEGIN) * 0x400 + second - LOW_SURROGATE_BEGIN + 0x10000,\n\t\t\t\tlong: true\n\t\t\t};\n\t\t}\n\t}\n\treturn {\n\t\tcode: first,\n\t\tlong: false\n\t};\n}\nfunction isCodeBetween(string, begin, end) {\n\tif (!string) {\n\t\treturn false;\n\t}\n\tconst codeData = getCodePointData(string);\n\tif (codeData) {\n\t\tconst code = codeData.code;\n\t\treturn code >= begin && code <= end;\n\t}\n\treturn false;\n}\nfunction numCharsToTakeForNextSymbol(string, index) {\n\tif (index === string.length - 1) {\n\t\treturn 1;\n\t}\n\tif (isCodeBetween(string[index], HIGH_SURROGATE_BEGIN, HIGH_SURROGATE_END)) {\n\t\tconst first = string.substring(index, index + 2);\n\t\tconst second = string.substring(index + 2, index + 4);\n\t\tif (isCodeBetween(second, FITZPATRICK_MODIFIER_BEGIN, FITZPATRICK_MODIFIER_END) || isCodeBetween(first, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END) && isCodeBetween(second, REGIONAL_INDICATOR_BEGIN, REGIONAL_INDICATOR_END)) {\n\t\t\treturn 4;\n\t\t}\n\t\tif (isCodeBetween(second, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {\n\t\t\treturn 3;\n\t\t}\n\t\treturn 2;\n\t}\n\tif (isCodeBetween(string[index + 1], VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {\n\t\treturn 2;\n\t}\n\treturn 1;\n}\nconst string = {\n\tASCII_LOWERCASE: ASCII_LOWERCASE,\n\tASCII_UPPERCASE: ASCII_UPPERCASE,\n\tASCII_LETTERS: ASCII_LETTERS,\n\tformat(s, ...args) {\n\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\ts = s.replace(`{${i}}`, args[i]);\n\t\t}\n\t\treturn s;\n\t},\n\tgetCodePoint(string, i) {\n\t\tconst codePointData = getCodePointData(string, i);\n\t\treturn codePointData && codePointData.code;\n\t},\n\tgetCodePoints(string) {\n\t\tif (typeof string !== 'string') {\n\t\t\tthrow new TypeError('Not a string');\n\t\t}\n\t\tlet i = 0;\n\t\tconst arr = [];\n\t\tlet codePoint;\n\t\twhile (!!(codePoint = getCodePointData(string, i))) {\n\t\t\tarr.push(codePoint.code);\n\t\t\ti += codePoint.long ? 2 : 1;\n\t\t}\n\t\treturn arr;\n\t},\n\tgetSymbols(string) {\n\t\tif (typeof string !== 'string') {\n\t\t\tthrow new TypeError('Not a string');\n\t\t}\n\t\tlet index = 0;\n\t\tconst length = string.length;\n\t\tconst output = [];\n\t\tlet take = 0;\n\t\tlet ch;\n\t\twhile (index < length) {\n\t\t\ttake += numCharsToTakeForNextSymbol(string, index + take);\n\t\t\tch = string[index + take];\n\t\t\tif (isCodeBetween(ch, DIACRITICAL_MARKS_BEGIN, DIACRITICAL_MARKS_END)) {\n\t\t\t\tch = string[index + take++];\n\t\t\t}\n\t\t\tif (isCodeBetween(ch, VARIATION_MODIFIER_BEGIN, VARIATION_MODIFIER_END)) {\n\t\t\t\tch = string[index + take++];\n\t\t\t}\n\t\t\tif (ch && ch.charCodeAt(0) === ZERO_WIDTH_JOINER) {\n\t\t\t\tch = string[index + take++];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst char = string.substring(index, index + take);\n\t\t\toutput.push(char);\n\t\t\tindex += take;\n\t\t\ttake = 0;\n\t\t}\n\t\treturn output;\n\t},\n\tfromCodePoint() {\n\t\tconst chars = [];\n\t\tlet current;\n\t\tlet codePoint;\n\t\tlet units;\n\t\tfor (let i = 0; i < arguments.length; ++i) {\n\t\t\tcurrent = Number(arguments[i]);\n\t\t\tcodePoint = current - 0x10000;\n\t\t\tunits = current > 0xFFFF ? [(codePoint >> 10) + 0xD800, codePoint % 0x400 + 0xDC00] : [current];\n\t\t\tchars.push(String.fromCharCode.apply(null, units));\n\t\t}\n\t\treturn chars.join('');\n\t}\n};\n\nexport { string };\n","class TagsCache {\n\tconstructor(key = null) {\n\t\tthis._index = {};\n\t\tthis._key = void 0;\n\t\tthis._key = key;\n\t}\n\taddItem(item) {\n\t\tconst tags = item.tags._list;\n\t\tfor (const tag of tags) {\n\t\t\tthis.add(tag, item);\n\t\t}\n\t}\n\tremoveItem(item) {\n\t\tconst tags = item.tags._list;\n\t\tfor (const tag of tags) {\n\t\t\tthis.remove(tag, item);\n\t\t}\n\t}\n\tadd(tag, item) {\n\t\tif (this._index[tag] && this._index[tag].list.indexOf(item) !== -1) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this._index[tag]) {\n\t\t\tthis._index[tag] = {\n\t\t\t\tlist: []\n\t\t\t};\n\t\t\tif (this._key) {\n\t\t\t\tthis._index[tag].keys = {};\n\t\t\t}\n\t\t}\n\t\tthis._index[tag].list.push(item);\n\t\tif (this._key) {\n\t\t\tthis._index[tag].keys[item[this._key]] = item;\n\t\t}\n\t}\n\tremove(tag, item) {\n\t\tif (!this._index[tag]) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._key) {\n\t\t\tif (!this._index[tag].keys[item[this._key]]) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tconst ind = this._index[tag].list.indexOf(item);\n\t\tif (ind === -1) {\n\t\t\treturn;\n\t\t}\n\t\tthis._index[tag].list.splice(ind, 1);\n\t\tif (this._key) {\n\t\t\tdelete this._index[tag].keys[item[this._key]];\n\t\t}\n\t\tif (this._index[tag].list.length === 0) {\n\t\t\tdelete this._index[tag];\n\t\t}\n\t}\n\tfind(args) {\n\t\tconst index = {};\n\t\tconst items = [];\n\t\tlet item, tag, tags, tagsRest, missingIndex;\n\t\tconst sort = (a, b) => {\n\t\t\treturn this._index[a].list.length - this._index[b].list.length;\n\t\t};\n\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\ttag = args[i];\n\t\t\tif (tag instanceof Array) {\n\t\t\t\tif (tag.length === 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (tag.length === 1) {\n\t\t\t\t\ttag = tag[0];\n\t\t\t\t} else {\n\t\t\t\t\tmissingIndex = false;\n\t\t\t\t\tfor (let t = 0; t < tag.length; t++) {\n\t\t\t\t\t\tif (!this._index[tag[t]]) {\n\t\t\t\t\t\t\tmissingIndex = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (missingIndex) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\ttags = tag.slice(0).sort(sort);\n\t\t\t\t\ttagsRest = tags.slice(1);\n\t\t\t\t\tif (tagsRest.length === 1) {\n\t\t\t\t\t\ttagsRest = tagsRest[0];\n\t\t\t\t\t}\n\t\t\t\t\tfor (let n = 0; n < this._index[tags[0]].list.length; n++) {\n\t\t\t\t\t\titem = this._index[tags[0]].list[n];\n\t\t\t\t\t\tif ((this._key ? !index[item[this._key]] : items.indexOf(item) === -1) && item.tags.has(tagsRest)) {\n\t\t\t\t\t\t\tif (this._key) {\n\t\t\t\t\t\t\t\tindex[item[this._key]] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\titems.push(item);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (tag && typeof tag === 'string' && this._index[tag]) {\n\t\t\t\tfor (let n = 0; n < this._index[tag].list.length; n++) {\n\t\t\t\t\titem = this._index[tag].list[n];\n\t\t\t\t\tif (this._key) {\n\t\t\t\t\t\tif (!index[item[this._key]]) {\n\t\t\t\t\t\t\tindex[item[this._key]] = true;\n\t\t\t\t\t\t\titems.push(item);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (items.indexOf(item) === -1) {\n\t\t\t\t\t\titems.push(item);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn items;\n\t}\n}\n\nexport { TagsCache };\n","import { EventHandler } from './event-handler.js';\n\nclass Tags extends EventHandler {\n\tconstructor(parent) {\n\t\tsuper();\n\t\tthis._index = {};\n\t\tthis._list = [];\n\t\tthis._parent = parent;\n\t}\n\tadd(...args) {\n\t\tlet changed = false;\n\t\tconst tags = this._processArguments(args, true);\n\t\tif (!tags.length) {\n\t\t\treturn changed;\n\t\t}\n\t\tfor (let i = 0; i < tags.length; i++) {\n\t\t\tif (this._index[tags[i]]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchanged = true;\n\t\t\tthis._index[tags[i]] = true;\n\t\t\tthis._list.push(tags[i]);\n\t\t\tthis.fire('add', tags[i], this._parent);\n\t\t}\n\t\tif (changed) {\n\t\t\tthis.fire('change', this._parent);\n\t\t}\n\t\treturn changed;\n\t}\n\tremove(...args) {\n\t\tlet changed = false;\n\t\tif (!this._list.length) {\n\t\t\treturn changed;\n\t\t}\n\t\tconst tags = this._processArguments(args, true);\n\t\tif (!tags.length) {\n\t\t\treturn changed;\n\t\t}\n\t\tfor (let i = 0; i < tags.length; i++) {\n\t\t\tif (!this._index[tags[i]]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tchanged = true;\n\t\t\tdelete this._index[tags[i]];\n\t\t\tthis._list.splice(this._list.indexOf(tags[i]), 1);\n\t\t\tthis.fire('remove', tags[i], this._parent);\n\t\t}\n\t\tif (changed) {\n\t\t\tthis.fire('change', this._parent);\n\t\t}\n\t\treturn changed;\n\t}\n\tclear() {\n\t\tif (!this._list.length) {\n\t\t\treturn;\n\t\t}\n\t\tconst tags = this._list.slice(0);\n\t\tthis._list = [];\n\t\tthis._index = {};\n\t\tfor (let i = 0; i < tags.length; i++) {\n\t\t\tthis.fire('remove', tags[i], this._parent);\n\t\t}\n\t\tthis.fire('change', this._parent);\n\t}\n\thas(...query) {\n\t\tif (!this._list.length) {\n\t\t\treturn false;\n\t\t}\n\t\treturn this._has(this._processArguments(query));\n\t}\n\t_has(tags) {\n\t\tif (!this._list.length || !tags.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < tags.length; i++) {\n\t\t\tif (tags[i].length === 1) {\n\t\t\t\tif (this._index[tags[i][0]]) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet multiple = true;\n\t\t\t\tfor (let t = 0; t < tags[i].length; t++) {\n\t\t\t\t\tif (this._index[tags[i][t]]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tmultiple = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (multiple) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tlist() {\n\t\treturn this._list.slice(0);\n\t}\n\t_processArguments(args, flat) {\n\t\tconst tags = [];\n\t\tlet tmp = [];\n\t\tif (!args || !args.length) {\n\t\t\treturn tags;\n\t\t}\n\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\tif (args[i] instanceof Array) {\n\t\t\t\tif (!flat) {\n\t\t\t\t\ttmp = [];\n\t\t\t\t}\n\t\t\t\tfor (let t = 0; t < args[i].length; t++) {\n\t\t\t\t\tif (typeof args[i][t] !== 'string') {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (flat) {\n\t\t\t\t\t\ttags.push(args[i][t]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttmp.push(args[i][t]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!flat && tmp.length) {\n\t\t\t\t\ttags.push(tmp);\n\t\t\t\t}\n\t\t\t} else if (typeof args[i] === 'string') {\n\t\t\t\tif (flat) {\n\t\t\t\t\ttags.push(args[i]);\n\t\t\t\t} else {\n\t\t\t\t\ttags.push([args[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tags;\n\t}\n\tget size() {\n\t\treturn this._list.length;\n\t}\n}\nTags.EVENT_ADD = 'add';\nTags.EVENT_REMOVE = 'remove';\nTags.EVENT_CHANGE = 'change';\n\nexport { Tags };\n","const now = typeof window !== 'undefined' && window.performance && window.performance.now ? performance.now.bind(performance) : Date.now;\n\nexport { now };\n","class Tracing {\n\tstatic set(channel, enabled = true) {}\n\tstatic get(channel) {\n\t\treturn Tracing._traceChannels.has(channel);\n\t}\n}\nTracing._traceChannels = new Set();\nTracing.stack = false;\n\nexport { Tracing };\n","function createURI(options) {\n\tlet s = '';\n\tif ((options.authority || options.scheme) && (options.host || options.hostpath)) {\n\t\tthrow new Error('Can\\'t have \\'scheme\\' or \\'authority\\' and \\'host\\' or \\'hostpath\\' option');\n\t}\n\tif (options.host && options.hostpath) {\n\t\tthrow new Error('Can\\'t have \\'host\\' and \\'hostpath\\' option');\n\t}\n\tif (options.path && options.hostpath) {\n\t\tthrow new Error('Can\\'t have \\'path\\' and \\'hostpath\\' option');\n\t}\n\tif (options.scheme) {\n\t\ts += `${options.scheme}:`;\n\t}\n\tif (options.authority) {\n\t\ts += `//${options.authority}`;\n\t}\n\tif (options.host) {\n\t\ts += options.host;\n\t}\n\tif (options.path) {\n\t\ts += options.path;\n\t}\n\tif (options.hostpath) {\n\t\ts += options.hostpath;\n\t}\n\tif (options.query) {\n\t\ts += `?${options.query}`;\n\t}\n\tif (options.fragment) {\n\t\ts += `#${options.fragment}`;\n\t}\n\treturn s;\n}\nconst re = /^(([^:/?#]+):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\nclass URI {\n\tconstructor(uri) {\n\t\tthis.scheme = void 0;\n\t\tthis.authority = void 0;\n\t\tthis.path = void 0;\n\t\tthis.query = void 0;\n\t\tthis.fragment = void 0;\n\t\tconst result = uri.match(re);\n\t\tthis.scheme = result[2];\n\t\tthis.authority = result[4];\n\t\tthis.path = result[5];\n\t\tthis.query = result[7];\n\t\tthis.fragment = result[9];\n\t}\n\ttoString() {\n\t\tlet s = '';\n\t\tif (this.scheme) {\n\t\t\ts += `${this.scheme}:`;\n\t\t}\n\t\tif (this.authority) {\n\t\t\ts += `//${this.authority}`;\n\t\t}\n\t\ts += this.path;\n\t\tif (this.query) {\n\t\t\ts += `?${this.query}`;\n\t\t}\n\t\tif (this.fragment) {\n\t\t\ts += `#${this.fragment}`;\n\t\t}\n\t\treturn s;\n\t}\n\tgetQuery() {\n\t\tconst result = {};\n\t\tif (this.query) {\n\t\t\tconst queryParams = decodeURIComponent(this.query).split('&');\n\t\t\tfor (const queryParam of queryParams) {\n\t\t\t\tconst pair = queryParam.split('=');\n\t\t\t\tresult[pair[0]] = pair[1];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tsetQuery(params) {\n\t\tlet q = '';\n\t\tfor (const key in params) {\n\t\t\tif (params.hasOwnProperty(key)) {\n\t\t\t\tif (q !== '') {\n\t\t\t\t\tq += '&';\n\t\t\t\t}\n\t\t\t\tq += `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`;\n\t\t\t}\n\t\t}\n\t\tthis.query = q;\n\t}\n}\n\nexport { URI, createURI };\n","const cachedResult = func => {\n\tconst uninitToken = {};\n\tlet result = uninitToken;\n\treturn () => {\n\t\tif (result === uninitToken) {\n\t\t\tresult = func();\n\t\t}\n\t\treturn result;\n\t};\n};\nclass Impl {\n\tstatic loadScript(url, callback) {\n\t\tconst s = document.createElement('script');\n\t\ts.setAttribute('src', url);\n\t\ts.onload = () => {\n\t\t\tcallback(null);\n\t\t};\n\t\ts.onerror = () => {\n\t\t\tcallback(`Failed to load script='${url}'`);\n\t\t};\n\t\tdocument.body.appendChild(s);\n\t}\n\tstatic loadWasm(moduleName, config, callback) {\n\t\tconst loadUrl = Impl.wasmSupported() && config.glueUrl && config.wasmUrl ? config.glueUrl : config.fallbackUrl;\n\t\tif (loadUrl) {\n\t\t\tImpl.loadScript(loadUrl, err => {\n\t\t\t\tif (err) {\n\t\t\t\t\tcallback(err, null);\n\t\t\t\t} else {\n\t\t\t\t\tconst module = window[moduleName];\n\t\t\t\t\twindow[moduleName] = undefined;\n\t\t\t\t\tmodule({\n\t\t\t\t\t\tlocateFile: () => config.wasmUrl,\n\t\t\t\t\t\tonAbort: () => {\n\t\t\t\t\t\t\tcallback('wasm module aborted.');\n\t\t\t\t\t\t}\n\t\t\t\t\t}).then(instance => {\n\t\t\t\t\t\tcallback(null, instance);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tcallback('No supported wasm modules found.', null);\n\t\t}\n\t}\n\tstatic getModule(name) {\n\t\tif (!Impl.modules.hasOwnProperty(name)) {\n\t\t\tImpl.modules[name] = {\n\t\t\t\tconfig: null,\n\t\t\t\tinitializing: false,\n\t\t\t\tinstance: null,\n\t\t\t\tcallbacks: []\n\t\t\t};\n\t\t}\n\t\treturn Impl.modules[name];\n\t}\n\tstatic initialize(moduleName, module) {\n\t\tif (module.initializing) {\n\t\t\treturn;\n\t\t}\n\t\tconst config = module.config;\n\t\tif (config.glueUrl || config.wasmUrl || config.fallbackUrl) {\n\t\t\tmodule.initializing = true;\n\t\t\tImpl.loadWasm(moduleName, config, (err, instance) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tif (config.errorHandler) {\n\t\t\t\t\t\tconfig.errorHandler(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.error(`failed to initialize module=${moduleName} error=${err}`);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmodule.instance = instance;\n\t\t\t\t\tmodule.callbacks.forEach(callback => {\n\t\t\t\t\t\tcallback(instance);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n}\nImpl.modules = {};\nImpl.wasmSupported = cachedResult(() => {\n\ttry {\n\t\tif (typeof WebAssembly === 'object' && typeof WebAssembly.instantiate === 'function') {\n\t\t\tconst module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));\n\t\t\tif (module instanceof WebAssembly.Module) {\n\t\t\t\treturn new WebAssembly.Instance(module) instanceof WebAssembly.Instance;\n\t\t\t}\n\t\t}\n\t} catch (e) {}\n\treturn false;\n});\nclass WasmModule {\n\tstatic setConfig(moduleName, config) {\n\t\tconst module = Impl.getModule(moduleName);\n\t\tmodule.config = config;\n\t\tif (module.callbacks.length > 0) {\n\t\t\tImpl.initialize(moduleName, module);\n\t\t}\n\t}\n\tstatic getConfig(moduleName) {\n\t\tvar _Impl$modules;\n\t\treturn (_Impl$modules = Impl.modules) == null || (_Impl$modules = _Impl$modules[moduleName]) == null ? void 0 : _Impl$modules.config;\n\t}\n\tstatic getInstance(moduleName, callback) {\n\t\tconst module = Impl.getModule(moduleName);\n\t\tif (module.instance) {\n\t\t\tcallback(module.instance);\n\t\t} else {\n\t\t\tmodule.callbacks.push(callback);\n\t\t\tif (module.config) {\n\t\t\t\tImpl.initialize(moduleName, module);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { WasmModule };\n","function __adjustStandardMaterialParameterTypes(types) {\n\ttypes.useGamma = 'boolean';\n\ttypes.aoIntensity = 'number';\n}\nconst _tintProperties = ['ambientTint', 'emissiveTint', 'diffuseTint', 'sheenTint'];\nfunction __adjustStandardMaterialData(data) {\n\t_tintProperties.forEach(prop => {\n\t\tif (data[prop] === undefined) {\n\t\t\tdata[prop] = true;\n\t\t}\n\t});\n}\n\nexport { __adjustStandardMaterialData, __adjustStandardMaterialParameterTypes };\n","class AnimBinder {\n\tstatic joinPath(pathSegments, character) {\n\t\tcharacter = character || '.';\n\t\tconst escape = function escape(string) {\n\t\t\treturn string.replace(/\\\\/g, '\\\\\\\\').replace(new RegExp(`\\\\${character}`, 'g'), `\\\\${character}`);\n\t\t};\n\t\treturn pathSegments.map(escape).join(character);\n\t}\n\tstatic splitPath(path, character) {\n\t\tcharacter = character || '.';\n\t\tconst result = [];\n\t\tlet curr = '';\n\t\tlet i = 0;\n\t\twhile (i < path.length) {\n\t\t\tlet c = path[i++];\n\t\t\tif (c === '\\\\' && i < path.length) {\n\t\t\t\tc = path[i++];\n\t\t\t\tif (c === '\\\\' || c === character) {\n\t\t\t\t\tcurr += c;\n\t\t\t\t} else {\n\t\t\t\t\tcurr += `\\\\${c}`;\n\t\t\t\t}\n\t\t\t} else if (c === character) {\n\t\t\t\tresult.push(curr);\n\t\t\t\tcurr = '';\n\t\t\t} else {\n\t\t\t\tcurr += c;\n\t\t\t}\n\t\t}\n\t\tif (curr.length > 0) {\n\t\t\tresult.push(curr);\n\t\t}\n\t\treturn result;\n\t}\n\tstatic encode(entityPath, component, propertyPath) {\n\t\treturn `${Array.isArray(entityPath) ? entityPath.join('/') : entityPath}/${component}/${Array.isArray(propertyPath) ? propertyPath.join('/') : propertyPath}`;\n\t}\n\tresolve(path) {\n\t\treturn null;\n\t}\n\tunresolve(path) {}\n\tupdate(deltaTime) {}\n}\n\nexport { AnimBinder };\n","import { AnimBinder } from './anim-binder.js';\nimport { AnimTarget } from '../evaluator/anim-target.js';\nimport { Entity } from '../../entity.js';\n\nclass DefaultAnimBinder {\n\tconstructor(graph) {\n\t\tthis._isPathInMask = (path, checkMaskValue) => {\n\t\t\tconst maskItem = this._mask[path];\n\t\t\tif (!maskItem) return false;else if (maskItem.children || checkMaskValue && maskItem.value !== false) return true;\n\t\t\treturn false;\n\t\t};\n\t\tthis.graph = graph;\n\t\tif (!graph) return;\n\t\tthis._mask = null;\n\t\tconst nodes = {};\n\t\tconst flatten = function flatten(node) {\n\t\t\tnodes[node.name] = node;\n\t\t\tfor (let i = 0; i < node.children.length; ++i) {\n\t\t\t\tflatten(node.children[i]);\n\t\t\t}\n\t\t};\n\t\tflatten(graph);\n\t\tthis.nodes = nodes;\n\t\tthis.targetCache = {};\n\t\tconst findMeshInstances = function findMeshInstances(node) {\n\t\t\tlet object = node;\n\t\t\twhile (object && !(object instanceof Entity)) {\n\t\t\t\tobject = object.parent;\n\t\t\t}\n\t\t\tlet meshInstances;\n\t\t\tif (object) {\n\t\t\t\tif (object.render) {\n\t\t\t\t\tmeshInstances = object.render.meshInstances;\n\t\t\t\t} else if (object.model) {\n\t\t\t\t\tmeshInstances = object.model.meshInstances;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn meshInstances;\n\t\t};\n\t\tthis.nodeCounts = {};\n\t\tthis.activeNodes = [];\n\t\tthis.handlers = {\n\t\t\t'localPosition': function (node) {\n\t\t\t\tconst object = node.localPosition;\n\t\t\t\tconst func = function func(value) {\n\t\t\t\t\tobject.set(...value);\n\t\t\t\t};\n\t\t\t\treturn DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localPosition');\n\t\t\t},\n\t\t\t'localRotation': function (node) {\n\t\t\t\tconst object = node.localRotation;\n\t\t\t\tconst func = function func(value) {\n\t\t\t\t\tobject.set(...value);\n\t\t\t\t};\n\t\t\t\treturn DefaultAnimBinder.createAnimTarget(func, 'quaternion', 4, node, 'localRotation');\n\t\t\t},\n\t\t\t'localScale': function (node) {\n\t\t\t\tconst object = node.localScale;\n\t\t\t\tconst func = function func(value) {\n\t\t\t\t\tobject.set(...value);\n\t\t\t\t};\n\t\t\t\treturn DefaultAnimBinder.createAnimTarget(func, 'vector', 3, node, 'localScale');\n\t\t\t},\n\t\t\t'weight': function (node, weightName) {\n\t\t\t\tif (weightName.indexOf('name.') === 0) {\n\t\t\t\t\tweightName = weightName.replace('name.', '');\n\t\t\t\t} else {\n\t\t\t\t\tweightName = Number(weightName);\n\t\t\t\t}\n\t\t\t\tconst meshInstances = findMeshInstances(node);\n\t\t\t\tlet setters;\n\t\t\t\tif (meshInstances) {\n\t\t\t\t\tfor (let i = 0; i < meshInstances.length; ++i) {\n\t\t\t\t\t\tif (meshInstances[i].node.name === node.name && meshInstances[i].morphInstance) {\n\t\t\t\t\t\t\tconst morphInstance = meshInstances[i].morphInstance;\n\t\t\t\t\t\t\tconst func = value => {\n\t\t\t\t\t\t\t\tmorphInstance.setWeight(weightName, value[0]);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tif (!setters) setters = [];\n\t\t\t\t\t\t\tsetters.push(func);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (setters) {\n\t\t\t\t\tconst callSetters = value => {\n\t\t\t\t\t\tfor (let i = 0; i < setters.length; ++i) {\n\t\t\t\t\t\t\tsetters[i](value);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\treturn DefaultAnimBinder.createAnimTarget(callSetters, 'number', 1, node, `weight.${weightName}`);\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t},\n\t\t\t'materialTexture': (node, textureName) => {\n\t\t\t\tconst meshInstances = findMeshInstances(node);\n\t\t\t\tif (meshInstances) {\n\t\t\t\t\tlet meshInstance;\n\t\t\t\t\tfor (let i = 0; i < meshInstances.length; ++i) {\n\t\t\t\t\t\tif (meshInstances[i].node.name === node.name) {\n\t\t\t\t\t\t\tmeshInstance = meshInstances[i];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (meshInstance) {\n\t\t\t\t\t\tconst func = value => {\n\t\t\t\t\t\t\tconst textureAsset = this.animComponent.system.app.assets.get(value[0]);\n\t\t\t\t\t\t\tif (textureAsset && textureAsset.resource && textureAsset.type === 'texture') {\n\t\t\t\t\t\t\t\tmeshInstance.material[textureName] = textureAsset.resource;\n\t\t\t\t\t\t\t\tmeshInstance.material.update();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t\treturn DefaultAnimBinder.createAnimTarget(func, 'vector', 1, node, 'materialTexture', 'material');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\t};\n\t}\n\t_isPathActive(path) {\n\t\tif (!this._mask) return true;\n\t\tconst rootNodeNames = [path.entityPath[0], this.graph.name];\n\t\tfor (let j = 0; j < rootNodeNames.length; ++j) {\n\t\t\tlet currEntityPath = rootNodeNames[j];\n\t\t\tif (this._isPathInMask(currEntityPath, path.entityPath.length === 1)) return true;\n\t\t\tfor (let i = 1; i < path.entityPath.length; i++) {\n\t\t\t\tcurrEntityPath += `/${path.entityPath[i]}`;\n\t\t\t\tif (this._isPathInMask(currEntityPath, i === path.entityPath.length - 1)) return true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tfindNode(path) {\n\t\tif (!this._isPathActive(path)) {\n\t\t\treturn null;\n\t\t}\n\t\tlet node;\n\t\tif (this.graph) {\n\t\t\tnode = this.graph.findByPath(path.entityPath);\n\t\t\tif (!node) {\n\t\t\t\tnode = this.graph.findByPath(path.entityPath.slice(1));\n\t\t\t}\n\t\t}\n\t\tif (!node) {\n\t\t\tnode = this.nodes[path.entityPath[path.entityPath.length - 1] || ''];\n\t\t}\n\t\treturn node;\n\t}\n\tstatic createAnimTarget(func, type, valueCount, node, propertyPath, componentType) {\n\t\tconst targetPath = AnimBinder.encode(node.path, componentType ? componentType : 'entity', propertyPath);\n\t\treturn new AnimTarget(func, type, valueCount, targetPath);\n\t}\n\tresolve(path) {\n\t\tconst encodedPath = AnimBinder.encode(path.entityPath, path.component, path.propertyPath);\n\t\tlet target = this.targetCache[encodedPath];\n\t\tif (target) return target;\n\t\tconst node = this.findNode(path);\n\t\tif (!node) {\n\t\t\treturn null;\n\t\t}\n\t\tconst handler = this.handlers[path.propertyPath];\n\t\tif (!handler) {\n\t\t\treturn null;\n\t\t}\n\t\ttarget = handler(node);\n\t\tif (!target) {\n\t\t\treturn null;\n\t\t}\n\t\tthis.targetCache[encodedPath] = target;\n\t\tif (!this.nodeCounts[node.path]) {\n\t\t\tthis.activeNodes.push(node);\n\t\t\tthis.nodeCounts[node.path] = 1;\n\t\t} else {\n\t\t\tthis.nodeCounts[node.path]++;\n\t\t}\n\t\treturn target;\n\t}\n\tunresolve(path) {\n\t\tif (path.component !== 'graph') {\n\t\t\treturn;\n\t\t}\n\t\tconst node = this.nodes[path.entityPath[path.entityPath.length - 1] || ''];\n\t\tthis.nodeCounts[node.path]--;\n\t\tif (this.nodeCounts[node.path] === 0) {\n\t\t\tconst activeNodes = this.activeNodes;\n\t\t\tconst i = activeNodes.indexOf(node.node);\n\t\t\tconst len = activeNodes.length;\n\t\t\tif (i < len - 1) {\n\t\t\t\tactiveNodes[i] = activeNodes[len - 1];\n\t\t\t}\n\t\t\tactiveNodes.pop();\n\t\t}\n\t}\n\tupdate(deltaTime) {\n\t\tconst activeNodes = this.activeNodes;\n\t\tfor (let i = 0; i < activeNodes.length; ++i) {\n\t\t\tactiveNodes[i]._dirtifyLocal();\n\t\t}\n\t}\n\tassignMask(mask) {\n\t\tif (mask !== this._mask) {\n\t\t\tthis._mask = mask;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nexport { DefaultAnimBinder };\n","const INTERPOLATION_STEP = 0;\nconst INTERPOLATION_LINEAR = 1;\nconst INTERPOLATION_CUBIC = 2;\n\nexport { INTERPOLATION_CUBIC, INTERPOLATION_LINEAR, INTERPOLATION_STEP };\n","import { math } from '../../../core/math/math.js';\nimport { AnimBlendTree } from './anim-blend-tree.js';\n\nclass AnimBlendTree1D extends AnimBlendTree {\n\tconstructor(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {\n\t\tchildren.sort((a, b) => a.point - b.point);\n\t\tsuper(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);\n\t}\n\tcalculateWeights() {\n\t\tif (this.updateParameterValues()) return;\n\t\tlet weightedDurationSum = 0.0;\n\t\tthis._children[0].weight = 0.0;\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst c1 = this._children[i];\n\t\t\tif (i !== this._children.length - 1) {\n\t\t\t\tconst c2 = this._children[i + 1];\n\t\t\t\tif (c1.point === c2.point) {\n\t\t\t\t\tc1.weight = 0.5;\n\t\t\t\t\tc2.weight = 0.5;\n\t\t\t\t} else if (math.between(this._parameterValues[0], c1.point, c2.point, true)) {\n\t\t\t\t\tconst child2Distance = Math.abs(c1.point - c2.point);\n\t\t\t\t\tconst parameterDistance = Math.abs(c1.point - this._parameterValues[0]);\n\t\t\t\t\tconst weight = (child2Distance - parameterDistance) / child2Distance;\n\t\t\t\t\tc1.weight = weight;\n\t\t\t\t\tc2.weight = 1.0 - weight;\n\t\t\t\t} else {\n\t\t\t\t\tc2.weight = 0.0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._syncAnimations) {\n\t\t\t\tweightedDurationSum += c1.animTrack.duration / c1.absoluteSpeed * c1.weight;\n\t\t\t}\n\t\t}\n\t\tif (this._syncAnimations) {\n\t\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\t\tconst child = this._children[i];\n\t\t\t\tchild.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { AnimBlendTree1D };\n","import { Vec2 } from '../../../core/math/vec2.js';\nimport { math } from '../../../core/math/math.js';\nimport { AnimBlendTree } from './anim-blend-tree.js';\n\nclass AnimBlendTreeCartesian2D extends AnimBlendTree {\n\tpointDistanceCache(i, j) {\n\t\tconst pointKey = `${i}${j}`;\n\t\tif (!this._pointCache[pointKey]) {\n\t\t\tthis._pointCache[pointKey] = this._children[j].point.clone().sub(this._children[i].point);\n\t\t}\n\t\treturn this._pointCache[pointKey];\n\t}\n\tcalculateWeights() {\n\t\tif (this.updateParameterValues()) return;\n\t\tlet weightSum, weightedDurationSum;\n\t\tAnimBlendTreeCartesian2D._p.set(...this._parameterValues);\n\t\tweightSum = 0.0;\n\t\tweightedDurationSum = 0.0;\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst child = this._children[i];\n\t\t\tconst pi = child.point;\n\t\t\tAnimBlendTreeCartesian2D._pip.set(AnimBlendTreeCartesian2D._p.x, AnimBlendTreeCartesian2D._p.y).sub(pi);\n\t\t\tlet minj = Number.MAX_VALUE;\n\t\t\tfor (let j = 0; j < this._children.length; j++) {\n\t\t\t\tif (i === j) continue;\n\t\t\t\tconst pipj = this.pointDistanceCache(i, j);\n\t\t\t\tconst result = math.clamp(1.0 - AnimBlendTreeCartesian2D._pip.dot(pipj) / pipj.lengthSq(), 0.0, 1.0);\n\t\t\t\tif (result < minj) minj = result;\n\t\t\t}\n\t\t\tchild.weight = minj;\n\t\t\tweightSum += minj;\n\t\t\tif (this._syncAnimations) {\n\t\t\t\tweightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst child = this._children[i];\n\t\t\tchild.weight = child._weight / weightSum;\n\t\t\tif (this._syncAnimations) {\n\t\t\t\tchild.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;\n\t\t\t}\n\t\t}\n\t}\n}\nAnimBlendTreeCartesian2D._p = new Vec2();\nAnimBlendTreeCartesian2D._pip = new Vec2();\n\nexport { AnimBlendTreeCartesian2D };\n","import { Vec2 } from '../../../core/math/vec2.js';\nimport { math } from '../../../core/math/math.js';\nimport { AnimBlendTree } from './anim-blend-tree.js';\n\nclass AnimBlendTreeDirectional2D extends AnimBlendTree {\n\tpointCache(i, j) {\n\t\tconst pointKey = `${i}${j}`;\n\t\tif (!this._pointCache[pointKey]) {\n\t\t\tthis._pointCache[pointKey] = new Vec2((this._children[j].pointLength - this._children[i].pointLength) / ((this._children[j].pointLength + this._children[i].pointLength) / 2), Vec2.angleRad(this._children[i].point, this._children[j].point) * 2.0);\n\t\t}\n\t\treturn this._pointCache[pointKey];\n\t}\n\tcalculateWeights() {\n\t\tif (this.updateParameterValues()) return;\n\t\tlet weightSum, weightedDurationSum;\n\t\tAnimBlendTreeDirectional2D._p.set(...this._parameterValues);\n\t\tconst pLength = AnimBlendTreeDirectional2D._p.length();\n\t\tweightSum = 0.0;\n\t\tweightedDurationSum = 0.0;\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst child = this._children[i];\n\t\t\tconst pi = child.point;\n\t\t\tconst piLength = child.pointLength;\n\t\t\tlet minj = Number.MAX_VALUE;\n\t\t\tfor (let j = 0; j < this._children.length; j++) {\n\t\t\t\tif (i === j) continue;\n\t\t\t\tconst pipj = this.pointCache(i, j);\n\t\t\t\tconst pjLength = this._children[j].pointLength;\n\t\t\t\tAnimBlendTreeDirectional2D._pip.set((pLength - piLength) / ((pjLength + piLength) / 2), Vec2.angleRad(pi, AnimBlendTreeDirectional2D._p) * 2.0);\n\t\t\t\tconst result = math.clamp(1.0 - Math.abs(AnimBlendTreeDirectional2D._pip.dot(pipj) / pipj.lengthSq()), 0.0, 1.0);\n\t\t\t\tif (result < minj) minj = result;\n\t\t\t}\n\t\t\tchild.weight = minj;\n\t\t\tweightSum += minj;\n\t\t\tif (this._syncAnimations) {\n\t\t\t\tweightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst child = this._children[i];\n\t\t\tchild.weight = child._weight / weightSum;\n\t\t\tif (this._syncAnimations) {\n\t\t\t\tconst weightedChildDuration = child.animTrack.duration / weightedDurationSum * weightSum;\n\t\t\t\tchild.weightedSpeed = child.absoluteSpeed * weightedChildDuration;\n\t\t\t}\n\t\t}\n\t}\n}\nAnimBlendTreeDirectional2D._p = new Vec2();\nAnimBlendTreeDirectional2D._pip = new Vec2();\n\nexport { AnimBlendTreeDirectional2D };\n","import { AnimBlendTree } from './anim-blend-tree.js';\n\nclass AnimBlendTreeDirect extends AnimBlendTree {\n\tcalculateWeights() {\n\t\tif (this.updateParameterValues()) return;\n\t\tlet weightSum = 0.0;\n\t\tlet weightedDurationSum = 0.0;\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tweightSum += Math.max(this._parameterValues[i], 0.0);\n\t\t\tif (this._syncAnimations) {\n\t\t\t\tconst child = this._children[i];\n\t\t\t\tweightedDurationSum += child.animTrack.duration / child.absoluteSpeed * child.weight;\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst child = this._children[i];\n\t\t\tconst weight = Math.max(this._parameterValues[i], 0.0);\n\t\t\tif (weightSum) {\n\t\t\t\tchild.weight = weight / weightSum;\n\t\t\t\tif (this._syncAnimations) {\n\t\t\t\t\tchild.weightedSpeed = child.animTrack.duration / child.absoluteSpeed / weightedDurationSum;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tchild.weight = 0.0;\n\t\t\t\tif (this._syncAnimations) {\n\t\t\t\t\tchild.weightedSpeed = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { AnimBlendTreeDirect };\n","import { AnimNode } from './anim-node.js';\n\nclass AnimBlendTree extends AnimNode {\n\tconstructor(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {\n\t\tsuper(state, parent, name, point);\n\t\tthis._parameters = parameters;\n\t\tthis._parameterValues = new Array(parameters.length);\n\t\tthis._children = [];\n\t\tthis._findParameter = findParameter;\n\t\tthis._syncAnimations = syncAnimations !== false;\n\t\tthis._pointCache = {};\n\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\tconst child = children[i];\n\t\t\tif (child.children) {\n\t\t\t\tthis._children.push(createTree(child.type, state, this, child.name, 1.0, child.parameter ? [child.parameter] : child.parameters, child.children, child.syncAnimations, createTree, findParameter));\n\t\t\t} else {\n\t\t\t\tthis._children.push(new AnimNode(state, this, child.name, child.point, child.speed));\n\t\t\t}\n\t\t}\n\t}\n\tget weight() {\n\t\tthis.calculateWeights();\n\t\treturn this._parent ? this._parent.weight * this._weight : this._weight;\n\t}\n\tget syncAnimations() {\n\t\treturn this._syncAnimations;\n\t}\n\tgetChild(name) {\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tif (this._children[i].name === name) return this._children[i];\n\t\t}\n\t\treturn null;\n\t}\n\tupdateParameterValues() {\n\t\tlet paramsEqual = true;\n\t\tfor (let i = 0; i < this._parameterValues.length; i++) {\n\t\t\tconst updatedParameter = this._findParameter(this._parameters[i]).value;\n\t\t\tif (this._parameterValues[i] !== updatedParameter) {\n\t\t\t\tthis._parameterValues[i] = updatedParameter;\n\t\t\t\tparamsEqual = false;\n\t\t\t}\n\t\t}\n\t\treturn paramsEqual;\n\t}\n\tgetNodeWeightedDuration(i) {\n\t\treturn this._children[i].animTrack.duration / this._children[i].speedMultiplier * this._children[i].weight;\n\t}\n\tgetNodeCount() {\n\t\tlet count = 0;\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst child = this._children[i];\n\t\t\tif (child.constructor === AnimBlendTree) {\n\t\t\t\tcount += this._children[i].getNodeCount();\n\t\t\t} else {\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n\nexport { AnimBlendTree };\n","import { extends as _extends } from '../../../../_virtual/_rollupPluginBabelHelpers.js';\nimport { sortPriority } from '../../../core/sort.js';\nimport { AnimClip } from '../evaluator/anim-clip.js';\nimport { AnimState } from './anim-state.js';\nimport { AnimNode } from './anim-node.js';\nimport { AnimTransition } from './anim-transition.js';\nimport { ANIM_STATE_START, ANIM_INTERRUPTION_NONE, ANIM_STATE_END, ANIM_STATE_ANY, ANIM_NOT_EQUAL_TO, ANIM_EQUAL_TO, ANIM_LESS_THAN_EQUAL_TO, ANIM_GREATER_THAN_EQUAL_TO, ANIM_LESS_THAN, ANIM_GREATER_THAN, ANIM_INTERRUPTION_NEXT_PREV, ANIM_INTERRUPTION_PREV_NEXT, ANIM_INTERRUPTION_NEXT, ANIM_INTERRUPTION_PREV, ANIM_PARAMETER_TRIGGER, ANIM_CONTROL_STATES } from './constants.js';\n\nclass AnimController {\n\tconstructor(animEvaluator, states, transitions, activate, eventHandler, findParameter, consumeTrigger) {\n\t\tthis._states = {};\n\t\tthis._stateNames = [];\n\t\tthis._findTransitionsFromStateCache = {};\n\t\tthis._findTransitionsBetweenStatesCache = {};\n\t\tthis._previousStateName = null;\n\t\tthis._activeStateName = ANIM_STATE_START;\n\t\tthis._activeStateDuration = 0;\n\t\tthis._activeStateDurationDirty = true;\n\t\tthis._playing = false;\n\t\tthis._activate = void 0;\n\t\tthis._transitions = void 0;\n\t\tthis._currTransitionTime = 1;\n\t\tthis._totalTransitionTime = 1;\n\t\tthis._isTransitioning = false;\n\t\tthis._transitionInterruptionSource = ANIM_INTERRUPTION_NONE;\n\t\tthis._transitionPreviousStates = [];\n\t\tthis._timeInState = 0;\n\t\tthis._timeInStateBefore = 0;\n\t\tthis.findParameter = name => {\n\t\t\treturn this._findParameter(name);\n\t\t};\n\t\tthis._animEvaluator = animEvaluator;\n\t\tthis._eventHandler = eventHandler;\n\t\tthis._findParameter = findParameter;\n\t\tthis._consumeTrigger = consumeTrigger;\n\t\tfor (let i = 0; i < states.length; i++) {\n\t\t\tthis._states[states[i].name] = new AnimState(this, states[i].name, states[i].speed, states[i].loop, states[i].blendTree);\n\t\t\tthis._stateNames.push(states[i].name);\n\t\t}\n\t\tthis._transitions = transitions.map(transition => {\n\t\t\treturn new AnimTransition(_extends({}, transition));\n\t\t});\n\t\tthis._activate = activate;\n\t}\n\tget animEvaluator() {\n\t\treturn this._animEvaluator;\n\t}\n\tset activeState(stateName) {\n\t\tthis._activeStateName = stateName;\n\t}\n\tget activeState() {\n\t\treturn this._findState(this._activeStateName);\n\t}\n\tget activeStateName() {\n\t\treturn this._activeStateName;\n\t}\n\tget activeStateAnimations() {\n\t\treturn this.activeState.animations;\n\t}\n\tset previousState(stateName) {\n\t\tthis._previousStateName = stateName;\n\t}\n\tget previousState() {\n\t\treturn this._findState(this._previousStateName);\n\t}\n\tget previousStateName() {\n\t\treturn this._previousStateName;\n\t}\n\tget playable() {\n\t\tlet playable = true;\n\t\tfor (let i = 0; i < this._stateNames.length; i++) {\n\t\t\tif (!this._states[this._stateNames[i]].playable) {\n\t\t\t\tplayable = false;\n\t\t\t}\n\t\t}\n\t\treturn playable;\n\t}\n\tset playing(value) {\n\t\tthis._playing = value;\n\t}\n\tget playing() {\n\t\treturn this._playing;\n\t}\n\tget activeStateProgress() {\n\t\treturn this._getActiveStateProgressForTime(this._timeInState);\n\t}\n\tget activeStateDuration() {\n\t\tif (this._activeStateDurationDirty) {\n\t\t\tlet maxDuration = 0.0;\n\t\t\tfor (let i = 0; i < this.activeStateAnimations.length; i++) {\n\t\t\t\tconst activeClip = this._animEvaluator.findClip(this.activeStateAnimations[i].name);\n\t\t\t\tif (activeClip) {\n\t\t\t\t\tmaxDuration = Math.max(maxDuration, activeClip.track.duration);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._activeStateDuration = maxDuration;\n\t\t\tthis._activeStateDurationDirty = false;\n\t\t}\n\t\treturn this._activeStateDuration;\n\t}\n\tset activeStateCurrentTime(time) {\n\t\tthis._timeInStateBefore = time;\n\t\tthis._timeInState = time;\n\t\tfor (let i = 0; i < this.activeStateAnimations.length; i++) {\n\t\t\tconst clip = this.animEvaluator.findClip(this.activeStateAnimations[i].name);\n\t\t\tif (clip) {\n\t\t\t\tclip.time = time;\n\t\t\t}\n\t\t}\n\t}\n\tget activeStateCurrentTime() {\n\t\treturn this._timeInState;\n\t}\n\tget transitioning() {\n\t\treturn this._isTransitioning;\n\t}\n\tget transitionProgress() {\n\t\treturn this._currTransitionTime / this._totalTransitionTime;\n\t}\n\tget states() {\n\t\treturn this._stateNames;\n\t}\n\tassignMask(mask) {\n\t\treturn this._animEvaluator.assignMask(mask);\n\t}\n\t_findState(stateName) {\n\t\treturn this._states[stateName];\n\t}\n\t_getActiveStateProgressForTime(time) {\n\t\tif (this.activeStateName === ANIM_STATE_START || this.activeStateName === ANIM_STATE_END || this.activeStateName === ANIM_STATE_ANY) {\n\t\t\treturn 1.0;\n\t\t}\n\t\tconst activeClip = this._animEvaluator.findClip(this.activeStateAnimations[0].name);\n\t\tif (activeClip) {\n\t\t\treturn activeClip.progressForTime(time);\n\t\t}\n\t\treturn null;\n\t}\n\t_findTransitionsFromState(stateName) {\n\t\tlet transitions = this._findTransitionsFromStateCache[stateName];\n\t\tif (!transitions) {\n\t\t\ttransitions = this._transitions.filter(transition => {\n\t\t\t\treturn transition.from === stateName;\n\t\t\t});\n\t\t\tsortPriority(transitions);\n\t\t\tthis._findTransitionsFromStateCache[stateName] = transitions;\n\t\t}\n\t\treturn transitions;\n\t}\n\t_findTransitionsBetweenStates(sourceStateName, destinationStateName) {\n\t\tlet transitions = this._findTransitionsBetweenStatesCache[`${sourceStateName}->${destinationStateName}`];\n\t\tif (!transitions) {\n\t\t\ttransitions = this._transitions.filter(transition => {\n\t\t\t\treturn transition.from === sourceStateName && transition.to === destinationStateName;\n\t\t\t});\n\t\t\tsortPriority(transitions);\n\t\t\tthis._findTransitionsBetweenStatesCache[`${sourceStateName}->${destinationStateName}`] = transitions;\n\t\t}\n\t\treturn transitions;\n\t}\n\t_transitionHasConditionsMet(transition) {\n\t\tconst conditions = transition.conditions;\n\t\tfor (let i = 0; i < conditions.length; i++) {\n\t\t\tconst condition = conditions[i];\n\t\t\tconst parameter = this._findParameter(condition.parameterName);\n\t\t\tswitch (condition.predicate) {\n\t\t\t\tcase ANIM_GREATER_THAN:\n\t\t\t\t\tif (!(parameter.value > condition.value)) return false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ANIM_LESS_THAN:\n\t\t\t\t\tif (!(parameter.value < condition.value)) return false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ANIM_GREATER_THAN_EQUAL_TO:\n\t\t\t\t\tif (!(parameter.value >= condition.value)) return false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ANIM_LESS_THAN_EQUAL_TO:\n\t\t\t\t\tif (!(parameter.value <= condition.value)) return false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ANIM_EQUAL_TO:\n\t\t\t\t\tif (!(parameter.value === condition.value)) return false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase ANIM_NOT_EQUAL_TO:\n\t\t\t\t\tif (!(parameter.value !== condition.value)) return false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t_findTransition(from, to) {\n\t\tlet transitions = [];\n\t\tif (from && to) {\n\t\t\ttransitions = transitions.concat(this._findTransitionsBetweenStates(from, to));\n\t\t} else {\n\t\t\tif (!this._isTransitioning) {\n\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));\n\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));\n\t\t\t} else {\n\t\t\t\tswitch (this._transitionInterruptionSource) {\n\t\t\t\t\tcase ANIM_INTERRUPTION_PREV:\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ANIM_INTERRUPTION_NEXT:\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ANIM_INTERRUPTION_PREV_NEXT:\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ANIM_INTERRUPTION_NEXT_PREV:\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(this._activeStateName));\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(this._previousStateName));\n\t\t\t\t\t\ttransitions = transitions.concat(this._findTransitionsFromState(ANIM_STATE_ANY));\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttransitions = transitions.filter(transition => {\n\t\t\tif (transition.to === this.activeStateName) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (transition.hasExitTime) {\n\t\t\t\tlet progressBefore = this._getActiveStateProgressForTime(this._timeInStateBefore);\n\t\t\t\tlet progress = this._getActiveStateProgressForTime(this._timeInState);\n\t\t\t\tif (transition.exitTime < 1.0 && this.activeState.loop) {\n\t\t\t\t\tprogressBefore -= Math.floor(progressBefore);\n\t\t\t\t\tprogress -= Math.floor(progress);\n\t\t\t\t}\n\t\t\t\tif (progress === progressBefore) {\n\t\t\t\t\tif (progress !== transition.exitTime) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t} else if (!(transition.exitTime > progressBefore && transition.exitTime <= progress)) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this._transitionHasConditionsMet(transition);\n\t\t});\n\t\tif (transitions.length > 0) {\n\t\t\tconst transition = transitions[0];\n\t\t\tif (transition.to === ANIM_STATE_END) {\n\t\t\t\tconst startTransition = this._findTransitionsFromState(ANIM_STATE_START)[0];\n\t\t\t\ttransition.to = startTransition.to;\n\t\t\t}\n\t\t\treturn transition;\n\t\t}\n\t\treturn null;\n\t}\n\tupdateStateFromTransition(transition) {\n\t\tlet state;\n\t\tlet animation;\n\t\tlet clip;\n\t\tthis.previousState = transition.from ? this.activeStateName : null;\n\t\tthis.activeState = transition.to;\n\t\tthis._activeStateDurationDirty = true;\n\t\tfor (let i = 0; i < transition.conditions.length; i++) {\n\t\t\tconst condition = transition.conditions[i];\n\t\t\tconst parameter = this._findParameter(condition.parameterName);\n\t\t\tif (parameter.type === ANIM_PARAMETER_TRIGGER) {\n\t\t\t\tthis._consumeTrigger(condition.parameterName);\n\t\t\t}\n\t\t}\n\t\tif (this.previousState) {\n\t\t\tif (!this._isTransitioning) {\n\t\t\t\tthis._transitionPreviousStates = [];\n\t\t\t}\n\t\t\tthis._transitionPreviousStates.push({\n\t\t\t\tname: this._previousStateName,\n\t\t\t\tweight: 1\n\t\t\t});\n\t\t\tconst interpolatedTime = Math.min(this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1, 1.0);\n\t\t\tfor (let i = 0; i < this._transitionPreviousStates.length; i++) {\n\t\t\t\tif (!this._isTransitioning) {\n\t\t\t\t\tthis._transitionPreviousStates[i].weight = 1.0;\n\t\t\t\t} else if (i !== this._transitionPreviousStates.length - 1) {\n\t\t\t\t\tthis._transitionPreviousStates[i].weight *= 1.0 - interpolatedTime;\n\t\t\t\t} else {\n\t\t\t\t\tthis._transitionPreviousStates[i].weight = interpolatedTime;\n\t\t\t\t}\n\t\t\t\tstate = this._findState(this._transitionPreviousStates[i].name);\n\t\t\t\tfor (let j = 0; j < state.animations.length; j++) {\n\t\t\t\t\tanimation = state.animations[j];\n\t\t\t\t\tclip = this._animEvaluator.findClip(`${animation.name}.previous.${i}`);\n\t\t\t\t\tif (!clip) {\n\t\t\t\t\t\tclip = this._animEvaluator.findClip(animation.name);\n\t\t\t\t\t\tclip.name = `${animation.name}.previous.${i}`;\n\t\t\t\t\t}\n\t\t\t\t\tif (i !== this._transitionPreviousStates.length - 1) {\n\t\t\t\t\t\tclip.pause();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._isTransitioning = true;\n\t\tthis._totalTransitionTime = transition.time;\n\t\tthis._currTransitionTime = 0;\n\t\tthis._transitionInterruptionSource = transition.interruptionSource;\n\t\tconst activeState = this.activeState;\n\t\tconst hasTransitionOffset = transition.transitionOffset && transition.transitionOffset > 0.0 && transition.transitionOffset < 1.0;\n\t\tlet timeInState = 0;\n\t\tlet timeInStateBefore = 0;\n\t\tif (hasTransitionOffset) {\n\t\t\tconst offsetTime = activeState.timelineDuration * transition.transitionOffset;\n\t\t\ttimeInState = offsetTime;\n\t\t\ttimeInStateBefore = offsetTime;\n\t\t}\n\t\tthis._timeInState = timeInState;\n\t\tthis._timeInStateBefore = timeInStateBefore;\n\t\tfor (let i = 0; i < activeState.animations.length; i++) {\n\t\t\tclip = this._animEvaluator.findClip(activeState.animations[i].name);\n\t\t\tif (!clip) {\n\t\t\t\tconst speed = Number.isFinite(activeState.animations[i].speed) ? activeState.animations[i].speed : activeState.speed;\n\t\t\t\tclip = new AnimClip(activeState.animations[i].animTrack, this._timeInState, speed, true, activeState.loop, this._eventHandler);\n\t\t\t\tclip.name = activeState.animations[i].name;\n\t\t\t\tthis._animEvaluator.addClip(clip);\n\t\t\t} else {\n\t\t\t\tclip.reset();\n\t\t\t}\n\t\t\tif (transition.time > 0) {\n\t\t\t\tclip.blendWeight = 0.0;\n\t\t\t} else {\n\t\t\t\tclip.blendWeight = activeState.animations[i].normalizedWeight;\n\t\t\t}\n\t\t\tclip.play();\n\t\t\tif (hasTransitionOffset) {\n\t\t\t\tclip.time = activeState.timelineDuration * transition.transitionOffset;\n\t\t\t} else {\n\t\t\t\tconst startTime = activeState.speed >= 0 ? 0 : this.activeStateDuration;\n\t\t\t\tclip.time = startTime;\n\t\t\t}\n\t\t}\n\t}\n\t_transitionToState(newStateName) {\n\t\tif (!this._findState(newStateName)) {\n\t\t\treturn;\n\t\t}\n\t\tlet transition = this._findTransition(this._activeStateName, newStateName);\n\t\tif (!transition) {\n\t\t\tthis._animEvaluator.removeClips();\n\t\t\ttransition = new AnimTransition({\n\t\t\t\tfrom: null,\n\t\t\t\tto: newStateName\n\t\t\t});\n\t\t}\n\t\tthis.updateStateFromTransition(transition);\n\t}\n\tassignAnimation(pathString, animTrack, speed, loop) {\n\t\tconst path = pathString.split('.');\n\t\tlet state = this._findState(path[0]);\n\t\tif (!state) {\n\t\t\tstate = new AnimState(this, path[0], speed);\n\t\t\tthis._states[path[0]] = state;\n\t\t\tthis._stateNames.push(path[0]);\n\t\t}\n\t\tstate.addAnimation(path, animTrack);\n\t\tthis._animEvaluator.updateClipTrack(state.name, animTrack);\n\t\tif (speed !== undefined) {\n\t\t\tstate.speed = speed;\n\t\t}\n\t\tif (loop !== undefined) {\n\t\t\tstate.loop = loop;\n\t\t}\n\t\tif (!this._playing && this._activate && this.playable) {\n\t\t\tthis.play();\n\t\t}\n\t\tthis._activeStateDurationDirty = true;\n\t}\n\tremoveNodeAnimations(nodeName) {\n\t\tif (ANIM_CONTROL_STATES.indexOf(nodeName) !== -1) {\n\t\t\treturn false;\n\t\t}\n\t\tconst state = this._findState(nodeName);\n\t\tif (!state) {\n\t\t\treturn false;\n\t\t}\n\t\tstate.animations = [];\n\t\treturn true;\n\t}\n\tplay(stateName) {\n\t\tif (stateName) {\n\t\t\tthis._transitionToState(stateName);\n\t\t}\n\t\tthis._playing = true;\n\t}\n\tpause() {\n\t\tthis._playing = false;\n\t}\n\treset() {\n\t\tthis._previousStateName = null;\n\t\tthis._activeStateName = ANIM_STATE_START;\n\t\tthis._playing = false;\n\t\tthis._currTransitionTime = 1.0;\n\t\tthis._totalTransitionTime = 1.0;\n\t\tthis._isTransitioning = false;\n\t\tthis._timeInState = 0;\n\t\tthis._timeInStateBefore = 0;\n\t\tthis._animEvaluator.removeClips();\n\t}\n\trebind() {\n\t\tthis._animEvaluator.rebind();\n\t}\n\tupdate(dt) {\n\t\tif (!this._playing) {\n\t\t\treturn;\n\t\t}\n\t\tlet state;\n\t\tlet animation;\n\t\tlet clip;\n\t\tif (this.activeState.loop || this._timeInState < this.activeStateDuration) {\n\t\t\tthis._timeInStateBefore = this._timeInState;\n\t\t\tthis._timeInState += dt * this.activeState.speed;\n\t\t\tif (!this.activeState.loop && this._timeInState > this.activeStateDuration) {\n\t\t\t\tthis._timeInState = this.activeStateDuration;\n\t\t\t\tdt = this.activeStateDuration - this._timeInStateBefore;\n\t\t\t}\n\t\t}\n\t\tconst transition = this._findTransition(this._activeStateName);\n\t\tif (transition) {\n\t\t\tthis.updateStateFromTransition(transition);\n\t\t}\n\t\tif (this._isTransitioning) {\n\t\t\tthis._currTransitionTime += dt;\n\t\t\tif (this._currTransitionTime <= this._totalTransitionTime) {\n\t\t\t\tconst interpolatedTime = this._totalTransitionTime !== 0 ? this._currTransitionTime / this._totalTransitionTime : 1;\n\t\t\t\tfor (let i = 0; i < this._transitionPreviousStates.length; i++) {\n\t\t\t\t\tstate = this._findState(this._transitionPreviousStates[i].name);\n\t\t\t\t\tconst stateWeight = this._transitionPreviousStates[i].weight;\n\t\t\t\t\tfor (let j = 0; j < state.animations.length; j++) {\n\t\t\t\t\t\tanimation = state.animations[j];\n\t\t\t\t\t\tclip = this._animEvaluator.findClip(`${animation.name}.previous.${i}`);\n\t\t\t\t\t\tif (clip) {\n\t\t\t\t\t\t\tclip.blendWeight = (1.0 - interpolatedTime) * animation.normalizedWeight * stateWeight;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstate = this.activeState;\n\t\t\t\tfor (let i = 0; i < state.animations.length; i++) {\n\t\t\t\t\tanimation = state.animations[i];\n\t\t\t\t\tthis._animEvaluator.findClip(animation.name).blendWeight = interpolatedTime * animation.normalizedWeight;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._isTransitioning = false;\n\t\t\t\tconst activeClips = this.activeStateAnimations.length;\n\t\t\t\tconst totalClips = this._animEvaluator.clips.length;\n\t\t\t\tfor (let i = 0; i < totalClips - activeClips; i++) {\n\t\t\t\t\tthis._animEvaluator.removeClip(0);\n\t\t\t\t}\n\t\t\t\tthis._transitionPreviousStates = [];\n\t\t\t\tstate = this.activeState;\n\t\t\t\tfor (let i = 0; i < state.animations.length; i++) {\n\t\t\t\t\tanimation = state.animations[i];\n\t\t\t\t\tclip = this._animEvaluator.findClip(animation.name);\n\t\t\t\t\tif (clip) {\n\t\t\t\t\t\tclip.blendWeight = animation.normalizedWeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.activeState._blendTree.constructor !== AnimNode) {\n\t\t\t\tstate = this.activeState;\n\t\t\t\tfor (let i = 0; i < state.animations.length; i++) {\n\t\t\t\t\tanimation = state.animations[i];\n\t\t\t\t\tclip = this._animEvaluator.findClip(animation.name);\n\t\t\t\t\tif (clip) {\n\t\t\t\t\t\tclip.blendWeight = animation.normalizedWeight;\n\t\t\t\t\t\tif (animation.parent.syncAnimations) {\n\t\t\t\t\t\t\tclip.speed = animation.speed;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._animEvaluator.update(dt, this.activeState.hasAnimations);\n\t}\n}\n\nexport { AnimController };\n","import { Vec2 } from '../../../core/math/vec2.js';\n\nclass AnimNode {\n\tconstructor(state, parent, name, point, speed = 1) {\n\t\tthis._state = state;\n\t\tthis._parent = parent;\n\t\tthis._name = name;\n\t\tif (Array.isArray(point)) {\n\t\t\tthis._point = new Vec2(point[0], point[1]);\n\t\t\tthis._pointLength = this._point.length();\n\t\t} else {\n\t\t\tthis._point = point;\n\t\t\tthis._pointLength = point;\n\t\t}\n\t\tthis._speed = speed;\n\t\tthis._weightedSpeed = 1.0;\n\t\tthis._weight = 1.0;\n\t\tthis._animTrack = null;\n\t}\n\tget parent() {\n\t\treturn this._parent;\n\t}\n\tget name() {\n\t\treturn this._name;\n\t}\n\tget path() {\n\t\treturn this._parent ? `${this._parent.path}.${this._name}` : this._name;\n\t}\n\tget point() {\n\t\treturn this._point;\n\t}\n\tget pointLength() {\n\t\treturn this._pointLength;\n\t}\n\tset weight(value) {\n\t\tthis._weight = value;\n\t}\n\tget weight() {\n\t\treturn this._parent ? this._parent.weight * this._weight : this._weight;\n\t}\n\tget normalizedWeight() {\n\t\tconst totalWeight = this._state.totalWeight;\n\t\tif (totalWeight === 0.0) return 0.0;\n\t\treturn this.weight / totalWeight;\n\t}\n\tget speed() {\n\t\treturn this._weightedSpeed * this._speed;\n\t}\n\tget absoluteSpeed() {\n\t\treturn Math.abs(this._speed);\n\t}\n\tset weightedSpeed(weightedSpeed) {\n\t\tthis._weightedSpeed = weightedSpeed;\n\t}\n\tget weightedSpeed() {\n\t\treturn this._weightedSpeed;\n\t}\n\tset animTrack(value) {\n\t\tthis._animTrack = value;\n\t}\n\tget animTrack() {\n\t\treturn this._animTrack;\n\t}\n}\n\nexport { AnimNode };\n","import { AnimTrack } from '../evaluator/anim-track.js';\nimport { AnimBlendTree1D } from './anim-blend-tree-1d.js';\nimport { AnimBlendTreeCartesian2D } from './anim-blend-tree-2d-cartesian.js';\nimport { AnimBlendTreeDirectional2D } from './anim-blend-tree-2d-directional.js';\nimport { AnimBlendTreeDirect } from './anim-blend-tree-direct.js';\nimport { AnimNode } from './anim-node.js';\nimport { ANIM_BLEND_DIRECT, ANIM_BLEND_2D_DIRECTIONAL, ANIM_BLEND_2D_CARTESIAN, ANIM_BLEND_1D, ANIM_CONTROL_STATES } from './constants.js';\n\nclass AnimState {\n\tconstructor(controller, name, speed = 1, loop = true, blendTree) {\n\t\tthis._animations = {};\n\t\tthis._animationList = [];\n\t\tthis._controller = controller;\n\t\tthis._name = name;\n\t\tthis._speed = speed;\n\t\tthis._loop = loop;\n\t\tthis._hasAnimations = false;\n\t\tif (blendTree) {\n\t\t\tthis._blendTree = this._createTree(blendTree.type, this, null, name, 1.0, blendTree.parameter ? [blendTree.parameter] : blendTree.parameters, blendTree.children, blendTree.syncAnimations, this._createTree, this._controller.findParameter);\n\t\t} else {\n\t\t\tthis._blendTree = new AnimNode(this, null, name, 1.0, speed);\n\t\t}\n\t}\n\t_createTree(type, state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter) {\n\t\tswitch (type) {\n\t\t\tcase ANIM_BLEND_1D:\n\t\t\t\treturn new AnimBlendTree1D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);\n\t\t\tcase ANIM_BLEND_2D_CARTESIAN:\n\t\t\t\treturn new AnimBlendTreeCartesian2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);\n\t\t\tcase ANIM_BLEND_2D_DIRECTIONAL:\n\t\t\t\treturn new AnimBlendTreeDirectional2D(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);\n\t\t\tcase ANIM_BLEND_DIRECT:\n\t\t\t\treturn new AnimBlendTreeDirect(state, parent, name, point, parameters, children, syncAnimations, createTree, findParameter);\n\t\t}\n\t\treturn undefined;\n\t}\n\t_getNodeFromPath(path) {\n\t\tlet currNode = this._blendTree;\n\t\tfor (let i = 1; i < path.length; i++) {\n\t\t\tcurrNode = currNode.getChild(path[i]);\n\t\t}\n\t\treturn currNode;\n\t}\n\taddAnimation(path, animTrack) {\n\t\tconst pathString = path.join('.');\n\t\tconst indexOfAnimation = this._animationList.findIndex(animation => {\n\t\t\treturn animation.path === pathString;\n\t\t});\n\t\tif (indexOfAnimation >= 0) {\n\t\t\tthis._animationList[indexOfAnimation].animTrack = animTrack;\n\t\t} else {\n\t\t\tconst node = this._getNodeFromPath(path);\n\t\t\tnode.animTrack = animTrack;\n\t\t\tthis._animationList.push(node);\n\t\t}\n\t\tthis._updateHasAnimations();\n\t}\n\t_updateHasAnimations() {\n\t\tthis._hasAnimations = this._animationList.length > 0 && this._animationList.every(animation => animation.animTrack && animation.animTrack !== AnimTrack.EMPTY);\n\t}\n\tget name() {\n\t\treturn this._name;\n\t}\n\tset animations(value) {\n\t\tthis._animationList = value;\n\t\tthis._updateHasAnimations();\n\t}\n\tget animations() {\n\t\treturn this._animationList;\n\t}\n\tget hasAnimations() {\n\t\treturn this._hasAnimations;\n\t}\n\tset speed(value) {\n\t\tthis._speed = value;\n\t}\n\tget speed() {\n\t\treturn this._speed;\n\t}\n\tset loop(value) {\n\t\tthis._loop = value;\n\t}\n\tget loop() {\n\t\treturn this._loop;\n\t}\n\tget nodeCount() {\n\t\tif (!this._blendTree || this._blendTree.constructor === AnimNode) return 1;\n\t\treturn this._blendTree.getNodeCount();\n\t}\n\tget playable() {\n\t\treturn ANIM_CONTROL_STATES.indexOf(this.name) !== -1 || this.animations.length === this.nodeCount;\n\t}\n\tget looping() {\n\t\tif (this.animations.length > 0) {\n\t\t\tconst trackClipName = `${this.name}.${this.animations[0].animTrack.name}`;\n\t\t\tconst trackClip = this._controller.animEvaluator.findClip(trackClipName);\n\t\t\tif (trackClip) {\n\t\t\t\treturn trackClip.loop;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tget totalWeight() {\n\t\tlet sum = 0;\n\t\tfor (let i = 0; i < this.animations.length; i++) {\n\t\t\tsum += this.animations[i].weight;\n\t\t}\n\t\treturn sum;\n\t}\n\tget timelineDuration() {\n\t\tlet duration = 0;\n\t\tfor (let i = 0; i < this.animations.length; i++) {\n\t\t\tconst animation = this.animations[i];\n\t\t\tif (animation.animTrack.duration > duration) {\n\t\t\t\tduration = animation.animTrack.duration;\n\t\t\t}\n\t\t}\n\t\treturn duration;\n\t}\n}\n\nexport { AnimState };\n","import { ANIM_INTERRUPTION_NONE } from './constants.js';\n\nclass AnimTransition {\n\tconstructor({\n\t\tfrom,\n\t\tto,\n\t\ttime = 0,\n\t\tpriority = 0,\n\t\tconditions = [],\n\t\texitTime = null,\n\t\ttransitionOffset = null,\n\t\tinterruptionSource = ANIM_INTERRUPTION_NONE\n\t}) {\n\t\tthis._from = from;\n\t\tthis._to = to;\n\t\tthis._time = time;\n\t\tthis._priority = priority;\n\t\tthis._conditions = conditions;\n\t\tthis._exitTime = exitTime;\n\t\tthis._transitionOffset = transitionOffset;\n\t\tthis._interruptionSource = interruptionSource;\n\t}\n\tget from() {\n\t\treturn this._from;\n\t}\n\tset to(value) {\n\t\tthis._to = value;\n\t}\n\tget to() {\n\t\treturn this._to;\n\t}\n\tget time() {\n\t\treturn this._time;\n\t}\n\tget priority() {\n\t\treturn this._priority;\n\t}\n\tget conditions() {\n\t\treturn this._conditions;\n\t}\n\tget exitTime() {\n\t\treturn this._exitTime;\n\t}\n\tget transitionOffset() {\n\t\treturn this._transitionOffset;\n\t}\n\tget interruptionSource() {\n\t\treturn this._interruptionSource;\n\t}\n\tget hasExitTime() {\n\t\treturn !!this.exitTime;\n\t}\n}\n\nexport { AnimTransition };\n","const ANIM_INTERRUPTION_NONE = 'NONE';\nconst ANIM_INTERRUPTION_PREV = 'PREV_STATE';\nconst ANIM_INTERRUPTION_NEXT = 'NEXT_STATE';\nconst ANIM_INTERRUPTION_PREV_NEXT = 'PREV_STATE_NEXT_STATE';\nconst ANIM_INTERRUPTION_NEXT_PREV = 'NEXT_STATE_PREV_STATE';\nconst ANIM_GREATER_THAN = 'GREATER_THAN';\nconst ANIM_LESS_THAN = 'LESS_THAN';\nconst ANIM_GREATER_THAN_EQUAL_TO = 'GREATER_THAN_EQUAL_TO';\nconst ANIM_LESS_THAN_EQUAL_TO = 'LESS_THAN_EQUAL_TO';\nconst ANIM_EQUAL_TO = 'EQUAL_TO';\nconst ANIM_NOT_EQUAL_TO = 'NOT_EQUAL_TO';\nconst ANIM_PARAMETER_INTEGER = 'INTEGER';\nconst ANIM_PARAMETER_FLOAT = 'FLOAT';\nconst ANIM_PARAMETER_BOOLEAN = 'BOOLEAN';\nconst ANIM_PARAMETER_TRIGGER = 'TRIGGER';\nconst ANIM_BLEND_1D = '1D';\nconst ANIM_BLEND_2D_DIRECTIONAL = '2D_DIRECTIONAL';\nconst ANIM_BLEND_2D_CARTESIAN = '2D_CARTESIAN';\nconst ANIM_BLEND_DIRECT = 'DIRECT';\nconst ANIM_STATE_START = 'START';\nconst ANIM_STATE_END = 'END';\nconst ANIM_STATE_ANY = 'ANY';\nconst ANIM_CONTROL_STATES = [ANIM_STATE_START, ANIM_STATE_END, ANIM_STATE_ANY];\nconst ANIM_LAYER_OVERWRITE = 'OVERWRITE';\nconst ANIM_LAYER_ADDITIVE = 'ADDITIVE';\n\nexport { ANIM_BLEND_1D, ANIM_BLEND_2D_CARTESIAN, ANIM_BLEND_2D_DIRECTIONAL, ANIM_BLEND_DIRECT, ANIM_CONTROL_STATES, ANIM_EQUAL_TO, ANIM_GREATER_THAN, ANIM_GREATER_THAN_EQUAL_TO, ANIM_INTERRUPTION_NEXT, ANIM_INTERRUPTION_NEXT_PREV, ANIM_INTERRUPTION_NONE, ANIM_INTERRUPTION_PREV, ANIM_INTERRUPTION_PREV_NEXT, ANIM_LAYER_ADDITIVE, ANIM_LAYER_OVERWRITE, ANIM_LESS_THAN, ANIM_LESS_THAN_EQUAL_TO, ANIM_NOT_EQUAL_TO, ANIM_PARAMETER_BOOLEAN, ANIM_PARAMETER_FLOAT, ANIM_PARAMETER_INTEGER, ANIM_PARAMETER_TRIGGER, ANIM_STATE_ANY, ANIM_STATE_END, ANIM_STATE_START };\n","class AnimBlend {\n\tstatic dot(a, b) {\n\t\tconst len = a.length;\n\t\tlet result = 0;\n\t\tfor (let i = 0; i < len; ++i) {\n\t\t\tresult += a[i] * b[i];\n\t\t}\n\t\treturn result;\n\t}\n\tstatic normalize(a) {\n\t\tlet l = AnimBlend.dot(a, a);\n\t\tif (l > 0) {\n\t\t\tl = 1.0 / Math.sqrt(l);\n\t\t\tconst len = a.length;\n\t\t\tfor (let i = 0; i < len; ++i) {\n\t\t\t\ta[i] *= l;\n\t\t\t}\n\t\t}\n\t}\n\tstatic set(a, b, type) {\n\t\tconst len = a.length;\n\t\tif (type === 'quaternion') {\n\t\t\tlet l = AnimBlend.dot(b, b);\n\t\t\tif (l > 0) {\n\t\t\t\tl = 1.0 / Math.sqrt(l);\n\t\t\t}\n\t\t\tfor (let i = 0; i < len; ++i) {\n\t\t\t\ta[i] = b[i] * l;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < len; ++i) {\n\t\t\t\ta[i] = b[i];\n\t\t\t}\n\t\t}\n\t}\n\tstatic blendVec(a, b, t, additive) {\n\t\tconst it = additive ? 1.0 : 1.0 - t;\n\t\tconst len = a.length;\n\t\tfor (let i = 0; i < len; ++i) {\n\t\t\ta[i] = a[i] * it + b[i] * t;\n\t\t}\n\t}\n\tstatic blendQuat(a, b, t, additive) {\n\t\tconst len = a.length;\n\t\tconst it = additive ? 1.0 : 1.0 - t;\n\t\tif (AnimBlend.dot(a, b) < 0) {\n\t\t\tt = -t;\n\t\t}\n\t\tfor (let i = 0; i < len; ++i) {\n\t\t\ta[i] = a[i] * it + b[i] * t;\n\t\t}\n\t\tif (!additive) {\n\t\t\tAnimBlend.normalize(a);\n\t\t}\n\t}\n\tstatic blend(a, b, t, type, additive) {\n\t\tif (type === 'quaternion') {\n\t\t\tAnimBlend.blendQuat(a, b, t, additive);\n\t\t} else {\n\t\t\tAnimBlend.blendVec(a, b, t, additive);\n\t\t}\n\t}\n\tstatic stableSort(a, lessFunc) {\n\t\tconst len = a.length;\n\t\tfor (let i = 0; i < len - 1; ++i) {\n\t\t\tfor (let j = i + 1; j < len; ++j) {\n\t\t\t\tif (lessFunc(a[j], a[i])) {\n\t\t\t\t\tconst tmp = a[i];\n\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\ta[j] = tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { AnimBlend };\n","import { math } from '../../../core/math/math.js';\nimport { INTERPOLATION_STEP, INTERPOLATION_CUBIC, INTERPOLATION_LINEAR } from '../constants.js';\n\nclass AnimCache {\n\tconstructor() {\n\t\tthis._left = Infinity;\n\t\tthis._right = -Infinity;\n\t\tthis._len = 0;\n\t\tthis._recip = 0;\n\t\tthis._p0 = 0;\n\t\tthis._p1 = 0;\n\t\tthis._t = 0;\n\t\tthis._hermite = {\n\t\t\tvalid: false,\n\t\t\tp0: 0,\n\t\t\tm0: 0,\n\t\t\tp1: 0,\n\t\t\tm1: 0\n\t\t};\n\t}\n\tupdate(time, input) {\n\t\tif (time < this._left || time >= this._right) {\n\t\t\tconst len = input.length;\n\t\t\tif (!len) {\n\t\t\t\tthis._left = -Infinity;\n\t\t\t\tthis._right = Infinity;\n\t\t\t\tthis._len = 0;\n\t\t\t\tthis._recip = 0;\n\t\t\t\tthis._p0 = this._p1 = 0;\n\t\t\t} else {\n\t\t\t\tif (time < input[0]) {\n\t\t\t\t\tthis._left = -Infinity;\n\t\t\t\t\tthis._right = input[0];\n\t\t\t\t\tthis._len = 0;\n\t\t\t\t\tthis._recip = 0;\n\t\t\t\t\tthis._p0 = this._p1 = 0;\n\t\t\t\t} else if (time >= input[len - 1]) {\n\t\t\t\t\tthis._left = input[len - 1];\n\t\t\t\t\tthis._right = Infinity;\n\t\t\t\t\tthis._len = 0;\n\t\t\t\t\tthis._recip = 0;\n\t\t\t\t\tthis._p0 = this._p1 = len - 1;\n\t\t\t\t} else {\n\t\t\t\t\tconst index = this._findKey(time, input);\n\t\t\t\t\tthis._left = input[index];\n\t\t\t\t\tthis._right = input[index + 1];\n\t\t\t\t\tthis._len = this._right - this._left;\n\t\t\t\t\tconst diff = 1.0 / this._len;\n\t\t\t\t\tthis._recip = isFinite(diff) ? diff : 0;\n\t\t\t\t\tthis._p0 = index;\n\t\t\t\t\tthis._p1 = index + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._t = this._recip === 0 ? 0 : (time - this._left) * this._recip;\n\t\tthis._hermite.valid = false;\n\t}\n\t_findKey(time, input) {\n\t\tlet index = 0;\n\t\twhile (time >= input[index + 1]) {\n\t\t\tindex++;\n\t\t}\n\t\treturn index;\n\t}\n\teval(result, interpolation, output) {\n\t\tconst data = output._data;\n\t\tconst comp = output._components;\n\t\tconst idx0 = this._p0 * comp;\n\t\tif (interpolation === INTERPOLATION_STEP) {\n\t\t\tfor (let i = 0; i < comp; ++i) {\n\t\t\t\tresult[i] = data[idx0 + i];\n\t\t\t}\n\t\t} else {\n\t\t\tconst t = this._t;\n\t\t\tconst idx1 = this._p1 * comp;\n\t\t\tswitch (interpolation) {\n\t\t\t\tcase INTERPOLATION_LINEAR:\n\t\t\t\t\tfor (let i = 0; i < comp; ++i) {\n\t\t\t\t\t\tresult[i] = math.lerp(data[idx0 + i], data[idx1 + i], t);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase INTERPOLATION_CUBIC:\n\t\t\t\t\t{\n\t\t\t\t\t\tconst hermite = this._hermite;\n\t\t\t\t\t\tif (!hermite.valid) {\n\t\t\t\t\t\t\tconst t2 = t * t;\n\t\t\t\t\t\t\tconst twot = t + t;\n\t\t\t\t\t\t\tconst omt = 1 - t;\n\t\t\t\t\t\t\tconst omt2 = omt * omt;\n\t\t\t\t\t\t\thermite.valid = true;\n\t\t\t\t\t\t\thermite.p0 = (1 + twot) * omt2;\n\t\t\t\t\t\t\thermite.m0 = t * omt2;\n\t\t\t\t\t\t\thermite.p1 = t2 * (3 - twot);\n\t\t\t\t\t\t\thermite.m1 = t2 * (t - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst p0 = (this._p0 * 3 + 1) * comp;\n\t\t\t\t\t\tconst m0 = (this._p0 * 3 + 2) * comp;\n\t\t\t\t\t\tconst p1 = (this._p1 * 3 + 1) * comp;\n\t\t\t\t\t\tconst m1 = (this._p1 * 3 + 0) * comp;\n\t\t\t\t\t\tfor (let i = 0; i < comp; ++i) {\n\t\t\t\t\t\t\tresult[i] = hermite.p0 * data[p0 + i] + hermite.m0 * data[m0 + i] * this._len + hermite.p1 * data[p1 + i] + hermite.m1 * data[m1 + i] * this._len;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { AnimCache };\n","import { extends as _extends } from '../../../../_virtual/_rollupPluginBabelHelpers.js';\nimport { AnimSnapshot } from './anim-snapshot.js';\n\nclass AnimClip {\n\tconstructor(track, time, speed, playing, loop, eventHandler) {\n\t\tthis._name = track.name;\n\t\tthis._track = track;\n\t\tthis._snapshot = new AnimSnapshot(track);\n\t\tthis._playing = playing;\n\t\tthis._time = time;\n\t\tthis._speed = speed;\n\t\tthis._loop = loop;\n\t\tthis._blendWeight = 1.0;\n\t\tthis._blendOrder = 0.0;\n\t\tthis._eventHandler = eventHandler;\n\t\tthis.alignCursorToCurrentTime();\n\t}\n\tset name(name) {\n\t\tthis._name = name;\n\t}\n\tget name() {\n\t\treturn this._name;\n\t}\n\tset track(track) {\n\t\tthis._track = track;\n\t\tthis._snapshot = new AnimSnapshot(track);\n\t}\n\tget track() {\n\t\treturn this._track;\n\t}\n\tget snapshot() {\n\t\treturn this._snapshot;\n\t}\n\tset time(time) {\n\t\tthis._time = time;\n\t\tthis.alignCursorToCurrentTime();\n\t}\n\tget time() {\n\t\treturn this._time;\n\t}\n\tset speed(speed) {\n\t\tconst signChanged = Math.sign(speed) !== Math.sign(this._speed);\n\t\tthis._speed = speed;\n\t\tif (signChanged) {\n\t\t\tthis.alignCursorToCurrentTime();\n\t\t}\n\t}\n\tget speed() {\n\t\treturn this._speed;\n\t}\n\tset loop(loop) {\n\t\tthis._loop = loop;\n\t}\n\tget loop() {\n\t\treturn this._loop;\n\t}\n\tset blendWeight(blendWeight) {\n\t\tthis._blendWeight = blendWeight;\n\t}\n\tget blendWeight() {\n\t\treturn this._blendWeight;\n\t}\n\tset blendOrder(blendOrder) {\n\t\tthis._blendOrder = blendOrder;\n\t}\n\tget blendOrder() {\n\t\treturn this._blendOrder;\n\t}\n\tset eventCursor(value) {\n\t\tthis._eventCursor = value;\n\t}\n\tget eventCursor() {\n\t\treturn this._eventCursor;\n\t}\n\tget eventCursorEnd() {\n\t\treturn this.isReverse ? 0 : this._track.events.length - 1;\n\t}\n\tget nextEvent() {\n\t\treturn this._track.events[this._eventCursor];\n\t}\n\tget isReverse() {\n\t\treturn this._speed < 0;\n\t}\n\tnextEventAheadOfTime(time) {\n\t\tif (!this.nextEvent) return false;\n\t\treturn this.isReverse ? this.nextEvent.time <= time : this.nextEvent.time >= time;\n\t}\n\tnextEventBehindTime(time) {\n\t\tif (!this.nextEvent) return false;\n\t\tif (time === this.track.duration) {\n\t\t\treturn this.isReverse ? this.nextEvent.time >= time : this.nextEvent.time <= time;\n\t\t}\n\t\treturn this.isReverse ? this.nextEvent.time > time : this.nextEvent.time < time;\n\t}\n\tresetEventCursor() {\n\t\tthis._eventCursor = this.isReverse ? this._track.events.length - 1 : 0;\n\t}\n\tmoveEventCursor() {\n\t\tthis._eventCursor += this.isReverse ? -1 : 1;\n\t\tif (this._eventCursor >= this.track.events.length) {\n\t\t\tthis._eventCursor = 0;\n\t\t} else if (this._eventCursor < 0) {\n\t\t\tthis._eventCursor = this.track.events.length - 1;\n\t\t}\n\t}\n\tclipFrameTime(frameEndTime) {\n\t\tconst eventFrame = AnimClip.eventFrame;\n\t\teventFrame.start = 0;\n\t\teventFrame.end = frameEndTime;\n\t\teventFrame.residual = 0;\n\t\tif (this.isReverse) {\n\t\t\tif (frameEndTime < 0) {\n\t\t\t\teventFrame.start = this.track.duration;\n\t\t\t\teventFrame.end = 0;\n\t\t\t\teventFrame.residual = frameEndTime + this.track.duration;\n\t\t\t}\n\t\t} else {\n\t\t\tif (frameEndTime > this.track.duration) {\n\t\t\t\teventFrame.start = 0;\n\t\t\t\teventFrame.end = this.track.duration;\n\t\t\t\teventFrame.residual = frameEndTime - this.track.duration;\n\t\t\t}\n\t\t}\n\t}\n\talignCursorToCurrentTime() {\n\t\tthis.resetEventCursor();\n\t\twhile (this.nextEventBehindTime(this._time) && this._eventCursor !== this.eventCursorEnd) {\n\t\t\tthis.moveEventCursor();\n\t\t}\n\t}\n\tfireNextEvent() {\n\t\tthis._eventHandler.fire(this.nextEvent.name, _extends({\n\t\t\ttrack: this.track\n\t\t}, this.nextEvent));\n\t\tthis.moveEventCursor();\n\t}\n\tfireNextEventInFrame(frameStartTime, frameEndTime) {\n\t\tif (this.nextEventAheadOfTime(frameStartTime) && this.nextEventBehindTime(frameEndTime)) {\n\t\t\tthis.fireNextEvent();\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tactiveEventsForFrame(frameStartTime, frameEndTime) {\n\t\tconst eventFrame = AnimClip.eventFrame;\n\t\tthis.clipFrameTime(frameEndTime);\n\t\tconst initialCursor = this.eventCursor;\n\t\twhile (this.fireNextEventInFrame(frameStartTime, eventFrame.end)) {\n\t\t\tif (initialCursor === this.eventCursor) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (this.loop && Math.abs(eventFrame.residual) > 0) {\n\t\t\tthis.activeEventsForFrame(eventFrame.start, eventFrame.residual);\n\t\t}\n\t}\n\tprogressForTime(time) {\n\t\treturn time * this._speed / this._track.duration;\n\t}\n\t_update(deltaTime) {\n\t\tif (this._playing) {\n\t\t\tlet time = this._time;\n\t\t\tconst duration = this._track.duration;\n\t\t\tconst speed = this._speed;\n\t\t\tconst loop = this._loop;\n\t\t\tif (this._track.events.length > 0 && duration > 0) {\n\t\t\t\tthis.activeEventsForFrame(time, time + speed * deltaTime);\n\t\t\t}\n\t\t\ttime += speed * deltaTime;\n\t\t\tif (speed >= 0) {\n\t\t\t\tif (time > duration) {\n\t\t\t\t\tif (loop) {\n\t\t\t\t\t\ttime = time % duration || 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttime = this._track.duration;\n\t\t\t\t\t\tthis.pause();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (time < 0) {\n\t\t\t\t\tif (loop) {\n\t\t\t\t\t\ttime = duration + (time % duration || 0);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttime = 0;\n\t\t\t\t\t\tthis.pause();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._time = time;\n\t\t}\n\t\tif (this._time !== this._snapshot._time) {\n\t\t\tthis._track.eval(this._time, this._snapshot);\n\t\t}\n\t}\n\tplay() {\n\t\tthis._playing = true;\n\t\tthis._time = 0;\n\t}\n\tstop() {\n\t\tthis._playing = false;\n\t\tthis._time = 0;\n\t}\n\tpause() {\n\t\tthis._playing = false;\n\t}\n\tresume() {\n\t\tthis._playing = true;\n\t}\n\treset() {\n\t\tthis._time = 0;\n\t}\n}\nAnimClip.eventFrame = {\n\tstart: 0,\n\tend: 0,\n\tresidual: 0\n};\n\nexport { AnimClip };\n","class AnimCurve {\n\tconstructor(paths, input, output, interpolation) {\n\t\tthis._paths = paths;\n\t\tthis._input = input;\n\t\tthis._output = output;\n\t\tthis._interpolation = interpolation;\n\t}\n\tget paths() {\n\t\treturn this._paths;\n\t}\n\tget input() {\n\t\treturn this._input;\n\t}\n\tget output() {\n\t\treturn this._output;\n\t}\n\tget interpolation() {\n\t\treturn this._interpolation;\n\t}\n}\n\nexport { AnimCurve };\n","class AnimData {\n\tconstructor(components, data) {\n\t\tthis._components = components;\n\t\tthis._data = data;\n\t}\n\tget components() {\n\t\treturn this._components;\n\t}\n\tget data() {\n\t\treturn this._data;\n\t}\n}\n\nexport { AnimData };\n","import { AnimTargetValue } from './anim-target-value.js';\nimport { AnimBlend } from './anim-blend.js';\n\nclass AnimEvaluator {\n\tconstructor(binder) {\n\t\tthis._binder = binder;\n\t\tthis._clips = [];\n\t\tthis._inputs = [];\n\t\tthis._outputs = [];\n\t\tthis._targets = {};\n\t}\n\tget clips() {\n\t\treturn this._clips;\n\t}\n\taddClip(clip) {\n\t\tconst targets = this._targets;\n\t\tconst binder = this._binder;\n\t\tconst curves = clip.track.curves;\n\t\tconst snapshot = clip.snapshot;\n\t\tconst inputs = [];\n\t\tconst outputs = [];\n\t\tfor (let i = 0; i < curves.length; ++i) {\n\t\t\tconst curve = curves[i];\n\t\t\tconst paths = curve.paths;\n\t\t\tfor (let j = 0; j < paths.length; ++j) {\n\t\t\t\tconst path = paths[j];\n\t\t\t\tconst resolved = binder.resolve(path);\n\t\t\t\tlet target = targets[resolved && resolved.targetPath || null];\n\t\t\t\tif (!target && resolved) {\n\t\t\t\t\ttarget = {\n\t\t\t\t\t\ttarget: resolved,\n\t\t\t\t\t\tvalue: [],\n\t\t\t\t\t\tcurves: 0,\n\t\t\t\t\t\tblendCounter: 0\n\t\t\t\t\t};\n\t\t\t\t\tfor (let k = 0; k < target.target.components; ++k) {\n\t\t\t\t\t\ttarget.value.push(0);\n\t\t\t\t\t}\n\t\t\t\t\ttargets[resolved.targetPath] = target;\n\t\t\t\t\tif (binder.animComponent) {\n\t\t\t\t\t\tif (!binder.animComponent.targets[resolved.targetPath]) {\n\t\t\t\t\t\t\tlet type;\n\t\t\t\t\t\t\tif (resolved.targetPath.substring(resolved.targetPath.length - 13) === 'localRotation') {\n\t\t\t\t\t\t\t\ttype = AnimTargetValue.TYPE_QUAT;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttype = AnimTargetValue.TYPE_VEC3;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbinder.animComponent.targets[resolved.targetPath] = new AnimTargetValue(binder.animComponent, type);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbinder.animComponent.targets[resolved.targetPath].layerCounter++;\n\t\t\t\t\t\tbinder.animComponent.targets[resolved.targetPath].setMask(binder.layerIndex, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (target) {\n\t\t\t\t\ttarget.curves++;\n\t\t\t\t\tinputs.push(snapshot._results[i]);\n\t\t\t\t\toutputs.push(target);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._clips.push(clip);\n\t\tthis._inputs.push(inputs);\n\t\tthis._outputs.push(outputs);\n\t}\n\tremoveClip(index) {\n\t\tconst targets = this._targets;\n\t\tconst binder = this._binder;\n\t\tconst clips = this._clips;\n\t\tconst clip = clips[index];\n\t\tconst curves = clip.track.curves;\n\t\tfor (let i = 0; i < curves.length; ++i) {\n\t\t\tconst curve = curves[i];\n\t\t\tconst paths = curve.paths;\n\t\t\tfor (let j = 0; j < paths.length; ++j) {\n\t\t\t\tconst path = paths[j];\n\t\t\t\tconst target = this._binder.resolve(path);\n\t\t\t\tif (target) {\n\t\t\t\t\ttarget.curves--;\n\t\t\t\t\tif (target.curves === 0) {\n\t\t\t\t\t\tbinder.unresolve(path);\n\t\t\t\t\t\tdelete targets[target.targetPath];\n\t\t\t\t\t\tif (binder.animComponent) {\n\t\t\t\t\t\t\tbinder.animComponent.targets[target.targetPath].layerCounter--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tclips.splice(index, 1);\n\t\tthis._inputs.splice(index, 1);\n\t\tthis._outputs.splice(index, 1);\n\t}\n\tremoveClips() {\n\t\twhile (this._clips.length > 0) {\n\t\t\tthis.removeClip(0);\n\t\t}\n\t}\n\tupdateClipTrack(name, animTrack) {\n\t\tthis._clips.forEach(clip => {\n\t\t\tif (clip.name.includes(name)) {\n\t\t\t\tclip.track = animTrack;\n\t\t\t}\n\t\t});\n\t\tthis.rebind();\n\t}\n\tfindClip(name) {\n\t\tconst clips = this._clips;\n\t\tfor (let i = 0; i < clips.length; ++i) {\n\t\t\tconst clip = clips[i];\n\t\t\tif (clip.name === name) {\n\t\t\t\treturn clip;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\trebind() {\n\t\tthis._binder.rebind();\n\t\tthis._targets = {};\n\t\tconst clips = [...this.clips];\n\t\tthis.removeClips();\n\t\tclips.forEach(clip => {\n\t\t\tthis.addClip(clip);\n\t\t});\n\t}\n\tassignMask(mask) {\n\t\treturn this._binder.assignMask(mask);\n\t}\n\tupdate(deltaTime, outputAnimation = true) {\n\t\tconst clips = this._clips;\n\t\tconst order = clips.map((c, i) => {\n\t\t\treturn i;\n\t\t});\n\t\tAnimBlend.stableSort(order, (a, b) => {\n\t\t\treturn clips[a].blendOrder < clips[b].blendOrder;\n\t\t});\n\t\tfor (let i = 0; i < order.length; ++i) {\n\t\t\tconst index = order[i];\n\t\t\tconst clip = clips[index];\n\t\t\tconst inputs = this._inputs[index];\n\t\t\tconst outputs = this._outputs[index];\n\t\t\tconst blendWeight = clip.blendWeight;\n\t\t\tif (blendWeight > 0.0) {\n\t\t\t\tclip._update(deltaTime);\n\t\t\t}\n\t\t\tif (!outputAnimation) break;\n\t\t\tlet input;\n\t\t\tlet output;\n\t\t\tlet value;\n\t\t\tif (blendWeight >= 1.0) {\n\t\t\t\tfor (let j = 0; j < inputs.length; ++j) {\n\t\t\t\t\tinput = inputs[j];\n\t\t\t\t\toutput = outputs[j];\n\t\t\t\t\tvalue = output.value;\n\t\t\t\t\tAnimBlend.set(value, input, output.target.type);\n\t\t\t\t\toutput.blendCounter++;\n\t\t\t\t}\n\t\t\t} else if (blendWeight > 0.0) {\n\t\t\t\tfor (let j = 0; j < inputs.length; ++j) {\n\t\t\t\t\tinput = inputs[j];\n\t\t\t\t\toutput = outputs[j];\n\t\t\t\t\tvalue = output.value;\n\t\t\t\t\tif (output.blendCounter === 0) {\n\t\t\t\t\t\tAnimBlend.set(value, input, output.target.type);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tAnimBlend.blend(value, input, blendWeight, output.target.type);\n\t\t\t\t\t}\n\t\t\t\t\toutput.blendCounter++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst targets = this._targets;\n\t\tconst binder = this._binder;\n\t\tfor (const path in targets) {\n\t\t\tif (targets.hasOwnProperty(path)) {\n\t\t\t\tconst target = targets[path];\n\t\t\t\tif (binder.animComponent && target.target.isTransform) {\n\t\t\t\t\tconst animTarget = binder.animComponent.targets[path];\n\t\t\t\t\tif (animTarget.counter === animTarget.layerCounter) {\n\t\t\t\t\t\tanimTarget.counter = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (!animTarget.path) {\n\t\t\t\t\t\tanimTarget.path = path;\n\t\t\t\t\t\tanimTarget.baseValue = target.target.get();\n\t\t\t\t\t\tanimTarget.setter = target.target.set;\n\t\t\t\t\t}\n\t\t\t\t\tanimTarget.updateValue(binder.layerIndex, target.value);\n\t\t\t\t\tanimTarget.counter++;\n\t\t\t\t} else {\n\t\t\t\t\ttarget.target.set(target.value);\n\t\t\t\t}\n\t\t\t\ttarget.blendCounter = 0;\n\t\t\t}\n\t\t}\n\t\tthis._binder.update(deltaTime);\n\t}\n}\n\nexport { AnimEvaluator };\n","class AnimEvents {\n\tconstructor(events) {\n\t\tthis._events = [...events];\n\t\tthis._events.sort((a, b) => a.time - b.time);\n\t}\n\tget events() {\n\t\treturn this._events;\n\t}\n}\n\nexport { AnimEvents };\n","import { AnimCache } from './anim-cache.js';\n\nclass AnimSnapshot {\n\tconstructor(animTrack) {\n\t\tthis._name = `${animTrack.name}Snapshot`;\n\t\tthis._time = -1;\n\t\tthis._cache = [];\n\t\tthis._results = [];\n\t\tfor (let i = 0; i < animTrack._inputs.length; ++i) {\n\t\t\tthis._cache[i] = new AnimCache();\n\t\t}\n\t\tconst curves = animTrack._curves;\n\t\tconst outputs = animTrack._outputs;\n\t\tfor (let i = 0; i < curves.length; ++i) {\n\t\t\tconst curve = curves[i];\n\t\t\tconst output = outputs[curve._output];\n\t\t\tconst storage = [];\n\t\t\tfor (let j = 0; j < output._components; ++j) {\n\t\t\t\tstorage[j] = 0;\n\t\t\t}\n\t\t\tthis._results[i] = storage;\n\t\t}\n\t}\n}\n\nexport { AnimSnapshot };\n","import { Quat } from '../../../core/math/quat.js';\nimport { ANIM_LAYER_OVERWRITE, ANIM_LAYER_ADDITIVE } from '../controller/constants.js';\nimport { AnimBlend } from './anim-blend.js';\nimport { math } from '../../../core/math/math.js';\n\nclass AnimTargetValue {\n\tconstructor(component, type) {\n\t\tthis._component = component;\n\t\tthis.mask = new Int8Array(component.layers.length);\n\t\tthis.weights = new Float32Array(component.layers.length);\n\t\tthis.totalWeight = 0;\n\t\tthis.counter = 0;\n\t\tthis.layerCounter = 0;\n\t\tthis.valueType = type;\n\t\tthis.dirty = true;\n\t\tthis.value = type === AnimTargetValue.TYPE_QUAT ? [0, 0, 0, 1] : [0, 0, 0];\n\t\tthis.baseValue = null;\n\t\tthis.setter = null;\n\t}\n\tget _normalizeWeights() {\n\t\treturn this._component.normalizeWeights;\n\t}\n\tgetWeight(index) {\n\t\tif (this.dirty) this.updateWeights();\n\t\tif (this._normalizeWeights && this.totalWeight === 0 || !this.mask[index]) {\n\t\t\treturn 0;\n\t\t} else if (this._normalizeWeights) {\n\t\t\treturn this.weights[index] / this.totalWeight;\n\t\t}\n\t\treturn math.clamp(this.weights[index], 0, 1);\n\t}\n\t_layerBlendType(index) {\n\t\treturn this._component.layers[index].blendType;\n\t}\n\tsetMask(index, value) {\n\t\tthis.mask[index] = value;\n\t\tif (this._normalizeWeights) {\n\t\t\tif (this._component.layers[index].blendType === ANIM_LAYER_OVERWRITE) {\n\t\t\t\tthis.mask = this.mask.fill(0, 0, index);\n\t\t\t}\n\t\t\tthis.dirty = true;\n\t\t}\n\t}\n\tupdateWeights() {\n\t\tthis.totalWeight = 0;\n\t\tfor (let i = 0; i < this.weights.length; i++) {\n\t\t\tthis.weights[i] = this._component.layers[i].weight;\n\t\t\tthis.totalWeight += this.mask[i] * this.weights[i];\n\t\t}\n\t\tthis.dirty = false;\n\t}\n\tupdateValue(index, value) {\n\t\tif (this.counter === 0) {\n\t\t\tAnimBlend.set(this.value, AnimTargetValue.IDENTITY_QUAT_ARR, this.valueType);\n\t\t\tif (!this._normalizeWeights) {\n\t\t\t\tAnimBlend.blend(this.value, this.baseValue, 1, this.valueType);\n\t\t\t}\n\t\t}\n\t\tif (!this.mask[index] || this.getWeight(index) === 0) return;\n\t\tif (this._layerBlendType(index) === ANIM_LAYER_ADDITIVE && !this._normalizeWeights) {\n\t\t\tif (this.valueType === AnimTargetValue.TYPE_QUAT) {\n\t\t\t\tconst v = AnimTargetValue.q1.set(this.value[0], this.value[1], this.value[2], this.value[3]);\n\t\t\t\tconst aV1 = AnimTargetValue.q2.set(this.baseValue[0], this.baseValue[1], this.baseValue[2], this.baseValue[3]);\n\t\t\t\tconst aV2 = AnimTargetValue.q3.set(value[0], value[1], value[2], value[3]);\n\t\t\t\tconst aV = aV1.invert().mul(aV2);\n\t\t\t\taV.slerp(Quat.IDENTITY, aV, this.getWeight(index));\n\t\t\t\tv.mul(aV);\n\t\t\t\tAnimTargetValue.quatArr[0] = v.x;\n\t\t\t\tAnimTargetValue.quatArr[1] = v.y;\n\t\t\t\tAnimTargetValue.quatArr[2] = v.z;\n\t\t\t\tAnimTargetValue.quatArr[3] = v.w;\n\t\t\t\tAnimBlend.set(this.value, AnimTargetValue.quatArr, this.valueType);\n\t\t\t} else {\n\t\t\t\tAnimTargetValue.vecArr[0] = value[0] - this.baseValue[0];\n\t\t\t\tAnimTargetValue.vecArr[1] = value[1] - this.baseValue[1];\n\t\t\t\tAnimTargetValue.vecArr[2] = value[2] - this.baseValue[2];\n\t\t\t\tAnimBlend.blend(this.value, AnimTargetValue.vecArr, this.getWeight(index), this.valueType, true);\n\t\t\t}\n\t\t} else {\n\t\t\tAnimBlend.blend(this.value, value, this.getWeight(index), this.valueType);\n\t\t}\n\t\tif (this.setter) this.setter(this.value);\n\t}\n\tunbind() {\n\t\tif (this.setter) {\n\t\t\tthis.setter(this.baseValue);\n\t\t}\n\t}\n}\nAnimTargetValue.TYPE_QUAT = 'quaternion';\nAnimTargetValue.TYPE_VEC3 = 'vector3';\nAnimTargetValue.q1 = new Quat();\nAnimTargetValue.q2 = new Quat();\nAnimTargetValue.q3 = new Quat();\nAnimTargetValue.quatArr = [0, 0, 0, 1];\nAnimTargetValue.vecArr = [0, 0, 0];\nAnimTargetValue.IDENTITY_QUAT_ARR = [0, 0, 0, 1];\n\nexport { AnimTargetValue };\n","class AnimTarget {\n\tconstructor(func, type, components, targetPath) {\n\t\tif (func.set) {\n\t\t\tthis._set = func.set;\n\t\t\tthis._get = func.get;\n\t\t} else {\n\t\t\tthis._set = func;\n\t\t}\n\t\tthis._type = type;\n\t\tthis._components = components;\n\t\tthis._targetPath = targetPath;\n\t\tthis._isTransform = this._targetPath.substring(this._targetPath.length - 13) === 'localRotation' || this._targetPath.substring(this._targetPath.length - 13) === 'localPosition' || this._targetPath.substring(this._targetPath.length - 10) === 'localScale';\n\t}\n\tget set() {\n\t\treturn this._set;\n\t}\n\tget get() {\n\t\treturn this._get;\n\t}\n\tget type() {\n\t\treturn this._type;\n\t}\n\tget components() {\n\t\treturn this._components;\n\t}\n\tget targetPath() {\n\t\treturn this._targetPath;\n\t}\n\tget isTransform() {\n\t\treturn this._isTransform;\n\t}\n}\n\nexport { AnimTarget };\n","import { AnimEvents } from './anim-events.js';\n\nvar _AnimTrack;\nclass AnimTrack {\n\tconstructor(name, duration, inputs, outputs, curves, animEvents = new AnimEvents([])) {\n\t\tthis._name = name;\n\t\tthis._duration = duration;\n\t\tthis._inputs = inputs;\n\t\tthis._outputs = outputs;\n\t\tthis._curves = curves;\n\t\tthis._animEvents = animEvents;\n\t}\n\tget name() {\n\t\treturn this._name;\n\t}\n\tget duration() {\n\t\treturn this._duration;\n\t}\n\tget inputs() {\n\t\treturn this._inputs;\n\t}\n\tget outputs() {\n\t\treturn this._outputs;\n\t}\n\tget curves() {\n\t\treturn this._curves;\n\t}\n\tset events(animEvents) {\n\t\tthis._animEvents = animEvents;\n\t}\n\tget events() {\n\t\treturn this._animEvents.events;\n\t}\n\teval(time, snapshot) {\n\t\tsnapshot._time = time;\n\t\tconst inputs = this._inputs;\n\t\tconst outputs = this._outputs;\n\t\tconst curves = this._curves;\n\t\tconst cache = snapshot._cache;\n\t\tconst results = snapshot._results;\n\t\tfor (let i = 0; i < inputs.length; ++i) {\n\t\t\tcache[i].update(time, inputs[i]._data);\n\t\t}\n\t\tfor (let i = 0; i < curves.length; ++i) {\n\t\t\tconst curve = curves[i];\n\t\t\tconst output = outputs[curve._output];\n\t\t\tconst result = results[i];\n\t\t\tcache[curve._input].eval(result, curve._interpolation, output);\n\t\t}\n\t}\n}\n_AnimTrack = AnimTrack;\nAnimTrack.EMPTY = Object.freeze(new _AnimTrack('empty', Number.MAX_VALUE, [], [], []));\n\nexport { AnimTrack };\n","class AnimStateGraph {\n\tconstructor(data) {\n\t\tthis._layers = [];\n\t\tthis._parameters = {};\n\t\tif (!Array.isArray(data.layers)) {\n\t\t\tfor (const layerId in data.layers) {\n\t\t\t\tconst dataLayer = data.layers[layerId];\n\t\t\t\tconst layer = {\n\t\t\t\t\tname: dataLayer.name,\n\t\t\t\t\tblendType: dataLayer.blendType,\n\t\t\t\t\tweight: dataLayer.weight,\n\t\t\t\t\tstates: [],\n\t\t\t\t\ttransitions: []\n\t\t\t\t};\n\t\t\t\tfor (let i = 0; i < dataLayer.states.length; i++) {\n\t\t\t\t\tlayer.states.push(data.states[dataLayer.states[i]]);\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < dataLayer.transitions.length; i++) {\n\t\t\t\t\tconst dataLayerTransition = data.transitions[dataLayer.transitions[i]];\n\t\t\t\t\tif (dataLayerTransition.conditions && !Array.isArray(dataLayerTransition.conditions)) {\n\t\t\t\t\t\tconst conditionKeys = Object.keys(dataLayerTransition.conditions);\n\t\t\t\t\t\tconst conditions = [];\n\t\t\t\t\t\tfor (let j = 0; j < conditionKeys.length; j++) {\n\t\t\t\t\t\t\tconst condition = dataLayerTransition.conditions[conditionKeys[j]];\n\t\t\t\t\t\t\tif (condition.parameterName) {\n\t\t\t\t\t\t\t\tconditions.push(condition);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdataLayerTransition.conditions = conditions;\n\t\t\t\t\t}\n\t\t\t\t\tif (Number.isInteger(dataLayerTransition.from)) {\n\t\t\t\t\t\tdataLayerTransition.from = data.states[dataLayerTransition.from].name;\n\t\t\t\t\t}\n\t\t\t\t\tif (Number.isInteger(dataLayerTransition.to)) {\n\t\t\t\t\t\tdataLayerTransition.to = data.states[dataLayerTransition.to].name;\n\t\t\t\t\t}\n\t\t\t\t\tlayer.transitions.push(dataLayerTransition);\n\t\t\t\t}\n\t\t\t\tthis._layers.push(layer);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._layers = data.layers;\n\t\t}\n\t\tfor (const paramId in data.parameters) {\n\t\t\tconst param = data.parameters[paramId];\n\t\t\tthis._parameters[param.name] = {\n\t\t\t\ttype: param.type,\n\t\t\t\tvalue: param.value\n\t\t\t};\n\t\t}\n\t}\n\tget parameters() {\n\t\treturn Object.assign({}, this._parameters);\n\t}\n\tget layers() {\n\t\treturn this._layers;\n\t}\n}\n\nexport { AnimStateGraph };\n","import { platform } from '../core/platform.js';\nimport { now } from '../core/time.js';\nimport { path } from '../core/path.js';\nimport { EventHandler } from '../core/event-handler.js';\nimport { Color } from '../core/math/color.js';\nimport { Mat4 } from '../core/math/mat4.js';\nimport { math } from '../core/math/math.js';\nimport { Quat } from '../core/math/quat.js';\nimport { Vec3 } from '../core/math/vec3.js';\nimport { PRIMITIVE_TRIANGLES, PRIMITIVE_TRISTRIP, PRIMITIVE_TRIFAN, CULLFACE_NONE } from '../platform/graphics/constants.js';\nimport { http } from '../platform/net/http.js';\nimport { LAYERID_WORLD, LAYERID_DEPTH, SORTMODE_NONE, LAYERID_SKYBOX, LAYERID_UI, SORTMODE_MANUAL, LAYERID_IMMEDIATE, SPECULAR_BLINN } from '../scene/constants.js';\nimport { setProgramLibrary } from '../scene/shader-lib/get-program-library.js';\nimport { ProgramLibrary } from '../scene/shader-lib/program-library.js';\nimport { ForwardRenderer } from '../scene/renderer/forward-renderer.js';\nimport { FrameGraph } from '../scene/frame-graph.js';\nimport { AreaLightLuts } from '../scene/area-light-luts.js';\nimport { Layer } from '../scene/layer.js';\nimport { LayerComposition } from '../scene/composition/layer-composition.js';\nimport { Scene } from '../scene/scene.js';\nimport { Material } from '../scene/materials/material.js';\nimport { StandardMaterial } from '../scene/materials/standard-material.js';\nimport { setDefaultMaterial } from '../scene/materials/default-material.js';\nimport { Asset } from './asset/asset.js';\nimport { AssetRegistry } from './asset/asset-registry.js';\nimport { BundleRegistry } from './bundle/bundle-registry.js';\nimport { ComponentSystemRegistry } from './components/registry.js';\nimport { BundleHandler } from './handlers/bundle.js';\nimport { ResourceLoader } from './handlers/loader.js';\nimport { I18n } from './i18n/i18n.js';\nimport { ScriptRegistry } from './script/script-registry.js';\nimport { Entity } from './entity.js';\nimport { SceneRegistry } from './scene-registry.js';\nimport { script } from './script.js';\nimport { ApplicationStats } from './stats.js';\nimport { FILLMODE_KEEP_ASPECT, RESOLUTION_FIXED, RESOLUTION_AUTO, FILLMODE_FILL_WINDOW } from './constants.js';\nimport { getApplication, setApplication } from './globals.js';\n\nclass Progress {\n\tconstructor(length) {\n\t\tthis.length = length;\n\t\tthis.count = 0;\n\t}\n\tinc() {\n\t\tthis.count++;\n\t}\n\tdone() {\n\t\treturn this.count === this.length;\n\t}\n}\nlet app = null;\nclass AppBase extends EventHandler {\n\tconstructor(canvas) {\n\t\tsuper();\n\t\tthis.frameRequestId = void 0;\n\t\tAppBase._applications[canvas.id] = this;\n\t\tsetApplication(this);\n\t\tapp = this;\n\t\tthis._destroyRequested = false;\n\t\tthis._inFrameUpdate = false;\n\t\tthis._time = 0;\n\t\tthis.timeScale = 1;\n\t\tthis.maxDeltaTime = 0.1;\n\t\tthis.frame = 0;\n\t\tthis.autoRender = true;\n\t\tthis.renderNextFrame = false;\n\t\tthis.useLegacyScriptAttributeCloning = script.legacy;\n\t\tthis._librariesLoaded = false;\n\t\tthis._fillMode = FILLMODE_KEEP_ASPECT;\n\t\tthis._resolutionMode = RESOLUTION_FIXED;\n\t\tthis._allowResize = true;\n\t\tthis.context = this;\n\t}\n\tinit(appOptions) {\n\t\tconst device = appOptions.graphicsDevice;\n\t\tthis.graphicsDevice = device;\n\t\tthis._initDefaultMaterial();\n\t\tthis._initProgramLibrary();\n\t\tthis.stats = new ApplicationStats(device);\n\t\tthis._soundManager = appOptions.soundManager;\n\t\tthis.loader = new ResourceLoader(this);\n\t\tthis._entityIndex = {};\n\t\tthis.scene = new Scene(device);\n\t\tthis._registerSceneImmediate(this.scene);\n\t\tthis.root = new Entity();\n\t\tthis.root._enabledInHierarchy = true;\n\t\tthis.assets = new AssetRegistry(this.loader);\n\t\tif (appOptions.assetPrefix) this.assets.prefix = appOptions.assetPrefix;\n\t\tthis.bundles = new BundleRegistry(this.assets);\n\t\tthis.enableBundles = typeof TextDecoder !== 'undefined';\n\t\tthis.scriptsOrder = appOptions.scriptsOrder || [];\n\t\tthis.scripts = new ScriptRegistry(this);\n\t\tthis.i18n = new I18n(this);\n\t\tthis.scenes = new SceneRegistry(this);\n\t\tthis.defaultLayerWorld = new Layer({\n\t\t\tname: 'World',\n\t\t\tid: LAYERID_WORLD\n\t\t});\n\t\tthis.defaultLayerDepth = new Layer({\n\t\t\tname: 'Depth',\n\t\t\tid: LAYERID_DEPTH,\n\t\t\tenabled: false,\n\t\t\topaqueSortMode: SORTMODE_NONE\n\t\t});\n\t\tthis.defaultLayerSkybox = new Layer({\n\t\t\tname: 'Skybox',\n\t\t\tid: LAYERID_SKYBOX,\n\t\t\topaqueSortMode: SORTMODE_NONE\n\t\t});\n\t\tthis.defaultLayerUi = new Layer({\n\t\t\tname: 'UI',\n\t\t\tid: LAYERID_UI,\n\t\t\ttransparentSortMode: SORTMODE_MANUAL\n\t\t});\n\t\tthis.defaultLayerImmediate = new Layer({\n\t\t\tname: 'Immediate',\n\t\t\tid: LAYERID_IMMEDIATE,\n\t\t\topaqueSortMode: SORTMODE_NONE\n\t\t});\n\t\tconst defaultLayerComposition = new LayerComposition('default');\n\t\tdefaultLayerComposition.pushOpaque(this.defaultLayerWorld);\n\t\tdefaultLayerComposition.pushOpaque(this.defaultLayerDepth);\n\t\tdefaultLayerComposition.pushOpaque(this.defaultLayerSkybox);\n\t\tdefaultLayerComposition.pushTransparent(this.defaultLayerWorld);\n\t\tdefaultLayerComposition.pushOpaque(this.defaultLayerImmediate);\n\t\tdefaultLayerComposition.pushTransparent(this.defaultLayerImmediate);\n\t\tdefaultLayerComposition.pushTransparent(this.defaultLayerUi);\n\t\tthis.scene.layers = defaultLayerComposition;\n\t\tAreaLightLuts.createPlaceholder(device);\n\t\tthis.renderer = new ForwardRenderer(device);\n\t\tthis.renderer.scene = this.scene;\n\t\tthis.frameGraph = new FrameGraph();\n\t\tthis.lightmapper = null;\n\t\tif (appOptions.lightmapper) {\n\t\t\tthis.lightmapper = new appOptions.lightmapper(device, this.root, this.scene, this.renderer, this.assets);\n\t\t\tthis.once('prerender', this._firstBake, this);\n\t\t}\n\t\tthis._batcher = null;\n\t\tif (appOptions.batchManager) {\n\t\t\tthis._batcher = new appOptions.batchManager(device, this.root, this.scene);\n\t\t\tthis.once('prerender', this._firstBatch, this);\n\t\t}\n\t\tthis.keyboard = appOptions.keyboard || null;\n\t\tthis.mouse = appOptions.mouse || null;\n\t\tthis.touch = appOptions.touch || null;\n\t\tthis.gamepads = appOptions.gamepads || null;\n\t\tthis.elementInput = appOptions.elementInput || null;\n\t\tif (this.elementInput) {\n\t\t\tthis.elementInput.app = this;\n\t\t}\n\t\tthis.xr = appOptions.xr ? new appOptions.xr(this) : null;\n\t\tif (this.elementInput) {\n\t\t\tthis.elementInput.attachSelectEvents();\n\t\t}\n\t\tthis._inTools = false;\n\t\tthis._skyboxAsset = null;\n\t\tthis._scriptPrefix = appOptions.scriptPrefix || '';\n\t\tif (this.enableBundles) {\n\t\t\tthis.loader.addHandler('bundle', new BundleHandler(this));\n\t\t}\n\t\tappOptions.resourceHandlers.forEach(resourceHandler => {\n\t\t\tconst handler = new resourceHandler(this);\n\t\t\tthis.loader.addHandler(handler.handlerType, handler);\n\t\t});\n\t\tthis.systems = new ComponentSystemRegistry();\n\t\tappOptions.componentSystems.forEach(componentSystem => {\n\t\t\tthis.systems.add(new componentSystem(this));\n\t\t});\n\t\tthis._visibilityChangeHandler = this.onVisibilityChange.bind(this);\n\t\tif (typeof document !== 'undefined') {\n\t\t\tif (document.hidden !== undefined) {\n\t\t\t\tthis._hiddenAttr = 'hidden';\n\t\t\t\tdocument.addEventListener('visibilitychange', this._visibilityChangeHandler, false);\n\t\t\t} else if (document.mozHidden !== undefined) {\n\t\t\t\tthis._hiddenAttr = 'mozHidden';\n\t\t\t\tdocument.addEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);\n\t\t\t} else if (document.msHidden !== undefined) {\n\t\t\t\tthis._hiddenAttr = 'msHidden';\n\t\t\t\tdocument.addEventListener('msvisibilitychange', this._visibilityChangeHandler, false);\n\t\t\t} else if (document.webkitHidden !== undefined) {\n\t\t\t\tthis._hiddenAttr = 'webkitHidden';\n\t\t\t\tdocument.addEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);\n\t\t\t}\n\t\t}\n\t\tthis.tick = makeTick(this);\n\t}\n\tstatic getApplication(id) {\n\t\treturn id ? AppBase._applications[id] : getApplication();\n\t}\n\t_initDefaultMaterial() {\n\t\tconst material = new StandardMaterial();\n\t\tmaterial.name = 'Default Material';\n\t\tmaterial.shadingModel = SPECULAR_BLINN;\n\t\tsetDefaultMaterial(this.graphicsDevice, material);\n\t}\n\t_initProgramLibrary() {\n\t\tconst library = new ProgramLibrary(this.graphicsDevice, new StandardMaterial());\n\t\tsetProgramLibrary(this.graphicsDevice, library);\n\t}\n\tget soundManager() {\n\t\treturn this._soundManager;\n\t}\n\tget batcher() {\n\t\treturn this._batcher;\n\t}\n\tget fillMode() {\n\t\treturn this._fillMode;\n\t}\n\tget resolutionMode() {\n\t\treturn this._resolutionMode;\n\t}\n\tconfigure(url, callback) {\n\t\thttp.get(url, (err, response) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst props = response.application_properties;\n\t\t\tconst scenes = response.scenes;\n\t\t\tconst assets = response.assets;\n\t\t\tthis._parseApplicationProperties(props, err => {\n\t\t\t\tthis._parseScenes(scenes);\n\t\t\t\tthis._parseAssets(assets);\n\t\t\t\tif (!err) {\n\t\t\t\t\tcallback(null);\n\t\t\t\t} else {\n\t\t\t\t\tcallback(err);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\tpreload(callback) {\n\t\tthis.fire('preload:start');\n\t\tconst assets = this.assets.list({\n\t\t\tpreload: true\n\t\t});\n\t\tconst progress = new Progress(assets.length);\n\t\tlet _done = false;\n\t\tconst done = () => {\n\t\t\tif (!this.graphicsDevice) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!_done && progress.done()) {\n\t\t\t\t_done = true;\n\t\t\t\tthis.fire('preload:end');\n\t\t\t\tcallback();\n\t\t\t}\n\t\t};\n\t\tconst total = assets.length;\n\t\tif (progress.length) {\n\t\t\tconst onAssetLoad = asset => {\n\t\t\t\tprogress.inc();\n\t\t\t\tthis.fire('preload:progress', progress.count / total);\n\t\t\t\tif (progress.done()) {\n\t\t\t\t\tdone();\n\t\t\t\t}\n\t\t\t};\n\t\t\tconst onAssetError = (err, asset) => {\n\t\t\t\tprogress.inc();\n\t\t\t\tthis.fire('preload:progress', progress.count / total);\n\t\t\t\tif (progress.done()) {\n\t\t\t\t\tdone();\n\t\t\t\t}\n\t\t\t};\n\t\t\tfor (let i = 0; i < assets.length; i++) {\n\t\t\t\tif (!assets[i].loaded) {\n\t\t\t\t\tassets[i].once('load', onAssetLoad);\n\t\t\t\t\tassets[i].once('error', onAssetError);\n\t\t\t\t\tthis.assets.load(assets[i]);\n\t\t\t\t} else {\n\t\t\t\t\tprogress.inc();\n\t\t\t\t\tthis.fire('preload:progress', progress.count / total);\n\t\t\t\t\tif (progress.done()) {\n\t\t\t\t\t\tdone();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdone();\n\t\t}\n\t}\n\t_preloadScripts(sceneData, callback) {\n\t\tif (!script.legacy) {\n\t\t\tcallback();\n\t\t\treturn;\n\t\t}\n\t\tthis.systems.script.preloading = true;\n\t\tconst scripts = this._getScriptReferences(sceneData);\n\t\tconst l = scripts.length;\n\t\tconst progress = new Progress(l);\n\t\tconst regex = /^https?:\\/\\//;\n\t\tif (l) {\n\t\t\tconst onLoad = (err, ScriptType) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t}\n\t\t\t\tprogress.inc();\n\t\t\t\tif (progress.done()) {\n\t\t\t\t\tthis.systems.script.preloading = false;\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t};\n\t\t\tfor (let i = 0; i < l; i++) {\n\t\t\t\tlet scriptUrl = scripts[i];\n\t\t\t\tif (!regex.test(scriptUrl.toLowerCase()) && this._scriptPrefix) {\n\t\t\t\t\tscriptUrl = path.join(this._scriptPrefix, scripts[i]);\n\t\t\t\t}\n\t\t\t\tthis.loader.load(scriptUrl, 'script', onLoad);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.systems.script.preloading = false;\n\t\t\tcallback();\n\t\t}\n\t}\n\t_parseApplicationProperties(props, callback) {\n\t\tif (typeof props.maxAssetRetries === 'number' && props.maxAssetRetries > 0) {\n\t\t\tthis.loader.enableRetry(props.maxAssetRetries);\n\t\t}\n\t\tif (!props.useDevicePixelRatio) {\n\t\t\tprops.useDevicePixelRatio = props.use_device_pixel_ratio;\n\t\t}\n\t\tif (!props.resolutionMode) {\n\t\t\tprops.resolutionMode = props.resolution_mode;\n\t\t}\n\t\tif (!props.fillMode) {\n\t\t\tprops.fillMode = props.fill_mode;\n\t\t}\n\t\tthis._width = props.width;\n\t\tthis._height = props.height;\n\t\tif (props.useDevicePixelRatio) {\n\t\t\tthis.graphicsDevice.maxPixelRatio = window.devicePixelRatio;\n\t\t}\n\t\tthis.setCanvasResolution(props.resolutionMode, this._width, this._height);\n\t\tthis.setCanvasFillMode(props.fillMode, this._width, this._height);\n\t\tif (props.layers && props.layerOrder) {\n\t\t\tconst composition = new LayerComposition('application');\n\t\t\tconst layers = {};\n\t\t\tfor (const key in props.layers) {\n\t\t\t\tconst data = props.layers[key];\n\t\t\t\tdata.id = parseInt(key, 10);\n\t\t\t\tdata.enabled = data.id !== LAYERID_DEPTH;\n\t\t\t\tlayers[key] = new Layer(data);\n\t\t\t}\n\t\t\tfor (let i = 0, len = props.layerOrder.length; i < len; i++) {\n\t\t\t\tconst sublayer = props.layerOrder[i];\n\t\t\t\tconst layer = layers[sublayer.layer];\n\t\t\t\tif (!layer) continue;\n\t\t\t\tif (sublayer.transparent) {\n\t\t\t\t\tcomposition.pushTransparent(layer);\n\t\t\t\t} else {\n\t\t\t\t\tcomposition.pushOpaque(layer);\n\t\t\t\t}\n\t\t\t\tcomposition.subLayerEnabled[i] = sublayer.enabled;\n\t\t\t}\n\t\t\tthis.scene.layers = composition;\n\t\t}\n\t\tif (props.batchGroups) {\n\t\t\tconst batcher = this.batcher;\n\t\t\tif (batcher) {\n\t\t\t\tfor (let i = 0, len = props.batchGroups.length; i < len; i++) {\n\t\t\t\t\tconst grp = props.batchGroups[i];\n\t\t\t\t\tbatcher.addGroup(grp.name, grp.dynamic, grp.maxAabbSize, grp.id, grp.layers);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (props.i18nAssets) {\n\t\t\tthis.i18n.assets = props.i18nAssets;\n\t\t}\n\t\tthis._loadLibraries(props.libraries, callback);\n\t}\n\t_loadLibraries(urls, callback) {\n\t\tconst len = urls.length;\n\t\tlet count = len;\n\t\tconst regex = /^https?:\\/\\//;\n\t\tif (len) {\n\t\t\tconst onLoad = (err, script) => {\n\t\t\t\tcount--;\n\t\t\t\tif (err) {\n\t\t\t\t\tcallback(err);\n\t\t\t\t} else if (count === 0) {\n\t\t\t\t\tthis.onLibrariesLoaded();\n\t\t\t\t\tcallback(null);\n\t\t\t\t}\n\t\t\t};\n\t\t\tfor (let i = 0; i < len; ++i) {\n\t\t\t\tlet url = urls[i];\n\t\t\t\tif (!regex.test(url.toLowerCase()) && this._scriptPrefix) {\n\t\t\t\t\turl = path.join(this._scriptPrefix, url);\n\t\t\t\t}\n\t\t\t\tthis.loader.load(url, 'script', onLoad);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.onLibrariesLoaded();\n\t\t\tcallback(null);\n\t\t}\n\t}\n\t_parseScenes(scenes) {\n\t\tif (!scenes) return;\n\t\tfor (let i = 0; i < scenes.length; i++) {\n\t\t\tthis.scenes.add(scenes[i].name, scenes[i].url);\n\t\t}\n\t}\n\t_parseAssets(assets) {\n\t\tconst list = [];\n\t\tconst scriptsIndex = {};\n\t\tconst bundlesIndex = {};\n\t\tif (!script.legacy) {\n\t\t\tfor (let i = 0; i < this.scriptsOrder.length; i++) {\n\t\t\t\tconst id = this.scriptsOrder[i];\n\t\t\t\tif (!assets[id]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tscriptsIndex[id] = true;\n\t\t\t\tlist.push(assets[id]);\n\t\t\t}\n\t\t\tif (this.enableBundles) {\n\t\t\t\tfor (const id in assets) {\n\t\t\t\t\tif (assets[id].type === 'bundle') {\n\t\t\t\t\t\tbundlesIndex[id] = true;\n\t\t\t\t\t\tlist.push(assets[id]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const id in assets) {\n\t\t\t\tif (scriptsIndex[id] || bundlesIndex[id]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlist.push(assets[id]);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.enableBundles) {\n\t\t\t\tfor (const id in assets) {\n\t\t\t\t\tif (assets[id].type === 'bundle') {\n\t\t\t\t\t\tbundlesIndex[id] = true;\n\t\t\t\t\t\tlist.push(assets[id]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const id in assets) {\n\t\t\t\tif (bundlesIndex[id]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlist.push(assets[id]);\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < list.length; i++) {\n\t\t\tconst data = list[i];\n\t\t\tconst asset = new Asset(data.name, data.type, data.file, data.data);\n\t\t\tasset.id = parseInt(data.id, 10);\n\t\t\tasset.preload = data.preload ? data.preload : false;\n\t\t\tasset.loaded = data.type === 'script' && data.data && data.data.loadingType > 0;\n\t\t\tasset.tags.add(data.tags);\n\t\t\tif (data.i18n) {\n\t\t\t\tfor (const locale in data.i18n) {\n\t\t\t\t\tasset.addLocalizedAssetId(locale, data.i18n[locale]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.assets.add(asset);\n\t\t}\n\t}\n\t_getScriptReferences(scene) {\n\t\tlet priorityScripts = [];\n\t\tif (scene.settings.priority_scripts) {\n\t\t\tpriorityScripts = scene.settings.priority_scripts;\n\t\t}\n\t\tconst _scripts = [];\n\t\tconst _index = {};\n\t\tfor (let i = 0; i < priorityScripts.length; i++) {\n\t\t\t_scripts.push(priorityScripts[i]);\n\t\t\t_index[priorityScripts[i]] = true;\n\t\t}\n\t\tconst entities = scene.entities;\n\t\tfor (const key in entities) {\n\t\t\tif (!entities[key].components.script) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst scripts = entities[key].components.script.scripts;\n\t\t\tfor (let i = 0; i < scripts.length; i++) {\n\t\t\t\tif (_index[scripts[i].url]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t_scripts.push(scripts[i].url);\n\t\t\t\t_index[scripts[i].url] = true;\n\t\t\t}\n\t\t}\n\t\treturn _scripts;\n\t}\n\tstart() {\n\t\tthis.frame = 0;\n\t\tthis.fire('start', {\n\t\t\ttimestamp: now(),\n\t\t\ttarget: this\n\t\t});\n\t\tif (!this._librariesLoaded) {\n\t\t\tthis.onLibrariesLoaded();\n\t\t}\n\t\tthis.systems.fire('initialize', this.root);\n\t\tthis.fire('initialize');\n\t\tthis.systems.fire('postInitialize', this.root);\n\t\tthis.systems.fire('postPostInitialize', this.root);\n\t\tthis.fire('postinitialize');\n\t\tthis.tick();\n\t}\n\tinputUpdate(dt) {\n\t\tif (this.controller) {\n\t\t\tthis.controller.update(dt);\n\t\t}\n\t\tif (this.mouse) {\n\t\t\tthis.mouse.update();\n\t\t}\n\t\tif (this.keyboard) {\n\t\t\tthis.keyboard.update();\n\t\t}\n\t\tif (this.gamepads) {\n\t\t\tthis.gamepads.update();\n\t\t}\n\t}\n\tupdate(dt) {\n\t\tthis.frame++;\n\t\tthis.graphicsDevice.updateClientRect();\n\t\tif (script.legacy) {\n\t\t\tthis.systems.fire('fixedUpdate', 1.0 / 60.0);\n\t\t}\n\t\tthis.systems.fire(this._inTools ? 'toolsUpdate' : 'update', dt);\n\t\tthis.systems.fire('animationUpdate', dt);\n\t\tthis.systems.fire('postUpdate', dt);\n\t\tthis.fire('update', dt);\n\t\tthis.inputUpdate(dt);\n\t}\n\tframeStart() {\n\t\tthis.graphicsDevice.frameStart();\n\t}\n\tframeEnd() {\n\t\tthis.graphicsDevice.frameEnd();\n\t}\n\trender() {\n\t\tthis.fire('prerender');\n\t\tthis.root.syncHierarchy();\n\t\tif (this._batcher) {\n\t\t\tthis._batcher.updateAll();\n\t\t}\n\t\tthis.renderComposition(this.scene.layers);\n\t\tthis.fire('postrender');\n\t}\n\trenderComposition(layerComposition) {\n\t\tthis.renderer.buildFrameGraph(this.frameGraph, layerComposition);\n\t\tthis.frameGraph.render(this.graphicsDevice);\n\t}\n\t_fillFrameStatsBasic(now, dt, ms) {\n\t\tconst stats = this.stats.frame;\n\t\tstats.dt = dt;\n\t\tstats.ms = ms;\n\t\tif (now > stats._timeToCountFrames) {\n\t\t\tstats.fps = stats._fpsAccum;\n\t\t\tstats._fpsAccum = 0;\n\t\t\tstats._timeToCountFrames = now + 1000;\n\t\t} else {\n\t\t\tstats._fpsAccum++;\n\t\t}\n\t\tthis.stats.drawCalls.total = this.graphicsDevice._drawCallsPerFrame;\n\t\tthis.graphicsDevice._drawCallsPerFrame = 0;\n\t}\n\t_fillFrameStats() {\n\t\tlet stats = this.stats.frame;\n\t\tstats.cameras = this.renderer._camerasRendered;\n\t\tstats.materials = this.renderer._materialSwitches;\n\t\tstats.shaders = this.graphicsDevice._shaderSwitchesPerFrame;\n\t\tstats.shadowMapUpdates = this.renderer._shadowMapUpdates;\n\t\tstats.shadowMapTime = this.renderer._shadowMapTime;\n\t\tstats.depthMapTime = this.renderer._depthMapTime;\n\t\tstats.forwardTime = this.renderer._forwardTime;\n\t\tconst prims = this.graphicsDevice._primsPerFrame;\n\t\tstats.triangles = prims[PRIMITIVE_TRIANGLES] / 3 + Math.max(prims[PRIMITIVE_TRISTRIP] - 2, 0) + Math.max(prims[PRIMITIVE_TRIFAN] - 2, 0);\n\t\tstats.cullTime = this.renderer._cullTime;\n\t\tstats.sortTime = this.renderer._sortTime;\n\t\tstats.skinTime = this.renderer._skinTime;\n\t\tstats.morphTime = this.renderer._morphTime;\n\t\tstats.lightClusters = this.renderer._lightClusters;\n\t\tstats.lightClustersTime = this.renderer._lightClustersTime;\n\t\tstats.otherPrimitives = 0;\n\t\tfor (let i = 0; i < prims.length; i++) {\n\t\t\tif (i < PRIMITIVE_TRIANGLES) {\n\t\t\t\tstats.otherPrimitives += prims[i];\n\t\t\t}\n\t\t\tprims[i] = 0;\n\t\t}\n\t\tthis.renderer._camerasRendered = 0;\n\t\tthis.renderer._materialSwitches = 0;\n\t\tthis.renderer._shadowMapUpdates = 0;\n\t\tthis.graphicsDevice._shaderSwitchesPerFrame = 0;\n\t\tthis.renderer._cullTime = 0;\n\t\tthis.renderer._layerCompositionUpdateTime = 0;\n\t\tthis.renderer._lightClustersTime = 0;\n\t\tthis.renderer._sortTime = 0;\n\t\tthis.renderer._skinTime = 0;\n\t\tthis.renderer._morphTime = 0;\n\t\tthis.renderer._shadowMapTime = 0;\n\t\tthis.renderer._depthMapTime = 0;\n\t\tthis.renderer._forwardTime = 0;\n\t\tstats = this.stats.drawCalls;\n\t\tstats.forward = this.renderer._forwardDrawCalls;\n\t\tstats.culled = this.renderer._numDrawCallsCulled;\n\t\tstats.depth = 0;\n\t\tstats.shadow = this.renderer._shadowDrawCalls;\n\t\tstats.skinned = this.renderer._skinDrawCalls;\n\t\tstats.immediate = 0;\n\t\tstats.instanced = 0;\n\t\tstats.removedByInstancing = 0;\n\t\tstats.misc = stats.total - (stats.forward + stats.shadow);\n\t\tthis.renderer._depthDrawCalls = 0;\n\t\tthis.renderer._shadowDrawCalls = 0;\n\t\tthis.renderer._forwardDrawCalls = 0;\n\t\tthis.renderer._numDrawCallsCulled = 0;\n\t\tthis.renderer._skinDrawCalls = 0;\n\t\tthis.renderer._immediateRendered = 0;\n\t\tthis.renderer._instancedDrawCalls = 0;\n\t\tthis.stats.misc.renderTargetCreationTime = this.graphicsDevice.renderTargetCreationTime;\n\t\tstats = this.stats.particles;\n\t\tstats.updatesPerFrame = stats._updatesPerFrame;\n\t\tstats.frameTime = stats._frameTime;\n\t\tstats._updatesPerFrame = 0;\n\t\tstats._frameTime = 0;\n\t}\n\tsetCanvasFillMode(mode, width, height) {\n\t\tthis._fillMode = mode;\n\t\tthis.resizeCanvas(width, height);\n\t}\n\tsetCanvasResolution(mode, width, height) {\n\t\tthis._resolutionMode = mode;\n\t\tif (mode === RESOLUTION_AUTO && width === undefined) {\n\t\t\twidth = this.graphicsDevice.canvas.clientWidth;\n\t\t\theight = this.graphicsDevice.canvas.clientHeight;\n\t\t}\n\t\tthis.graphicsDevice.resizeCanvas(width, height);\n\t}\n\tisHidden() {\n\t\treturn document[this._hiddenAttr];\n\t}\n\tonVisibilityChange() {\n\t\tif (this.isHidden()) {\n\t\t\tif (this._soundManager) {\n\t\t\t\tthis._soundManager.suspend();\n\t\t\t}\n\t\t} else {\n\t\t\tif (this._soundManager) {\n\t\t\t\tthis._soundManager.resume();\n\t\t\t}\n\t\t}\n\t}\n\tresizeCanvas(width, height) {\n\t\tif (!this._allowResize) return undefined;\n\t\tif (this.xr && this.xr.session) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst windowWidth = window.innerWidth;\n\t\tconst windowHeight = window.innerHeight;\n\t\tif (this._fillMode === FILLMODE_KEEP_ASPECT) {\n\t\t\tconst r = this.graphicsDevice.canvas.width / this.graphicsDevice.canvas.height;\n\t\t\tconst winR = windowWidth / windowHeight;\n\t\t\tif (r > winR) {\n\t\t\t\twidth = windowWidth;\n\t\t\t\theight = width / r;\n\t\t\t} else {\n\t\t\t\theight = windowHeight;\n\t\t\t\twidth = height * r;\n\t\t\t}\n\t\t} else if (this._fillMode === FILLMODE_FILL_WINDOW) {\n\t\t\twidth = windowWidth;\n\t\t\theight = windowHeight;\n\t\t}\n\t\tthis.graphicsDevice.canvas.style.width = `${width}px`;\n\t\tthis.graphicsDevice.canvas.style.height = `${height}px`;\n\t\tthis.updateCanvasSize();\n\t\treturn {\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\t}\n\tupdateCanvasSize() {\n\t\tvar _this$xr;\n\t\tif (!this._allowResize || (_this$xr = this.xr) != null && _this$xr.active) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._resolutionMode === RESOLUTION_AUTO) {\n\t\t\tconst canvas = this.graphicsDevice.canvas;\n\t\t\tthis.graphicsDevice.resizeCanvas(canvas.clientWidth, canvas.clientHeight);\n\t\t}\n\t}\n\tonLibrariesLoaded() {\n\t\tthis._librariesLoaded = true;\n\t\tif (this.systems.rigidbody) {\n\t\t\tthis.systems.rigidbody.onLibraryLoaded();\n\t\t}\n\t}\n\tapplySceneSettings(settings) {\n\t\tlet asset;\n\t\tif (this.systems.rigidbody && typeof Ammo !== 'undefined') {\n\t\t\tconst gravity = settings.physics.gravity;\n\t\t\tthis.systems.rigidbody.gravity.set(gravity[0], gravity[1], gravity[2]);\n\t\t}\n\t\tthis.scene.applySettings(settings);\n\t\tif (settings.render.hasOwnProperty('skybox')) {\n\t\t\tif (settings.render.skybox) {\n\t\t\t\tasset = this.assets.get(settings.render.skybox);\n\t\t\t\tif (asset) {\n\t\t\t\t\tthis.setSkybox(asset);\n\t\t\t\t} else {\n\t\t\t\t\tthis.assets.once(`add:${settings.render.skybox}`, this.setSkybox, this);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.setSkybox(null);\n\t\t\t}\n\t\t}\n\t}\n\tsetAreaLightLuts(ltcMat1, ltcMat2) {\n\t\tif (ltcMat1 && ltcMat2) {\n\t\t\tAreaLightLuts.set(this.graphicsDevice, ltcMat1, ltcMat2);\n\t\t}\n\t}\n\tsetSkybox(asset) {\n\t\tif (asset !== this._skyboxAsset) {\n\t\t\tconst onSkyboxRemoved = () => {\n\t\t\t\tthis.setSkybox(null);\n\t\t\t};\n\t\t\tconst onSkyboxChanged = () => {\n\t\t\t\tthis.scene.setSkybox(this._skyboxAsset ? this._skyboxAsset.resources : null);\n\t\t\t};\n\t\t\tif (this._skyboxAsset) {\n\t\t\t\tthis.assets.off(`load:${this._skyboxAsset.id}`, onSkyboxChanged, this);\n\t\t\t\tthis.assets.off(`remove:${this._skyboxAsset.id}`, onSkyboxRemoved, this);\n\t\t\t\tthis._skyboxAsset.off('change', onSkyboxChanged, this);\n\t\t\t}\n\t\t\tthis._skyboxAsset = asset;\n\t\t\tif (this._skyboxAsset) {\n\t\t\t\tthis.assets.on(`load:${this._skyboxAsset.id}`, onSkyboxChanged, this);\n\t\t\t\tthis.assets.once(`remove:${this._skyboxAsset.id}`, onSkyboxRemoved, this);\n\t\t\t\tthis._skyboxAsset.on('change', onSkyboxChanged, this);\n\t\t\t\tif (this.scene.skyboxMip === 0 && !this._skyboxAsset.loadFaces) {\n\t\t\t\t\tthis._skyboxAsset.loadFaces = true;\n\t\t\t\t}\n\t\t\t\tthis.assets.load(this._skyboxAsset);\n\t\t\t}\n\t\t\tonSkyboxChanged();\n\t\t}\n\t}\n\t_firstBake() {\n\t\tvar _this$lightmapper;\n\t\t(_this$lightmapper = this.lightmapper) == null || _this$lightmapper.bake(null, this.scene.lightmapMode);\n\t}\n\t_firstBatch() {\n\t\tvar _this$batcher;\n\t\t(_this$batcher = this.batcher) == null || _this$batcher.generate();\n\t}\n\t_processTimestamp(timestamp) {\n\t\treturn timestamp;\n\t}\n\tdrawLine(start, end, color, depthTest, layer) {\n\t\tthis.scene.drawLine(start, end, color, depthTest, layer);\n\t}\n\tdrawLines(positions, colors, depthTest = true, layer = this.scene.defaultDrawLayer) {\n\t\tthis.scene.drawLines(positions, colors, depthTest, layer);\n\t}\n\tdrawLineArrays(positions, colors, depthTest = true, layer = this.scene.defaultDrawLayer) {\n\t\tthis.scene.drawLineArrays(positions, colors, depthTest, layer);\n\t}\n\tdrawWireSphere(center, radius, color = Color.WHITE, segments = 20, depthTest = true, layer = this.scene.defaultDrawLayer) {\n\t\tthis.scene.immediate.drawWireSphere(center, radius, color, segments, depthTest, layer);\n\t}\n\tdrawWireAlignedBox(minPoint, maxPoint, color = Color.WHITE, depthTest = true, layer = this.scene.defaultDrawLayer, mat) {\n\t\tthis.scene.immediate.drawWireAlignedBox(minPoint, maxPoint, color, depthTest, layer, mat);\n\t}\n\tdrawMeshInstance(meshInstance, layer = this.scene.defaultDrawLayer) {\n\t\tthis.scene.immediate.drawMesh(null, null, null, meshInstance, layer);\n\t}\n\tdrawMesh(mesh, material, matrix, layer = this.scene.defaultDrawLayer) {\n\t\tthis.scene.immediate.drawMesh(material, matrix, mesh, null, layer);\n\t}\n\tdrawQuad(matrix, material, layer = this.scene.defaultDrawLayer) {\n\t\tthis.scene.immediate.drawMesh(material, matrix, this.scene.immediate.getQuadMesh(), null, layer);\n\t}\n\tdrawTexture(x, y, width, height, texture, material, layer = this.scene.defaultDrawLayer, filterable = true) {\n\t\tif (filterable === false && !this.graphicsDevice.isWebGPU) {\n\t\t\treturn;\n\t\t}\n\t\tconst matrix = new Mat4();\n\t\tmatrix.setTRS(new Vec3(x, y, 0.0), Quat.IDENTITY, new Vec3(width, -height, 0.0));\n\t\tif (!material) {\n\t\t\tmaterial = new Material();\n\t\t\tmaterial.cull = CULLFACE_NONE;\n\t\t\tmaterial.setParameter('colorMap', texture);\n\t\t\tmaterial.shader = filterable ? this.scene.immediate.getTextureShader() : this.scene.immediate.getUnfilterableTextureShader();\n\t\t\tmaterial.update();\n\t\t}\n\t\tthis.drawQuad(matrix, material, layer);\n\t}\n\tdrawDepthTexture(x, y, width, height, layer = this.scene.defaultDrawLayer) {\n\t\tconst material = new Material();\n\t\tmaterial.cull = CULLFACE_NONE;\n\t\tmaterial.shader = this.scene.immediate.getDepthTextureShader();\n\t\tmaterial.update();\n\t\tthis.drawTexture(x, y, width, height, null, material, layer);\n\t}\n\tdestroy() {\n\t\tvar _this$lightmapper2, _this$xr2, _this$xr3, _this$_soundManager;\n\t\tif (this._inFrameUpdate) {\n\t\t\tthis._destroyRequested = true;\n\t\t\treturn;\n\t\t}\n\t\tconst canvasId = this.graphicsDevice.canvas.id;\n\t\tthis.fire('destroy', this);\n\t\tthis.off('librariesloaded');\n\t\tif (typeof document !== 'undefined') {\n\t\t\tdocument.removeEventListener('visibilitychange', this._visibilityChangeHandler, false);\n\t\t\tdocument.removeEventListener('mozvisibilitychange', this._visibilityChangeHandler, false);\n\t\t\tdocument.removeEventListener('msvisibilitychange', this._visibilityChangeHandler, false);\n\t\t\tdocument.removeEventListener('webkitvisibilitychange', this._visibilityChangeHandler, false);\n\t\t}\n\t\tthis._visibilityChangeHandler = null;\n\t\tthis.root.destroy();\n\t\tthis.root = null;\n\t\tif (this.mouse) {\n\t\t\tthis.mouse.off();\n\t\t\tthis.mouse.detach();\n\t\t\tthis.mouse = null;\n\t\t}\n\t\tif (this.keyboard) {\n\t\t\tthis.keyboard.off();\n\t\t\tthis.keyboard.detach();\n\t\t\tthis.keyboard = null;\n\t\t}\n\t\tif (this.touch) {\n\t\t\tthis.touch.off();\n\t\t\tthis.touch.detach();\n\t\t\tthis.touch = null;\n\t\t}\n\t\tif (this.elementInput) {\n\t\t\tthis.elementInput.detach();\n\t\t\tthis.elementInput = null;\n\t\t}\n\t\tif (this.gamepads) {\n\t\t\tthis.gamepads.destroy();\n\t\t\tthis.gamepads = null;\n\t\t}\n\t\tif (this.controller) {\n\t\t\tthis.controller = null;\n\t\t}\n\t\tthis.systems.destroy();\n\t\tif (this.scene.layers) {\n\t\t\tthis.scene.layers.destroy();\n\t\t}\n\t\tconst assets = this.assets.list();\n\t\tfor (let i = 0; i < assets.length; i++) {\n\t\t\tassets[i].unload();\n\t\t\tassets[i].off();\n\t\t}\n\t\tthis.assets.off();\n\t\tthis.bundles.destroy();\n\t\tthis.bundles = null;\n\t\tthis.i18n.destroy();\n\t\tthis.i18n = null;\n\t\tconst scriptHandler = this.loader.getHandler('script');\n\t\tscriptHandler == null || scriptHandler.clearCache();\n\t\tthis.loader.destroy();\n\t\tthis.loader = null;\n\t\tthis.scene.destroy();\n\t\tthis.scene = null;\n\t\tthis.systems = null;\n\t\tthis.context = null;\n\t\tthis.scripts.destroy();\n\t\tthis.scripts = null;\n\t\tthis.scenes.destroy();\n\t\tthis.scenes = null;\n\t\t(_this$lightmapper2 = this.lightmapper) == null || _this$lightmapper2.destroy();\n\t\tthis.lightmapper = null;\n\t\tif (this._batcher) {\n\t\t\tthis._batcher.destroy();\n\t\t\tthis._batcher = null;\n\t\t}\n\t\tthis._entityIndex = {};\n\t\tthis.defaultLayerDepth.onPreRenderOpaque = null;\n\t\tthis.defaultLayerDepth.onPostRenderOpaque = null;\n\t\tthis.defaultLayerDepth.onDisable = null;\n\t\tthis.defaultLayerDepth.onEnable = null;\n\t\tthis.defaultLayerDepth = null;\n\t\tthis.defaultLayerWorld = null;\n\t\t(_this$xr2 = this.xr) == null || _this$xr2.end();\n\t\t(_this$xr3 = this.xr) == null || _this$xr3.destroy();\n\t\tthis.renderer.destroy();\n\t\tthis.renderer = null;\n\t\tthis.graphicsDevice.destroy();\n\t\tthis.graphicsDevice = null;\n\t\tthis.tick = null;\n\t\tthis.off();\n\t\t(_this$_soundManager = this._soundManager) == null || _this$_soundManager.destroy();\n\t\tthis._soundManager = null;\n\t\tscript.app = null;\n\t\tAppBase._applications[canvasId] = null;\n\t\tif (getApplication() === this) {\n\t\t\tsetApplication(null);\n\t\t}\n\t\tAppBase.cancelTick(this);\n\t}\n\tstatic cancelTick(app) {\n\t\tif (app.frameRequestId) {\n\t\t\twindow.cancelAnimationFrame(app.frameRequestId);\n\t\t\tapp.frameRequestId = undefined;\n\t\t}\n\t}\n\tgetEntityFromIndex(guid) {\n\t\treturn this._entityIndex[guid];\n\t}\n\t_registerSceneImmediate(scene) {\n\t\tthis.on('postrender', scene.immediate.onPostRender, scene.immediate);\n\t}\n}\nAppBase._applications = {};\nconst _frameEndData = {};\nconst makeTick = function makeTick(_app) {\n\tconst application = _app;\n\treturn function (timestamp, frame) {\n\t\tvar _application$xr2;\n\t\tif (!application.graphicsDevice) {\n\t\t\treturn;\n\t\t}\n\t\tif (application.frameRequestId) {\n\t\t\tvar _application$xr;\n\t\t\t(_application$xr = application.xr) == null || (_application$xr = _application$xr.session) == null || _application$xr.cancelAnimationFrame(application.frameRequestId);\n\t\t\tcancelAnimationFrame(application.frameRequestId);\n\t\t\tapplication.frameRequestId = null;\n\t\t}\n\t\tapplication._inFrameUpdate = true;\n\t\tsetApplication(application);\n\t\tapp = application;\n\t\tconst currentTime = application._processTimestamp(timestamp) || now();\n\t\tconst ms = currentTime - (application._time || currentTime);\n\t\tlet dt = ms / 1000.0;\n\t\tdt = math.clamp(dt, 0, application.maxDeltaTime);\n\t\tdt *= application.timeScale;\n\t\tapplication._time = currentTime;\n\t\tif ((_application$xr2 = application.xr) != null && _application$xr2.session) {\n\t\t\tapplication.frameRequestId = application.xr.session.requestAnimationFrame(application.tick);\n\t\t} else {\n\t\t\tapplication.frameRequestId = platform.browser || platform.worker ? requestAnimationFrame(application.tick) : null;\n\t\t}\n\t\tif (application.graphicsDevice.contextLost) {\n\t\t\treturn;\n\t\t}\n\t\tapplication._fillFrameStatsBasic(currentTime, dt, ms);\n\t\tapplication.fire('frameupdate', ms);\n\t\tlet shouldRenderFrame = true;\n\t\tif (frame) {\n\t\t\tvar _application$xr3;\n\t\t\tshouldRenderFrame = (_application$xr3 = application.xr) == null ? void 0 : _application$xr3.update(frame);\n\t\t\tapplication.graphicsDevice.defaultFramebuffer = frame.session.renderState.baseLayer.framebuffer;\n\t\t} else {\n\t\t\tapplication.graphicsDevice.defaultFramebuffer = null;\n\t\t}\n\t\tif (shouldRenderFrame) {\n\t\t\tapplication.update(dt);\n\t\t\tapplication.fire('framerender');\n\t\t\tif (application.autoRender || application.renderNextFrame) {\n\t\t\t\tapplication.updateCanvasSize();\n\t\t\t\tapplication.frameStart();\n\t\t\t\tapplication.render();\n\t\t\t\tapplication.frameEnd();\n\t\t\t\tapplication.renderNextFrame = false;\n\t\t\t}\n\t\t\t_frameEndData.timestamp = now();\n\t\t\t_frameEndData.target = application;\n\t\t\tapplication.fire('frameend', _frameEndData);\n\t\t}\n\t\tapplication._inFrameUpdate = false;\n\t\tif (application._destroyRequested) {\n\t\t\tapplication.destroy();\n\t\t}\n\t};\n};\n\nexport { AppBase, app };\n","class AppOptions {\n\tconstructor() {\n\t\tthis.elementInput = void 0;\n\t\tthis.keyboard = void 0;\n\t\tthis.mouse = void 0;\n\t\tthis.touch = void 0;\n\t\tthis.gamepads = void 0;\n\t\tthis.scriptPrefix = void 0;\n\t\tthis.assetPrefix = void 0;\n\t\tthis.scriptsOrder = void 0;\n\t\tthis.soundManager = void 0;\n\t\tthis.graphicsDevice = void 0;\n\t\tthis.lightmapper = void 0;\n\t\tthis.batchManager = void 0;\n\t\tthis.xr = void 0;\n\t\tthis.componentSystems = [];\n\t\tthis.resourceHandlers = [];\n\t}\n}\n\nexport { AppOptions };\n","import { platform } from '../core/platform.js';\nimport { WebglGraphicsDevice } from '../platform/graphics/webgl/webgl-graphics-device.js';\nimport { SoundManager } from '../platform/sound/manager.js';\nimport { Lightmapper } from './lightmapper/lightmapper.js';\nimport { BatchManager } from '../scene/batching/batch-manager.js';\nimport { AppBase } from './app-base.js';\nimport { AppOptions } from './app-options.js';\nimport { script } from './script.js';\nimport { AnimationComponentSystem } from './components/animation/system.js';\nimport { AnimComponentSystem } from './components/anim/system.js';\nimport { AudioListenerComponentSystem } from './components/audio-listener/system.js';\nimport { AudioSourceComponentSystem } from './components/audio-source/system.js';\nimport { ButtonComponentSystem } from './components/button/system.js';\nimport { CollisionComponentSystem } from './components/collision/system.js';\nimport { ElementComponentSystem } from './components/element/system.js';\nimport { JointComponentSystem } from './components/joint/system.js';\nimport { LayoutChildComponentSystem } from './components/layout-child/system.js';\nimport { LayoutGroupComponentSystem } from './components/layout-group/system.js';\nimport { ModelComponentSystem } from './components/model/system.js';\nimport { ParticleSystemComponentSystem } from './components/particle-system/system.js';\nimport { RenderComponentSystem } from './components/render/system.js';\nimport { RigidBodyComponentSystem } from './components/rigid-body/system.js';\nimport { ScreenComponentSystem } from './components/screen/system.js';\nimport { ScriptLegacyComponentSystem } from './components/script-legacy/system.js';\nimport { ScrollViewComponentSystem } from './components/scroll-view/system.js';\nimport { ScrollbarComponentSystem } from './components/scrollbar/system.js';\nimport { SoundComponentSystem } from './components/sound/system.js';\nimport { SpriteComponentSystem } from './components/sprite/system.js';\nimport { ZoneComponentSystem } from './components/zone/system.js';\nimport { CameraComponentSystem } from './components/camera/system.js';\nimport { LightComponentSystem } from './components/light/system.js';\nimport { ScriptComponentSystem } from './components/script/system.js';\nimport { GSplatComponentSystem } from './components/gsplat/system.js';\nimport { RenderHandler } from './handlers/render.js';\nimport { AnimationHandler } from './handlers/animation.js';\nimport { AnimClipHandler } from './handlers/anim-clip.js';\nimport { AnimStateGraphHandler } from './handlers/anim-state-graph.js';\nimport { AudioHandler } from './handlers/audio.js';\nimport { BinaryHandler } from './handlers/binary.js';\nimport { ContainerHandler } from './handlers/container.js';\nimport { CssHandler } from './handlers/css.js';\nimport { CubemapHandler } from './handlers/cubemap.js';\nimport { FolderHandler } from './handlers/folder.js';\nimport { FontHandler } from './handlers/font.js';\nimport { GSplatHandler } from './handlers/gsplat.js';\nimport { HierarchyHandler } from './handlers/hierarchy.js';\nimport { HtmlHandler } from './handlers/html.js';\nimport { JsonHandler } from './handlers/json.js';\nimport { MaterialHandler } from './handlers/material.js';\nimport { ModelHandler } from './handlers/model.js';\nimport { SceneHandler } from './handlers/scene.js';\nimport { ScriptHandler } from './handlers/script.js';\nimport { ShaderHandler } from './handlers/shader.js';\nimport { SpriteHandler } from './handlers/sprite.js';\nimport { TemplateHandler } from './handlers/template.js';\nimport { TextHandler } from './handlers/text.js';\nimport { TextureAtlasHandler } from './handlers/texture-atlas.js';\nimport { TextureHandler } from './handlers/texture.js';\nimport { XrManager } from './xr/xr-manager.js';\n\nclass Application extends AppBase {\n\tconstructor(canvas, options = {}) {\n\t\tvar _options$graphicsDevi;\n\t\tsuper(canvas);\n\t\tconst appOptions = new AppOptions();\n\t\tappOptions.graphicsDevice = (_options$graphicsDevi = options.graphicsDevice) != null ? _options$graphicsDevi : this.createDevice(canvas, options);\n\t\tthis.addComponentSystems(appOptions);\n\t\tthis.addResourceHandles(appOptions);\n\t\tappOptions.elementInput = options.elementInput;\n\t\tappOptions.keyboard = options.keyboard;\n\t\tappOptions.mouse = options.mouse;\n\t\tappOptions.touch = options.touch;\n\t\tappOptions.gamepads = options.gamepads;\n\t\tappOptions.scriptPrefix = options.scriptPrefix;\n\t\tappOptions.assetPrefix = options.assetPrefix;\n\t\tappOptions.scriptsOrder = options.scriptsOrder;\n\t\tappOptions.soundManager = new SoundManager();\n\t\tappOptions.lightmapper = Lightmapper;\n\t\tappOptions.batchManager = BatchManager;\n\t\tappOptions.xr = XrManager;\n\t\tthis.init(appOptions);\n\t}\n\tcreateDevice(canvas, options) {\n\t\tif (!options.graphicsDeviceOptions) {\n\t\t\toptions.graphicsDeviceOptions = {};\n\t\t}\n\t\tif (platform.browser && !!navigator.xr) {\n\t\t\toptions.graphicsDeviceOptions.xrCompatible = true;\n\t\t}\n\t\toptions.graphicsDeviceOptions.alpha = options.graphicsDeviceOptions.alpha || false;\n\t\treturn new WebglGraphicsDevice(canvas, options.graphicsDeviceOptions);\n\t}\n\taddComponentSystems(appOptions) {\n\t\tappOptions.componentSystems = [RigidBodyComponentSystem, CollisionComponentSystem, JointComponentSystem, AnimationComponentSystem, AnimComponentSystem, ModelComponentSystem, RenderComponentSystem, CameraComponentSystem, LightComponentSystem, script.legacy ? ScriptLegacyComponentSystem : ScriptComponentSystem, AudioSourceComponentSystem, SoundComponentSystem, AudioListenerComponentSystem, ParticleSystemComponentSystem, ScreenComponentSystem, ElementComponentSystem, ButtonComponentSystem, ScrollViewComponentSystem, ScrollbarComponentSystem, SpriteComponentSystem, LayoutGroupComponentSystem, LayoutChildComponentSystem, ZoneComponentSystem, GSplatComponentSystem];\n\t}\n\taddResourceHandles(appOptions) {\n\t\tappOptions.resourceHandlers = [RenderHandler, AnimationHandler, AnimClipHandler, AnimStateGraphHandler, ModelHandler, MaterialHandler, TextureHandler, TextHandler, JsonHandler, AudioHandler, ScriptHandler, SceneHandler, CubemapHandler, HtmlHandler, CssHandler, ShaderHandler, HierarchyHandler, FolderHandler, FontHandler, BinaryHandler, TextureAtlasHandler, SpriteHandler, TemplateHandler, ContainerHandler, GSplatHandler];\n\t}\n}\n\nexport { Application };\n","class AssetFile {\n\tconstructor(url = '', filename = '', hash = null, size = null, opt = null, contents = null) {\n\t\tthis.url = url;\n\t\tthis.filename = filename;\n\t\tthis.hash = hash;\n\t\tthis.size = size;\n\t\tthis.opt = opt;\n\t\tthis.contents = contents;\n\t}\n\tequals(other) {\n\t\treturn this.url === other.url && this.filename === other.filename && this.hash === other.hash && this.size === other.size && this.opt === other.opt && this.contents === other.contents;\n\t}\n}\n\nexport { AssetFile };\n","import { EventHandler } from '../../core/event-handler.js';\nimport { Asset } from './asset.js';\n\nclass LocalizedAsset extends EventHandler {\n\tconstructor(app) {\n\t\tsuper();\n\t\tthis._app = app;\n\t\tapp.i18n.on('set:locale', this._onSetLocale, this);\n\t\tthis._autoLoad = false;\n\t\tthis._disableLocalization = false;\n\t\tthis._defaultAsset = null;\n\t\tthis._localizedAsset = null;\n\t}\n\tset defaultAsset(value) {\n\t\tconst id = value instanceof Asset ? value.id : value;\n\t\tif (this._defaultAsset === id) return;\n\t\tif (this._defaultAsset) {\n\t\t\tthis._unbindDefaultAsset();\n\t\t}\n\t\tthis._defaultAsset = id;\n\t\tif (this._defaultAsset) {\n\t\t\tthis._bindDefaultAsset();\n\t\t}\n\t\tthis._onSetLocale(this._app.i18n.locale);\n\t}\n\tget defaultAsset() {\n\t\treturn this._defaultAsset;\n\t}\n\tset localizedAsset(value) {\n\t\tconst id = value instanceof Asset ? value.id : value;\n\t\tif (this._localizedAsset === id) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._localizedAsset) {\n\t\t\tthis._app.assets.off(`add:${this._localizedAsset}`, this._onLocalizedAssetAdd, this);\n\t\t\tthis._unbindLocalizedAsset();\n\t\t}\n\t\tthis._localizedAsset = id;\n\t\tif (this._localizedAsset) {\n\t\t\tconst asset = this._app.assets.get(this._localizedAsset);\n\t\t\tif (!asset) {\n\t\t\t\tthis._app.assets.once(`add:${this._localizedAsset}`, this._onLocalizedAssetAdd, this);\n\t\t\t} else {\n\t\t\t\tthis._bindLocalizedAsset();\n\t\t\t}\n\t\t}\n\t}\n\tget localizedAsset() {\n\t\treturn this._localizedAsset;\n\t}\n\tset autoLoad(value) {\n\t\tif (this._autoLoad === value) return;\n\t\tthis._autoLoad = value;\n\t\tif (this._autoLoad && this._localizedAsset) {\n\t\t\tthis._unbindLocalizedAsset();\n\t\t\tthis._bindLocalizedAsset();\n\t\t}\n\t}\n\tget autoLoad() {\n\t\treturn this._autoLoad;\n\t}\n\tset disableLocalization(value) {\n\t\tif (this._disableLocalization === value) return;\n\t\tthis._disableLocalization = value;\n\t\tthis._onSetLocale(this._app.i18n.locale);\n\t}\n\tget disableLocalization() {\n\t\treturn this._disableLocalization;\n\t}\n\t_bindDefaultAsset() {\n\t\tconst asset = this._app.assets.get(this._defaultAsset);\n\t\tif (!asset) {\n\t\t\tthis._app.assets.once(`add:${this._defaultAsset}`, this._onDefaultAssetAdd, this);\n\t\t} else {\n\t\t\tthis._onDefaultAssetAdd(asset);\n\t\t}\n\t}\n\t_unbindDefaultAsset() {\n\t\tif (!this._defaultAsset) return;\n\t\tthis._app.assets.off(`add:${this._defaultAsset}`, this._onDefaultAssetAdd, this);\n\t\tconst asset = this._app.assets.get(this._defaultAsset);\n\t\tif (!asset) return;\n\t\tasset.off('add:localized', this._onLocaleAdd, this);\n\t\tasset.off('remove:localized', this._onLocaleRemove, this);\n\t\tasset.off('remove', this._onDefaultAssetRemove, this);\n\t}\n\t_onDefaultAssetAdd(asset) {\n\t\tif (this._defaultAsset !== asset.id) return;\n\t\tasset.on('add:localized', this._onLocaleAdd, this);\n\t\tasset.on('remove:localized', this._onLocaleRemove, this);\n\t\tasset.once('remove', this._onDefaultAssetRemove, this);\n\t}\n\t_onDefaultAssetRemove(asset) {\n\t\tif (this._defaultAsset !== asset.id) return;\n\t\tasset.off('add:localized', this._onLocaleAdd, this);\n\t\tasset.off('remove:localized', this._onLocaleAdd, this);\n\t\tthis._app.assets.once(`add:${this._defaultAsset}`, this._onDefaultAssetAdd, this);\n\t}\n\t_bindLocalizedAsset() {\n\t\tif (!this._autoLoad) return;\n\t\tconst asset = this._app.assets.get(this._localizedAsset);\n\t\tif (!asset) return;\n\t\tasset.on('load', this._onLocalizedAssetLoad, this);\n\t\tasset.on('change', this._onLocalizedAssetChange, this);\n\t\tasset.on('remove', this._onLocalizedAssetRemove, this);\n\t\tif (asset.resource) {\n\t\t\tthis._onLocalizedAssetLoad(asset);\n\t\t} else {\n\t\t\tthis._app.assets.load(asset);\n\t\t}\n\t}\n\t_unbindLocalizedAsset() {\n\t\tconst asset = this._app.assets.get(this._localizedAsset);\n\t\tif (!asset) return;\n\t\tasset.off('load', this._onLocalizedAssetLoad, this);\n\t\tasset.off('change', this._onLocalizedAssetChange, this);\n\t\tasset.off('remove', this._onLocalizedAssetRemove, this);\n\t}\n\t_onLocalizedAssetAdd(asset) {\n\t\tif (this._localizedAsset !== asset.id) return;\n\t\tthis._bindLocalizedAsset();\n\t}\n\t_onLocalizedAssetLoad(asset) {\n\t\tthis.fire('load', asset);\n\t}\n\t_onLocalizedAssetChange(asset, name, newValue, oldValue) {\n\t\tthis.fire('change', asset, name, newValue, oldValue);\n\t}\n\t_onLocalizedAssetRemove(asset) {\n\t\tif (this._localizedAsset === asset.id) {\n\t\t\tthis.localizedAsset = this._defaultAsset;\n\t\t}\n\t\tthis.fire('remove', asset);\n\t}\n\t_onLocaleAdd(locale, assetId) {\n\t\tif (this._app.i18n.locale !== locale) return;\n\t\tthis._onSetLocale(locale);\n\t}\n\t_onLocaleRemove(locale, assetId) {\n\t\tif (this._app.i18n.locale !== locale) return;\n\t\tthis._onSetLocale(locale);\n\t}\n\t_onSetLocale(locale) {\n\t\tif (!this._defaultAsset) {\n\t\t\tthis.localizedAsset = null;\n\t\t\treturn;\n\t\t}\n\t\tconst asset = this._app.assets.get(this._defaultAsset);\n\t\tif (!asset || this._disableLocalization) {\n\t\t\tthis.localizedAsset = this._defaultAsset;\n\t\t\treturn;\n\t\t}\n\t\tconst localizedAssetId = asset.getLocalizedAssetId(locale);\n\t\tif (!localizedAssetId) {\n\t\t\tthis.localizedAsset = this._defaultAsset;\n\t\t\treturn;\n\t\t}\n\t\tthis.localizedAsset = localizedAssetId;\n\t}\n\tdestroy() {\n\t\tthis.defaultAsset = null;\n\t\tthis._app.i18n.off('set:locale', this._onSetLocale, this);\n\t\tthis.off();\n\t}\n}\n\nexport { LocalizedAsset };\n","class AssetReference {\n\tconstructor(propertyName, parent, registry, callbacks, scope) {\n\t\tthis._evtLoadById = null;\n\t\tthis._evtUnloadById = null;\n\t\tthis._evtAddById = null;\n\t\tthis._evtRemoveById = null;\n\t\tthis._evtLoadByUrl = null;\n\t\tthis._evtAddByUrl = null;\n\t\tthis._evtRemoveByUrl = null;\n\t\tthis.propertyName = propertyName;\n\t\tthis.parent = parent;\n\t\tthis._scope = scope;\n\t\tthis._registry = registry;\n\t\tthis.id = null;\n\t\tthis.url = null;\n\t\tthis.asset = null;\n\t\tthis._onAssetLoad = callbacks.load;\n\t\tthis._onAssetAdd = callbacks.add;\n\t\tthis._onAssetRemove = callbacks.remove;\n\t\tthis._onAssetUnload = callbacks.unload;\n\t}\n\tset id(value) {\n\t\tif (this.url) throw Error('Can\\'t set id and url');\n\t\tthis._unbind();\n\t\tthis._id = value;\n\t\tthis.asset = this._registry.get(this._id);\n\t\tthis._bind();\n\t}\n\tget id() {\n\t\treturn this._id;\n\t}\n\tset url(value) {\n\t\tif (this.id) throw Error('Can\\'t set id and url');\n\t\tthis._unbind();\n\t\tthis._url = value;\n\t\tthis.asset = this._registry.getByUrl(this._url);\n\t\tthis._bind();\n\t}\n\tget url() {\n\t\treturn this._url;\n\t}\n\t_bind() {\n\t\tif (this.id) {\n\t\t\tif (this._onAssetLoad) this._evtLoadById = this._registry.on(`load:${this.id}`, this._onLoad, this);\n\t\t\tif (this._onAssetAdd) this._evtAddById = this._registry.once(`add:${this.id}`, this._onAdd, this);\n\t\t\tif (this._onAssetRemove) this._evtRemoveById = this._registry.on(`remove:${this.id}`, this._onRemove, this);\n\t\t\tif (this._onAssetUnload) this._evtUnloadById = this._registry.on(`unload:${this.id}`, this._onUnload, this);\n\t\t}\n\t\tif (this.url) {\n\t\t\tif (this._onAssetLoad) this._evtLoadByUrl = this._registry.on(`load:url:${this.url}`, this._onLoad, this);\n\t\t\tif (this._onAssetAdd) this._evtAddByUrl = this._registry.once(`add:url:${this.url}`, this._onAdd, this);\n\t\t\tif (this._onAssetRemove) this._evtRemoveByUrl = this._registry.on(`remove:url:${this.url}`, this._onRemove, this);\n\t\t}\n\t}\n\t_unbind() {\n\t\tif (this.id) {\n\t\t\tvar _this$_evtLoadById, _this$_evtAddById, _this$_evtRemoveById, _this$_evtUnloadById;\n\t\t\t(_this$_evtLoadById = this._evtLoadById) == null || _this$_evtLoadById.off();\n\t\t\tthis._evtLoadById = null;\n\t\t\t(_this$_evtAddById = this._evtAddById) == null || _this$_evtAddById.off();\n\t\t\tthis._evtAddById = null;\n\t\t\t(_this$_evtRemoveById = this._evtRemoveById) == null || _this$_evtRemoveById.off();\n\t\t\tthis._evtRemoveById = null;\n\t\t\t(_this$_evtUnloadById = this._evtUnloadById) == null || _this$_evtUnloadById.off();\n\t\t\tthis._evtUnloadById = null;\n\t\t}\n\t\tif (this.url) {\n\t\t\tvar _this$_evtLoadByUrl, _this$_evtAddByUrl, _this$_evtRemoveByUrl;\n\t\t\t(_this$_evtLoadByUrl = this._evtLoadByUrl) == null || _this$_evtLoadByUrl.off();\n\t\t\tthis._evtLoadByUrl = null;\n\t\t\t(_this$_evtAddByUrl = this._evtAddByUrl) == null || _this$_evtAddByUrl.off();\n\t\t\tthis._evtAddByUrl = null;\n\t\t\t(_this$_evtRemoveByUrl = this._evtRemoveByUrl) == null || _this$_evtRemoveByUrl.off();\n\t\t\tthis._evtRemoveByUrl = null;\n\t\t}\n\t}\n\t_onLoad(asset) {\n\t\tthis._onAssetLoad.call(this._scope, this.propertyName, this.parent, asset);\n\t}\n\t_onAdd(asset) {\n\t\tthis.asset = asset;\n\t\tthis._onAssetAdd.call(this._scope, this.propertyName, this.parent, asset);\n\t}\n\t_onRemove(asset) {\n\t\tthis._onAssetRemove.call(this._scope, this.propertyName, this.parent, asset);\n\t\tthis.asset = null;\n\t}\n\t_onUnload(asset) {\n\t\tthis._onAssetUnload.call(this._scope, this.propertyName, this.parent, asset);\n\t}\n}\n\nexport { AssetReference };\n","import { path } from '../../core/path.js';\nimport { EventHandler } from '../../core/event-handler.js';\nimport { TagsCache } from '../../core/tags-cache.js';\nimport { standardMaterialTextureParameters } from '../../scene/materials/standard-material-parameters.js';\nimport { script } from '../script.js';\nimport { Asset } from './asset.js';\n\nclass AssetRegistry extends EventHandler {\n\tconstructor(loader) {\n\t\tsuper();\n\t\tthis._assets = new Set();\n\t\tthis._idToAsset = new Map();\n\t\tthis._urlToAsset = new Map();\n\t\tthis._nameToAsset = new Map();\n\t\tthis._tags = new TagsCache('_id');\n\t\tthis.prefix = null;\n\t\tthis.bundles = null;\n\t\tthis._loader = loader;\n\t}\n\tlist(filters = {}) {\n\t\tconst assets = Array.from(this._assets);\n\t\tif (filters.preload !== undefined) {\n\t\t\treturn assets.filter(asset => asset.preload === filters.preload);\n\t\t}\n\t\treturn assets;\n\t}\n\tadd(asset) {\n\t\tvar _asset$file, _asset$file2;\n\t\tif (this._assets.has(asset)) return;\n\t\tthis._assets.add(asset);\n\t\tthis._idToAsset.set(asset.id, asset);\n\t\tif ((_asset$file = asset.file) != null && _asset$file.url) {\n\t\t\tthis._urlToAsset.set(asset.file.url, asset);\n\t\t}\n\t\tif (!this._nameToAsset.has(asset.name)) {\n\t\t\tthis._nameToAsset.set(asset.name, new Set());\n\t\t}\n\t\tthis._nameToAsset.get(asset.name).add(asset);\n\t\tasset.on('name', this._onNameChange, this);\n\t\tasset.registry = this;\n\t\tthis._tags.addItem(asset);\n\t\tasset.tags.on('add', this._onTagAdd, this);\n\t\tasset.tags.on('remove', this._onTagRemove, this);\n\t\tthis.fire('add', asset);\n\t\tthis.fire(`add:${asset.id}`, asset);\n\t\tif ((_asset$file2 = asset.file) != null && _asset$file2.url) {\n\t\t\tthis.fire(`add:url:${asset.file.url}`, asset);\n\t\t}\n\t\tif (asset.preload) {\n\t\t\tthis.load(asset);\n\t\t}\n\t}\n\tremove(asset) {\n\t\tvar _asset$file3, _asset$file4;\n\t\tif (!this._assets.has(asset)) return false;\n\t\tthis._assets.delete(asset);\n\t\tthis._idToAsset.delete(asset.id);\n\t\tif ((_asset$file3 = asset.file) != null && _asset$file3.url) {\n\t\t\tthis._urlToAsset.delete(asset.file.url);\n\t\t}\n\t\tasset.off('name', this._onNameChange, this);\n\t\tif (this._nameToAsset.has(asset.name)) {\n\t\t\tconst items = this._nameToAsset.get(asset.name);\n\t\t\titems.delete(asset);\n\t\t\tif (items.size === 0) {\n\t\t\t\tthis._nameToAsset.delete(asset.name);\n\t\t\t}\n\t\t}\n\t\tthis._tags.removeItem(asset);\n\t\tasset.tags.off('add', this._onTagAdd, this);\n\t\tasset.tags.off('remove', this._onTagRemove, this);\n\t\tasset.fire('remove', asset);\n\t\tthis.fire('remove', asset);\n\t\tthis.fire(`remove:${asset.id}`, asset);\n\t\tif ((_asset$file4 = asset.file) != null && _asset$file4.url) {\n\t\t\tthis.fire(`remove:url:${asset.file.url}`, asset);\n\t\t}\n\t\treturn true;\n\t}\n\tget(id) {\n\t\treturn this._idToAsset.get(Number(id));\n\t}\n\tgetByUrl(url) {\n\t\treturn this._urlToAsset.get(url);\n\t}\n\tload(asset, options) {\n\t\tif ((asset.loading || asset.loaded) && !(options != null && options.force)) {\n\t\t\treturn;\n\t\t}\n\t\tconst file = asset.file;\n\t\tconst _fireLoad = () => {\n\t\t\tthis.fire('load', asset);\n\t\t\tthis.fire(`load:${asset.id}`, asset);\n\t\t\tif (file && file.url) {\n\t\t\t\tthis.fire(`load:url:${file.url}`, asset);\n\t\t\t}\n\t\t\tasset.fire('load', asset);\n\t\t};\n\t\tconst _opened = resource => {\n\t\t\tif (resource instanceof Array) {\n\t\t\t\tasset.resources = resource;\n\t\t\t} else {\n\t\t\t\tasset.resource = resource;\n\t\t\t}\n\t\t\tthis._loader.patch(asset, this);\n\t\t\tif (asset.type === 'bundle') {\n\t\t\t\tconst assetIds = asset.data.assets;\n\t\t\t\tfor (let i = 0; i < assetIds.length; i++) {\n\t\t\t\t\tconst assetInBundle = this._idToAsset.get(assetIds[i]);\n\t\t\t\t\tif (assetInBundle && !assetInBundle.loaded) {\n\t\t\t\t\t\tthis.load(assetInBundle, {\n\t\t\t\t\t\t\tforce: true\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (asset.resource.loaded) {\n\t\t\t\t\t_fireLoad();\n\t\t\t\t} else {\n\t\t\t\t\tthis.fire('load:start', asset);\n\t\t\t\t\tthis.fire(`load:start:${asset.id}`, asset);\n\t\t\t\t\tif (file && file.url) {\n\t\t\t\t\t\tthis.fire(`load:start:url:${file.url}`, asset);\n\t\t\t\t\t}\n\t\t\t\t\tasset.fire('load:start', asset);\n\t\t\t\t\tasset.resource.on('load', _fireLoad);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t_fireLoad();\n\t\t\t}\n\t\t};\n\t\tconst _loaded = (err, resource, extra) => {\n\t\t\tasset.loaded = true;\n\t\t\tasset.loading = false;\n\t\t\tif (err) {\n\t\t\t\tthis.fire('error', err, asset);\n\t\t\t\tthis.fire(`error:${asset.id}`, err, asset);\n\t\t\t\tasset.fire('error', err, asset);\n\t\t\t} else {\n\t\t\t\tif (!script.legacy && asset.type === 'script') {\n\t\t\t\t\tconst handler = this._loader.getHandler('script');\n\t\t\t\t\tif (handler._cache[asset.id] && handler._cache[asset.id].parentNode === document.head) {\n\t\t\t\t\t\tdocument.head.removeChild(handler._cache[asset.id]);\n\t\t\t\t\t}\n\t\t\t\t\thandler._cache[asset.id] = extra;\n\t\t\t\t}\n\t\t\t\t_opened(resource);\n\t\t\t}\n\t\t};\n\t\tif (file || asset.type === 'cubemap') {\n\t\t\tthis.fire('load:start', asset);\n\t\t\tthis.fire(`load:${asset.id}:start`, asset);\n\t\t\tasset.loading = true;\n\t\t\tconst fileUrl = asset.getFileUrl();\n\t\t\tif (asset.type === 'bundle') {\n\t\t\t\tconst assetIds = asset.data.assets;\n\t\t\t\tfor (let i = 0; i < assetIds.length; i++) {\n\t\t\t\t\tconst assetInBundle = this._idToAsset.get(assetIds[i]);\n\t\t\t\t\tif (!assetInBundle) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (assetInBundle.loaded || assetInBundle.resource || assetInBundle.loading) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tassetInBundle.loading = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._loader.load(fileUrl, asset.type, _loaded, asset, options);\n\t\t} else {\n\t\t\tconst resource = this._loader.open(asset.type, asset.data);\n\t\t\tasset.loaded = true;\n\t\t\t_opened(resource);\n\t\t}\n\t}\n\tloadFromUrl(url, type, callback) {\n\t\tthis.loadFromUrlAndFilename(url, null, type, callback);\n\t}\n\tloadFromUrlAndFilename(url, filename, type, callback) {\n\t\tconst name = path.getBasename(filename || url);\n\t\tconst file = {\n\t\t\tfilename: filename || name,\n\t\t\turl: url\n\t\t};\n\t\tlet asset = this.getByUrl(url);\n\t\tif (!asset) {\n\t\t\tasset = new Asset(name, type, file);\n\t\t\tthis.add(asset);\n\t\t} else if (asset.loaded) {\n\t\t\tcallback(asset.loadFromUrlError || null, asset);\n\t\t\treturn;\n\t\t}\n\t\tconst startLoad = asset => {\n\t\t\tasset.once('load', loadedAsset => {\n\t\t\t\tif (type === 'material') {\n\t\t\t\t\tthis._loadTextures(loadedAsset, (err, textures) => {\n\t\t\t\t\t\tcallback(err, loadedAsset);\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcallback(null, loadedAsset);\n\t\t\t\t}\n\t\t\t});\n\t\t\tasset.once('error', err => {\n\t\t\t\tif (err) {\n\t\t\t\t\tthis.loadFromUrlError = err;\n\t\t\t\t}\n\t\t\t\tcallback(err, asset);\n\t\t\t});\n\t\t\tthis.load(asset);\n\t\t};\n\t\tif (asset.resource) {\n\t\t\tcallback(null, asset);\n\t\t} else if (type === 'model') {\n\t\t\tthis._loadModel(asset, startLoad);\n\t\t} else {\n\t\t\tstartLoad(asset);\n\t\t}\n\t}\n\t_loadModel(modelAsset, continuation) {\n\t\tconst url = modelAsset.getFileUrl();\n\t\tconst ext = path.getExtension(url);\n\t\tif (ext === '.json' || ext === '.glb') {\n\t\t\tconst dir = path.getDirectory(url);\n\t\t\tconst basename = path.getBasename(url);\n\t\t\tconst mappingUrl = path.join(dir, basename.replace(ext, '.mapping.json'));\n\t\t\tthis._loader.load(mappingUrl, 'json', (err, data) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tmodelAsset.data = {\n\t\t\t\t\t\tmapping: []\n\t\t\t\t\t};\n\t\t\t\t\tcontinuation(modelAsset);\n\t\t\t\t} else {\n\t\t\t\t\tthis._loadMaterials(modelAsset, data, (e, materials) => {\n\t\t\t\t\t\tmodelAsset.data = data;\n\t\t\t\t\t\tcontinuation(modelAsset);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tcontinuation(modelAsset);\n\t\t}\n\t}\n\t_loadMaterials(modelAsset, mapping, callback) {\n\t\tconst materials = [];\n\t\tlet count = 0;\n\t\tconst onMaterialLoaded = (err, materialAsset) => {\n\t\t\tthis._loadTextures(materialAsset, (err, textures) => {\n\t\t\t\tmaterials.push(materialAsset);\n\t\t\t\tif (materials.length === count) {\n\t\t\t\t\tcallback(null, materials);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t\tfor (let i = 0; i < mapping.mapping.length; i++) {\n\t\t\tconst path = mapping.mapping[i].path;\n\t\t\tif (path) {\n\t\t\t\tcount++;\n\t\t\t\tconst url = modelAsset.getAbsoluteUrl(path);\n\t\t\t\tthis.loadFromUrl(url, 'material', onMaterialLoaded);\n\t\t\t}\n\t\t}\n\t\tif (count === 0) {\n\t\t\tcallback(null, materials);\n\t\t}\n\t}\n\t_loadTextures(materialAsset, callback) {\n\t\tconst textures = [];\n\t\tlet count = 0;\n\t\tconst data = materialAsset.data;\n\t\tif (data.mappingFormat !== 'path') {\n\t\t\tcallback(null, textures);\n\t\t\treturn;\n\t\t}\n\t\tconst onTextureLoaded = (err, texture) => {\n\t\t\tif (err) console.error(err);\n\t\t\ttextures.push(texture);\n\t\t\tif (textures.length === count) {\n\t\t\t\tcallback(null, textures);\n\t\t\t}\n\t\t};\n\t\tconst texParams = standardMaterialTextureParameters;\n\t\tfor (let i = 0; i < texParams.length; i++) {\n\t\t\tconst path = data[texParams[i]];\n\t\t\tif (path && typeof path === 'string') {\n\t\t\t\tcount++;\n\t\t\t\tconst url = materialAsset.getAbsoluteUrl(path);\n\t\t\t\tthis.loadFromUrl(url, 'texture', onTextureLoaded);\n\t\t\t}\n\t\t}\n\t\tif (count === 0) {\n\t\t\tcallback(null, textures);\n\t\t}\n\t}\n\t_onTagAdd(tag, asset) {\n\t\tthis._tags.add(tag, asset);\n\t}\n\t_onTagRemove(tag, asset) {\n\t\tthis._tags.remove(tag, asset);\n\t}\n\t_onNameChange(asset, name, nameOld) {\n\t\tif (this._nameToAsset.has(nameOld)) {\n\t\t\tconst items = this._nameToAsset.get(nameOld);\n\t\t\titems.delete(asset);\n\t\t\tif (items.size === 0) {\n\t\t\t\tthis._nameToAsset.delete(nameOld);\n\t\t\t}\n\t\t}\n\t\tif (!this._nameToAsset.has(asset.name)) {\n\t\t\tthis._nameToAsset.set(asset.name, new Set());\n\t\t}\n\t\tthis._nameToAsset.get(asset.name).add(asset);\n\t}\n\tfindByTag() {\n\t\treturn this._tags.find(arguments);\n\t}\n\tfilter(callback) {\n\t\treturn Array.from(this._assets).filter(asset => callback(asset));\n\t}\n\tfind(name, type) {\n\t\tconst items = this._nameToAsset.get(name);\n\t\tif (!items) return null;\n\t\tfor (const asset of items) {\n\t\t\tif (!type || asset.type === type) {\n\t\t\t\treturn asset;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\tfindAll(name, type) {\n\t\tconst items = this._nameToAsset.get(name);\n\t\tif (!items) return [];\n\t\tconst results = Array.from(items);\n\t\tif (!type) return results;\n\t\treturn results.filter(asset => asset.type === type);\n\t}\n}\nAssetRegistry.EVENT_LOAD = 'load';\nAssetRegistry.EVENT_ADD = 'add';\nAssetRegistry.EVENT_REMOVE = 'remove';\nAssetRegistry.EVENT_ERROR = 'error';\n\nexport { AssetRegistry };\n","import { path } from '../../core/path.js';\nimport { Tags } from '../../core/tags.js';\nimport { EventHandler } from '../../core/event-handler.js';\nimport { findAvailableLocale } from '../i18n/utils.js';\nimport { ABSOLUTE_URL } from './constants.js';\nimport { AssetFile } from './asset-file.js';\nimport { getApplication } from '../globals.js';\nimport { http } from '../../platform/net/http.js';\n\nlet assetIdCounter = -1;\nconst VARIANT_SUPPORT = {\n\tpvr: 'extCompressedTexturePVRTC',\n\tdxt: 'extCompressedTextureS3TC',\n\tetc2: 'extCompressedTextureETC',\n\tetc1: 'extCompressedTextureETC1',\n\tbasis: 'canvas'\n};\nconst VARIANT_DEFAULT_PRIORITY = ['pvr', 'dxt', 'etc2', 'etc1', 'basis'];\nclass Asset extends EventHandler {\n\tconstructor(name, type, file, data, options) {\n\t\tsuper();\n\t\tthis._id = assetIdCounter--;\n\t\tthis._name = name || '';\n\t\tthis.type = type;\n\t\tthis.tags = new Tags(this);\n\t\tthis._preload = false;\n\t\tthis._file = null;\n\t\tthis._data = data || {};\n\t\tthis.options = options || {};\n\t\tthis._resources = [];\n\t\tthis.urlObject = null;\n\t\tthis._i18n = {};\n\t\tthis.loaded = false;\n\t\tthis.loading = false;\n\t\tthis.registry = null;\n\t\tif (file) this.file = file;\n\t}\n\tset id(value) {\n\t\tthis._id = value;\n\t}\n\tget id() {\n\t\treturn this._id;\n\t}\n\tset name(value) {\n\t\tif (this._name === value) {\n\t\t\treturn;\n\t\t}\n\t\tconst old = this._name;\n\t\tthis._name = value;\n\t\tthis.fire('name', this, this._name, old);\n\t}\n\tget name() {\n\t\treturn this._name;\n\t}\n\tset file(value) {\n\t\tif (value && value.variants && ['texture', 'textureatlas', 'bundle'].indexOf(this.type) !== -1) {\n\t\t\tvar _this$registry;\n\t\t\tconst app = ((_this$registry = this.registry) == null || (_this$registry = _this$registry._loader) == null ? void 0 : _this$registry._app) || getApplication();\n\t\t\tconst device = app == null ? void 0 : app.graphicsDevice;\n\t\t\tif (device) {\n\t\t\t\tfor (let i = 0, len = VARIANT_DEFAULT_PRIORITY.length; i < len; i++) {\n\t\t\t\t\tconst variant = VARIANT_DEFAULT_PRIORITY[i];\n\t\t\t\t\tif (value.variants[variant] && device[VARIANT_SUPPORT[variant]]) {\n\t\t\t\t\t\tvalue = value.variants[variant];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (app.enableBundles) {\n\t\t\t\t\t\tconst bundles = app.bundles.listBundlesForAsset(this);\n\t\t\t\t\t\tif (bundles && bundles.find(b => {\n\t\t\t\t\t\t\tvar _b$file;\n\t\t\t\t\t\t\treturn b == null || (_b$file = b.file) == null ? void 0 : _b$file.variants[variant];\n\t\t\t\t\t\t})) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst oldFile = this._file;\n\t\tconst newFile = value ? new AssetFile(value.url, value.filename, value.hash, value.size, value.opt, value.contents) : null;\n\t\tif (!!newFile !== !!oldFile || newFile && !newFile.equals(oldFile)) {\n\t\t\tthis._file = newFile;\n\t\t\tthis.fire('change', this, 'file', newFile, oldFile);\n\t\t\tthis.reload();\n\t\t}\n\t}\n\tget file() {\n\t\treturn this._file;\n\t}\n\tset data(value) {\n\t\tconst old = this._data;\n\t\tthis._data = value;\n\t\tif (value !== old) {\n\t\t\tthis.fire('change', this, 'data', value, old);\n\t\t\tif (this.loaded) {\n\t\t\t\tthis.registry._loader.patch(this, this.registry);\n\t\t\t}\n\t\t}\n\t}\n\tget data() {\n\t\treturn this._data;\n\t}\n\tset resource(value) {\n\t\tconst _old = this._resources[0];\n\t\tthis._resources[0] = value;\n\t\tthis.fire('change', this, 'resource', value, _old);\n\t}\n\tget resource() {\n\t\treturn this._resources[0];\n\t}\n\tset resources(value) {\n\t\tconst _old = this._resources;\n\t\tthis._resources = value;\n\t\tthis.fire('change', this, 'resources', value, _old);\n\t}\n\tget resources() {\n\t\treturn this._resources;\n\t}\n\tset preload(value) {\n\t\tvalue = !!value;\n\t\tif (this._preload === value) {\n\t\t\treturn;\n\t\t}\n\t\tthis._preload = value;\n\t\tif (this._preload && !this.loaded && !this.loading && this.registry) {\n\t\t\tthis.registry.load(this);\n\t\t}\n\t}\n\tget preload() {\n\t\treturn this._preload;\n\t}\n\tset loadFaces(value) {\n\t\tvalue = !!value;\n\t\tif (!this.hasOwnProperty('_loadFaces') || value !== this._loadFaces) {\n\t\t\tthis._loadFaces = value;\n\t\t\tif (this.loaded) {\n\t\t\t\tthis.registry._loader.patch(this, this.registry);\n\t\t\t}\n\t\t}\n\t}\n\tget loadFaces() {\n\t\treturn this._loadFaces;\n\t}\n\tgetFileUrl() {\n\t\tconst file = this.file;\n\t\tif (!file || !file.url) {\n\t\t\treturn null;\n\t\t}\n\t\tlet url = file.url;\n\t\tif (this.registry && this.registry.prefix && !ABSOLUTE_URL.test(url)) {\n\t\t\turl = this.registry.prefix + url;\n\t\t}\n\t\tif (this.type !== 'script' && file.hash) {\n\t\t\tconst separator = url.indexOf('?') !== -1 ? '&' : '?';\n\t\t\turl += `${separator}t=${file.hash}`;\n\t\t}\n\t\treturn url;\n\t}\n\tgetAbsoluteUrl(relativePath) {\n\t\tif (relativePath.startsWith('blob:') || relativePath.startsWith('data:')) {\n\t\t\treturn relativePath;\n\t\t}\n\t\tconst base = path.getDirectory(this.file.url);\n\t\treturn path.join(base, relativePath);\n\t}\n\tgetLocalizedAssetId(locale) {\n\t\tlocale = findAvailableLocale(locale, this._i18n);\n\t\treturn this._i18n[locale] || null;\n\t}\n\taddLocalizedAssetId(locale, assetId) {\n\t\tthis._i18n[locale] = assetId;\n\t\tthis.fire('add:localized', locale, assetId);\n\t}\n\tremoveLocalizedAssetId(locale) {\n\t\tconst assetId = this._i18n[locale];\n\t\tif (assetId) {\n\t\t\tdelete this._i18n[locale];\n\t\t\tthis.fire('remove:localized', locale, assetId);\n\t\t}\n\t}\n\tready(callback, scope) {\n\t\tscope = scope || this;\n\t\tif (this.loaded) {\n\t\t\tcallback.call(scope, this);\n\t\t} else {\n\t\t\tthis.once('load', asset => {\n\t\t\t\tcallback.call(scope, asset);\n\t\t\t});\n\t\t}\n\t}\n\treload() {\n\t\tif (this.loaded) {\n\t\t\tthis.loaded = false;\n\t\t\tthis.registry.load(this);\n\t\t}\n\t}\n\tunload() {\n\t\tif (!this.loaded && this._resources.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tthis.fire('unload', this);\n\t\tthis.registry.fire(`unload:${this.id}`, this);\n\t\tconst old = this._resources;\n\t\tif (this.urlObject) {\n\t\t\tURL.revokeObjectURL(this.urlObject);\n\t\t\tthis.urlObject = null;\n\t\t}\n\t\tthis.resources = [];\n\t\tthis.loaded = false;\n\t\tif (this.file) {\n\t\t\tthis.registry._loader.clearCache(this.getFileUrl(), this.type);\n\t\t}\n\t\tfor (let i = 0; i < old.length; ++i) {\n\t\t\tconst resource = old[i];\n\t\t\tif (resource && resource.destroy) {\n\t\t\t\tresource.destroy();\n\t\t\t}\n\t\t}\n\t}\n\tstatic fetchArrayBuffer(loadUrl, callback, asset, maxRetries = 0) {\n\t\tvar _asset$file;\n\t\tif (asset != null && (_asset$file = asset.file) != null && _asset$file.contents) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tcallback(null, asset.file.contents);\n\t\t\t});\n\t\t} else {\n\t\t\thttp.get(loadUrl, {\n\t\t\t\tcache: true,\n\t\t\t\tresponseType: 'arraybuffer',\n\t\t\t\tretry: maxRetries > 0,\n\t\t\t\tmaxRetries: maxRetries\n\t\t\t}, callback);\n\t\t}\n\t}\n}\nAsset.EVENT_LOAD = 'load';\nAsset.EVENT_UNLOAD = 'unload';\nAsset.EVENT_REMOVE = 'remove';\nAsset.EVENT_ERROR = 'error';\nAsset.EVENT_CHANGE = 'change';\nAsset.EVENT_ADDLOCALIZED = 'add:localized';\nAsset.EVENT_REMOVELOCALIZED = 'remove:localized';\n\nexport { Asset };\n","const ABSOLUTE_URL = new RegExp('^' + '\\\\s*' + '(?:' + '(?:' + '[a-z]+[a-z0-9\\\\-+.]*' + ':' + ')?' + '//' + '|' + 'data:' + '|blob:' + ')', 'i');\nconst ASSET_ANIMATION = 'animation';\nconst ASSET_AUDIO = 'audio';\nconst ASSET_IMAGE = 'image';\nconst ASSET_JSON = 'json';\nconst ASSET_MODEL = 'model';\nconst ASSET_MATERIAL = 'material';\nconst ASSET_TEXT = 'text';\nconst ASSET_TEXTURE = 'texture';\nconst ASSET_TEXTUREATLAS = 'textureatlas';\nconst ASSET_CUBEMAP = 'cubemap';\nconst ASSET_SHADER = 'shader';\nconst ASSET_CSS = 'css';\nconst ASSET_HTML = 'html';\nconst ASSET_SCRIPT = 'script';\nconst ASSET_CONTAINER = 'container';\n\nexport { ABSOLUTE_URL, ASSET_ANIMATION, ASSET_AUDIO, ASSET_CONTAINER, ASSET_CSS, ASSET_CUBEMAP, ASSET_HTML, ASSET_IMAGE, ASSET_JSON, ASSET_MATERIAL, ASSET_MODEL, ASSET_SCRIPT, ASSET_SHADER, ASSET_TEXT, ASSET_TEXTURE, ASSET_TEXTUREATLAS };\n","class BundleRegistry {\n\tconstructor(assets) {\n\t\tthis._idToBundle = new Map();\n\t\tthis._assetToBundles = new Map();\n\t\tthis._urlsToBundles = new Map();\n\t\tthis._fileRequests = new Map();\n\t\tthis._assets = assets;\n\t\tthis._assets.bundles = this;\n\t\tthis._assets.on('add', this._onAssetAdd, this);\n\t\tthis._assets.on('remove', this._onAssetRemove, this);\n\t}\n\t_onAssetAdd(asset) {\n\t\tif (asset.type === 'bundle') {\n\t\t\tthis._idToBundle.set(asset.id, asset);\n\t\t\tthis._assets.on(`load:start:${asset.id}`, this._onBundleLoadStart, this);\n\t\t\tthis._assets.on(`load:${asset.id}`, this._onBundleLoad, this);\n\t\t\tthis._assets.on(`error:${asset.id}`, this._onBundleError, this);\n\t\t\tconst assetIds = asset.data.assets;\n\t\t\tfor (let i = 0; i < assetIds.length; i++) {\n\t\t\t\tthis._indexAssetInBundle(assetIds[i], asset);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this._assetToBundles.has(asset.id)) {\n\t\t\t\tthis._indexAssetFileUrls(asset);\n\t\t\t}\n\t\t}\n\t}\n\t_unbindAssetEvents(id) {\n\t\tthis._assets.off(`load:start:${id}`, this._onBundleLoadStart, this);\n\t\tthis._assets.off(`load:${id}`, this._onBundleLoad, this);\n\t\tthis._assets.off(`error:${id}`, this._onBundleError, this);\n\t}\n\t_indexAssetInBundle(id, bundle) {\n\t\tlet bundles = this._assetToBundles.get(id);\n\t\tif (!bundles) {\n\t\t\tbundles = new Set();\n\t\t\tthis._assetToBundles.set(id, bundles);\n\t\t}\n\t\tbundles.add(bundle);\n\t\tconst asset = this._assets.get(id);\n\t\tif (asset) this._indexAssetFileUrls(asset);\n\t}\n\t_indexAssetFileUrls(asset) {\n\t\tconst urls = this._getAssetFileUrls(asset);\n\t\tif (!urls) return;\n\t\tfor (let i = 0; i < urls.length; i++) {\n\t\t\tconst bundles = this._assetToBundles.get(asset.id);\n\t\t\tif (!bundles) continue;\n\t\t\tthis._urlsToBundles.set(urls[i], bundles);\n\t\t}\n\t}\n\t_getAssetFileUrls(asset) {\n\t\tlet url = asset.getFileUrl();\n\t\tif (!url) return null;\n\t\turl = url.split('?')[0];\n\t\tconst urls = [url];\n\t\tif (asset.type === 'font') {\n\t\t\tconst numFiles = asset.data.info.maps.length;\n\t\t\tfor (let i = 1; i < numFiles; i++) {\n\t\t\t\turls.push(url.replace('.png', `${i}.png`));\n\t\t\t}\n\t\t}\n\t\treturn urls;\n\t}\n\t_onAssetRemove(asset) {\n\t\tif (asset.type === 'bundle') {\n\t\t\tthis._idToBundle.delete(asset.id);\n\t\t\tthis._unbindAssetEvents(asset.id);\n\t\t\tconst assetIds = asset.data.assets;\n\t\t\tfor (let i = 0; i < assetIds.length; i++) {\n\t\t\t\tconst bundles = this._assetToBundles.get(assetIds[i]);\n\t\t\t\tif (!bundles) continue;\n\t\t\t\tbundles.delete(asset);\n\t\t\t\tif (bundles.size === 0) {\n\t\t\t\t\tthis._assetToBundles.delete(assetIds[i]);\n\t\t\t\t\tfor (const [url, otherBundles] of this._urlsToBundles) {\n\t\t\t\t\t\tif (otherBundles !== bundles) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._urlsToBundles.delete(url);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._onBundleError(`Bundle ${asset.id} was removed`);\n\t\t} else {\n\t\t\tconst bundles = this._assetToBundles.get(asset.id);\n\t\t\tif (!bundles) return;\n\t\t\tthis._assetToBundles.delete(asset.id);\n\t\t\tconst urls = this._getAssetFileUrls(asset);\n\t\t\tif (!urls) return;\n\t\t\tfor (let i = 0; i < urls.length; i++) {\n\t\t\t\tthis._urlsToBundles.delete(urls[i]);\n\t\t\t}\n\t\t}\n\t}\n\t_onBundleLoadStart(asset) {\n\t\tasset.resource.on('add', (url, data) => {\n\t\t\tconst callbacks = this._fileRequests.get(url);\n\t\t\tif (!callbacks) return;\n\t\t\tfor (let i = 0; i < callbacks.length; i++) {\n\t\t\t\tcallbacks[i](null, data);\n\t\t\t}\n\t\t\tthis._fileRequests.delete(url);\n\t\t});\n\t}\n\t_onBundleLoad(asset) {\n\t\tif (!asset.resource) {\n\t\t\tthis._onBundleError(`Bundle ${asset.id} failed to load`);\n\t\t\treturn;\n\t\t}\n\t\tif (!this._fileRequests) {\n\t\t\treturn;\n\t\t}\n\t\tfor (const [url, requests] of this._fileRequests) {\n\t\t\tconst bundles = this._urlsToBundles.get(url);\n\t\t\tif (!bundles || !bundles.has(asset)) continue;\n\t\t\tconst decodedUrl = decodeURIComponent(url);\n\t\t\tlet err, data;\n\t\t\tif (asset.resource.has(decodedUrl)) {\n\t\t\t\tdata = asset.resource.get(decodedUrl);\n\t\t\t} else if (asset.resource.loaded) {\n\t\t\t\terr = `Bundle ${asset.id} does not contain URL ${url}`;\n\t\t\t} else {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (let i = 0; i < requests.length; i++) {\n\t\t\t\trequests[i](err, err || data);\n\t\t\t}\n\t\t\tthis._fileRequests.delete(url);\n\t\t}\n\t}\n\t_onBundleError(err) {\n\t\tfor (const [url, requests] of this._fileRequests) {\n\t\t\tconst bundle = this._findLoadedOrLoadingBundleForUrl(url);\n\t\t\tif (!bundle) {\n\t\t\t\tfor (let i = 0; i < requests.length; i++) {\n\t\t\t\t\trequests[i](err);\n\t\t\t\t}\n\t\t\t\tthis._fileRequests.delete(url);\n\t\t\t}\n\t\t}\n\t}\n\t_findLoadedOrLoadingBundleForUrl(url) {\n\t\tconst bundles = this._urlsToBundles.get(url);\n\t\tif (!bundles) return null;\n\t\tlet candidate = null;\n\t\tfor (const bundle of bundles) {\n\t\t\tif (bundle.loaded && bundle.resource) {\n\t\t\t\treturn bundle;\n\t\t\t} else if (bundle.loading) {\n\t\t\t\tcandidate = bundle;\n\t\t\t}\n\t\t}\n\t\treturn candidate;\n\t}\n\tlistBundlesForAsset(asset) {\n\t\tconst bundles = this._assetToBundles.get(asset.id);\n\t\tif (bundles) return Array.from(bundles);\n\t\treturn null;\n\t}\n\tlist() {\n\t\treturn Array.from(this._idToBundle.values());\n\t}\n\thasUrl(url) {\n\t\treturn this._urlsToBundles.has(url);\n\t}\n\turlIsLoadedOrLoading(url) {\n\t\treturn !!this._findLoadedOrLoadingBundleForUrl(url);\n\t}\n\tloadUrl(url, callback) {\n\t\tconst bundle = this._findLoadedOrLoadingBundleForUrl(url);\n\t\tif (!bundle) {\n\t\t\tcallback(`URL ${url} not found in any bundles`);\n\t\t\treturn;\n\t\t}\n\t\tif (bundle.loaded) {\n\t\t\tconst decodedUrl = decodeURIComponent(url);\n\t\t\tif (bundle.resource.has(decodedUrl)) {\n\t\t\t\tcallback(null, bundle.resource.get(decodedUrl));\n\t\t\t\treturn;\n\t\t\t} else if (bundle.resource.loaded) {\n\t\t\t\tcallback(`Bundle ${bundle.id} does not contain URL ${url}`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tlet callbacks = this._fileRequests.get(url);\n\t\tif (!callbacks) {\n\t\t\tcallbacks = [];\n\t\t\tthis._fileRequests.set(url, callbacks);\n\t\t}\n\t\tcallbacks.push(callback);\n\t}\n\tdestroy() {\n\t\tthis._assets.off('add', this._onAssetAdd, this);\n\t\tthis._assets.off('remove', this._onAssetRemove, this);\n\t\tfor (const id of this._idToBundle.keys()) {\n\t\t\tthis._unbindAssetEvents(id);\n\t\t}\n\t\tthis._assets = null;\n\t\tthis._idToBundle.clear();\n\t\tthis._idToBundle = null;\n\t\tthis._assetToBundles.clear();\n\t\tthis._assetToBundles = null;\n\t\tthis._urlsToBundles.clear();\n\t\tthis._urlsToBundles = null;\n\t\tthis._fileRequests.clear();\n\t\tthis._fileRequests = null;\n\t}\n}\n\nexport { BundleRegistry };\n","import { EventHandler } from '../../core/event-handler.js';\n\nclass Bundle extends EventHandler {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis._index = new Map();\n\t\tthis._loaded = false;\n\t}\n\taddFile(url, data) {\n\t\tif (this._index.has(url)) {\n\t\t\treturn;\n\t\t}\n\t\tthis._index.set(url, data);\n\t\tthis.fire('add', url, data);\n\t}\n\thas(url) {\n\t\treturn this._index.has(url);\n\t}\n\tget(url) {\n\t\treturn this._index.get(url) || null;\n\t}\n\tdestroy() {\n\t\tthis._index.clear();\n\t}\n\tset loaded(value) {\n\t\tif (!value || this._loaded) {\n\t\t\treturn;\n\t\t}\n\t\tthis._loaded = true;\n\t\tthis.fire('load');\n\t}\n\tget loaded() {\n\t\treturn this._loaded;\n\t}\n}\nBundle.EVENT_ADD = 'add';\nBundle.EVENT_LOAD = 'load';\n\nexport { Bundle };\n","import { AnimTarget } from '../../anim/evaluator/anim-target.js';\nimport { DefaultAnimBinder } from '../../anim/binder/default-anim-binder.js';\nimport { AnimBinder } from '../../anim/binder/anim-binder.js';\nimport { Color } from '../../../core/math/color.js';\nimport { Quat } from '../../../core/math/quat.js';\nimport { Vec2 } from '../../../core/math/vec2.js';\nimport { Vec3 } from '../../../core/math/vec3.js';\nimport { Vec4 } from '../../../core/math/vec4.js';\n\nconst v2 = new Vec2();\nconst v3 = new Vec3();\nconst v4 = new Vec4();\nconst c = new Color();\nconst q = new Quat();\nclass AnimComponentBinder extends DefaultAnimBinder {\n\tconstructor(animComponent, graph, layerName, mask, layerIndex) {\n\t\tsuper(graph);\n\t\tthis.animComponent = animComponent;\n\t\tthis._mask = mask;\n\t\tthis.layerName = layerName;\n\t\tthis.layerIndex = layerIndex;\n\t}\n\tstatic _packFloat(values) {\n\t\treturn values[0];\n\t}\n\tstatic _packBoolean(values) {\n\t\treturn !!values[0];\n\t}\n\tstatic _packVec2(values) {\n\t\tv2.x = values[0];\n\t\tv2.y = values[1];\n\t\treturn v2;\n\t}\n\tstatic _packVec3(values) {\n\t\tv3.x = values[0];\n\t\tv3.y = values[1];\n\t\tv3.z = values[2];\n\t\treturn v3;\n\t}\n\tstatic _packVec4(values) {\n\t\tv4.x = values[0];\n\t\tv4.y = values[1];\n\t\tv4.z = values[2];\n\t\tv4.w = values[3];\n\t\treturn v4;\n\t}\n\tstatic _packColor(values) {\n\t\tc.r = values[0];\n\t\tc.g = values[1];\n\t\tc.b = values[2];\n\t\tc.a = values[3];\n\t\treturn c;\n\t}\n\tstatic _packQuat(values) {\n\t\tq.x = values[0];\n\t\tq.y = values[1];\n\t\tq.z = values[2];\n\t\tq.w = values[3];\n\t\treturn q;\n\t}\n\tresolve(path) {\n\t\tconst encodedPath = AnimBinder.encode(path.entityPath, path.component, path.propertyPath);\n\t\tlet target = this.targetCache[encodedPath];\n\t\tif (target) return target;\n\t\tlet entity;\n\t\tlet propertyComponent;\n\t\tlet targetPath;\n\t\tswitch (path.component) {\n\t\t\tcase 'entity':\n\t\t\t\tentity = this._getEntityFromHierarchy(path.entityPath);\n\t\t\t\ttargetPath = AnimBinder.encode(entity.path, 'entity', path.propertyPath);\n\t\t\t\tpropertyComponent = entity;\n\t\t\t\tbreak;\n\t\t\tcase 'graph':\n\t\t\t\tpropertyComponent = this.findNode(path);\n\t\t\t\tif (!propertyComponent) return null;\n\t\t\t\ttargetPath = AnimBinder.encode(propertyComponent.path, 'graph', path.propertyPath);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tentity = this._getEntityFromHierarchy(path.entityPath);\n\t\t\t\tpropertyComponent = entity.findComponent(path.component);\n\t\t\t\tif (!propertyComponent) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\ttargetPath = AnimBinder.encode(entity.path, path.component, path.propertyPath);\n\t\t\t\tbreak;\n\t\t}\n\t\ttarget = this._createAnimTargetForProperty(propertyComponent, path.propertyPath, targetPath);\n\t\tthis.targetCache[encodedPath] = target;\n\t\treturn target;\n\t}\n\tupdate(deltaTime) {\n\t\tconst activeNodes = this.activeNodes;\n\t\tif (activeNodes) {\n\t\t\tfor (let i = 0; i < activeNodes.length; i++) {\n\t\t\t\tactiveNodes[i]._dirtifyLocal();\n\t\t\t}\n\t\t}\n\t}\n\t_getEntityFromHierarchy(entityHierarchy) {\n\t\tif (!this.animComponent.entity.name === entityHierarchy[0]) {\n\t\t\treturn null;\n\t\t}\n\t\tconst currEntity = this.animComponent.entity;\n\t\tif (entityHierarchy.length === 1) {\n\t\t\treturn currEntity;\n\t\t}\n\t\treturn currEntity._parent.findByPath(entityHierarchy);\n\t}\n\t_resolvePath(object, path, resolveLeaf) {\n\t\tconst steps = path.length - (resolveLeaf ? 0 : 1);\n\t\tfor (let i = 0; i < steps; i++) {\n\t\t\tobject = object[path[i]];\n\t\t}\n\t\treturn object;\n\t}\n\t_setter(object, path, packFunc) {\n\t\tconst obj = this._resolvePath(object, path);\n\t\tconst key = path[path.length - 1];\n\t\tconst setterFuncName = `set${key.substring(0, 1).toUpperCase()}${key.substring(1)}`;\n\t\tif (obj[setterFuncName]) {\n\t\t\tconst getterFunc = obj[`get${key.substring(0, 1).toUpperCase()}${key.substring(1)}`].bind(obj);\n\t\t\tlet baseValues = getterFunc();\n\t\t\tbaseValues = [baseValues.x, baseValues.y, baseValues.z, baseValues.w];\n\t\t\tconst setterFunc = obj[setterFuncName].bind(obj);\n\t\t\treturn {\n\t\t\t\tset: values => {\n\t\t\t\t\tsetterFunc(packFunc(values));\n\t\t\t\t},\n\t\t\t\tget: () => baseValues\n\t\t\t};\n\t\t}\n\t\tconst prop = obj[key];\n\t\tif (typeof prop === 'object' && prop.hasOwnProperty('copy')) {\n\t\t\treturn function (values) {\n\t\t\t\tprop.copy(packFunc(values));\n\t\t\t};\n\t\t}\n\t\tif ([Vec2, Vec3, Vec4, Color, Quat].indexOf(obj.constructor) !== -1 && path.length > 1) {\n\t\t\tconst parent = path.length > 2 ? this._resolvePath(object, path.slice(0, -1)) : object;\n\t\t\tconst objKey = path[path.length - 2];\n\t\t\treturn function (values) {\n\t\t\t\tobj[key] = packFunc(values);\n\t\t\t\tparent[objKey] = obj;\n\t\t\t};\n\t\t}\n\t\treturn function (values) {\n\t\t\tobj[key] = packFunc(values);\n\t\t};\n\t}\n\t_createAnimTargetForProperty(propertyComponent, propertyHierarchy, targetPath) {\n\t\tif (this.handlers && propertyHierarchy[0].startsWith('weight.')) {\n\t\t\treturn this.handlers.weight(propertyComponent, propertyHierarchy[0].replace('weight.', ''));\n\t\t} else if (this.handlers && propertyHierarchy[0] === 'material' && propertyHierarchy.length === 2) {\n\t\t\tconst materialPropertyName = propertyHierarchy[1];\n\t\t\tif (materialPropertyName.endsWith('Map')) {\n\t\t\t\treturn this.handlers.materialTexture(propertyComponent, materialPropertyName);\n\t\t\t}\n\t\t}\n\t\tconst property = this._resolvePath(propertyComponent, propertyHierarchy, true);\n\t\tif (typeof property === 'undefined') {\n\t\t\treturn null;\n\t\t}\n\t\tlet setter;\n\t\tlet animDataType;\n\t\tlet animDataComponents;\n\t\tif (typeof property === 'number') {\n\t\t\tsetter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packFloat);\n\t\t\tanimDataType = 'vector';\n\t\t\tanimDataComponents = 1;\n\t\t} else if (typeof property === 'boolean') {\n\t\t\tsetter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packBoolean);\n\t\t\tanimDataType = 'vector';\n\t\t\tanimDataComponents = 1;\n\t\t} else if (typeof property === 'object') {\n\t\t\tswitch (property.constructor) {\n\t\t\t\tcase Vec2:\n\t\t\t\t\tsetter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec2);\n\t\t\t\t\tanimDataType = 'vector';\n\t\t\t\t\tanimDataComponents = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase Vec3:\n\t\t\t\t\tsetter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec3);\n\t\t\t\t\tanimDataType = 'vector';\n\t\t\t\t\tanimDataComponents = 3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase Vec4:\n\t\t\t\t\tsetter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packVec4);\n\t\t\t\t\tanimDataType = 'vector';\n\t\t\t\t\tanimDataComponents = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase Color:\n\t\t\t\t\tsetter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packColor);\n\t\t\t\t\tanimDataType = 'vector';\n\t\t\t\t\tanimDataComponents = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase Quat:\n\t\t\t\t\tsetter = this._setter(propertyComponent, propertyHierarchy, AnimComponentBinder._packQuat);\n\t\t\t\t\tanimDataType = 'quaternion';\n\t\t\t\t\tanimDataComponents = 4;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tif (propertyHierarchy.indexOf('material') !== -1) {\n\t\t\treturn new AnimTarget(values => {\n\t\t\t\tsetter(values);\n\t\t\t\tpropertyComponent.material.update();\n\t\t\t}, animDataType, animDataComponents, targetPath);\n\t\t}\n\t\treturn new AnimTarget(setter, animDataType, animDataComponents, targetPath);\n\t}\n\trebind() {\n\t\tthis.targetCache = {};\n\t\tif (this.animComponent.rootBone) {\n\t\t\tthis.graph = this.animComponent.rootBone;\n\t\t} else {\n\t\t\tthis.graph = this.animComponent.entity;\n\t\t}\n\t\tconst nodes = {};\n\t\tconst flatten = function flatten(node) {\n\t\t\tnodes[node.name] = node;\n\t\t\tfor (let i = 0; i < node.children.length; ++i) {\n\t\t\t\tflatten(node.children[i]);\n\t\t\t}\n\t\t};\n\t\tflatten(this.graph);\n\t\tthis.nodes = nodes;\n\t}\n}\n\nexport { AnimComponentBinder };\n","import { math } from '../../../core/math/math.js';\nimport { AnimTrack } from '../../anim/evaluator/anim-track.js';\nimport { AnimTransition } from '../../anim/controller/anim-transition.js';\nimport { ANIM_LAYER_OVERWRITE } from '../../anim/controller/constants.js';\n\nclass AnimComponentLayer {\n\tconstructor(name, controller, component, weight = 1, blendType = ANIM_LAYER_OVERWRITE) {\n\t\tthis._name = void 0;\n\t\tthis._controller = void 0;\n\t\tthis._component = void 0;\n\t\tthis._weight = void 0;\n\t\tthis._blendType = void 0;\n\t\tthis._mask = null;\n\t\tthis._blendTime = 0;\n\t\tthis._blendTimeElapsed = 0;\n\t\tthis._startingWeight = 0;\n\t\tthis._targetWeight = 0;\n\t\tthis._name = name;\n\t\tthis._controller = controller;\n\t\tthis._component = component;\n\t\tthis._weight = weight;\n\t\tthis._blendType = blendType;\n\t}\n\tget name() {\n\t\treturn this._name;\n\t}\n\tset playing(value) {\n\t\tthis._controller.playing = value;\n\t}\n\tget playing() {\n\t\treturn this._controller.playing;\n\t}\n\tget playable() {\n\t\treturn this._controller.playable;\n\t}\n\tget activeState() {\n\t\treturn this._controller.activeStateName;\n\t}\n\tget previousState() {\n\t\treturn this._controller.previousStateName;\n\t}\n\tget activeStateProgress() {\n\t\treturn this._controller.activeStateProgress;\n\t}\n\tget activeStateDuration() {\n\t\treturn this._controller.activeStateDuration;\n\t}\n\tset activeStateCurrentTime(time) {\n\t\tconst controller = this._controller;\n\t\tconst layerPlaying = controller.playing;\n\t\tcontroller.playing = true;\n\t\tcontroller.activeStateCurrentTime = time;\n\t\tif (!layerPlaying) {\n\t\t\tcontroller.update(0);\n\t\t}\n\t\tcontroller.playing = layerPlaying;\n\t}\n\tget activeStateCurrentTime() {\n\t\treturn this._controller.activeStateCurrentTime;\n\t}\n\tget transitioning() {\n\t\treturn this._controller.transitioning;\n\t}\n\tget transitionProgress() {\n\t\tif (this.transitioning) {\n\t\t\treturn this._controller.transitionProgress;\n\t\t}\n\t\treturn null;\n\t}\n\tget states() {\n\t\treturn this._controller.states;\n\t}\n\tset weight(value) {\n\t\tthis._weight = value;\n\t\tthis._component.dirtifyTargets();\n\t}\n\tget weight() {\n\t\treturn this._weight;\n\t}\n\tset blendType(value) {\n\t\tif (value !== this._blendType) {\n\t\t\tthis._blendType = value;\n\t\t\tif (this._controller.normalizeWeights) {\n\t\t\t\tthis._component.rebind();\n\t\t\t}\n\t\t}\n\t}\n\tget blendType() {\n\t\treturn this._blendType;\n\t}\n\tset mask(value) {\n\t\tif (this._controller.assignMask(value)) {\n\t\t\tthis._component.rebind();\n\t\t}\n\t\tthis._mask = value;\n\t}\n\tget mask() {\n\t\treturn this._mask;\n\t}\n\tplay(name) {\n\t\tthis._controller.play(name);\n\t}\n\tpause() {\n\t\tthis._controller.pause();\n\t}\n\treset() {\n\t\tthis._controller.reset();\n\t}\n\trebind() {\n\t\tthis._controller.rebind();\n\t}\n\tupdate(dt) {\n\t\tif (this._blendTime) {\n\t\t\tif (this._blendTimeElapsed < this._blendTime) {\n\t\t\t\tthis.weight = math.lerp(this._startingWeight, this._targetWeight, this._blendTimeElapsed / this._blendTime);\n\t\t\t\tthis._blendTimeElapsed += dt;\n\t\t\t} else {\n\t\t\t\tthis.weight = this._targetWeight;\n\t\t\t\tthis._blendTime = 0;\n\t\t\t\tthis._blendTimeElapsed = 0;\n\t\t\t\tthis._startingWeight = 0;\n\t\t\t\tthis._targetWeight = 0;\n\t\t\t}\n\t\t}\n\t\tthis._controller.update(dt);\n\t}\n\tblendToWeight(weight, time) {\n\t\tthis._startingWeight = this.weight;\n\t\tthis._targetWeight = weight;\n\t\tthis._blendTime = Math.max(0, time);\n\t\tthis._blendTimeElapsed = 0;\n\t}\n\tassignMask(mask) {\n\t\tif (this._controller.assignMask(mask)) {\n\t\t\tthis._component.rebind();\n\t\t}\n\t\tthis._mask = mask;\n\t}\n\tassignAnimation(nodePath, animTrack, speed, loop) {\n\t\tif (!(animTrack instanceof AnimTrack)) {\n\t\t\treturn;\n\t\t}\n\t\tthis._controller.assignAnimation(nodePath, animTrack, speed, loop);\n\t\tif (this._controller._transitions.length === 0) {\n\t\t\tthis._controller._transitions.push(new AnimTransition({\n\t\t\t\tfrom: 'START',\n\t\t\t\tto: nodePath\n\t\t\t}));\n\t\t}\n\t\tif (this._component.activate && this._component.playable) {\n\t\t\tthis._component.playing = true;\n\t\t}\n\t}\n\tremoveNodeAnimations(nodeName) {\n\t\tif (this._controller.removeNodeAnimations(nodeName)) {\n\t\t\tthis._component.playing = false;\n\t\t}\n\t}\n\tgetAnimationAsset(stateName) {\n\t\treturn this._component.animationAssets[`${this.name}:${stateName}`];\n\t}\n\ttransition(to, time = 0, transitionOffset = null) {\n\t\tthis._controller.updateStateFromTransition(new AnimTransition({\n\t\t\tfrom: this._controller.activeStateName,\n\t\t\tto,\n\t\t\ttime,\n\t\t\ttransitionOffset\n\t\t}));\n\t}\n}\n\nexport { AnimComponentLayer };\n","import { extends as _extends } from '../../../../_virtual/_rollupPluginBabelHelpers.js';\nimport { Asset } from '../../asset/asset.js';\nimport { AnimEvaluator } from '../../anim/evaluator/anim-evaluator.js';\nimport { AnimController } from '../../anim/controller/anim-controller.js';\nimport { Component } from '../component.js';\nimport { ANIM_CONTROL_STATES, ANIM_PARAMETER_FLOAT, ANIM_PARAMETER_INTEGER, ANIM_PARAMETER_BOOLEAN, ANIM_PARAMETER_TRIGGER } from '../../anim/controller/constants.js';\nimport { AnimComponentBinder } from './component-binder.js';\nimport { AnimComponentLayer } from './component-layer.js';\nimport { AnimStateGraph } from '../../anim/state-graph/anim-state-graph.js';\nimport { Entity } from '../../entity.js';\nimport { AnimTrack } from '../../anim/evaluator/anim-track.js';\n\nclass AnimComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis.findParameter = name => {\n\t\t\treturn this._parameters[name];\n\t\t};\n\t\tthis.consumeTrigger = name => {\n\t\t\tthis._consumedTriggers.add(name);\n\t\t};\n\t\tthis._stateGraphAsset = null;\n\t\tthis._animationAssets = {};\n\t\tthis._speed = 1.0;\n\t\tthis._activate = true;\n\t\tthis._playing = false;\n\t\tthis._rootBone = null;\n\t\tthis._stateGraph = null;\n\t\tthis._layers = [];\n\t\tthis._layerIndices = {};\n\t\tthis._parameters = {};\n\t\tthis._targets = {};\n\t\tthis._consumedTriggers = new Set();\n\t\tthis._normalizeWeights = false;\n\t}\n\tset stateGraphAsset(value) {\n\t\tif (value === null) {\n\t\t\tthis.removeStateGraph();\n\t\t\treturn;\n\t\t}\n\t\tif (this._stateGraphAsset) {\n\t\t\tconst stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);\n\t\t\tstateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);\n\t\t}\n\t\tlet _id;\n\t\tlet _asset;\n\t\tif (value instanceof Asset) {\n\t\t\t_id = value.id;\n\t\t\t_asset = this.system.app.assets.get(_id);\n\t\t\tif (!_asset) {\n\t\t\t\tthis.system.app.assets.add(value);\n\t\t\t\t_asset = this.system.app.assets.get(_id);\n\t\t\t}\n\t\t} else {\n\t\t\t_id = value;\n\t\t\t_asset = this.system.app.assets.get(_id);\n\t\t}\n\t\tif (!_asset || this._stateGraphAsset === _id) {\n\t\t\treturn;\n\t\t}\n\t\tif (_asset.resource) {\n\t\t\tthis._stateGraph = _asset.resource;\n\t\t\tthis.loadStateGraph(this._stateGraph);\n\t\t\t_asset.on('change', this._onStateGraphAssetChangeEvent, this);\n\t\t} else {\n\t\t\t_asset.once('load', asset => {\n\t\t\t\tthis._stateGraph = asset.resource;\n\t\t\t\tthis.loadStateGraph(this._stateGraph);\n\t\t\t});\n\t\t\t_asset.on('change', this._onStateGraphAssetChangeEvent, this);\n\t\t\tthis.system.app.assets.load(_asset);\n\t\t}\n\t\tthis._stateGraphAsset = _id;\n\t}\n\tget stateGraphAsset() {\n\t\treturn this._stateGraphAsset;\n\t}\n\tset normalizeWeights(value) {\n\t\tthis._normalizeWeights = value;\n\t\tthis.unbind();\n\t}\n\tget normalizeWeights() {\n\t\treturn this._normalizeWeights;\n\t}\n\tset animationAssets(value) {\n\t\tthis._animationAssets = value;\n\t\tthis.loadAnimationAssets();\n\t}\n\tget animationAssets() {\n\t\treturn this._animationAssets;\n\t}\n\tset speed(value) {\n\t\tthis._speed = value;\n\t}\n\tget speed() {\n\t\treturn this._speed;\n\t}\n\tset activate(value) {\n\t\tthis._activate = value;\n\t}\n\tget activate() {\n\t\treturn this._activate;\n\t}\n\tset playing(value) {\n\t\tthis._playing = value;\n\t}\n\tget playing() {\n\t\treturn this._playing;\n\t}\n\tset rootBone(value) {\n\t\tif (typeof value === 'string') {\n\t\t\tconst entity = this.entity.root.findByGuid(value);\n\t\t\tthis._rootBone = entity;\n\t\t} else if (value instanceof Entity) {\n\t\t\tthis._rootBone = value;\n\t\t} else {\n\t\t\tthis._rootBone = null;\n\t\t}\n\t\tthis.rebind();\n\t}\n\tget rootBone() {\n\t\treturn this._rootBone;\n\t}\n\tset stateGraph(value) {\n\t\tthis._stateGraph = value;\n\t}\n\tget stateGraph() {\n\t\treturn this._stateGraph;\n\t}\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\tset layerIndices(value) {\n\t\tthis._layerIndices = value;\n\t}\n\tget layerIndices() {\n\t\treturn this._layerIndices;\n\t}\n\tset parameters(value) {\n\t\tthis._parameters = value;\n\t}\n\tget parameters() {\n\t\treturn this._parameters;\n\t}\n\tset targets(value) {\n\t\tthis._targets = value;\n\t}\n\tget targets() {\n\t\treturn this._targets;\n\t}\n\tget playable() {\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tif (!this._layers[i].playable) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tget baseLayer() {\n\t\tif (this._layers.length > 0) {\n\t\t\treturn this._layers[0];\n\t\t}\n\t\treturn null;\n\t}\n\t_onStateGraphAssetChangeEvent(asset) {\n\t\tconst prevAnimationAssets = this.animationAssets;\n\t\tconst prevMasks = this.layers.map(layer => layer.mask);\n\t\tthis.removeStateGraph();\n\t\tthis._stateGraph = new AnimStateGraph(asset._data);\n\t\tthis.loadStateGraph(this._stateGraph);\n\t\tthis.animationAssets = prevAnimationAssets;\n\t\tthis.loadAnimationAssets();\n\t\tthis.layers.forEach((layer, i) => {\n\t\t\tlayer.mask = prevMasks[i];\n\t\t});\n\t\tthis.rebind();\n\t}\n\tdirtifyTargets() {\n\t\tconst targets = Object.values(this._targets);\n\t\tfor (let i = 0; i < targets.length; i++) {\n\t\t\ttargets[i].dirty = true;\n\t\t}\n\t}\n\t_addLayer({\n\t\tname,\n\t\tstates,\n\t\ttransitions,\n\t\tweight,\n\t\tmask,\n\t\tblendType\n\t}) {\n\t\tlet graph;\n\t\tif (this.rootBone) {\n\t\t\tgraph = this.rootBone;\n\t\t} else {\n\t\t\tgraph = this.entity;\n\t\t}\n\t\tconst layerIndex = this._layers.length;\n\t\tconst animBinder = new AnimComponentBinder(this, graph, name, mask, layerIndex);\n\t\tconst animEvaluator = new AnimEvaluator(animBinder);\n\t\tconst controller = new AnimController(animEvaluator, states, transitions, this._activate, this, this.findParameter, this.consumeTrigger);\n\t\tthis._layers.push(new AnimComponentLayer(name, controller, this, weight, blendType));\n\t\tthis._layerIndices[name] = layerIndex;\n\t\treturn this._layers[layerIndex];\n\t}\n\taddLayer(name, weight, mask, blendType) {\n\t\tconst layer = this.findAnimationLayer(name);\n\t\tif (layer) return layer;\n\t\tconst states = [{\n\t\t\t'name': 'START',\n\t\t\t'speed': 1\n\t\t}];\n\t\tconst transitions = [];\n\t\treturn this._addLayer({\n\t\t\tname,\n\t\t\tstates,\n\t\t\ttransitions,\n\t\t\tweight,\n\t\t\tmask,\n\t\t\tblendType\n\t\t});\n\t}\n\t_assignParameters(stateGraph) {\n\t\tthis._parameters = {};\n\t\tconst paramKeys = Object.keys(stateGraph.parameters);\n\t\tfor (let i = 0; i < paramKeys.length; i++) {\n\t\t\tconst paramKey = paramKeys[i];\n\t\t\tthis._parameters[paramKey] = {\n\t\t\t\ttype: stateGraph.parameters[paramKey].type,\n\t\t\t\tvalue: stateGraph.parameters[paramKey].value\n\t\t\t};\n\t\t}\n\t}\n\tloadStateGraph(stateGraph) {\n\t\tthis._stateGraph = stateGraph;\n\t\tthis._assignParameters(stateGraph);\n\t\tthis._layers = [];\n\t\tlet containsBlendTree = false;\n\t\tfor (let i = 0; i < stateGraph.layers.length; i++) {\n\t\t\tconst layer = stateGraph.layers[i];\n\t\t\tthis._addLayer(_extends({}, layer));\n\t\t\tif (layer.states.some(state => state.blendTree)) {\n\t\t\t\tcontainsBlendTree = true;\n\t\t\t}\n\t\t}\n\t\tif (!containsBlendTree) {\n\t\t\tthis.setupAnimationAssets();\n\t\t}\n\t}\n\tsetupAnimationAssets() {\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layer = this._layers[i];\n\t\t\tconst layerName = layer.name;\n\t\t\tfor (let j = 0; j < layer.states.length; j++) {\n\t\t\t\tconst stateName = layer.states[j];\n\t\t\t\tif (ANIM_CONTROL_STATES.indexOf(stateName) === -1) {\n\t\t\t\t\tconst stateKey = `${layerName}:${stateName}`;\n\t\t\t\t\tif (!this._animationAssets[stateKey]) {\n\t\t\t\t\t\tthis._animationAssets[stateKey] = {\n\t\t\t\t\t\t\tasset: null\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.loadAnimationAssets();\n\t}\n\tloadAnimationAssets() {\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layer = this._layers[i];\n\t\t\tfor (let j = 0; j < layer.states.length; j++) {\n\t\t\t\tconst stateName = layer.states[j];\n\t\t\t\tif (ANIM_CONTROL_STATES.indexOf(stateName) !== -1) continue;\n\t\t\t\tconst animationAsset = this._animationAssets[`${layer.name}:${stateName}`];\n\t\t\t\tif (!animationAsset || !animationAsset.asset) {\n\t\t\t\t\tthis.findAnimationLayer(layer.name).assignAnimation(stateName, AnimTrack.EMPTY);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst assetId = animationAsset.asset;\n\t\t\t\tconst asset = this.system.app.assets.get(assetId);\n\t\t\t\tif (asset) {\n\t\t\t\t\tif (asset.resource) {\n\t\t\t\t\t\tthis.onAnimationAssetLoaded(layer.name, stateName, asset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tasset.once('load', function (layerName, stateName) {\n\t\t\t\t\t\t\treturn function (asset) {\n\t\t\t\t\t\t\t\tthis.onAnimationAssetLoaded(layerName, stateName, asset);\n\t\t\t\t\t\t\t}.bind(this);\n\t\t\t\t\t\t}.bind(this)(layer.name, stateName));\n\t\t\t\t\t\tthis.system.app.assets.load(asset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tonAnimationAssetLoaded(layerName, stateName, asset) {\n\t\tthis.findAnimationLayer(layerName).assignAnimation(stateName, asset.resource);\n\t}\n\tremoveStateGraph() {\n\t\tthis._stateGraph = null;\n\t\tthis._stateGraphAsset = null;\n\t\tthis._animationAssets = {};\n\t\tthis._layers = [];\n\t\tthis._layerIndices = {};\n\t\tthis._parameters = {};\n\t\tthis._playing = false;\n\t\tthis.unbind();\n\t\tthis._targets = {};\n\t}\n\treset() {\n\t\tthis._assignParameters(this._stateGraph);\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layerPlaying = this._layers[i].playing;\n\t\t\tthis._layers[i].reset();\n\t\t\tthis._layers[i].playing = layerPlaying;\n\t\t}\n\t}\n\tunbind() {\n\t\tif (!this._normalizeWeights) {\n\t\t\tObject.keys(this._targets).forEach(targetKey => {\n\t\t\t\tthis._targets[targetKey].unbind();\n\t\t\t});\n\t\t}\n\t}\n\trebind() {\n\t\tthis._targets = {};\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tthis._layers[i].rebind();\n\t\t}\n\t}\n\tfindAnimationLayer(name) {\n\t\tconst layerIndex = this._layerIndices[name];\n\t\treturn this._layers[layerIndex] || null;\n\t}\n\taddAnimationState(nodeName, animTrack, speed = 1, loop = true, layerName = 'Base') {\n\t\tif (!this._stateGraph) {\n\t\t\tthis.loadStateGraph(new AnimStateGraph({\n\t\t\t\t'layers': [{\n\t\t\t\t\t'name': layerName,\n\t\t\t\t\t'states': [{\n\t\t\t\t\t\t'name': 'START',\n\t\t\t\t\t\t'speed': 1\n\t\t\t\t\t}, {\n\t\t\t\t\t\t'name': nodeName,\n\t\t\t\t\t\t'speed': speed,\n\t\t\t\t\t\t'loop': loop,\n\t\t\t\t\t\t'defaultState': true\n\t\t\t\t\t}],\n\t\t\t\t\t'transitions': [{\n\t\t\t\t\t\t'from': 'START',\n\t\t\t\t\t\t'to': nodeName\n\t\t\t\t\t}]\n\t\t\t\t}],\n\t\t\t\t'parameters': {}\n\t\t\t}));\n\t\t}\n\t\tconst layer = this.findAnimationLayer(layerName);\n\t\tif (layer) {\n\t\t\tlayer.assignAnimation(nodeName, animTrack, speed, loop);\n\t\t} else {\n\t\t\tvar _this$addLayer;\n\t\t\t(_this$addLayer = this.addLayer(layerName)) == null || _this$addLayer.assignAnimation(nodeName, animTrack, speed, loop);\n\t\t}\n\t}\n\tassignAnimation(nodePath, animTrack, layerName, speed = 1, loop = true) {\n\t\tif (!this._stateGraph && nodePath.indexOf('.') === -1) {\n\t\t\tthis.loadStateGraph(new AnimStateGraph({\n\t\t\t\t'layers': [{\n\t\t\t\t\t'name': 'Base',\n\t\t\t\t\t'states': [{\n\t\t\t\t\t\t'name': 'START',\n\t\t\t\t\t\t'speed': 1\n\t\t\t\t\t}, {\n\t\t\t\t\t\t'name': nodePath,\n\t\t\t\t\t\t'speed': speed,\n\t\t\t\t\t\t'loop': loop,\n\t\t\t\t\t\t'defaultState': true\n\t\t\t\t\t}],\n\t\t\t\t\t'transitions': [{\n\t\t\t\t\t\t'from': 'START',\n\t\t\t\t\t\t'to': nodePath\n\t\t\t\t\t}]\n\t\t\t\t}],\n\t\t\t\t'parameters': {}\n\t\t\t}));\n\t\t\tthis.baseLayer.assignAnimation(nodePath, animTrack);\n\t\t\treturn;\n\t\t}\n\t\tconst layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;\n\t\tif (!layer) {\n\t\t\treturn;\n\t\t}\n\t\tlayer.assignAnimation(nodePath, animTrack, speed, loop);\n\t}\n\tremoveNodeAnimations(nodeName, layerName) {\n\t\tconst layer = layerName ? this.findAnimationLayer(layerName) : this.baseLayer;\n\t\tif (!layer) {\n\t\t\treturn;\n\t\t}\n\t\tlayer.removeNodeAnimations(nodeName);\n\t}\n\tgetParameterValue(name, type) {\n\t\tconst param = this._parameters[name];\n\t\tif (param && param.type === type) {\n\t\t\treturn param.value;\n\t\t}\n\t\treturn undefined;\n\t}\n\tsetParameterValue(name, type, value) {\n\t\tconst param = this._parameters[name];\n\t\tif (param && param.type === type) {\n\t\t\tparam.value = value;\n\t\t\treturn;\n\t\t}\n\t}\n\tgetFloat(name) {\n\t\treturn this.getParameterValue(name, ANIM_PARAMETER_FLOAT);\n\t}\n\tsetFloat(name, value) {\n\t\tthis.setParameterValue(name, ANIM_PARAMETER_FLOAT, value);\n\t}\n\tgetInteger(name) {\n\t\treturn this.getParameterValue(name, ANIM_PARAMETER_INTEGER);\n\t}\n\tsetInteger(name, value) {\n\t\tif (typeof value === 'number' && value % 1 === 0) {\n\t\t\tthis.setParameterValue(name, ANIM_PARAMETER_INTEGER, value);\n\t\t}\n\t}\n\tgetBoolean(name) {\n\t\treturn this.getParameterValue(name, ANIM_PARAMETER_BOOLEAN);\n\t}\n\tsetBoolean(name, value) {\n\t\tthis.setParameterValue(name, ANIM_PARAMETER_BOOLEAN, !!value);\n\t}\n\tgetTrigger(name) {\n\t\treturn this.getParameterValue(name, ANIM_PARAMETER_TRIGGER);\n\t}\n\tsetTrigger(name, singleFrame = false) {\n\t\tthis.setParameterValue(name, ANIM_PARAMETER_TRIGGER, true);\n\t\tif (singleFrame) {\n\t\t\tthis._consumedTriggers.add(name);\n\t\t}\n\t}\n\tresetTrigger(name) {\n\t\tthis.setParameterValue(name, ANIM_PARAMETER_TRIGGER, false);\n\t}\n\tonBeforeRemove() {\n\t\tif (Number.isFinite(this._stateGraphAsset)) {\n\t\t\tconst stateGraphAsset = this.system.app.assets.get(this._stateGraphAsset);\n\t\t\tstateGraphAsset.off('change', this._onStateGraphAssetChangeEvent, this);\n\t\t}\n\t}\n\tupdate(dt) {\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tthis.layers[i].update(dt * this.speed);\n\t\t}\n\t\tthis._consumedTriggers.forEach(trigger => {\n\t\t\tthis.parameters[trigger].value = false;\n\t\t});\n\t\tthis._consumedTriggers.clear();\n\t}\n\tresolveDuplicatedEntityReferenceProperties(oldAnim, duplicatedIdsMap) {\n\t\tif (oldAnim.rootBone && duplicatedIdsMap[oldAnim.rootBone.getGuid()]) {\n\t\t\tthis.rootBone = duplicatedIdsMap[oldAnim.rootBone.getGuid()];\n\t\t} else {\n\t\t\tthis.rebind();\n\t\t}\n\t}\n}\n\nexport { AnimComponent };\n","class AnimComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n}\n\nexport { AnimComponentData };\n","import { AnimTrack } from '../../anim/evaluator/anim-track.js';\nimport { Component } from '../component.js';\nimport { ComponentSystem } from '../system.js';\nimport { AnimComponent } from './component.js';\nimport { AnimComponentData } from './data.js';\n\nconst _schema = ['enabled'];\nclass AnimComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'anim';\n\t\tthis.ComponentType = AnimComponent;\n\t\tthis.DataType = AnimComponentData;\n\t\tthis.schema = _schema;\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t\tthis.app.systems.on('animationUpdate', this.onAnimationUpdate, this);\n\t}\n\tinitializeComponentData(component, data, properties) {\n\t\tsuper.initializeComponentData(component, data, _schema);\n\t\tconst complexProperties = ['animationAssets', 'stateGraph', 'layers', 'masks'];\n\t\tObject.keys(data).forEach(key => {\n\t\t\tif (complexProperties.includes(key)) return;\n\t\t\tcomponent[key] = data[key];\n\t\t});\n\t\tif (data.stateGraph) {\n\t\t\tcomponent.stateGraph = data.stateGraph;\n\t\t\tcomponent.loadStateGraph(component.stateGraph);\n\t\t}\n\t\tif (data.layers) {\n\t\t\tdata.layers.forEach((layer, i) => {\n\t\t\t\tlayer._controller.states.forEach(stateKey => {\n\t\t\t\t\tlayer._controller._states[stateKey]._animationList.forEach(node => {\n\t\t\t\t\t\tif (!node.animTrack || node.animTrack === AnimTrack.EMPTY) {\n\t\t\t\t\t\t\tconst animationAsset = this.app.assets.get(layer._component._animationAssets[`${layer.name}:${node.name}`].asset);\n\t\t\t\t\t\t\tif (animationAsset && !animationAsset.loaded) {\n\t\t\t\t\t\t\t\tanimationAsset.once('load', () => {\n\t\t\t\t\t\t\t\t\tcomponent.layers[i].assignAnimation(node.name, animationAsset.resource);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcomponent.layers[i].assignAnimation(node.name, node.animTrack);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\tif (data.animationAssets) {\n\t\t\tcomponent.animationAssets = Object.assign(component.animationAssets, data.animationAssets);\n\t\t}\n\t\tif (data.masks) {\n\t\t\tObject.keys(data.masks).forEach(key => {\n\t\t\t\tif (component.layers[key]) {\n\t\t\t\t\tconst maskData = data.masks[key].mask;\n\t\t\t\t\tconst mask = {};\n\t\t\t\t\tObject.keys(maskData).forEach(maskKey => {\n\t\t\t\t\t\tmask[decodeURI(maskKey)] = maskData[maskKey];\n\t\t\t\t\t});\n\t\t\t\t\tcomponent.layers[key].mask = mask;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\tonAnimationUpdate(dt) {\n\t\tconst components = this.store;\n\t\tfor (const id in components) {\n\t\t\tif (components.hasOwnProperty(id)) {\n\t\t\t\tconst component = components[id].entity.anim;\n\t\t\t\tconst componentData = component.data;\n\t\t\t\tif (componentData.enabled && component.entity.enabled && component.playing) {\n\t\t\t\t\tcomponent.update(dt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcloneComponent(entity, clone) {\n\t\tlet masks;\n\t\tif (!entity.anim.rootBone || entity.anim.rootBone === entity) {\n\t\t\tmasks = {};\n\t\t\tentity.anim.layers.forEach((layer, i) => {\n\t\t\t\tif (layer.mask) {\n\t\t\t\t\tconst mask = {};\n\t\t\t\t\tObject.keys(layer.mask).forEach(path => {\n\t\t\t\t\t\tconst pathArr = path.split('/');\n\t\t\t\t\t\tpathArr.shift();\n\t\t\t\t\t\tconst clonePath = [clone.name, ...pathArr].join('/');\n\t\t\t\t\t\tmask[clonePath] = layer.mask[path];\n\t\t\t\t\t});\n\t\t\t\t\tmasks[i] = {\n\t\t\t\t\t\tmask\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tconst data = {\n\t\t\tstateGraphAsset: entity.anim.stateGraphAsset,\n\t\t\tanimationAssets: entity.anim.animationAssets,\n\t\t\tspeed: entity.anim.speed,\n\t\t\tactivate: entity.anim.activate,\n\t\t\tplaying: entity.anim.playing,\n\t\t\trootBone: entity.anim.rootBone,\n\t\t\tstateGraph: entity.anim.stateGraph,\n\t\t\tlayers: entity.anim.layers,\n\t\t\tlayerIndices: entity.anim.layerIndices,\n\t\t\tparameters: entity.anim.parameters,\n\t\t\tnormalizeWeights: entity.anim.normalizeWeights,\n\t\t\tmasks\n\t\t};\n\t\treturn this.addComponent(clone, data);\n\t}\n\tonBeforeRemove(entity, component) {\n\t\tcomponent.onBeforeRemove();\n\t}\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('animationUpdate', this.onAnimationUpdate, this);\n\t}\n}\nComponent._buildAccessors(AnimComponent.prototype, _schema);\n\nexport { AnimComponentSystem };\n","import { AnimClip } from '../../anim/evaluator/anim-clip.js';\nimport { AnimEvaluator } from '../../anim/evaluator/anim-evaluator.js';\nimport { AnimTrack } from '../../anim/evaluator/anim-track.js';\nimport { DefaultAnimBinder } from '../../anim/binder/default-anim-binder.js';\nimport { Skeleton } from '../../../scene/animation/skeleton.js';\nimport { Asset } from '../../asset/asset.js';\nimport { Component } from '../component.js';\n\nclass AnimationComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._animations = {};\n\t\tthis._assets = [];\n\t\tthis._loop = true;\n\t\tthis.animEvaluator = null;\n\t\tthis.model = null;\n\t\tthis.skeleton = null;\n\t\tthis.fromSkel = null;\n\t\tthis.toSkel = null;\n\t\tthis.animationsIndex = {};\n\t\tthis.prevAnim = null;\n\t\tthis.currAnim = null;\n\t\tthis.blend = 0;\n\t\tthis.blending = false;\n\t\tthis.blendSpeed = 0;\n\t\tthis.activate = true;\n\t\tthis.speed = 1;\n\t}\n\tset animations(value) {\n\t\tthis._animations = value;\n\t\tthis.onSetAnimations();\n\t}\n\tget animations() {\n\t\treturn this._animations;\n\t}\n\tset assets(value) {\n\t\tconst assets = this._assets;\n\t\tif (assets && assets.length) {\n\t\t\tfor (let i = 0; i < assets.length; i++) {\n\t\t\t\tif (assets[i]) {\n\t\t\t\t\tconst asset = this.system.app.assets.get(assets[i]);\n\t\t\t\t\tif (asset) {\n\t\t\t\t\t\tasset.off('change', this.onAssetChanged, this);\n\t\t\t\t\t\tasset.off('remove', this.onAssetRemoved, this);\n\t\t\t\t\t\tconst animName = this.animationsIndex[asset.id];\n\t\t\t\t\t\tif (this.currAnim === animName) {\n\t\t\t\t\t\t\tthis._stopCurrentAnimation();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdelete this.animations[animName];\n\t\t\t\t\t\tdelete this.animationsIndex[asset.id];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._assets = value;\n\t\tconst assetIds = value.map(value => {\n\t\t\treturn value instanceof Asset ? value.id : value;\n\t\t});\n\t\tthis.loadAnimationAssets(assetIds);\n\t}\n\tget assets() {\n\t\treturn this._assets;\n\t}\n\tset currentTime(currentTime) {\n\t\tif (this.skeleton) {\n\t\t\tthis.skeleton.currentTime = currentTime;\n\t\t\tthis.skeleton.addTime(0);\n\t\t\tthis.skeleton.updateGraph();\n\t\t}\n\t\tif (this.animEvaluator) {\n\t\t\tconst clips = this.animEvaluator.clips;\n\t\t\tfor (let i = 0; i < clips.length; ++i) {\n\t\t\t\tclips[i].time = currentTime;\n\t\t\t}\n\t\t}\n\t}\n\tget currentTime() {\n\t\tif (this.skeleton) {\n\t\t\treturn this.skeleton._time;\n\t\t}\n\t\tif (this.animEvaluator) {\n\t\t\tconst clips = this.animEvaluator.clips;\n\t\t\tif (clips.length > 0) {\n\t\t\t\treturn clips[clips.length - 1].time;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tget duration() {\n\t\tif (this.currAnim) {\n\t\t\treturn this.animations[this.currAnim].duration;\n\t\t}\n\t\treturn 0;\n\t}\n\tset loop(value) {\n\t\tthis._loop = value;\n\t\tif (this.skeleton) {\n\t\t\tthis.skeleton.looping = value;\n\t\t}\n\t\tif (this.animEvaluator) {\n\t\t\tfor (let i = 0; i < this.animEvaluator.clips.length; ++i) {\n\t\t\t\tthis.animEvaluator.clips[i].loop = value;\n\t\t\t}\n\t\t}\n\t}\n\tget loop() {\n\t\treturn this._loop;\n\t}\n\tplay(name, blendTime = 0) {\n\t\tif (!this.enabled || !this.entity.enabled) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this.animations[name]) {\n\t\t\treturn;\n\t\t}\n\t\tthis.prevAnim = this.currAnim;\n\t\tthis.currAnim = name;\n\t\tif (this.model) {\n\t\t\tif (!this.skeleton && !this.animEvaluator) {\n\t\t\t\tthis._createAnimationController();\n\t\t\t}\n\t\t\tconst prevAnim = this.animations[this.prevAnim];\n\t\t\tconst currAnim = this.animations[this.currAnim];\n\t\t\tthis.blending = blendTime > 0 && !!this.prevAnim;\n\t\t\tif (this.blending) {\n\t\t\t\tthis.blend = 0;\n\t\t\t\tthis.blendSpeed = 1 / blendTime;\n\t\t\t}\n\t\t\tif (this.skeleton) {\n\t\t\t\tif (this.blending) {\n\t\t\t\t\tthis.fromSkel.animation = prevAnim;\n\t\t\t\t\tthis.fromSkel.addTime(this.skeleton._time);\n\t\t\t\t\tthis.toSkel.animation = currAnim;\n\t\t\t\t} else {\n\t\t\t\t\tthis.skeleton.animation = currAnim;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.animEvaluator) {\n\t\t\t\tconst animEvaluator = this.animEvaluator;\n\t\t\t\tif (this.blending) {\n\t\t\t\t\twhile (animEvaluator.clips.length > 1) {\n\t\t\t\t\t\tanimEvaluator.removeClip(0);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.animEvaluator.removeClips();\n\t\t\t\t}\n\t\t\t\tconst clip = new AnimClip(this.animations[this.currAnim], 0, 1.0, true, this.loop);\n\t\t\t\tclip.name = this.currAnim;\n\t\t\t\tclip.blendWeight = this.blending ? 0 : 1;\n\t\t\t\tclip.reset();\n\t\t\t\tthis.animEvaluator.addClip(clip);\n\t\t\t}\n\t\t}\n\t\tthis.playing = true;\n\t}\n\tgetAnimation(name) {\n\t\treturn this.animations[name];\n\t}\n\tsetModel(model) {\n\t\tif (model !== this.model) {\n\t\t\tthis._resetAnimationController();\n\t\t\tthis.model = model;\n\t\t\tif (this.animations && this.currAnim && this.animations[this.currAnim]) {\n\t\t\t\tthis.play(this.currAnim);\n\t\t\t}\n\t\t}\n\t}\n\tonSetAnimations() {\n\t\tconst modelComponent = this.entity.model;\n\t\tif (modelComponent) {\n\t\t\tconst m = modelComponent.model;\n\t\t\tif (m && m !== this.model) {\n\t\t\t\tthis.setModel(m);\n\t\t\t}\n\t\t}\n\t\tif (!this.currAnim && this.activate && this.enabled && this.entity.enabled) {\n\t\t\tconst animationNames = Object.keys(this._animations);\n\t\t\tif (animationNames.length > 0) {\n\t\t\t\tthis.play(animationNames[0]);\n\t\t\t}\n\t\t}\n\t}\n\t_resetAnimationController() {\n\t\tthis.skeleton = null;\n\t\tthis.fromSkel = null;\n\t\tthis.toSkel = null;\n\t\tthis.animEvaluator = null;\n\t}\n\t_createAnimationController() {\n\t\tconst model = this.model;\n\t\tconst animations = this.animations;\n\t\tlet hasJson = false;\n\t\tlet hasGlb = false;\n\t\tfor (const animation in animations) {\n\t\t\tif (animations.hasOwnProperty(animation)) {\n\t\t\t\tconst anim = animations[animation];\n\t\t\t\tif (anim.constructor === AnimTrack) {\n\t\t\t\t\thasGlb = true;\n\t\t\t\t} else {\n\t\t\t\t\thasJson = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst graph = model.getGraph();\n\t\tif (hasJson) {\n\t\t\tthis.fromSkel = new Skeleton(graph);\n\t\t\tthis.toSkel = new Skeleton(graph);\n\t\t\tthis.skeleton = new Skeleton(graph);\n\t\t\tthis.skeleton.looping = this.loop;\n\t\t\tthis.skeleton.setGraph(graph);\n\t\t} else if (hasGlb) {\n\t\t\tthis.animEvaluator = new AnimEvaluator(new DefaultAnimBinder(this.entity));\n\t\t}\n\t}\n\tloadAnimationAssets(ids) {\n\t\tif (!ids || !ids.length) {\n\t\t\treturn;\n\t\t}\n\t\tconst assets = this.system.app.assets;\n\t\tconst onAssetReady = asset => {\n\t\t\tif (asset.resources.length > 1) {\n\t\t\t\tfor (let i = 0; i < asset.resources.length; i++) {\n\t\t\t\t\tthis.animations[asset.resources[i].name] = asset.resources[i];\n\t\t\t\t\tthis.animationsIndex[asset.id] = asset.resources[i].name;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.animations[asset.name] = asset.resource;\n\t\t\t\tthis.animationsIndex[asset.id] = asset.name;\n\t\t\t}\n\t\t\tthis.animations = this.animations;\n\t\t};\n\t\tconst onAssetAdd = asset => {\n\t\t\tasset.off('change', this.onAssetChanged, this);\n\t\t\tasset.on('change', this.onAssetChanged, this);\n\t\t\tasset.off('remove', this.onAssetRemoved, this);\n\t\t\tasset.on('remove', this.onAssetRemoved, this);\n\t\t\tif (asset.resource) {\n\t\t\t\tonAssetReady(asset);\n\t\t\t} else {\n\t\t\t\tasset.once('load', onAssetReady, this);\n\t\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\t\tassets.load(asset);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tfor (let i = 0, l = ids.length; i < l; i++) {\n\t\t\tconst asset = assets.get(ids[i]);\n\t\t\tif (asset) {\n\t\t\t\tonAssetAdd(asset);\n\t\t\t} else {\n\t\t\t\tassets.on(`add:${ids[i]}`, onAssetAdd);\n\t\t\t}\n\t\t}\n\t}\n\tonAssetChanged(asset, attribute, newValue, oldValue) {\n\t\tif (attribute === 'resource' || attribute === 'resources') {\n\t\t\tif (attribute === 'resources' && newValue && newValue.length === 0) {\n\t\t\t\tnewValue = null;\n\t\t\t}\n\t\t\tif (newValue) {\n\t\t\t\tlet restarted = false;\n\t\t\t\tif (newValue.length > 1) {\n\t\t\t\t\tif (oldValue && oldValue.length > 1) {\n\t\t\t\t\t\tfor (let i = 0; i < oldValue.length; i++) {\n\t\t\t\t\t\t\tdelete this.animations[oldValue[i].name];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete this.animations[asset.name];\n\t\t\t\t\t}\n\t\t\t\t\trestarted = false;\n\t\t\t\t\tfor (let i = 0; i < newValue.length; i++) {\n\t\t\t\t\t\tthis.animations[newValue[i].name] = newValue[i];\n\t\t\t\t\t\tif (!restarted && this.currAnim === newValue[i].name) {\n\t\t\t\t\t\t\tif (this.playing && this.enabled && this.entity.enabled) {\n\t\t\t\t\t\t\t\trestarted = true;\n\t\t\t\t\t\t\t\tthis.play(newValue[i].name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!restarted) {\n\t\t\t\t\t\tthis._stopCurrentAnimation();\n\t\t\t\t\t\tthis.onSetAnimations();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (oldValue && oldValue.length > 1) {\n\t\t\t\t\t\tfor (let i = 0; i < oldValue.length; i++) {\n\t\t\t\t\t\t\tdelete this.animations[oldValue[i].name];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.animations[asset.name] = newValue[0] || newValue;\n\t\t\t\t\trestarted = false;\n\t\t\t\t\tif (this.currAnim === asset.name) {\n\t\t\t\t\t\tif (this.playing && this.enabled && this.entity.enabled) {\n\t\t\t\t\t\t\trestarted = true;\n\t\t\t\t\t\t\tthis.play(asset.name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!restarted) {\n\t\t\t\t\t\tthis._stopCurrentAnimation();\n\t\t\t\t\t\tthis.onSetAnimations();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.animationsIndex[asset.id] = asset.name;\n\t\t\t} else {\n\t\t\t\tif (oldValue.length > 1) {\n\t\t\t\t\tfor (let i = 0; i < oldValue.length; i++) {\n\t\t\t\t\t\tdelete this.animations[oldValue[i].name];\n\t\t\t\t\t\tif (this.currAnim === oldValue[i].name) {\n\t\t\t\t\t\t\tthis._stopCurrentAnimation();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdelete this.animations[asset.name];\n\t\t\t\t\tif (this.currAnim === asset.name) {\n\t\t\t\t\t\tthis._stopCurrentAnimation();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdelete this.animationsIndex[asset.id];\n\t\t\t}\n\t\t}\n\t}\n\tonAssetRemoved(asset) {\n\t\tasset.off('remove', this.onAssetRemoved, this);\n\t\tif (this.animations) {\n\t\t\tif (asset.resources.length > 1) {\n\t\t\t\tfor (let i = 0; i < asset.resources.length; i++) {\n\t\t\t\t\tdelete this.animations[asset.resources[i].name];\n\t\t\t\t\tif (this.currAnim === asset.resources[i].name) {\n\t\t\t\t\t\tthis._stopCurrentAnimation();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdelete this.animations[asset.name];\n\t\t\t\tif (this.currAnim === asset.name) {\n\t\t\t\t\tthis._stopCurrentAnimation();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelete this.animationsIndex[asset.id];\n\t\t}\n\t}\n\t_stopCurrentAnimation() {\n\t\tthis.currAnim = null;\n\t\tthis.playing = false;\n\t\tif (this.skeleton) {\n\t\t\tthis.skeleton.currentTime = 0;\n\t\t\tthis.skeleton.animation = null;\n\t\t}\n\t\tif (this.animEvaluator) {\n\t\t\tfor (let i = 0; i < this.animEvaluator.clips.length; ++i) {\n\t\t\t\tthis.animEvaluator.clips[i].stop();\n\t\t\t}\n\t\t\tthis.animEvaluator.update(0);\n\t\t\tthis.animEvaluator.removeClips();\n\t\t}\n\t}\n\tonEnable() {\n\t\tsuper.onEnable();\n\t\tconst assets = this.assets;\n\t\tconst registry = this.system.app.assets;\n\t\tif (assets) {\n\t\t\tfor (let i = 0, len = assets.length; i < len; i++) {\n\t\t\t\tlet asset = assets[i];\n\t\t\t\tif (!(asset instanceof Asset)) {\n\t\t\t\t\tasset = registry.get(asset);\n\t\t\t\t}\n\t\t\t\tif (asset && !asset.resource) {\n\t\t\t\t\tregistry.load(asset);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.activate && !this.currAnim) {\n\t\t\tconst animationNames = Object.keys(this.animations);\n\t\t\tif (animationNames.length > 0) {\n\t\t\t\tthis.play(animationNames[0]);\n\t\t\t}\n\t\t}\n\t}\n\tonBeforeRemove() {\n\t\tfor (let i = 0; i < this.assets.length; i++) {\n\t\t\tlet asset = this.assets[i];\n\t\t\tif (typeof asset === 'number') {\n\t\t\t\tasset = this.system.app.assets.get(asset);\n\t\t\t}\n\t\t\tif (!asset) continue;\n\t\t\tasset.off('change', this.onAssetChanged, this);\n\t\t\tasset.off('remove', this.onAssetRemoved, this);\n\t\t}\n\t\tthis.skeleton = null;\n\t\tthis.fromSkel = null;\n\t\tthis.toSkel = null;\n\t\tthis.animEvaluator = null;\n\t}\n\tupdate(dt) {\n\t\tif (this.blending) {\n\t\t\tthis.blend += dt * this.blendSpeed;\n\t\t\tif (this.blend >= 1) {\n\t\t\t\tthis.blend = 1;\n\t\t\t}\n\t\t}\n\t\tif (this.playing) {\n\t\t\tconst skeleton = this.skeleton;\n\t\t\tif (skeleton !== null && this.model !== null) {\n\t\t\t\tif (this.blending) {\n\t\t\t\t\tskeleton.blend(this.fromSkel, this.toSkel, this.blend);\n\t\t\t\t} else {\n\t\t\t\t\tconst delta = dt * this.speed;\n\t\t\t\t\tskeleton.addTime(delta);\n\t\t\t\t\tif (this.speed > 0 && skeleton._time === skeleton.animation.duration && !this.loop) {\n\t\t\t\t\t\tthis.playing = false;\n\t\t\t\t\t} else if (this.speed < 0 && skeleton._time === 0 && !this.loop) {\n\t\t\t\t\t\tthis.playing = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.blending && this.blend === 1) {\n\t\t\t\t\tskeleton.animation = this.toSkel.animation;\n\t\t\t\t}\n\t\t\t\tskeleton.updateGraph();\n\t\t\t}\n\t\t}\n\t\tconst animEvaluator = this.animEvaluator;\n\t\tif (animEvaluator) {\n\t\t\tfor (let i = 0; i < animEvaluator.clips.length; ++i) {\n\t\t\t\tconst clip = animEvaluator.clips[i];\n\t\t\t\tclip.speed = this.speed;\n\t\t\t\tif (!this.playing) {\n\t\t\t\t\tclip.pause();\n\t\t\t\t} else {\n\t\t\t\t\tclip.resume();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.blending && animEvaluator.clips.length > 1) {\n\t\t\t\tanimEvaluator.clips[1].blendWeight = this.blend;\n\t\t\t}\n\t\t\tanimEvaluator.update(dt);\n\t\t}\n\t\tif (this.blending && this.blend === 1) {\n\t\t\tthis.blending = false;\n\t\t}\n\t}\n}\n\nexport { AnimationComponent };\n","class AnimationComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n}\n\nexport { AnimationComponentData };\n","import { Component } from '../component.js';\nimport { ComponentSystem } from '../system.js';\nimport { AnimationComponent } from './component.js';\nimport { AnimationComponentData } from './data.js';\n\nconst _schema = ['enabled'];\nclass AnimationComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'animation';\n\t\tthis.ComponentType = AnimationComponent;\n\t\tthis.DataType = AnimationComponentData;\n\t\tthis.schema = _schema;\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t}\n\tinitializeComponentData(component, data, properties) {\n\t\tproperties = ['activate', 'enabled', 'loop', 'speed', 'assets'];\n\t\tfor (const property of properties) {\n\t\t\tif (data.hasOwnProperty(property)) {\n\t\t\t\tcomponent[property] = data[property];\n\t\t\t}\n\t\t}\n\t\tsuper.initializeComponentData(component, data, _schema);\n\t}\n\tcloneComponent(entity, clone) {\n\t\tthis.addComponent(clone, {});\n\t\tclone.animation.assets = entity.animation.assets.slice();\n\t\tclone.animation.speed = entity.animation.speed;\n\t\tclone.animation.loop = entity.animation.loop;\n\t\tclone.animation.activate = entity.animation.activate;\n\t\tclone.animation.enabled = entity.animation.enabled;\n\t\tconst clonedAnimations = {};\n\t\tconst animations = entity.animation.animations;\n\t\tfor (const key in animations) {\n\t\t\tif (animations.hasOwnProperty(key)) {\n\t\t\t\tclonedAnimations[key] = animations[key];\n\t\t\t}\n\t\t}\n\t\tclone.animation.animations = clonedAnimations;\n\t\tconst clonedAnimationsIndex = {};\n\t\tconst animationsIndex = entity.animation.animationsIndex;\n\t\tfor (const key in animationsIndex) {\n\t\t\tif (animationsIndex.hasOwnProperty(key)) {\n\t\t\t\tclonedAnimationsIndex[key] = animationsIndex[key];\n\t\t\t}\n\t\t}\n\t\tclone.animation.animationsIndex = clonedAnimationsIndex;\n\t\treturn clone.animation;\n\t}\n\tonBeforeRemove(entity, component) {\n\t\tcomponent.onBeforeRemove();\n\t}\n\tonUpdate(dt) {\n\t\tconst components = this.store;\n\t\tfor (const id in components) {\n\t\t\tif (components.hasOwnProperty(id)) {\n\t\t\t\tconst component = components[id];\n\t\t\t\tif (component.data.enabled && component.entity.enabled) {\n\t\t\t\t\tcomponent.entity.animation.update(dt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n}\nComponent._buildAccessors(AnimationComponent.prototype, _schema);\n\nexport { AnimationComponentSystem };\n","import { Component } from '../component.js';\n\nclass AudioListenerComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t}\n\tsetCurrentListener() {\n\t\tif (this.enabled && this.entity.audiolistener && this.entity.enabled) {\n\t\t\tthis.system.current = this.entity;\n\t\t\tconst position = this.system.current.getPosition();\n\t\t\tthis.system.manager.listener.setPosition(position);\n\t\t}\n\t}\n\tonEnable() {\n\t\tthis.setCurrentListener();\n\t}\n\tonDisable() {\n\t\tif (this.system.current === this.entity) {\n\t\t\tthis.system.current = null;\n\t\t}\n\t}\n}\n\nexport { AudioListenerComponent };\n","class AudioListenerComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n}\n\nexport { AudioListenerComponentData };\n","import { Component } from '../component.js';\nimport { ComponentSystem } from '../system.js';\nimport { AudioListenerComponent } from './component.js';\nimport { AudioListenerComponentData } from './data.js';\n\nconst _schema = ['enabled'];\nclass AudioListenerComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'audiolistener';\n\t\tthis.ComponentType = AudioListenerComponent;\n\t\tthis.DataType = AudioListenerComponentData;\n\t\tthis.schema = _schema;\n\t\tthis.manager = app.soundManager;\n\t\tthis.current = null;\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t}\n\tinitializeComponentData(component, data, properties) {\n\t\tproperties = ['enabled'];\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\tonUpdate(dt) {\n\t\tif (this.current) {\n\t\t\tconst position = this.current.getPosition();\n\t\t\tthis.manager.listener.setPosition(position);\n\t\t\tconst wtm = this.current.getWorldTransform();\n\t\t\tthis.manager.listener.setOrientation(wtm);\n\t\t}\n\t}\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n}\nComponent._buildAccessors(AudioListenerComponent.prototype, _schema);\n\nexport { AudioListenerComponentSystem };\n","import { Asset } from '../../asset/asset.js';\nimport { Channel3d } from '../../../platform/audio/channel3d.js';\nimport { Component } from '../component.js';\n\nclass AudioSourceComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis.on('set_assets', this.onSetAssets, this);\n\t\tthis.on('set_loop', this.onSetLoop, this);\n\t\tthis.on('set_volume', this.onSetVolume, this);\n\t\tthis.on('set_pitch', this.onSetPitch, this);\n\t\tthis.on('set_minDistance', this.onSetMinDistance, this);\n\t\tthis.on('set_maxDistance', this.onSetMaxDistance, this);\n\t\tthis.on('set_rollOffFactor', this.onSetRollOffFactor, this);\n\t\tthis.on('set_distanceModel', this.onSetDistanceModel, this);\n\t\tthis.on('set_3d', this.onSet3d, this);\n\t}\n\tplay(name) {\n\t\tif (!this.enabled || !this.entity.enabled) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.channel) {\n\t\t\tthis.stop();\n\t\t}\n\t\tlet channel;\n\t\tconst componentData = this.data;\n\t\tif (componentData.sources[name]) {\n\t\t\tif (!componentData['3d']) {\n\t\t\t\tchannel = this.system.manager.playSound(componentData.sources[name], componentData);\n\t\t\t\tcomponentData.currentSource = name;\n\t\t\t\tcomponentData.channel = channel;\n\t\t\t} else {\n\t\t\t\tconst pos = this.entity.getPosition();\n\t\t\t\tchannel = this.system.manager.playSound3d(componentData.sources[name], pos, componentData);\n\t\t\t\tcomponentData.currentSource = name;\n\t\t\t\tcomponentData.channel = channel;\n\t\t\t}\n\t\t}\n\t}\n\tpause() {\n\t\tif (this.channel) {\n\t\t\tthis.channel.pause();\n\t\t}\n\t}\n\tunpause() {\n\t\tif (this.channel && this.channel.paused) {\n\t\t\tthis.channel.unpause();\n\t\t}\n\t}\n\tstop() {\n\t\tif (this.channel) {\n\t\t\tthis.channel.stop();\n\t\t\tthis.channel = null;\n\t\t}\n\t}\n\tonSetAssets(name, oldValue, newValue) {\n\t\tconst newAssets = [];\n\t\tconst len = newValue.length;\n\t\tif (oldValue && oldValue.length) {\n\t\t\tfor (let i = 0; i < oldValue.length; i++) {\n\t\t\t\tif (oldValue[i]) {\n\t\t\t\t\tconst asset = this.system.app.assets.get(oldValue[i]);\n\t\t\t\t\tif (asset) {\n\t\t\t\t\t\tasset.off('change', this.onAssetChanged, this);\n\t\t\t\t\t\tasset.off('remove', this.onAssetRemoved, this);\n\t\t\t\t\t\tif (this.currentSource === asset.name) {\n\t\t\t\t\t\t\tthis.stop();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (len) {\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tif (oldValue.indexOf(newValue[i]) < 0) {\n\t\t\t\t\tif (newValue[i] instanceof Asset) {\n\t\t\t\t\t\tnewAssets.push(newValue[i].id);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnewAssets.push(newValue[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!this.system._inTools && newAssets.length) {\n\t\t\tthis.loadAudioSourceAssets(newAssets);\n\t\t}\n\t}\n\tonAssetChanged(asset, attribute, newValue, oldValue) {\n\t\tif (attribute === 'resource') {\n\t\t\tconst sources = this.data.sources;\n\t\t\tif (sources) {\n\t\t\t\tthis.data.sources[asset.name] = newValue;\n\t\t\t\tif (this.data.currentSource === asset.name) {\n\t\t\t\t\tif (this.channel) {\n\t\t\t\t\t\tif (this.channel.paused) {\n\t\t\t\t\t\t\tthis.play(asset.name);\n\t\t\t\t\t\t\tthis.pause();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.play(asset.name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tonAssetRemoved(asset) {\n\t\tasset.off('remove', this.onAssetRemoved, this);\n\t\tif (this.data.sources[asset.name]) {\n\t\t\tdelete this.data.sources[asset.name];\n\t\t\tif (this.data.currentSource === asset.name) {\n\t\t\t\tthis.stop();\n\t\t\t\tthis.data.currentSource = null;\n\t\t\t}\n\t\t}\n\t}\n\tonSetLoop(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.channel) {\n\t\t\t\tthis.channel.setLoop(newValue);\n\t\t\t}\n\t\t}\n\t}\n\tonSetVolume(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.channel) {\n\t\t\t\tthis.channel.setVolume(newValue);\n\t\t\t}\n\t\t}\n\t}\n\tonSetPitch(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.channel) {\n\t\t\t\tthis.channel.setPitch(newValue);\n\t\t\t}\n\t\t}\n\t}\n\tonSetMaxDistance(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.channel instanceof Channel3d) {\n\t\t\t\tthis.channel.setMaxDistance(newValue);\n\t\t\t}\n\t\t}\n\t}\n\tonSetMinDistance(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.channel instanceof Channel3d) {\n\t\t\t\tthis.channel.setMinDistance(newValue);\n\t\t\t}\n\t\t}\n\t}\n\tonSetRollOffFactor(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.channel instanceof Channel3d) {\n\t\t\t\tthis.channel.setRollOffFactor(newValue);\n\t\t\t}\n\t\t}\n\t}\n\tonSetDistanceModel(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.channel instanceof Channel3d) {\n\t\t\t\tthis.channel.setDistanceModel(newValue);\n\t\t\t}\n\t\t}\n\t}\n\tonSet3d(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.system.initialized && this.currentSource) {\n\t\t\t\tlet paused = false;\n\t\t\t\tlet suspended = false;\n\t\t\t\tif (this.channel) {\n\t\t\t\t\tpaused = this.channel.paused;\n\t\t\t\t\tsuspended = this.channel.suspended;\n\t\t\t\t}\n\t\t\t\tthis.play(this.currentSource);\n\t\t\t\tif (this.channel) {\n\t\t\t\t\tthis.channel.paused = paused;\n\t\t\t\t\tthis.channel.suspended = suspended;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tonEnable() {\n\t\tconst assets = this.data.assets;\n\t\tif (assets) {\n\t\t\tconst registry = this.system.app.assets;\n\t\t\tfor (let i = 0, len = assets.length; i < len; i++) {\n\t\t\t\tlet asset = assets[i];\n\t\t\t\tif (!(asset instanceof Asset)) {\n\t\t\t\t\tasset = registry.get(asset);\n\t\t\t\t}\n\t\t\t\tif (asset && !asset.resource) {\n\t\t\t\t\tregistry.load(asset);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.system.initialized) {\n\t\t\tif (this.data.activate && !this.channel) {\n\t\t\t\tthis.play(this.currentSource);\n\t\t\t} else {\n\t\t\t\tthis.unpause();\n\t\t\t}\n\t\t}\n\t}\n\tonDisable() {\n\t\tthis.pause();\n\t}\n\tloadAudioSourceAssets(ids) {\n\t\tconst assets = ids.map(id => {\n\t\t\treturn this.system.app.assets.get(id);\n\t\t});\n\t\tconst sources = {};\n\t\tlet currentSource = null;\n\t\tlet count = assets.length;\n\t\tconst _error = e => {\n\t\t\tcount--;\n\t\t};\n\t\tconst _done = () => {\n\t\t\tthis.data.sources = sources;\n\t\t\tthis.data.currentSource = currentSource;\n\t\t\tif (this.enabled && this.activate && currentSource) {\n\t\t\t\tthis.onEnable();\n\t\t\t}\n\t\t};\n\t\tassets.forEach((asset, index) => {\n\t\t\tif (asset) {\n\t\t\t\tcurrentSource = currentSource || asset.name;\n\t\t\t\tasset.off('change', this.onAssetChanged, this);\n\t\t\t\tasset.on('change', this.onAssetChanged, this);\n\t\t\t\tasset.off('remove', this.onAssetRemoved, this);\n\t\t\t\tasset.on('remove', this.onAssetRemoved, this);\n\t\t\t\tasset.off('error', _error, this);\n\t\t\t\tasset.on('error', _error, this);\n\t\t\t\tasset.ready(asset => {\n\t\t\t\t\tsources[asset.name] = asset.resource;\n\t\t\t\t\tcount--;\n\t\t\t\t\tif (count === 0) {\n\t\t\t\t\t\t_done();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (!asset.resource && this.enabled && this.entity.enabled) {\n\t\t\t\t\tthis.system.app.assets.load(asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcount--;\n\t\t\t\tif (count === 0) {\n\t\t\t\t\t_done();\n\t\t\t\t}\n\t\t\t\tthis.system.app.assets.on(`add:${ids[index]}`, asset => {\n\t\t\t\t\tasset.ready(asset => {\n\t\t\t\t\t\tthis.data.sources[asset.name] = asset.resource;\n\t\t\t\t\t});\n\t\t\t\t\tif (!asset.resource) {\n\t\t\t\t\t\tthis.system.app.assets.load(asset);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport { AudioSourceComponent };\n","import { DISTANCE_INVERSE } from '../../../platform/audio/constants.js';\n\nclass AudioSourceComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t\tthis.assets = [];\n\t\tthis.activate = true;\n\t\tthis.volume = 1;\n\t\tthis.pitch = 1;\n\t\tthis.loop = false;\n\t\tthis['3d'] = true;\n\t\tthis.minDistance = 1;\n\t\tthis.maxDistance = 10000;\n\t\tthis.rollOffFactor = 1;\n\t\tthis.distanceModel = DISTANCE_INVERSE;\n\t\tthis.paused = true;\n\t\tthis.sources = {};\n\t\tthis.currentSource = null;\n\t\tthis.channel = null;\n\t}\n}\n\nexport { AudioSourceComponentData };\n","import { Channel3d } from '../../../platform/audio/channel3d.js';\nimport { Entity } from '../../entity.js';\nimport { Component } from '../component.js';\nimport { ComponentSystem } from '../system.js';\nimport { AudioSourceComponent } from './component.js';\nimport { AudioSourceComponentData } from './data.js';\n\nconst _schema = ['enabled', 'assets', 'volume', 'pitch', 'loop', 'activate', '3d', 'minDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'sources', 'currentSource', 'channel'];\nclass AudioSourceComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'audiosource';\n\t\tthis.ComponentType = AudioSourceComponent;\n\t\tthis.DataType = AudioSourceComponentData;\n\t\tthis.schema = _schema;\n\t\tthis.manager = app.soundManager;\n\t\tthis.initialized = false;\n\t\tthis.app.systems.on('initialize', this.onInitialize, this);\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t\tthis.on('remove', this.onRemove, this);\n\t}\n\tinitializeComponentData(component, data, properties) {\n\t\tproperties = ['activate', 'volume', 'pitch', 'loop', '3d', 'minDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'enabled', 'assets'];\n\t\tsuper.initializeComponentData(component, data, properties);\n\t\tcomponent.paused = !(component.enabled && component.activate);\n\t}\n\tonInitialize(root) {\n\t\tif (root.audiosource && root.enabled && root.audiosource.enabled && root.audiosource.activate) {\n\t\t\troot.audiosource.play(root.audiosource.currentSource);\n\t\t}\n\t\tconst children = root._children;\n\t\tfor (let i = 0, len = children.length; i < len; i++) {\n\t\t\tif (children[i] instanceof Entity) {\n\t\t\t\tthis.onInitialize(children[i]);\n\t\t\t}\n\t\t}\n\t\tthis.initialized = true;\n\t}\n\tonUpdate(dt) {\n\t\tconst components = this.store;\n\t\tfor (const id in components) {\n\t\t\tif (components.hasOwnProperty(id)) {\n\t\t\t\tconst component = components[id];\n\t\t\t\tconst entity = component.entity;\n\t\t\t\tconst componentData = component.data;\n\t\t\t\tif (componentData.enabled && entity.enabled && componentData.channel instanceof Channel3d) {\n\t\t\t\t\tconst pos = entity.getPosition();\n\t\t\t\t\tcomponentData.channel.setPosition(pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tonRemove(entity, data) {\n\t\tif (data.channel) {\n\t\t\tdata.channel.stop();\n\t\t\tdata.channel = null;\n\t\t}\n\t}\n\tsetVolume(volume) {\n\t\tthis.manager.setVolume(volume);\n\t}\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('initialize', this.onInitialize, this);\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n}\nComponent._buildAccessors(AudioSourceComponent.prototype, _schema);\n\nexport { AudioSourceComponentSystem };\n","import { now } from '../../../core/time.js';\nimport { math } from '../../../core/math/math.js';\nimport { Color } from '../../../core/math/color.js';\nimport { GraphNode } from '../../../scene/graph-node.js';\nimport { Component } from '../component.js';\nimport { BUTTON_TRANSITION_MODE_SPRITE_CHANGE, BUTTON_TRANSITION_MODE_TINT } from './constants.js';\nimport { ELEMENTTYPE_GROUP } from '../element/constants.js';\n\nconst VisualState = {\n\tDEFAULT: 'DEFAULT',\n\tHOVER: 'HOVER',\n\tPRESSED: 'PRESSED',\n\tINACTIVE: 'INACTIVE'\n};\nconst STATES_TO_TINT_NAMES = {};\nSTATES_TO_TINT_NAMES[VisualState.DEFAULT] = '_defaultTint';\nSTATES_TO_TINT_NAMES[VisualState.HOVER] = 'hoverTint';\nSTATES_TO_TINT_NAMES[VisualState.PRESSED] = 'pressedTint';\nSTATES_TO_TINT_NAMES[VisualState.INACTIVE] = 'inactiveTint';\nconst STATES_TO_SPRITE_ASSET_NAMES = {};\nSTATES_TO_SPRITE_ASSET_NAMES[VisualState.DEFAULT] = '_defaultSpriteAsset';\nSTATES_TO_SPRITE_ASSET_NAMES[VisualState.HOVER] = 'hoverSpriteAsset';\nSTATES_TO_SPRITE_ASSET_NAMES[VisualState.PRESSED] = 'pressedSpriteAsset';\nSTATES_TO_SPRITE_ASSET_NAMES[VisualState.INACTIVE] = 'inactiveSpriteAsset';\nconst STATES_TO_SPRITE_FRAME_NAMES = {};\nSTATES_TO_SPRITE_FRAME_NAMES[VisualState.DEFAULT] = '_defaultSpriteFrame';\nSTATES_TO_SPRITE_FRAME_NAMES[VisualState.HOVER] = 'hoverSpriteFrame';\nSTATES_TO_SPRITE_FRAME_NAMES[VisualState.PRESSED] = 'pressedSpriteFrame';\nSTATES_TO_SPRITE_FRAME_NAMES[VisualState.INACTIVE] = 'inactiveSpriteFrame';\nclass ButtonComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._imageEntity = null;\n\t\tthis._evtElementAdd = null;\n\t\tthis._evtImageEntityElementAdd = null;\n\t\tthis._evtImageEntityElementRemove = null;\n\t\tthis._evtImageEntityElementColor = null;\n\t\tthis._evtImageEntityElementOpacity = null;\n\t\tthis._evtImageEntityElementSpriteAsset = null;\n\t\tthis._evtImageEntityElementSpriteFrame = null;\n\t\tthis._visualState = VisualState.DEFAULT;\n\t\tthis._isHovering = false;\n\t\tthis._hoveringCounter = 0;\n\t\tthis._isPressed = false;\n\t\tthis._defaultTint = new Color(1, 1, 1, 1);\n\t\tthis._defaultSpriteAsset = null;\n\t\tthis._defaultSpriteFrame = 0;\n\t\tthis._toggleLifecycleListeners('on', system);\n\t}\n\tget data() {\n\t\tconst record = this.system.store[this.entity.getGuid()];\n\t\treturn record ? record.data : null;\n\t}\n\tset enabled(arg) {\n\t\tthis._setValue('enabled', arg);\n\t}\n\tget enabled() {\n\t\treturn this.data.enabled;\n\t}\n\tset active(arg) {\n\t\tthis._setValue('active', arg);\n\t}\n\tget active() {\n\t\treturn this.data.active;\n\t}\n\tset imageEntity(arg) {\n\t\tif (this._imageEntity !== arg) {\n\t\t\tconst isString = typeof arg === 'string';\n\t\t\tif (this._imageEntity && isString && this._imageEntity.getGuid() === arg) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._imageEntity) {\n\t\t\t\tthis._imageEntityUnsubscribe();\n\t\t\t}\n\t\t\tif (arg instanceof GraphNode) {\n\t\t\t\tthis._imageEntity = arg;\n\t\t\t} else if (isString) {\n\t\t\t\tthis._imageEntity = this.system.app.getEntityFromIndex(arg) || null;\n\t\t\t} else {\n\t\t\t\tthis._imageEntity = null;\n\t\t\t}\n\t\t\tif (this._imageEntity) {\n\t\t\t\tthis._imageEntitySubscribe();\n\t\t\t}\n\t\t\tif (this._imageEntity) {\n\t\t\t\tthis.data.imageEntity = this._imageEntity.getGuid();\n\t\t\t} else if (isString && arg) {\n\t\t\t\tthis.data.imageEntity = arg;\n\t\t\t}\n\t\t}\n\t}\n\tget imageEntity() {\n\t\treturn this._imageEntity;\n\t}\n\tset hitPadding(arg) {\n\t\tthis._setValue('hitPadding', arg);\n\t}\n\tget hitPadding() {\n\t\treturn this.data.hitPadding;\n\t}\n\tset transitionMode(arg) {\n\t\tthis._setValue('transitionMode', arg);\n\t}\n\tget transitionMode() {\n\t\treturn this.data.transitionMode;\n\t}\n\tset hoverTint(arg) {\n\t\tthis._setValue('hoverTint', arg);\n\t}\n\tget hoverTint() {\n\t\treturn this.data.hoverTint;\n\t}\n\tset pressedTint(arg) {\n\t\tthis._setValue('pressedTint', arg);\n\t}\n\tget pressedTint() {\n\t\treturn this.data.pressedTint;\n\t}\n\tset inactiveTint(arg) {\n\t\tthis._setValue('inactiveTint', arg);\n\t}\n\tget inactiveTint() {\n\t\treturn this.data.inactiveTint;\n\t}\n\tset fadeDuration(arg) {\n\t\tthis._setValue('fadeDuration', arg);\n\t}\n\tget fadeDuration() {\n\t\treturn this.data.fadeDuration;\n\t}\n\tset hoverSpriteAsset(arg) {\n\t\tthis._setValue('hoverSpriteAsset', arg);\n\t}\n\tget hoverSpriteAsset() {\n\t\treturn this.data.hoverSpriteAsset;\n\t}\n\tset hoverSpriteFrame(arg) {\n\t\tthis._setValue('hoverSpriteFrame', arg);\n\t}\n\tget hoverSpriteFrame() {\n\t\treturn this.data.hoverSpriteFrame;\n\t}\n\tset pressedSpriteAsset(arg) {\n\t\tthis._setValue('pressedSpriteAsset', arg);\n\t}\n\tget pressedSpriteAsset() {\n\t\treturn this.data.pressedSpriteAsset;\n\t}\n\tset pressedSpriteFrame(arg) {\n\t\tthis._setValue('pressedSpriteFrame', arg);\n\t}\n\tget pressedSpriteFrame() {\n\t\treturn this.data.pressedSpriteFrame;\n\t}\n\tset inactiveSpriteAsset(arg) {\n\t\tthis._setValue('inactiveSpriteAsset', arg);\n\t}\n\tget inactiveSpriteAsset() {\n\t\treturn this.data.inactiveSpriteAsset;\n\t}\n\tset inactiveSpriteFrame(arg) {\n\t\tthis._setValue('inactiveSpriteFrame', arg);\n\t}\n\tget inactiveSpriteFrame() {\n\t\treturn this.data.inactiveSpriteFrame;\n\t}\n\t_setValue(name, value) {\n\t\tconst data = this.data;\n\t\tconst oldValue = data[name];\n\t\tdata[name] = value;\n\t\tthis.fire('set', name, oldValue, value);\n\t}\n\t_toggleLifecycleListeners(onOrOff, system) {\n\t\tthis[onOrOff]('set_active', this._onSetActive, this);\n\t\tthis[onOrOff]('set_transitionMode', this._onSetTransitionMode, this);\n\t\tthis[onOrOff]('set_hoverTint', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_pressedTint', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_inactiveTint', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_hoverSpriteAsset', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_hoverSpriteFrame', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_pressedSpriteAsset', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_pressedSpriteFrame', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_inactiveSpriteAsset', this._onSetTransitionValue, this);\n\t\tthis[onOrOff]('set_inactiveSpriteFrame', this._onSetTransitionValue, this);\n\t\tif (onOrOff === 'on') {\n\t\t\tthis._evtElementAdd = this.entity.on('element:add', this._onElementComponentAdd, this);\n\t\t} else {\n\t\t\tvar _this$_evtElementAdd;\n\t\t\t(_this$_evtElementAdd = this._evtElementAdd) == null || _this$_evtElementAdd.off();\n\t\t\tthis._evtElementAdd = null;\n\t\t}\n\t}\n\t_onSetActive(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tthis._updateVisualState();\n\t\t}\n\t}\n\t_onSetTransitionMode(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tthis._cancelTween();\n\t\t\tthis._resetToDefaultVisualState(oldValue);\n\t\t\tthis._forceReapplyVisualState();\n\t\t}\n\t}\n\t_onSetTransitionValue(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tthis._forceReapplyVisualState();\n\t\t}\n\t}\n\t_imageEntitySubscribe() {\n\t\tthis._evtImageEntityElementAdd = this._imageEntity.on('element:add', this._onImageElementGain, this);\n\t\tif (this._imageEntity.element) {\n\t\t\tthis._onImageElementGain();\n\t\t}\n\t}\n\t_imageEntityUnsubscribe() {\n\t\tvar _this$_evtImageEntity, _this$_imageEntity;\n\t\t(_this$_evtImageEntity = this._evtImageEntityElementAdd) == null || _this$_evtImageEntity.off();\n\t\tthis._evtImageEntityElementAdd = null;\n\t\tif ((_this$_imageEntity = this._imageEntity) != null && _this$_imageEntity.element) {\n\t\t\tthis._onImageElementLose();\n\t\t}\n\t}\n\t_imageEntityElementSubscribe() {\n\t\tconst element = this._imageEntity.element;\n\t\tthis._evtImageEntityElementRemove = element.once('beforeremove', this._onImageElementLose, this);\n\t\tthis._evtImageEntityElementColor = element.on('set:color', this._onSetColor, this);\n\t\tthis._evtImageEntityElementOpacity = element.on('set:opacity', this._onSetOpacity, this);\n\t\tthis._evtImageEntityElementSpriteAsset = element.on('set:spriteAsset', this._onSetSpriteAsset, this);\n\t\tthis._evtImageEntityElementSpriteFrame = element.on('set:spriteFrame', this._onSetSpriteFrame, this);\n\t}\n\t_imageEntityElementUnsubscribe() {\n\t\tvar _this$_evtImageEntity2, _this$_evtImageEntity3, _this$_evtImageEntity4, _this$_evtImageEntity5, _this$_evtImageEntity6;\n\t\t(_this$_evtImageEntity2 = this._evtImageEntityElementRemove) == null || _this$_evtImageEntity2.off();\n\t\tthis._evtImageEntityElementRemove = null;\n\t\t(_this$_evtImageEntity3 = this._evtImageEntityElementColor) == null || _this$_evtImageEntity3.off();\n\t\tthis._evtImageEntityElementColor = null;\n\t\t(_this$_evtImageEntity4 = this._evtImageEntityElementOpacity) == null || _this$_evtImageEntity4.off();\n\t\tthis._evtImageEntityElementOpacity = null;\n\t\t(_this$_evtImageEntity5 = this._evtImageEntityElementSpriteAsset) == null || _this$_evtImageEntity5.off();\n\t\tthis._evtImageEntityElementSpriteAsset = null;\n\t\t(_this$_evtImageEntity6 = this._evtImageEntityElementSpriteFrame) == null || _this$_evtImageEntity6.off();\n\t\tthis._evtImageEntityElementSpriteFrame = null;\n\t}\n\t_onElementComponentRemove() {\n\t\tthis._toggleHitElementListeners('off');\n\t}\n\t_onElementComponentAdd() {\n\t\tthis._toggleHitElementListeners('on');\n\t}\n\t_onImageElementLose() {\n\t\tthis._imageEntityElementUnsubscribe();\n\t\tthis._cancelTween();\n\t\tthis._resetToDefaultVisualState(this.transitionMode);\n\t}\n\t_onImageElementGain() {\n\t\tthis._imageEntityElementSubscribe();\n\t\tthis._storeDefaultVisualState();\n\t\tthis._forceReapplyVisualState();\n\t}\n\t_toggleHitElementListeners(onOrOff) {\n\t\tif (this.entity.element) {\n\t\t\tconst isAdding = onOrOff === 'on';\n\t\t\tif (isAdding && this._hasHitElementListeners) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.entity.element[onOrOff]('beforeremove', this._onElementComponentRemove, this);\n\t\t\tthis.entity.element[onOrOff]('mouseenter', this._onMouseEnter, this);\n\t\t\tthis.entity.element[onOrOff]('mouseleave', this._onMouseLeave, this);\n\t\t\tthis.entity.element[onOrOff]('mousedown', this._onMouseDown, this);\n\t\t\tthis.entity.element[onOrOff]('mouseup', this._onMouseUp, this);\n\t\t\tthis.entity.element[onOrOff]('touchstart', this._onTouchStart, this);\n\t\t\tthis.entity.element[onOrOff]('touchend', this._onTouchEnd, this);\n\t\t\tthis.entity.element[onOrOff]('touchleave', this._onTouchLeave, this);\n\t\t\tthis.entity.element[onOrOff]('touchcancel', this._onTouchCancel, this);\n\t\t\tthis.entity.element[onOrOff]('selectstart', this._onSelectStart, this);\n\t\t\tthis.entity.element[onOrOff]('selectend', this._onSelectEnd, this);\n\t\t\tthis.entity.element[onOrOff]('selectenter', this._onSelectEnter, this);\n\t\t\tthis.entity.element[onOrOff]('selectleave', this._onSelectLeave, this);\n\t\t\tthis.entity.element[onOrOff]('click', this._onClick, this);\n\t\t\tthis._hasHitElementListeners = isAdding;\n\t\t}\n\t}\n\t_storeDefaultVisualState() {\n\t\tvar _this$_imageEntity2;\n\t\tconst element = (_this$_imageEntity2 = this._imageEntity) == null ? void 0 : _this$_imageEntity2.element;\n\t\tif (!element || element.type === ELEMENTTYPE_GROUP) {\n\t\t\treturn;\n\t\t}\n\t\tthis._storeDefaultColor(element.color);\n\t\tthis._storeDefaultOpacity(element.opacity);\n\t\tthis._storeDefaultSpriteAsset(element.spriteAsset);\n\t\tthis._storeDefaultSpriteFrame(element.spriteFrame);\n\t}\n\t_storeDefaultColor(color) {\n\t\tthis._defaultTint.r = color.r;\n\t\tthis._defaultTint.g = color.g;\n\t\tthis._defaultTint.b = color.b;\n\t}\n\t_storeDefaultOpacity(opacity) {\n\t\tthis._defaultTint.a = opacity;\n\t}\n\t_storeDefaultSpriteAsset(spriteAsset) {\n\t\tthis._defaultSpriteAsset = spriteAsset;\n\t}\n\t_storeDefaultSpriteFrame(spriteFrame) {\n\t\tthis._defaultSpriteFrame = spriteFrame;\n\t}\n\t_onSetColor(color) {\n\t\tif (!this._isApplyingTint) {\n\t\t\tthis._storeDefaultColor(color);\n\t\t\tthis._forceReapplyVisualState();\n\t\t}\n\t}\n\t_onSetOpacity(opacity) {\n\t\tif (!this._isApplyingTint) {\n\t\t\tthis._storeDefaultOpacity(opacity);\n\t\t\tthis._forceReapplyVisualState();\n\t\t}\n\t}\n\t_onSetSpriteAsset(spriteAsset) {\n\t\tif (!this._isApplyingSprite) {\n\t\t\tthis._storeDefaultSpriteAsset(spriteAsset);\n\t\t\tthis._forceReapplyVisualState();\n\t\t}\n\t}\n\t_onSetSpriteFrame(spriteFrame) {\n\t\tif (!this._isApplyingSprite) {\n\t\t\tthis._storeDefaultSpriteFrame(spriteFrame);\n\t\t\tthis._forceReapplyVisualState();\n\t\t}\n\t}\n\t_onMouseEnter(event) {\n\t\tthis._isHovering = true;\n\t\tthis._updateVisualState();\n\t\tthis._fireIfActive('mouseenter', event);\n\t}\n\t_onMouseLeave(event) {\n\t\tthis._isHovering = false;\n\t\tthis._isPressed = false;\n\t\tthis._updateVisualState();\n\t\tthis._fireIfActive('mouseleave', event);\n\t}\n\t_onMouseDown(event) {\n\t\tthis._isPressed = true;\n\t\tthis._updateVisualState();\n\t\tthis._fireIfActive('mousedown', event);\n\t}\n\t_onMouseUp(event) {\n\t\tthis._isPressed = false;\n\t\tthis._updateVisualState();\n\t\tthis._fireIfActive('mouseup', event);\n\t}\n\t_onTouchStart(event) {\n\t\tthis._isPressed = true;\n\t\tthis._updateVisualState();\n\t\tthis._fireIfActive('touchstart', event);\n\t}\n\t_onTouchEnd(event) {\n\t\tevent.event.preventDefault();\n\t\tthis._isPressed = false;\n\t\tthis._updateVisualState();\n\t\tthis._fireIfActive('touchend', event);\n\t}\n\t_onTouchLeave(event) {\n\t\tthis._isPressed = false;\n\t\tthis._updateVisualState();\n\t\tthis._fireIfActive('touchleave', event);\n\t}\n\t_onTouchCancel(event) {\n\t\tthis._isPressed = false;\n\t\tthis._updateVisualState();\n\t\tthis._fireIfActive('touchcancel', event);\n\t}\n\t_onSelectStart(event) {\n\t\tthis._isPressed = true;\n\t\tthis._updateVisualState();\n\t\tthis._fireIfActive('selectstart', event);\n\t}\n\t_onSelectEnd(event) {\n\t\tthis._isPressed = false;\n\t\tthis._updateVisualState();\n\t\tthis._fireIfActive('selectend', event);\n\t}\n\t_onSelectEnter(event) {\n\t\tthis._hoveringCounter++;\n\t\tif (this._hoveringCounter === 1) {\n\t\t\tthis._isHovering = true;\n\t\t\tthis._updateVisualState();\n\t\t}\n\t\tthis._fireIfActive('selectenter', event);\n\t}\n\t_onSelectLeave(event) {\n\t\tthis._hoveringCounter--;\n\t\tif (this._hoveringCounter === 0) {\n\t\t\tthis._isHovering = false;\n\t\t\tthis._isPressed = false;\n\t\t\tthis._updateVisualState();\n\t\t}\n\t\tthis._fireIfActive('selectleave', event);\n\t}\n\t_onClick(event) {\n\t\tthis._fireIfActive('click', event);\n\t}\n\t_fireIfActive(name, event) {\n\t\tif (this.data.active) {\n\t\t\tthis.fire(name, event);\n\t\t}\n\t}\n\t_updateVisualState(force) {\n\t\tconst oldVisualState = this._visualState;\n\t\tconst newVisualState = this._determineVisualState();\n\t\tif ((oldVisualState !== newVisualState || force) && this.enabled) {\n\t\t\tthis._visualState = newVisualState;\n\t\t\tif (oldVisualState === VisualState.HOVER) {\n\t\t\t\tthis._fireIfActive('hoverend');\n\t\t\t}\n\t\t\tif (oldVisualState === VisualState.PRESSED) {\n\t\t\t\tthis._fireIfActive('pressedend');\n\t\t\t}\n\t\t\tif (newVisualState === VisualState.HOVER) {\n\t\t\t\tthis._fireIfActive('hoverstart');\n\t\t\t}\n\t\t\tif (newVisualState === VisualState.PRESSED) {\n\t\t\t\tthis._fireIfActive('pressedstart');\n\t\t\t}\n\t\t\tswitch (this.transitionMode) {\n\t\t\t\tcase BUTTON_TRANSITION_MODE_TINT:\n\t\t\t\t\t{\n\t\t\t\t\t\tconst tintName = STATES_TO_TINT_NAMES[this._visualState];\n\t\t\t\t\t\tconst tintColor = this[tintName];\n\t\t\t\t\t\tthis._applyTint(tintColor);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tcase BUTTON_TRANSITION_MODE_SPRITE_CHANGE:\n\t\t\t\t\t{\n\t\t\t\t\t\tconst spriteAssetName = STATES_TO_SPRITE_ASSET_NAMES[this._visualState];\n\t\t\t\t\t\tconst spriteFrameName = STATES_TO_SPRITE_FRAME_NAMES[this._visualState];\n\t\t\t\t\t\tconst spriteAsset = this[spriteAssetName];\n\t\t\t\t\t\tconst spriteFrame = this[spriteFrameName];\n\t\t\t\t\t\tthis._applySprite(spriteAsset, spriteFrame);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t_forceReapplyVisualState() {\n\t\tthis._updateVisualState(true);\n\t}\n\t_resetToDefaultVisualState(transitionMode) {\n\t\tvar _this$_imageEntity3;\n\t\tif (!((_this$_imageEntity3 = this._imageEntity) != null && _this$_imageEntity3.element)) {\n\t\t\treturn;\n\t\t}\n\t\tswitch (transitionMode) {\n\t\t\tcase BUTTON_TRANSITION_MODE_TINT:\n\t\t\t\tthis._cancelTween();\n\t\t\t\tthis._applyTintImmediately(this._defaultTint);\n\t\t\t\tbreak;\n\t\t\tcase BUTTON_TRANSITION_MODE_SPRITE_CHANGE:\n\t\t\t\tthis._applySprite(this._defaultSpriteAsset, this._defaultSpriteFrame);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\t_determineVisualState() {\n\t\tif (!this.active) {\n\t\t\treturn VisualState.INACTIVE;\n\t\t} else if (this._isPressed) {\n\t\t\treturn VisualState.PRESSED;\n\t\t} else if (this._isHovering) {\n\t\t\treturn VisualState.HOVER;\n\t\t}\n\t\treturn VisualState.DEFAULT;\n\t}\n\t_applySprite(spriteAsset, spriteFrame) {\n\t\tvar _this$_imageEntity4;\n\t\tconst element = (_this$_imageEntity4 = this._imageEntity) == null ? void 0 : _this$_imageEntity4.element;\n\t\tif (!element) {\n\t\t\treturn;\n\t\t}\n\t\tspriteFrame = spriteFrame || 0;\n\t\tthis._isApplyingSprite = true;\n\t\tif (element.spriteAsset !== spriteAsset) {\n\t\t\telement.spriteAsset = spriteAsset;\n\t\t}\n\t\tif (element.spriteFrame !== spriteFrame) {\n\t\t\telement.spriteFrame = spriteFrame;\n\t\t}\n\t\tthis._isApplyingSprite = false;\n\t}\n\t_applyTint(tintColor) {\n\t\tthis._cancelTween();\n\t\tif (this.fadeDuration === 0) {\n\t\t\tthis._applyTintImmediately(tintColor);\n\t\t} else {\n\t\t\tthis._applyTintWithTween(tintColor);\n\t\t}\n\t}\n\t_applyTintImmediately(tintColor) {\n\t\tvar _this$_imageEntity5;\n\t\tconst element = (_this$_imageEntity5 = this._imageEntity) == null ? void 0 : _this$_imageEntity5.element;\n\t\tif (!tintColor || !element || element.type === ELEMENTTYPE_GROUP) {\n\t\t\treturn;\n\t\t}\n\t\tconst color3 = toColor3(tintColor);\n\t\tthis._isApplyingTint = true;\n\t\tif (!color3.equals(element.color)) {\n\t\t\telement.color = color3;\n\t\t}\n\t\tif (element.opacity !== tintColor.a) {\n\t\t\telement.opacity = tintColor.a;\n\t\t}\n\t\tthis._isApplyingTint = false;\n\t}\n\t_applyTintWithTween(tintColor) {\n\t\tvar _this$_imageEntity6;\n\t\tconst element = (_this$_imageEntity6 = this._imageEntity) == null ? void 0 : _this$_imageEntity6.element;\n\t\tif (!tintColor || !element || element.type === ELEMENTTYPE_GROUP) {\n\t\t\treturn;\n\t\t}\n\t\tconst color3 = toColor3(tintColor);\n\t\tconst color = element.color;\n\t\tconst opacity = element.opacity;\n\t\tif (color3.equals(color) && tintColor.a === opacity) return;\n\t\tthis._tweenInfo = {\n\t\t\tstartTime: now(),\n\t\t\tfrom: new Color(color.r, color.g, color.b, opacity),\n\t\t\tto: tintColor.clone(),\n\t\t\tlerpColor: new Color()\n\t\t};\n\t}\n\t_updateTintTween() {\n\t\tconst elapsedTime = now() - this._tweenInfo.startTime;\n\t\tlet elapsedProportion = this.fadeDuration === 0 ? 1 : elapsedTime / this.fadeDuration;\n\t\telapsedProportion = math.clamp(elapsedProportion, 0, 1);\n\t\tif (Math.abs(elapsedProportion - 1) > 1e-5) {\n\t\t\tconst lerpColor = this._tweenInfo.lerpColor;\n\t\t\tlerpColor.lerp(this._tweenInfo.from, this._tweenInfo.to, elapsedProportion);\n\t\t\tthis._applyTintImmediately(new Color(lerpColor.r, lerpColor.g, lerpColor.b, lerpColor.a));\n\t\t} else {\n\t\t\tthis._applyTintImmediately(this._tweenInfo.to);\n\t\t\tthis._cancelTween();\n\t\t}\n\t}\n\t_cancelTween() {\n\t\tdelete this._tweenInfo;\n\t}\n\tonUpdate() {\n\t\tif (this._tweenInfo) {\n\t\t\tthis._updateTintTween();\n\t\t}\n\t}\n\tonEnable() {\n\t\tthis._isHovering = false;\n\t\tthis._hoveringCounter = 0;\n\t\tthis._isPressed = false;\n\t\tthis._toggleHitElementListeners('on');\n\t\tthis._forceReapplyVisualState();\n\t}\n\tonDisable() {\n\t\tthis._toggleHitElementListeners('off');\n\t\tthis._resetToDefaultVisualState(this.transitionMode);\n\t}\n\tonRemove() {\n\t\tthis._imageEntityUnsubscribe();\n\t\tthis._toggleLifecycleListeners('off', this.system);\n\t\tthis.onDisable();\n\t}\n\tresolveDuplicatedEntityReferenceProperties(oldButton, duplicatedIdsMap) {\n\t\tif (oldButton.imageEntity) {\n\t\t\tthis.imageEntity = duplicatedIdsMap[oldButton.imageEntity.getGuid()];\n\t\t}\n\t}\n}\nButtonComponent.EVENT_MOUSEDOWN = 'mousedown';\nButtonComponent.EVENT_MOUSEUP = 'mouseup';\nButtonComponent.EVENT_MOUSEENTER = 'mouseenter';\nButtonComponent.EVENT_MOUSELEAVE = 'mouseleave';\nButtonComponent.EVENT_CLICK = 'click';\nButtonComponent.EVENT_TOUCHSTART = 'touchstart';\nButtonComponent.EVENT_TOUCHEND = 'touchend';\nButtonComponent.EVENT_TOUCHCANCEL = 'touchcancel';\nButtonComponent.EVENT_TOUCHLEAVE = 'touchleave';\nButtonComponent.EVENT_SELECTSTART = 'selectstart';\nButtonComponent.EVENT_SELECTEND = 'selectend';\nButtonComponent.EVENT_SELECTENTER = 'selectenter';\nButtonComponent.EVENT_SELECTLEAVE = 'selectleave';\nButtonComponent.EVENT_HOVERSTART = 'hoverstart';\nButtonComponent.EVENT_HOVEREND = 'hoverend';\nButtonComponent.EVENT_PRESSEDSTART = 'pressedstart';\nButtonComponent.EVENT_PRESSEDEND = 'pressedend';\nfunction toColor3(color4) {\n\treturn new Color(color4.r, color4.g, color4.b);\n}\n\nexport { ButtonComponent };\n","const BUTTON_TRANSITION_MODE_TINT = 0;\nconst BUTTON_TRANSITION_MODE_SPRITE_CHANGE = 1;\n\nexport { BUTTON_TRANSITION_MODE_SPRITE_CHANGE, BUTTON_TRANSITION_MODE_TINT };\n","import { Color } from '../../../core/math/color.js';\nimport { Vec4 } from '../../../core/math/vec4.js';\nimport { BUTTON_TRANSITION_MODE_TINT } from './constants.js';\n\nclass ButtonComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t\tthis.active = true;\n\t\tthis.imageEntity = null;\n\t\tthis.hitPadding = new Vec4();\n\t\tthis.transitionMode = BUTTON_TRANSITION_MODE_TINT;\n\t\tthis.hoverTint = new Color(0.75, 0.75, 0.75);\n\t\tthis.pressedTint = new Color(0.5, 0.5, 0.5);\n\t\tthis.inactiveTint = new Color(0.25, 0.25, 0.25);\n\t\tthis.fadeDuration = 0;\n\t\tthis.hoverSpriteAsset = null;\n\t\tthis.hoverSpriteFrame = 0;\n\t\tthis.pressedSpriteAsset = null;\n\t\tthis.pressedSpriteFrame = 0;\n\t\tthis.inactiveSpriteAsset = null;\n\t\tthis.inactiveSpriteFrame = 0;\n\t}\n}\n\nexport { ButtonComponentData };\n","import { ComponentSystem } from '../system.js';\nimport { ButtonComponent } from './component.js';\nimport { ButtonComponentData } from './data.js';\n\nconst _schema = ['enabled', 'active', {\n\tname: 'hitPadding',\n\ttype: 'vec4'\n}, 'transitionMode', {\n\tname: 'hoverTint',\n\ttype: 'rgba'\n}, {\n\tname: 'pressedTint',\n\ttype: 'rgba'\n}, {\n\tname: 'inactiveTint',\n\ttype: 'rgba'\n}, 'fadeDuration', 'hoverSpriteAsset', 'hoverSpriteFrame', 'pressedSpriteAsset', 'pressedSpriteFrame', 'inactiveSpriteAsset', 'inactiveSpriteFrame'];\nclass ButtonComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'button';\n\t\tthis.ComponentType = ButtonComponent;\n\t\tthis.DataType = ButtonComponentData;\n\t\tthis.schema = _schema;\n\t\tthis.on('beforeremove', this._onRemoveComponent, this);\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t}\n\tinitializeComponentData(component, data, properties) {\n\t\tcomponent.imageEntity = data.imageEntity;\n\t\tsuper.initializeComponentData(component, data, _schema);\n\t}\n\tonUpdate(dt) {\n\t\tconst components = this.store;\n\t\tfor (const id in components) {\n\t\t\tconst entity = components[id].entity;\n\t\t\tconst component = entity.button;\n\t\t\tif (component.enabled && entity.enabled) {\n\t\t\t\tcomponent.onUpdate();\n\t\t\t}\n\t\t}\n\t}\n\t_onRemoveComponent(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n}\n\nexport { ButtonComponentSystem };\n","import { LAYERID_UI, LAYERID_DEPTH, ASPECT_AUTO } from '../../../scene/constants.js';\nimport { Camera } from '../../../scene/camera.js';\nimport { ShaderPass } from '../../../scene/shader-pass.js';\nimport { Component } from '../component.js';\nimport { PostEffectQueue } from './post-effect-queue.js';\n\nclass CameraComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis.onPostprocessing = null;\n\t\tthis.onPreRender = null;\n\t\tthis.onPostRender = null;\n\t\tthis._renderSceneDepthMap = 0;\n\t\tthis._renderSceneColorMap = 0;\n\t\tthis._sceneDepthMapRequested = false;\n\t\tthis._sceneColorMapRequested = false;\n\t\tthis._priority = 0;\n\t\tthis._disablePostEffectsLayer = LAYERID_UI;\n\t\tthis._camera = new Camera();\n\t\tthis._evtLayersChanged = null;\n\t\tthis._evtLayerAdded = null;\n\t\tthis._evtLayerRemoved = null;\n\t\tthis._camera.node = entity;\n\t\tthis._postEffects = new PostEffectQueue(system.app, this);\n\t}\n\tsetShaderPass(name) {\n\t\tconst shaderPass = ShaderPass.get(this.system.app.graphicsDevice);\n\t\tconst shaderPassInfo = name ? shaderPass.allocate(name, {\n\t\t\tisForward: true\n\t\t}) : null;\n\t\tthis._camera.shaderPassInfo = shaderPassInfo;\n\t\treturn shaderPassInfo.index;\n\t}\n\tgetShaderPass() {\n\t\tvar _this$_camera$shaderP;\n\t\treturn (_this$_camera$shaderP = this._camera.shaderPassInfo) == null ? void 0 : _this$_camera$shaderP.name;\n\t}\n\tset renderPasses(passes) {\n\t\tthis._camera.renderPasses = passes;\n\t}\n\tget renderPasses() {\n\t\treturn this._camera.renderPasses;\n\t}\n\tset aperture(value) {\n\t\tthis._camera.aperture = value;\n\t}\n\tget aperture() {\n\t\treturn this._camera.aperture;\n\t}\n\tset aspectRatio(value) {\n\t\tthis._camera.aspectRatio = value;\n\t}\n\tget aspectRatio() {\n\t\treturn this._camera.aspectRatio;\n\t}\n\tset aspectRatioMode(value) {\n\t\tthis._camera.aspectRatioMode = value;\n\t}\n\tget aspectRatioMode() {\n\t\treturn this._camera.aspectRatioMode;\n\t}\n\tset calculateProjection(value) {\n\t\tthis._camera.calculateProjection = value;\n\t}\n\tget calculateProjection() {\n\t\treturn this._camera.calculateProjection;\n\t}\n\tset calculateTransform(value) {\n\t\tthis._camera.calculateTransform = value;\n\t}\n\tget calculateTransform() {\n\t\treturn this._camera.calculateTransform;\n\t}\n\tget camera() {\n\t\treturn this._camera;\n\t}\n\tset clearColor(value) {\n\t\tthis._camera.clearColor = value;\n\t}\n\tget clearColor() {\n\t\treturn this._camera.clearColor;\n\t}\n\tset clearColorBuffer(value) {\n\t\tthis._camera.clearColorBuffer = value;\n\t\tthis.dirtyLayerCompositionCameras();\n\t}\n\tget clearColorBuffer() {\n\t\treturn this._camera.clearColorBuffer;\n\t}\n\tset clearDepthBuffer(value) {\n\t\tthis._camera.clearDepthBuffer = value;\n\t\tthis.dirtyLayerCompositionCameras();\n\t}\n\tget clearDepthBuffer() {\n\t\treturn this._camera.clearDepthBuffer;\n\t}\n\tset clearStencilBuffer(value) {\n\t\tthis._camera.clearStencilBuffer = value;\n\t\tthis.dirtyLayerCompositionCameras();\n\t}\n\tget clearStencilBuffer() {\n\t\treturn this._camera.clearStencilBuffer;\n\t}\n\tset cullFaces(value) {\n\t\tthis._camera.cullFaces = value;\n\t}\n\tget cullFaces() {\n\t\treturn this._camera.cullFaces;\n\t}\n\tset disablePostEffectsLayer(layer) {\n\t\tthis._disablePostEffectsLayer = layer;\n\t\tthis.dirtyLayerCompositionCameras();\n\t}\n\tget disablePostEffectsLayer() {\n\t\treturn this._disablePostEffectsLayer;\n\t}\n\tset farClip(value) {\n\t\tthis._camera.farClip = value;\n\t}\n\tget farClip() {\n\t\treturn this._camera.farClip;\n\t}\n\tset flipFaces(value) {\n\t\tthis._camera.flipFaces = value;\n\t}\n\tget flipFaces() {\n\t\treturn this._camera.flipFaces;\n\t}\n\tset fov(value) {\n\t\tthis._camera.fov = value;\n\t}\n\tget fov() {\n\t\treturn this._camera.fov;\n\t}\n\tget frustum() {\n\t\treturn this._camera.frustum;\n\t}\n\tset frustumCulling(value) {\n\t\tthis._camera.frustumCulling = value;\n\t}\n\tget frustumCulling() {\n\t\treturn this._camera.frustumCulling;\n\t}\n\tset horizontalFov(value) {\n\t\tthis._camera.horizontalFov = value;\n\t}\n\tget horizontalFov() {\n\t\treturn this._camera.horizontalFov;\n\t}\n\tset layers(newValue) {\n\t\tconst layers = this._camera.layers;\n\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(layers[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.removeCamera(this);\n\t\t}\n\t\tthis._camera.layers = newValue;\n\t\tif (!this.enabled || !this.entity.enabled) return;\n\t\tfor (let i = 0; i < newValue.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(newValue[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.addCamera(this);\n\t\t}\n\t}\n\tget layers() {\n\t\treturn this._camera.layers;\n\t}\n\tget layersSet() {\n\t\treturn this._camera.layersSet;\n\t}\n\tset jitter(value) {\n\t\tthis._camera.jitter = value;\n\t}\n\tget jitter() {\n\t\treturn this._camera.jitter;\n\t}\n\tset nearClip(value) {\n\t\tthis._camera.nearClip = value;\n\t}\n\tget nearClip() {\n\t\treturn this._camera.nearClip;\n\t}\n\tset orthoHeight(value) {\n\t\tthis._camera.orthoHeight = value;\n\t}\n\tget orthoHeight() {\n\t\treturn this._camera.orthoHeight;\n\t}\n\tget postEffects() {\n\t\treturn this._postEffects;\n\t}\n\tget postEffectsEnabled() {\n\t\treturn this._postEffects.enabled;\n\t}\n\tset priority(newValue) {\n\t\tthis._priority = newValue;\n\t\tthis.dirtyLayerCompositionCameras();\n\t}\n\tget priority() {\n\t\treturn this._priority;\n\t}\n\tset projection(value) {\n\t\tthis._camera.projection = value;\n\t}\n\tget projection() {\n\t\treturn this._camera.projection;\n\t}\n\tget projectionMatrix() {\n\t\treturn this._camera.projectionMatrix;\n\t}\n\tset rect(value) {\n\t\tthis._camera.rect = value;\n\t\tthis.fire('set:rect', this._camera.rect);\n\t}\n\tget rect() {\n\t\treturn this._camera.rect;\n\t}\n\tset renderSceneColorMap(value) {\n\t\tif (value && !this._sceneColorMapRequested) {\n\t\t\tthis.requestSceneColorMap(true);\n\t\t\tthis._sceneColorMapRequested = true;\n\t\t} else if (this._sceneColorMapRequested) {\n\t\t\tthis.requestSceneColorMap(false);\n\t\t\tthis._sceneColorMapRequested = false;\n\t\t}\n\t}\n\tget renderSceneColorMap() {\n\t\treturn this._renderSceneColorMap > 0;\n\t}\n\tset renderSceneDepthMap(value) {\n\t\tif (value && !this._sceneDepthMapRequested) {\n\t\t\tthis.requestSceneDepthMap(true);\n\t\t\tthis._sceneDepthMapRequested = true;\n\t\t} else if (this._sceneDepthMapRequested) {\n\t\t\tthis.requestSceneDepthMap(false);\n\t\t\tthis._sceneDepthMapRequested = false;\n\t\t}\n\t}\n\tget renderSceneDepthMap() {\n\t\treturn this._renderSceneDepthMap > 0;\n\t}\n\tset renderTarget(value) {\n\t\tthis._camera.renderTarget = value;\n\t\tthis.dirtyLayerCompositionCameras();\n\t}\n\tget renderTarget() {\n\t\treturn this._camera.renderTarget;\n\t}\n\tset scissorRect(value) {\n\t\tthis._camera.scissorRect = value;\n\t}\n\tget scissorRect() {\n\t\treturn this._camera.scissorRect;\n\t}\n\tset sensitivity(value) {\n\t\tthis._camera.sensitivity = value;\n\t}\n\tget sensitivity() {\n\t\treturn this._camera.sensitivity;\n\t}\n\tset shutter(value) {\n\t\tthis._camera.shutter = value;\n\t}\n\tget shutter() {\n\t\treturn this._camera.shutter;\n\t}\n\tget viewMatrix() {\n\t\treturn this._camera.viewMatrix;\n\t}\n\t_enableDepthLayer(value) {\n\t\tconst hasDepthLayer = this.layers.find(layerId => layerId === LAYERID_DEPTH);\n\t\tif (hasDepthLayer) {\n\t\t\tconst depthLayer = this.system.app.scene.layers.getLayerById(LAYERID_DEPTH);\n\t\t\tif (value) {\n\t\t\t\tdepthLayer == null || depthLayer.incrementCounter();\n\t\t\t} else {\n\t\t\t\tdepthLayer == null || depthLayer.decrementCounter();\n\t\t\t}\n\t\t} else if (value) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\trequestSceneColorMap(enabled) {\n\t\tthis._renderSceneColorMap += enabled ? 1 : -1;\n\t\tthis._enableDepthLayer(enabled);\n\t\tthis.camera._enableRenderPassColorGrab(this.system.app.graphicsDevice, this.renderSceneColorMap);\n\t}\n\trequestSceneDepthMap(enabled) {\n\t\tthis._renderSceneDepthMap += enabled ? 1 : -1;\n\t\tthis._enableDepthLayer(enabled);\n\t\tthis.camera._enableRenderPassDepthGrab(this.system.app.graphicsDevice, this.system.app.renderer, this.renderSceneDepthMap);\n\t}\n\tdirtyLayerCompositionCameras() {\n\t\tconst layerComp = this.system.app.scene.layers;\n\t\tlayerComp._dirty = true;\n\t}\n\tscreenToWorld(screenx, screeny, cameraz, worldCoord) {\n\t\tconst device = this.system.app.graphicsDevice;\n\t\tconst w = device.clientRect.width;\n\t\tconst h = device.clientRect.height;\n\t\treturn this._camera.screenToWorld(screenx, screeny, cameraz, w, h, worldCoord);\n\t}\n\tworldToScreen(worldCoord, screenCoord) {\n\t\tconst device = this.system.app.graphicsDevice;\n\t\tconst w = device.clientRect.width;\n\t\tconst h = device.clientRect.height;\n\t\treturn this._camera.worldToScreen(worldCoord, w, h, screenCoord);\n\t}\n\tonAppPrerender() {\n\t\tthis._camera._viewMatDirty = true;\n\t\tthis._camera._viewProjMatDirty = true;\n\t}\n\taddCameraToLayers() {\n\t\tconst layers = this.layers;\n\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(layers[i]);\n\t\t\tif (layer) {\n\t\t\t\tlayer.addCamera(this);\n\t\t\t}\n\t\t}\n\t}\n\tremoveCameraFromLayers() {\n\t\tconst layers = this.layers;\n\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(layers[i]);\n\t\t\tif (layer) {\n\t\t\t\tlayer.removeCamera(this);\n\t\t\t}\n\t\t}\n\t}\n\tonLayersChanged(oldComp, newComp) {\n\t\tthis.addCameraToLayers();\n\t\toldComp.off('add', this.onLayerAdded, this);\n\t\toldComp.off('remove', this.onLayerRemoved, this);\n\t\tnewComp.on('add', this.onLayerAdded, this);\n\t\tnewComp.on('remove', this.onLayerRemoved, this);\n\t}\n\tonLayerAdded(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.addCamera(this);\n\t}\n\tonLayerRemoved(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.removeCamera(this);\n\t}\n\tonEnable() {\n\t\tvar _this$_evtLayersChang;\n\t\tconst scene = this.system.app.scene;\n\t\tconst layers = scene.layers;\n\t\tthis.system.addCamera(this);\n\t\t(_this$_evtLayersChang = this._evtLayersChanged) == null || _this$_evtLayersChang.off();\n\t\tthis._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);\n\t\tif (layers) {\n\t\t\tvar _this$_evtLayerAdded, _this$_evtLayerRemove;\n\t\t\t(_this$_evtLayerAdded = this._evtLayerAdded) == null || _this$_evtLayerAdded.off();\n\t\t\tthis._evtLayerAdded = layers.on('add', this.onLayerAdded, this);\n\t\t\t(_this$_evtLayerRemove = this._evtLayerRemoved) == null || _this$_evtLayerRemove.off();\n\t\t\tthis._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);\n\t\t}\n\t\tif (this.enabled && this.entity.enabled) {\n\t\t\tthis.addCameraToLayers();\n\t\t}\n\t\tthis.postEffects.enable();\n\t}\n\tonDisable() {\n\t\tvar _this$_evtLayersChang2;\n\t\tconst scene = this.system.app.scene;\n\t\tconst layers = scene.layers;\n\t\tthis.postEffects.disable();\n\t\tthis.removeCameraFromLayers();\n\t\t(_this$_evtLayersChang2 = this._evtLayersChanged) == null || _this$_evtLayersChang2.off();\n\t\tthis._evtLayersChanged = null;\n\t\tif (layers) {\n\t\t\tvar _this$_evtLayerAdded2, _this$_evtLayerRemove2;\n\t\t\t(_this$_evtLayerAdded2 = this._evtLayerAdded) == null || _this$_evtLayerAdded2.off();\n\t\t\tthis._evtLayerAdded = null;\n\t\t\t(_this$_evtLayerRemove2 = this._evtLayerRemoved) == null || _this$_evtLayerRemove2.off();\n\t\t\tthis._evtLayerRemoved = null;\n\t\t}\n\t\tthis.system.removeCamera(this);\n\t}\n\tonRemove() {\n\t\tthis.onDisable();\n\t\tthis.off();\n\t\tthis.camera.destroy();\n\t}\n\tcalculateAspectRatio(rt) {\n\t\tconst device = this.system.app.graphicsDevice;\n\t\tconst width = rt ? rt.width : device.width;\n\t\tconst height = rt ? rt.height : device.height;\n\t\treturn width * this.rect.z / (height * this.rect.w);\n\t}\n\tframeUpdate(rt) {\n\t\tif (this.aspectRatioMode === ASPECT_AUTO) {\n\t\t\tthis.aspectRatio = this.calculateAspectRatio(rt);\n\t\t}\n\t}\n\tstartXr(type, spaceType, options) {\n\t\tthis.system.app.xr.start(this, type, spaceType, options);\n\t}\n\tendXr(callback) {\n\t\tif (!this._camera.xr) {\n\t\t\tif (callback) callback(new Error('Camera is not in XR'));\n\t\t\treturn;\n\t\t}\n\t\tthis._camera.xr.end(callback);\n\t}\n\tcopy(source) {\n\t\tthis.aperture = source.aperture;\n\t\tthis.aspectRatio = source.aspectRatio;\n\t\tthis.aspectRatioMode = source.aspectRatioMode;\n\t\tthis.calculateProjection = source.calculateProjection;\n\t\tthis.calculateTransform = source.calculateTransform;\n\t\tthis.clearColor = source.clearColor;\n\t\tthis.clearColorBuffer = source.clearColorBuffer;\n\t\tthis.clearDepthBuffer = source.clearDepthBuffer;\n\t\tthis.clearStencilBuffer = source.clearStencilBuffer;\n\t\tthis.cullFaces = source.cullFaces;\n\t\tthis.disablePostEffectsLayer = source.disablePostEffectsLayer;\n\t\tthis.farClip = source.farClip;\n\t\tthis.flipFaces = source.flipFaces;\n\t\tthis.fov = source.fov;\n\t\tthis.frustumCulling = source.frustumCulling;\n\t\tthis.horizontalFov = source.horizontalFov;\n\t\tthis.layers = source.layers;\n\t\tthis.nearClip = source.nearClip;\n\t\tthis.orthoHeight = source.orthoHeight;\n\t\tthis.priority = source.priority;\n\t\tthis.projection = source.projection;\n\t\tthis.rect = source.rect;\n\t\tthis.renderTarget = source.renderTarget;\n\t\tthis.scissorRect = source.scissorRect;\n\t\tthis.sensitivity = source.sensitivity;\n\t\tthis.shutter = source.shutter;\n\t}\n}\n\nexport { CameraComponent };\n","class CameraComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n}\n\nexport { CameraComponentData };\n","import { FILTER_NEAREST, ADDRESS_CLAMP_TO_EDGE, PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F, PIXELFORMAT_RGBA8 } from '../../../platform/graphics/constants.js';\nimport { RenderTarget } from '../../../platform/graphics/render-target.js';\nimport { Texture } from '../../../platform/graphics/texture.js';\nimport { LAYERID_DEPTH } from '../../../scene/constants.js';\n\nclass PostEffectEntry {\n\tconstructor(effect, inputTarget) {\n\t\tthis.effect = effect;\n\t\tthis.inputTarget = inputTarget;\n\t\tthis.outputTarget = null;\n\t\tthis.name = effect.constructor.name;\n\t}\n}\nclass PostEffectQueue {\n\tconstructor(app, camera) {\n\t\tthis.app = app;\n\t\tthis.camera = camera;\n\t\tthis.destinationRenderTarget = null;\n\t\tthis.effects = [];\n\t\tthis.enabled = false;\n\t\tthis.depthTarget = null;\n\t\tcamera.on('set:rect', this.onCameraRectChanged, this);\n\t}\n\t_allocateColorBuffer(format, name) {\n\t\tvar _renderTarget$width, _renderTarget$height;\n\t\tconst rect = this.camera.rect;\n\t\tconst renderTarget = this.destinationRenderTarget;\n\t\tconst device = this.app.graphicsDevice;\n\t\tconst width = Math.floor(rect.z * ((_renderTarget$width = renderTarget == null ? void 0 : renderTarget.width) != null ? _renderTarget$width : device.width));\n\t\tconst height = Math.floor(rect.w * ((_renderTarget$height = renderTarget == null ? void 0 : renderTarget.height) != null ? _renderTarget$height : device.height));\n\t\tconst colorBuffer = new Texture(device, {\n\t\t\tname: name,\n\t\t\tformat: format,\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tmipmaps: false,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t\t});\n\t\treturn colorBuffer;\n\t}\n\t_createOffscreenTarget(useDepth, hdr) {\n\t\tconst device = this.app.graphicsDevice;\n\t\tconst format = hdr && device.getRenderableHdrFormat([PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F], true) || PIXELFORMAT_RGBA8;\n\t\tconst name = `${this.camera.entity.name}-posteffect-${this.effects.length}`;\n\t\tconst colorBuffer = this._allocateColorBuffer(format, name);\n\t\treturn new RenderTarget({\n\t\t\tcolorBuffer: colorBuffer,\n\t\t\tdepth: useDepth,\n\t\t\tstencil: useDepth && this.app.graphicsDevice.supportsStencil,\n\t\t\tsamples: useDepth ? device.samples : 1\n\t\t});\n\t}\n\t_resizeOffscreenTarget(rt) {\n\t\tconst format = rt.colorBuffer.format;\n\t\tconst name = rt.colorBuffer.name;\n\t\trt.destroyFrameBuffers();\n\t\trt.destroyTextureBuffers();\n\t\trt._colorBuffer = this._allocateColorBuffer(format, name);\n\t\trt._colorBuffers = [rt._colorBuffer];\n\t}\n\t_destroyOffscreenTarget(rt) {\n\t\trt.destroyTextureBuffers();\n\t\trt.destroy();\n\t}\n\taddEffect(effect) {\n\t\tconst effects = this.effects;\n\t\tconst isFirstEffect = effects.length === 0;\n\t\tconst inputTarget = this._createOffscreenTarget(isFirstEffect, effect.hdr);\n\t\tconst newEntry = new PostEffectEntry(effect, inputTarget);\n\t\teffects.push(newEntry);\n\t\tthis._sourceTarget = newEntry.inputTarget;\n\t\tif (effects.length > 1) {\n\t\t\teffects[effects.length - 2].outputTarget = newEntry.inputTarget;\n\t\t}\n\t\tthis._newPostEffect = effect;\n\t\tif (effect.needsDepthBuffer) {\n\t\t\tthis._requestDepthMap();\n\t\t}\n\t\tthis.enable();\n\t\tthis._newPostEffect = undefined;\n\t}\n\tremoveEffect(effect) {\n\t\tlet index = -1;\n\t\tfor (let i = 0, len = this.effects.length; i < len; i++) {\n\t\t\tif (this.effects[i].effect === effect) {\n\t\t\t\tindex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (index >= 0) {\n\t\t\tif (index > 0) {\n\t\t\t\tthis.effects[index - 1].outputTarget = index + 1 < this.effects.length ? this.effects[index + 1].inputTarget : null;\n\t\t\t} else {\n\t\t\t\tif (this.effects.length > 1) {\n\t\t\t\t\tif (!this.effects[1].inputTarget._depth) {\n\t\t\t\t\t\tthis._destroyOffscreenTarget(this.effects[1].inputTarget);\n\t\t\t\t\t\tthis.effects[1].inputTarget = this._createOffscreenTarget(true, this.effects[1].hdr);\n\t\t\t\t\t\tthis._sourceTarget = this.effects[1].inputTarget;\n\t\t\t\t\t}\n\t\t\t\t\tthis.camera.renderTarget = this.effects[1].inputTarget;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._destroyOffscreenTarget(this.effects[index].inputTarget);\n\t\t\tthis.effects.splice(index, 1);\n\t\t}\n\t\tif (this.enabled) {\n\t\t\tif (effect.needsDepthBuffer) {\n\t\t\t\tthis._releaseDepthMap();\n\t\t\t}\n\t\t}\n\t\tif (this.effects.length === 0) {\n\t\t\tthis.disable();\n\t\t}\n\t}\n\t_requestDepthMaps() {\n\t\tfor (let i = 0, len = this.effects.length; i < len; i++) {\n\t\t\tconst effect = this.effects[i].effect;\n\t\t\tif (this._newPostEffect === effect) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (effect.needsDepthBuffer) {\n\t\t\t\tthis._requestDepthMap();\n\t\t\t}\n\t\t}\n\t}\n\t_releaseDepthMaps() {\n\t\tfor (let i = 0, len = this.effects.length; i < len; i++) {\n\t\t\tconst effect = this.effects[i].effect;\n\t\t\tif (effect.needsDepthBuffer) {\n\t\t\t\tthis._releaseDepthMap();\n\t\t\t}\n\t\t}\n\t}\n\t_requestDepthMap() {\n\t\tconst depthLayer = this.app.scene.layers.getLayerById(LAYERID_DEPTH);\n\t\tif (depthLayer) {\n\t\t\tdepthLayer.incrementCounter();\n\t\t\tthis.camera.requestSceneDepthMap(true);\n\t\t}\n\t}\n\t_releaseDepthMap() {\n\t\tconst depthLayer = this.app.scene.layers.getLayerById(LAYERID_DEPTH);\n\t\tif (depthLayer) {\n\t\t\tdepthLayer.decrementCounter();\n\t\t\tthis.camera.requestSceneDepthMap(false);\n\t\t}\n\t}\n\tdestroy() {\n\t\tfor (let i = 0, len = this.effects.length; i < len; i++) {\n\t\t\tthis.effects[i].inputTarget.destroy();\n\t\t}\n\t\tthis.effects.length = 0;\n\t\tthis.disable();\n\t}\n\tenable() {\n\t\tif (!this.enabled && this.effects.length) {\n\t\t\tthis.enabled = true;\n\t\t\tthis._requestDepthMaps();\n\t\t\tthis.app.graphicsDevice.on('resizecanvas', this._onCanvasResized, this);\n\t\t\tthis.destinationRenderTarget = this.camera.renderTarget;\n\t\t\tthis.camera.renderTarget = this.effects[0].inputTarget;\n\t\t\tthis.camera.onPostprocessing = () => {\n\t\t\t\tif (this.enabled) {\n\t\t\t\t\tlet rect = null;\n\t\t\t\t\tconst len = this.effects.length;\n\t\t\t\t\tif (len) {\n\t\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\t\tconst fx = this.effects[i];\n\t\t\t\t\t\t\tlet destTarget = fx.outputTarget;\n\t\t\t\t\t\t\tif (i === len - 1) {\n\t\t\t\t\t\t\t\trect = this.camera.rect;\n\t\t\t\t\t\t\t\tif (this.destinationRenderTarget) {\n\t\t\t\t\t\t\t\t\tdestTarget = this.destinationRenderTarget;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfx.effect.render(fx.inputTarget, destTarget, rect);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\tdisable() {\n\t\tif (this.enabled) {\n\t\t\tthis.enabled = false;\n\t\t\tthis.app.graphicsDevice.off('resizecanvas', this._onCanvasResized, this);\n\t\t\tthis._releaseDepthMaps();\n\t\t\tthis._destroyOffscreenTarget(this._sourceTarget);\n\t\t\tthis.camera.renderTarget = null;\n\t\t\tthis.camera.onPostprocessing = null;\n\t\t}\n\t}\n\t_onCanvasResized(width, height) {\n\t\tvar _renderTarget$width2, _renderTarget$height2;\n\t\tconst rect = this.camera.rect;\n\t\tconst renderTarget = this.destinationRenderTarget;\n\t\twidth = (_renderTarget$width2 = renderTarget == null ? void 0 : renderTarget.width) != null ? _renderTarget$width2 : width;\n\t\theight = (_renderTarget$height2 = renderTarget == null ? void 0 : renderTarget.height) != null ? _renderTarget$height2 : height;\n\t\tthis.camera.camera.aspectRatio = width * rect.z / (height * rect.w);\n\t\tthis.resizeRenderTargets();\n\t}\n\tresizeRenderTargets() {\n\t\tvar _renderTarget$width3, _renderTarget$height3;\n\t\tconst device = this.app.graphicsDevice;\n\t\tconst renderTarget = this.destinationRenderTarget;\n\t\tconst width = (_renderTarget$width3 = renderTarget == null ? void 0 : renderTarget.width) != null ? _renderTarget$width3 : device.width;\n\t\tconst height = (_renderTarget$height3 = renderTarget == null ? void 0 : renderTarget.height) != null ? _renderTarget$height3 : device.height;\n\t\tconst rect = this.camera.rect;\n\t\tconst desiredWidth = Math.floor(rect.z * width);\n\t\tconst desiredHeight = Math.floor(rect.w * height);\n\t\tconst effects = this.effects;\n\t\tfor (let i = 0, len = effects.length; i < len; i++) {\n\t\t\tconst fx = effects[i];\n\t\t\tif (fx.inputTarget.width !== desiredWidth || fx.inputTarget.height !== desiredHeight) {\n\t\t\t\tthis._resizeOffscreenTarget(fx.inputTarget);\n\t\t\t}\n\t\t}\n\t}\n\tonCameraRectChanged(name, oldValue, newValue) {\n\t\tif (this.enabled) {\n\t\t\tthis.resizeRenderTargets();\n\t\t}\n\t}\n}\n\nexport { PostEffectQueue };\n","import { sortPriority } from '../../../core/sort.js';\nimport { Color } from '../../../core/math/color.js';\nimport { Vec4 } from '../../../core/math/vec4.js';\nimport { Component } from '../component.js';\nimport { ComponentSystem } from '../system.js';\nimport { CameraComponent } from './component.js';\nimport { CameraComponentData } from './data.js';\n\nconst _schema = ['enabled'];\nclass CameraComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.cameras = [];\n\t\tthis.id = 'camera';\n\t\tthis.ComponentType = CameraComponent;\n\t\tthis.DataType = CameraComponentData;\n\t\tthis.schema = _schema;\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t\tthis.app.on('prerender', this.onAppPrerender, this);\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t}\n\tinitializeComponentData(component, data, properties) {\n\t\tproperties = ['aspectRatio', 'aspectRatioMode', 'calculateProjection', 'calculateTransform', 'clearColor', 'clearColorBuffer', 'clearDepthBuffer', 'clearStencilBuffer', 'renderSceneColorMap', 'renderSceneDepthMap', 'cullFaces', 'farClip', 'flipFaces', 'fov', 'frustumCulling', 'horizontalFov', 'layers', 'renderTarget', 'nearClip', 'orthoHeight', 'projection', 'priority', 'rect', 'scissorRect', 'aperture', 'shutter', 'sensitivity'];\n\t\tfor (let i = 0; i < properties.length; i++) {\n\t\t\tconst property = properties[i];\n\t\t\tif (data.hasOwnProperty(property)) {\n\t\t\t\tconst value = data[property];\n\t\t\t\tswitch (property) {\n\t\t\t\t\tcase 'rect':\n\t\t\t\t\tcase 'scissorRect':\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tcomponent[property] = new Vec4(value[0], value[1], value[2], value[3]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcomponent[property] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'clearColor':\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tcomponent[property] = new Color(value[0], value[1], value[2], value[3]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcomponent[property] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tcomponent[property] = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsuper.initializeComponentData(component, data, ['enabled']);\n\t}\n\tcloneComponent(entity, clone) {\n\t\tconst c = entity.camera;\n\t\treturn this.addComponent(clone, {\n\t\t\taspectRatio: c.aspectRatio,\n\t\t\taspectRatioMode: c.aspectRatioMode,\n\t\t\tcalculateProjection: c.calculateProjection,\n\t\t\tcalculateTransform: c.calculateTransform,\n\t\t\tclearColor: c.clearColor,\n\t\t\tclearColorBuffer: c.clearColorBuffer,\n\t\t\tclearDepthBuffer: c.clearDepthBuffer,\n\t\t\tclearStencilBuffer: c.clearStencilBuffer,\n\t\t\trenderSceneDepthMap: c.renderSceneDepthMap,\n\t\t\trenderSceneColorMap: c.renderSceneColorMap,\n\t\t\tcullFaces: c.cullFaces,\n\t\t\tenabled: c.enabled,\n\t\t\tfarClip: c.farClip,\n\t\t\tflipFaces: c.flipFaces,\n\t\t\tfov: c.fov,\n\t\t\tfrustumCulling: c.frustumCulling,\n\t\t\thorizontalFov: c.horizontalFov,\n\t\t\tlayers: c.layers,\n\t\t\trenderTarget: c.renderTarget,\n\t\t\tnearClip: c.nearClip,\n\t\t\torthoHeight: c.orthoHeight,\n\t\t\tprojection: c.projection,\n\t\t\tpriority: c.priority,\n\t\t\trect: c.rect,\n\t\t\tscissorRect: c.scissorRect,\n\t\t\taperture: c.aperture,\n\t\t\tsensitivity: c.sensitivity,\n\t\t\tshutter: c.shutter\n\t\t});\n\t}\n\tonBeforeRemove(entity, component) {\n\t\tthis.removeCamera(component);\n\t\tcomponent.onRemove();\n\t}\n\tonUpdate(dt) {}\n\tonAppPrerender() {\n\t\tfor (let i = 0, len = this.cameras.length; i < len; i++) {\n\t\t\tthis.cameras[i].onAppPrerender();\n\t\t}\n\t}\n\taddCamera(camera) {\n\t\tthis.cameras.push(camera);\n\t\tsortPriority(this.cameras);\n\t}\n\tremoveCamera(camera) {\n\t\tconst index = this.cameras.indexOf(camera);\n\t\tif (index >= 0) {\n\t\t\tthis.cameras.splice(index, 1);\n\t\t\tsortPriority(this.cameras);\n\t\t}\n\t}\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n}\nComponent._buildAccessors(CameraComponent.prototype, _schema);\n\nexport { CameraComponentSystem };\n","import { Quat } from '../../../core/math/quat.js';\nimport { Vec3 } from '../../../core/math/vec3.js';\nimport { Asset } from '../../asset/asset.js';\nimport { Component } from '../component.js';\n\nconst _vec3 = new Vec3();\nconst _quat = new Quat();\nclass CollisionComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._compoundParent = null;\n\t\tthis._hasOffset = false;\n\t\tthis.entity.on('insert', this._onInsert, this);\n\t\tthis.on('set_type', this.onSetType, this);\n\t\tthis.on('set_convexHull', this.onSetModel, this);\n\t\tthis.on('set_halfExtents', this.onSetHalfExtents, this);\n\t\tthis.on('set_linearOffset', this.onSetOffset, this);\n\t\tthis.on('set_angularOffset', this.onSetOffset, this);\n\t\tthis.on('set_radius', this.onSetRadius, this);\n\t\tthis.on('set_height', this.onSetHeight, this);\n\t\tthis.on('set_axis', this.onSetAxis, this);\n\t\tthis.on('set_asset', this.onSetAsset, this);\n\t\tthis.on('set_renderAsset', this.onSetRenderAsset, this);\n\t\tthis.on('set_model', this.onSetModel, this);\n\t\tthis.on('set_render', this.onSetRender, this);\n\t}\n\tget data() {\n\t\tconst record = this.system.store[this.entity.getGuid()];\n\t\treturn record ? record.data : null;\n\t}\n\tset enabled(arg) {\n\t\tthis._setValue('enabled', arg);\n\t}\n\tget enabled() {\n\t\treturn this.data.enabled;\n\t}\n\tset type(arg) {\n\t\tthis._setValue('type', arg);\n\t}\n\tget type() {\n\t\treturn this.data.type;\n\t}\n\tset halfExtents(arg) {\n\t\tthis._setValue('halfExtents', arg);\n\t}\n\tget halfExtents() {\n\t\treturn this.data.halfExtents;\n\t}\n\tset linearOffset(arg) {\n\t\tthis._setValue('linearOffset', arg);\n\t}\n\tget linearOffset() {\n\t\treturn this.data.linearOffset;\n\t}\n\tset angularOffset(arg) {\n\t\tthis._setValue('angularOffset', arg);\n\t}\n\tget angularOffset() {\n\t\treturn this.data.angularOffset;\n\t}\n\tset radius(arg) {\n\t\tthis._setValue('radius', arg);\n\t}\n\tget radius() {\n\t\treturn this.data.radius;\n\t}\n\tset axis(arg) {\n\t\tthis._setValue('axis', arg);\n\t}\n\tget axis() {\n\t\treturn this.data.axis;\n\t}\n\tset height(arg) {\n\t\tthis._setValue('height', arg);\n\t}\n\tget height() {\n\t\treturn this.data.height;\n\t}\n\tset asset(arg) {\n\t\tthis._setValue('asset', arg);\n\t}\n\tget asset() {\n\t\treturn this.data.asset;\n\t}\n\tset renderAsset(arg) {\n\t\tthis._setValue('renderAsset', arg);\n\t}\n\tget renderAsset() {\n\t\treturn this.data.renderAsset;\n\t}\n\tset convexHull(arg) {\n\t\tthis._setValue('convexHull', arg);\n\t}\n\tget convexHull() {\n\t\treturn this.data.convexHull;\n\t}\n\tset shape(arg) {\n\t\tthis._setValue('shape', arg);\n\t}\n\tget shape() {\n\t\treturn this.data.shape;\n\t}\n\tset model(arg) {\n\t\tthis._setValue('model', arg);\n\t}\n\tget model() {\n\t\treturn this.data.model;\n\t}\n\tset render(arg) {\n\t\tthis._setValue('render', arg);\n\t}\n\tget render() {\n\t\treturn this.data.render;\n\t}\n\tset checkVertexDuplicates(arg) {\n\t\tthis._setValue('checkVertexDuplicates', arg);\n\t}\n\tget checkVertexDuplicates() {\n\t\treturn this.data.checkVertexDuplicates;\n\t}\n\t_setValue(name, value) {\n\t\tconst data = this.data;\n\t\tconst oldValue = data[name];\n\t\tdata[name] = value;\n\t\tthis.fire('set', name, oldValue, value);\n\t}\n\tonSetType(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tthis.system.changeType(this, oldValue, newValue);\n\t\t}\n\t}\n\tonSetHalfExtents(name, oldValue, newValue) {\n\t\tconst t = this.data.type;\n\t\tif (this.data.initialized && t === 'box') {\n\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t}\n\t}\n\tonSetOffset(name, oldValue, newValue) {\n\t\tthis._hasOffset = !this.data.linearOffset.equals(Vec3.ZERO) || !this.data.angularOffset.equals(Quat.IDENTITY);\n\t\tif (this.data.initialized) {\n\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t}\n\t}\n\tonSetRadius(name, oldValue, newValue) {\n\t\tconst t = this.data.type;\n\t\tif (this.data.initialized && (t === 'sphere' || t === 'capsule' || t === 'cylinder' || t === 'cone')) {\n\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t}\n\t}\n\tonSetHeight(name, oldValue, newValue) {\n\t\tconst t = this.data.type;\n\t\tif (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {\n\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t}\n\t}\n\tonSetAxis(name, oldValue, newValue) {\n\t\tconst t = this.data.type;\n\t\tif (this.data.initialized && (t === 'capsule' || t === 'cylinder' || t === 'cone')) {\n\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t}\n\t}\n\tonSetAsset(name, oldValue, newValue) {\n\t\tconst assets = this.system.app.assets;\n\t\tif (oldValue) {\n\t\t\tconst asset = assets.get(oldValue);\n\t\t\tif (asset) {\n\t\t\t\tasset.off('remove', this.onAssetRemoved, this);\n\t\t\t}\n\t\t}\n\t\tif (newValue) {\n\t\t\tif (newValue instanceof Asset) {\n\t\t\t\tthis.data.asset = newValue.id;\n\t\t\t}\n\t\t\tconst asset = assets.get(this.data.asset);\n\t\t\tif (asset) {\n\t\t\t\tasset.off('remove', this.onAssetRemoved, this);\n\t\t\t\tasset.on('remove', this.onAssetRemoved, this);\n\t\t\t}\n\t\t}\n\t\tif (this.data.initialized && this.data.type === 'mesh') {\n\t\t\tif (!newValue) {\n\t\t\t\tthis.data.model = null;\n\t\t\t}\n\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t}\n\t}\n\tonSetRenderAsset(name, oldValue, newValue) {\n\t\tconst assets = this.system.app.assets;\n\t\tif (oldValue) {\n\t\t\tconst asset = assets.get(oldValue);\n\t\t\tif (asset) {\n\t\t\t\tasset.off('remove', this.onRenderAssetRemoved, this);\n\t\t\t}\n\t\t}\n\t\tif (newValue) {\n\t\t\tif (newValue instanceof Asset) {\n\t\t\t\tthis.data.renderAsset = newValue.id;\n\t\t\t}\n\t\t\tconst asset = assets.get(this.data.renderAsset);\n\t\t\tif (asset) {\n\t\t\t\tasset.off('remove', this.onRenderAssetRemoved, this);\n\t\t\t\tasset.on('remove', this.onRenderAssetRemoved, this);\n\t\t\t}\n\t\t}\n\t\tif (this.data.initialized && this.data.type === 'mesh') {\n\t\t\tif (!newValue) {\n\t\t\t\tthis.data.render = null;\n\t\t\t}\n\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t}\n\t}\n\tonSetModel(name, oldValue, newValue) {\n\t\tif (this.data.initialized && this.data.type === 'mesh') {\n\t\t\tthis.system.implementations.mesh.doRecreatePhysicalShape(this);\n\t\t}\n\t}\n\tonSetRender(name, oldValue, newValue) {\n\t\tthis.onSetModel(name, oldValue, newValue);\n\t}\n\tonAssetRemoved(asset) {\n\t\tasset.off('remove', this.onAssetRemoved, this);\n\t\tif (this.data.asset === asset.id) {\n\t\t\tthis.asset = null;\n\t\t}\n\t}\n\tonRenderAssetRemoved(asset) {\n\t\tasset.off('remove', this.onRenderAssetRemoved, this);\n\t\tif (this.data.renderAsset === asset.id) {\n\t\t\tthis.renderAsset = null;\n\t\t}\n\t}\n\tgetCompoundChildShapeIndex(shape) {\n\t\tconst compound = this.data.shape;\n\t\tconst shapes = compound.getNumChildShapes();\n\t\tfor (let i = 0; i < shapes; i++) {\n\t\t\tconst childShape = compound.getChildShape(i);\n\t\t\tif (Ammo.getPointer(childShape) === Ammo.getPointer(shape)) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t_onInsert(parent) {\n\t\tif (typeof Ammo === 'undefined') {\n\t\t\treturn;\n\t\t}\n\t\tif (this._compoundParent) {\n\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t} else if (!this.entity.rigidbody) {\n\t\t\tlet ancestor = this.entity.parent;\n\t\t\twhile (ancestor) {\n\t\t\t\tif (ancestor.collision && ancestor.collision.type === 'compound') {\n\t\t\t\t\tif (ancestor.collision.shape.getNumChildShapes() === 0) {\n\t\t\t\t\t\tthis.system.recreatePhysicalShapes(ancestor.collision);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tancestor = ancestor.parent;\n\t\t\t}\n\t\t}\n\t}\n\t_updateCompound() {\n\t\tconst entity = this.entity;\n\t\tif (entity._dirtyWorld) {\n\t\t\tlet dirty = entity._dirtyLocal;\n\t\t\tlet parent = entity;\n\t\t\twhile (parent && !dirty) {\n\t\t\t\tif (parent.collision && parent.collision === this._compoundParent) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (parent._dirtyLocal) {\n\t\t\t\t\tdirty = true;\n\t\t\t\t}\n\t\t\t\tparent = parent.parent;\n\t\t\t}\n\t\t\tif (dirty) {\n\t\t\t\tentity.forEach(this.system.implementations.compound._updateEachDescendantTransform, entity);\n\t\t\t\tconst bodyComponent = this._compoundParent.entity.rigidbody;\n\t\t\t\tif (bodyComponent) {\n\t\t\t\t\tbodyComponent.activate();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tgetShapePosition() {\n\t\tconst pos = this.entity.getPosition();\n\t\tif (this._hasOffset) {\n\t\t\tconst rot = this.entity.getRotation();\n\t\t\tconst lo = this.data.linearOffset;\n\t\t\t_quat.copy(rot).transformVector(lo, _vec3);\n\t\t\treturn _vec3.add(pos);\n\t\t}\n\t\treturn pos;\n\t}\n\tgetShapeRotation() {\n\t\tconst rot = this.entity.getRotation();\n\t\tif (this._hasOffset) {\n\t\t\treturn _quat.copy(rot).mul(this.data.angularOffset);\n\t\t}\n\t\treturn rot;\n\t}\n\tonEnable() {\n\t\tif (this.data.type === 'mesh' && (this.data.asset || this.data.renderAsset) && this.data.initialized) {\n\t\t\tconst asset = this.system.app.assets.get(this.data.asset || this.data.renderAsset);\n\t\t\tif (asset && (!asset.resource || !this.data.shape)) {\n\t\t\t\tthis.system.recreatePhysicalShapes(this);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (this.entity.rigidbody) {\n\t\t\tif (this.entity.rigidbody.enabled) {\n\t\t\t\tthis.entity.rigidbody.enableSimulation();\n\t\t\t}\n\t\t} else if (this._compoundParent && this !== this._compoundParent) {\n\t\t\tif (this._compoundParent.shape.getNumChildShapes() === 0) {\n\t\t\t\tthis.system.recreatePhysicalShapes(this._compoundParent);\n\t\t\t} else {\n\t\t\t\tconst transform = this.system._getNodeTransform(this.entity, this._compoundParent.entity);\n\t\t\t\tthis._compoundParent.shape.addChildShape(transform, this.data.shape);\n\t\t\t\tAmmo.destroy(transform);\n\t\t\t\tif (this._compoundParent.entity.rigidbody) {\n\t\t\t\t\tthis._compoundParent.entity.rigidbody.activate();\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.entity.trigger) {\n\t\t\tthis.entity.trigger.enable();\n\t\t}\n\t}\n\tonDisable() {\n\t\tif (this.entity.rigidbody) {\n\t\t\tthis.entity.rigidbody.disableSimulation();\n\t\t} else if (this._compoundParent && this !== this._compoundParent) {\n\t\t\tif (!this._compoundParent.entity._destroying) {\n\t\t\t\tthis.system._removeCompoundChild(this._compoundParent, this.data.shape);\n\t\t\t\tif (this._compoundParent.entity.rigidbody) {\n\t\t\t\t\tthis._compoundParent.entity.rigidbody.activate();\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this.entity.trigger) {\n\t\t\tthis.entity.trigger.disable();\n\t\t}\n\t}\n\tonBeforeRemove() {\n\t\tif (this.asset) {\n\t\t\tthis.asset = null;\n\t\t}\n\t\tif (this.renderAsset) {\n\t\t\tthis.renderAsset = null;\n\t\t}\n\t\tthis.entity.off('insert', this._onInsert, this);\n\t\tthis.off();\n\t}\n}\nCollisionComponent.EVENT_CONTACT = 'contact';\nCollisionComponent.EVENT_COLLISIONSTART = 'collisionstart';\nCollisionComponent.EVENT_COLLISIONEND = 'collisionend';\nCollisionComponent.EVENT_TRIGGERENTER = 'triggerenter';\nCollisionComponent.EVENT_TRIGGERLEAVE = 'triggerleave';\n\nexport { CollisionComponent };\n","import { Quat } from '../../../core/math/quat.js';\nimport { Vec3 } from '../../../core/math/vec3.js';\n\nclass CollisionComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t\tthis.type = 'box';\n\t\tthis.halfExtents = new Vec3(0.5, 0.5, 0.5);\n\t\tthis.linearOffset = new Vec3();\n\t\tthis.angularOffset = new Quat();\n\t\tthis.radius = 0.5;\n\t\tthis.axis = 1;\n\t\tthis.height = 2;\n\t\tthis.convexHull = false;\n\t\tthis.asset = null;\n\t\tthis.renderAsset = null;\n\t\tthis.checkVertexDuplicates = true;\n\t\tthis.shape = null;\n\t\tthis.model = null;\n\t\tthis.render = null;\n\t\tthis.initialized = false;\n\t}\n}\n\nexport { CollisionComponentData };\n","import { Mat4 } from '../../../core/math/mat4.js';\nimport { Quat } from '../../../core/math/quat.js';\nimport { Vec3 } from '../../../core/math/vec3.js';\nimport { SEMANTIC_POSITION } from '../../../platform/graphics/constants.js';\nimport { GraphNode } from '../../../scene/graph-node.js';\nimport { Model } from '../../../scene/model.js';\nimport { ComponentSystem } from '../system.js';\nimport { CollisionComponent } from './component.js';\nimport { CollisionComponentData } from './data.js';\nimport { Trigger } from './trigger.js';\n\nconst mat4 = new Mat4();\nconst p1 = new Vec3();\nconst p2 = new Vec3();\nconst quat = new Quat();\nconst tempGraphNode = new GraphNode();\nconst _schema = ['enabled', 'type', 'halfExtents', 'linearOffset', 'angularOffset', 'radius', 'axis', 'height', 'convexHull', 'asset', 'renderAsset', 'shape', 'model', 'render', 'checkVertexDuplicates'];\nclass CollisionSystemImpl {\n\tconstructor(system) {\n\t\tthis.system = system;\n\t}\n\tbeforeInitialize(component, data) {\n\t\tdata.shape = null;\n\t\tdata.model = new Model();\n\t\tdata.model.graph = new GraphNode();\n\t}\n\tafterInitialize(component, data) {\n\t\tthis.recreatePhysicalShapes(component);\n\t\tcomponent.data.initialized = true;\n\t}\n\treset(component, data) {\n\t\tthis.beforeInitialize(component, data);\n\t\tthis.afterInitialize(component, data);\n\t}\n\trecreatePhysicalShapes(component) {\n\t\tconst entity = component.entity;\n\t\tconst data = component.data;\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\tif (entity.trigger) {\n\t\t\t\tentity.trigger.destroy();\n\t\t\t\tdelete entity.trigger;\n\t\t\t}\n\t\t\tif (data.shape) {\n\t\t\t\tif (component._compoundParent) {\n\t\t\t\t\tif (component !== component._compoundParent) {\n\t\t\t\t\t\tthis.system._removeCompoundChild(component._compoundParent, data.shape);\n\t\t\t\t\t}\n\t\t\t\t\tif (component._compoundParent.entity.rigidbody) {\n\t\t\t\t\t\tcomponent._compoundParent.entity.rigidbody.activate();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.destroyShape(data);\n\t\t\t}\n\t\t\tdata.shape = this.createPhysicalShape(component.entity, data);\n\t\t\tconst firstCompoundChild = !component._compoundParent;\n\t\t\tif (data.type === 'compound' && (!component._compoundParent || component === component._compoundParent)) {\n\t\t\t\tcomponent._compoundParent = component;\n\t\t\t\tentity.forEach(this._addEachDescendant, component);\n\t\t\t} else if (data.type !== 'compound') {\n\t\t\t\tif (!component.rigidbody) {\n\t\t\t\t\tcomponent._compoundParent = null;\n\t\t\t\t\tlet parent = entity.parent;\n\t\t\t\t\twhile (parent) {\n\t\t\t\t\t\tif (parent.collision && parent.collision.type === 'compound') {\n\t\t\t\t\t\t\tcomponent._compoundParent = parent.collision;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparent = parent.parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (component._compoundParent) {\n\t\t\t\tif (component !== component._compoundParent) {\n\t\t\t\t\tif (firstCompoundChild && component._compoundParent.shape.getNumChildShapes() === 0) {\n\t\t\t\t\t\tthis.system.recreatePhysicalShapes(component._compoundParent);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.system.updateCompoundChildTransform(entity, true);\n\t\t\t\t\t\tif (component._compoundParent.entity.rigidbody) {\n\t\t\t\t\t\t\tcomponent._compoundParent.entity.rigidbody.activate();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (entity.rigidbody) {\n\t\t\t\tentity.rigidbody.disableSimulation();\n\t\t\t\tentity.rigidbody.createBody();\n\t\t\t\tif (entity.enabled && entity.rigidbody.enabled) {\n\t\t\t\t\tentity.rigidbody.enableSimulation();\n\t\t\t\t}\n\t\t\t} else if (!component._compoundParent) {\n\t\t\t\tif (!entity.trigger) {\n\t\t\t\t\tentity.trigger = new Trigger(this.system.app, component, data);\n\t\t\t\t} else {\n\t\t\t\t\tentity.trigger.initialize(data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcreatePhysicalShape(entity, data) {\n\t\treturn undefined;\n\t}\n\tupdateTransform(component, position, rotation, scale) {\n\t\tif (component.entity.trigger) {\n\t\t\tcomponent.entity.trigger.updateTransform();\n\t\t}\n\t}\n\tdestroyShape(data) {\n\t\tif (data.shape) {\n\t\t\tAmmo.destroy(data.shape);\n\t\t\tdata.shape = null;\n\t\t}\n\t}\n\tbeforeRemove(entity, component) {\n\t\tif (component.data.shape) {\n\t\t\tif (component._compoundParent && !component._compoundParent.entity._destroying) {\n\t\t\t\tthis.system._removeCompoundChild(component._compoundParent, component.data.shape);\n\t\t\t\tif (component._compoundParent.entity.rigidbody) {\n\t\t\t\t\tcomponent._compoundParent.entity.rigidbody.activate();\n\t\t\t\t}\n\t\t\t}\n\t\t\tcomponent._compoundParent = null;\n\t\t\tthis.destroyShape(component.data);\n\t\t}\n\t}\n\tremove(entity, data) {\n\t\tif (entity.rigidbody && entity.rigidbody.body) {\n\t\t\tentity.rigidbody.disableSimulation();\n\t\t}\n\t\tif (entity.trigger) {\n\t\t\tentity.trigger.destroy();\n\t\t\tdelete entity.trigger;\n\t\t}\n\t}\n\tclone(entity, clone) {\n\t\tconst src = this.system.store[entity.getGuid()];\n\t\tconst data = {\n\t\t\tenabled: src.data.enabled,\n\t\t\ttype: src.data.type,\n\t\t\thalfExtents: [src.data.halfExtents.x, src.data.halfExtents.y, src.data.halfExtents.z],\n\t\t\tlinearOffset: [src.data.linearOffset.x, src.data.linearOffset.y, src.data.linearOffset.z],\n\t\t\tangularOffset: [src.data.angularOffset.x, src.data.angularOffset.y, src.data.angularOffset.z, src.data.angularOffset.w],\n\t\t\tradius: src.data.radius,\n\t\t\taxis: src.data.axis,\n\t\t\theight: src.data.height,\n\t\t\tconvexHull: src.data.convexHull,\n\t\t\tasset: src.data.asset,\n\t\t\trenderAsset: src.data.renderAsset,\n\t\t\tmodel: src.data.model,\n\t\t\trender: src.data.render,\n\t\t\tcheckVertexDuplicates: src.data.checkVertexDuplicates\n\t\t};\n\t\treturn this.system.addComponent(clone, data);\n\t}\n}\nclass CollisionBoxSystemImpl extends CollisionSystemImpl {\n\tcreatePhysicalShape(entity, data) {\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\tconst he = data.halfExtents;\n\t\t\tconst ammoHe = new Ammo.btVector3(he ? he.x : 0.5, he ? he.y : 0.5, he ? he.z : 0.5);\n\t\t\tconst shape = new Ammo.btBoxShape(ammoHe);\n\t\t\tAmmo.destroy(ammoHe);\n\t\t\treturn shape;\n\t\t}\n\t\treturn undefined;\n\t}\n}\nclass CollisionSphereSystemImpl extends CollisionSystemImpl {\n\tcreatePhysicalShape(entity, data) {\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\treturn new Ammo.btSphereShape(data.radius);\n\t\t}\n\t\treturn undefined;\n\t}\n}\nclass CollisionCapsuleSystemImpl extends CollisionSystemImpl {\n\tcreatePhysicalShape(entity, data) {\n\t\tvar _data$axis, _data$radius, _data$height;\n\t\tconst axis = (_data$axis = data.axis) != null ? _data$axis : 1;\n\t\tconst radius = (_data$radius = data.radius) != null ? _data$radius : 0.5;\n\t\tconst height = Math.max(((_data$height = data.height) != null ? _data$height : 2) - 2 * radius, 0);\n\t\tlet shape = null;\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\tswitch (axis) {\n\t\t\t\tcase 0:\n\t\t\t\t\tshape = new Ammo.btCapsuleShapeX(radius, height);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tshape = new Ammo.btCapsuleShape(radius, height);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tshape = new Ammo.btCapsuleShapeZ(radius, height);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn shape;\n\t}\n}\nclass CollisionCylinderSystemImpl extends CollisionSystemImpl {\n\tcreatePhysicalShape(entity, data) {\n\t\tvar _data$axis2, _data$radius2, _data$height2;\n\t\tconst axis = (_data$axis2 = data.axis) != null ? _data$axis2 : 1;\n\t\tconst radius = (_data$radius2 = data.radius) != null ? _data$radius2 : 0.5;\n\t\tconst height = (_data$height2 = data.height) != null ? _data$height2 : 1;\n\t\tlet halfExtents = null;\n\t\tlet shape = null;\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\tswitch (axis) {\n\t\t\t\tcase 0:\n\t\t\t\t\thalfExtents = new Ammo.btVector3(height * 0.5, radius, radius);\n\t\t\t\t\tshape = new Ammo.btCylinderShapeX(halfExtents);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\thalfExtents = new Ammo.btVector3(radius, height * 0.5, radius);\n\t\t\t\t\tshape = new Ammo.btCylinderShape(halfExtents);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\thalfExtents = new Ammo.btVector3(radius, radius, height * 0.5);\n\t\t\t\t\tshape = new Ammo.btCylinderShapeZ(halfExtents);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (halfExtents) {\n\t\t\tAmmo.destroy(halfExtents);\n\t\t}\n\t\treturn shape;\n\t}\n}\nclass CollisionConeSystemImpl extends CollisionSystemImpl {\n\tcreatePhysicalShape(entity, data) {\n\t\tvar _data$axis3, _data$radius3, _data$height3;\n\t\tconst axis = (_data$axis3 = data.axis) != null ? _data$axis3 : 1;\n\t\tconst radius = (_data$radius3 = data.radius) != null ? _data$radius3 : 0.5;\n\t\tconst height = (_data$height3 = data.height) != null ? _data$height3 : 1;\n\t\tlet shape = null;\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\tswitch (axis) {\n\t\t\t\tcase 0:\n\t\t\t\t\tshape = new Ammo.btConeShapeX(radius, height);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tshape = new Ammo.btConeShape(radius, height);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tshape = new Ammo.btConeShapeZ(radius, height);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn shape;\n\t}\n}\nclass CollisionMeshSystemImpl extends CollisionSystemImpl {\n\tbeforeInitialize(component, data) {}\n\tcreateAmmoHull(mesh, node, shape, scale) {\n\t\tconst hull = new Ammo.btConvexHullShape();\n\t\tconst point = new Ammo.btVector3();\n\t\tconst positions = [];\n\t\tmesh.getPositions(positions);\n\t\tfor (let i = 0; i < positions.length; i += 3) {\n\t\t\tpoint.setValue(positions[i] * scale.x, positions[i + 1] * scale.y, positions[i + 2] * scale.z);\n\t\t\thull.addPoint(point, false);\n\t\t}\n\t\tAmmo.destroy(point);\n\t\thull.recalcLocalAabb();\n\t\thull.setMargin(0.01);\n\t\tshape.addChildShape(this.system._getNodeTransform(node), hull);\n\t}\n\tcreateAmmoMesh(mesh, node, shape, scale, checkDupes = true) {\n\t\tconst system = this.system;\n\t\tlet triMesh;\n\t\tif (system._triMeshCache[mesh.id]) {\n\t\t\ttriMesh = system._triMeshCache[mesh.id];\n\t\t} else {\n\t\t\tconst vb = mesh.vertexBuffer;\n\t\t\tconst format = vb.getFormat();\n\t\t\tlet stride, positions;\n\t\t\tfor (let i = 0; i < format.elements.length; i++) {\n\t\t\t\tconst element = format.elements[i];\n\t\t\t\tif (element.name === SEMANTIC_POSITION) {\n\t\t\t\t\tpositions = new Float32Array(vb.lock(), element.offset);\n\t\t\t\t\tstride = element.stride / 4;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst indices = [];\n\t\t\tmesh.getIndices(indices);\n\t\t\tconst numTriangles = mesh.primitive[0].count / 3;\n\t\t\tconst v1 = new Ammo.btVector3();\n\t\t\tlet i1, i2, i3;\n\t\t\tconst base = mesh.primitive[0].base;\n\t\t\ttriMesh = new Ammo.btTriangleMesh();\n\t\t\tsystem._triMeshCache[mesh.id] = triMesh;\n\t\t\tconst vertexCache = new Map();\n\t\t\tconst indexedArray = triMesh.getIndexedMeshArray();\n\t\t\tindexedArray.at(0).m_numTriangles = numTriangles;\n\t\t\tconst sx = scale ? scale.x : 1;\n\t\t\tconst sy = scale ? scale.y : 1;\n\t\t\tconst sz = scale ? scale.z : 1;\n\t\t\tconst addVertex = index => {\n\t\t\t\tconst x = positions[index * stride] * sx;\n\t\t\t\tconst y = positions[index * stride + 1] * sy;\n\t\t\t\tconst z = positions[index * stride + 2] * sz;\n\t\t\t\tlet idx;\n\t\t\t\tif (checkDupes) {\n\t\t\t\t\tconst str = `${x}:${y}:${z}`;\n\t\t\t\t\tidx = vertexCache.get(str);\n\t\t\t\t\tif (idx !== undefined) {\n\t\t\t\t\t\treturn idx;\n\t\t\t\t\t}\n\t\t\t\t\tv1.setValue(x, y, z);\n\t\t\t\t\tidx = triMesh.findOrAddVertex(v1, false);\n\t\t\t\t\tvertexCache.set(str, idx);\n\t\t\t\t} else {\n\t\t\t\t\tv1.setValue(x, y, z);\n\t\t\t\t\tidx = triMesh.findOrAddVertex(v1, false);\n\t\t\t\t}\n\t\t\t\treturn idx;\n\t\t\t};\n\t\t\tfor (let i = 0; i < numTriangles; i++) {\n\t\t\t\ti1 = addVertex(indices[base + i * 3]);\n\t\t\t\ti2 = addVertex(indices[base + i * 3 + 1]);\n\t\t\t\ti3 = addVertex(indices[base + i * 3 + 2]);\n\t\t\t\ttriMesh.addIndex(i1);\n\t\t\t\ttriMesh.addIndex(i2);\n\t\t\t\ttriMesh.addIndex(i3);\n\t\t\t}\n\t\t\tAmmo.destroy(v1);\n\t\t}\n\t\tconst triMeshShape = new Ammo.btBvhTriangleMeshShape(triMesh, true);\n\t\tif (!scale) {\n\t\t\tconst scaling = system._getNodeScaling(node);\n\t\t\ttriMeshShape.setLocalScaling(scaling);\n\t\t\tAmmo.destroy(scaling);\n\t\t}\n\t\tconst transform = system._getNodeTransform(node);\n\t\tshape.addChildShape(transform, triMeshShape);\n\t\tAmmo.destroy(transform);\n\t}\n\tcreatePhysicalShape(entity, data) {\n\t\tif (typeof Ammo === 'undefined') return undefined;\n\t\tif (data.model || data.render) {\n\t\t\tconst shape = new Ammo.btCompoundShape();\n\t\t\tconst entityTransform = entity.getWorldTransform();\n\t\t\tconst scale = entityTransform.getScale();\n\t\t\tif (data.model) {\n\t\t\t\tconst meshInstances = data.model.meshInstances;\n\t\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\t\tthis.createAmmoMesh(meshInstances[i].mesh, meshInstances[i].node, shape, null, data.checkVertexDuplicates);\n\t\t\t\t}\n\t\t\t\tconst vec = new Ammo.btVector3(scale.x, scale.y, scale.z);\n\t\t\t\tshape.setLocalScaling(vec);\n\t\t\t\tAmmo.destroy(vec);\n\t\t\t} else if (data.render) {\n\t\t\t\tconst meshes = data.render.meshes;\n\t\t\t\tfor (let i = 0; i < meshes.length; i++) {\n\t\t\t\t\tif (data.convexHull) {\n\t\t\t\t\t\tthis.createAmmoHull(meshes[i], tempGraphNode, shape, scale);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.createAmmoMesh(meshes[i], tempGraphNode, shape, scale, data.checkVertexDuplicates);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn shape;\n\t\t}\n\t\treturn undefined;\n\t}\n\trecreatePhysicalShapes(component) {\n\t\tconst data = component.data;\n\t\tif (data.renderAsset || data.asset) {\n\t\t\tif (component.enabled && component.entity.enabled) {\n\t\t\t\tthis.loadAsset(component, data.renderAsset || data.asset, data.renderAsset ? 'render' : 'model');\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tthis.doRecreatePhysicalShape(component);\n\t}\n\tloadAsset(component, id, property) {\n\t\tconst data = component.data;\n\t\tconst assets = this.system.app.assets;\n\t\tconst previousPropertyValue = data[property];\n\t\tconst onAssetFullyReady = asset => {\n\t\t\tif (data[property] !== previousPropertyValue) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdata[property] = asset.resource;\n\t\t\tthis.doRecreatePhysicalShape(component);\n\t\t};\n\t\tconst loadAndHandleAsset = asset => {\n\t\t\tasset.ready(asset => {\n\t\t\t\tif (asset.data.containerAsset) {\n\t\t\t\t\tconst containerAsset = assets.get(asset.data.containerAsset);\n\t\t\t\t\tif (containerAsset.loaded) {\n\t\t\t\t\t\tonAssetFullyReady(asset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontainerAsset.ready(() => {\n\t\t\t\t\t\t\tonAssetFullyReady(asset);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tassets.load(containerAsset);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tonAssetFullyReady(asset);\n\t\t\t\t}\n\t\t\t});\n\t\t\tassets.load(asset);\n\t\t};\n\t\tconst asset = assets.get(id);\n\t\tif (asset) {\n\t\t\tloadAndHandleAsset(asset);\n\t\t} else {\n\t\t\tassets.once(`add:${id}`, loadAndHandleAsset);\n\t\t}\n\t}\n\tdoRecreatePhysicalShape(component) {\n\t\tconst entity = component.entity;\n\t\tconst data = component.data;\n\t\tif (data.model || data.render) {\n\t\t\tthis.destroyShape(data);\n\t\t\tdata.shape = this.createPhysicalShape(entity, data);\n\t\t\tif (entity.rigidbody) {\n\t\t\t\tentity.rigidbody.disableSimulation();\n\t\t\t\tentity.rigidbody.createBody();\n\t\t\t\tif (entity.enabled && entity.rigidbody.enabled) {\n\t\t\t\t\tentity.rigidbody.enableSimulation();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!entity.trigger) {\n\t\t\t\t\tentity.trigger = new Trigger(this.system.app, component, data);\n\t\t\t\t} else {\n\t\t\t\t\tentity.trigger.initialize(data);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.beforeRemove(entity, component);\n\t\t\tthis.remove(entity, data);\n\t\t}\n\t}\n\tupdateTransform(component, position, rotation, scale) {\n\t\tif (component.shape) {\n\t\t\tconst entityTransform = component.entity.getWorldTransform();\n\t\t\tconst worldScale = entityTransform.getScale();\n\t\t\tconst previousScale = component.shape.getLocalScaling();\n\t\t\tif (worldScale.x !== previousScale.x() || worldScale.y !== previousScale.y() || worldScale.z !== previousScale.z()) {\n\t\t\t\tthis.doRecreatePhysicalShape(component);\n\t\t\t}\n\t\t}\n\t\tsuper.updateTransform(component, position, rotation, scale);\n\t}\n\tdestroyShape(data) {\n\t\tif (!data.shape) {\n\t\t\treturn;\n\t\t}\n\t\tconst numShapes = data.shape.getNumChildShapes();\n\t\tfor (let i = 0; i < numShapes; i++) {\n\t\t\tconst shape = data.shape.getChildShape(i);\n\t\t\tAmmo.destroy(shape);\n\t\t}\n\t\tAmmo.destroy(data.shape);\n\t\tdata.shape = null;\n\t}\n}\nclass CollisionCompoundSystemImpl extends CollisionSystemImpl {\n\tcreatePhysicalShape(entity, data) {\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\treturn new Ammo.btCompoundShape();\n\t\t}\n\t\treturn undefined;\n\t}\n\t_addEachDescendant(entity) {\n\t\tif (!entity.collision || entity.rigidbody) {\n\t\t\treturn;\n\t\t}\n\t\tentity.collision._compoundParent = this;\n\t\tif (entity !== this.entity) {\n\t\t\tentity.collision.system.recreatePhysicalShapes(entity.collision);\n\t\t}\n\t}\n\t_updateEachDescendant(entity) {\n\t\tif (!entity.collision) {\n\t\t\treturn;\n\t\t}\n\t\tif (entity.collision._compoundParent !== this) {\n\t\t\treturn;\n\t\t}\n\t\tentity.collision._compoundParent = null;\n\t\tif (entity !== this.entity && !entity.rigidbody) {\n\t\t\tentity.collision.system.recreatePhysicalShapes(entity.collision);\n\t\t}\n\t}\n\t_updateEachDescendantTransform(entity) {\n\t\tif (!entity.collision || entity.collision._compoundParent !== this.collision._compoundParent) {\n\t\t\treturn;\n\t\t}\n\t\tthis.collision.system.updateCompoundChildTransform(entity, false);\n\t}\n}\nclass CollisionComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'collision';\n\t\tthis.ComponentType = CollisionComponent;\n\t\tthis.DataType = CollisionComponentData;\n\t\tthis.schema = _schema;\n\t\tthis.implementations = {};\n\t\tthis._triMeshCache = {};\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t\tthis.on('remove', this.onRemove, this);\n\t}\n\tinitializeComponentData(component, _data, properties) {\n\t\tproperties = ['type', 'halfExtents', 'radius', 'axis', 'height', 'convexHull', 'shape', 'model', 'asset', 'render', 'renderAsset', 'enabled', 'linearOffset', 'angularOffset', 'checkVertexDuplicates'];\n\t\tconst data = {};\n\t\tfor (let i = 0, len = properties.length; i < len; i++) {\n\t\t\tconst property = properties[i];\n\t\t\tdata[property] = _data[property];\n\t\t}\n\t\tlet idx;\n\t\tif (_data.hasOwnProperty('asset')) {\n\t\t\tidx = properties.indexOf('model');\n\t\t\tif (idx !== -1) {\n\t\t\t\tproperties.splice(idx, 1);\n\t\t\t}\n\t\t\tidx = properties.indexOf('render');\n\t\t\tif (idx !== -1) {\n\t\t\t\tproperties.splice(idx, 1);\n\t\t\t}\n\t\t} else if (_data.hasOwnProperty('model')) {\n\t\t\tidx = properties.indexOf('asset');\n\t\t\tif (idx !== -1) {\n\t\t\t\tproperties.splice(idx, 1);\n\t\t\t}\n\t\t}\n\t\tif (!data.type) {\n\t\t\tdata.type = component.data.type;\n\t\t}\n\t\tcomponent.data.type = data.type;\n\t\tif (Array.isArray(data.halfExtents)) {\n\t\t\tdata.halfExtents = new Vec3(data.halfExtents);\n\t\t}\n\t\tif (Array.isArray(data.linearOffset)) {\n\t\t\tdata.linearOffset = new Vec3(data.linearOffset);\n\t\t}\n\t\tif (Array.isArray(data.angularOffset)) {\n\t\t\tconst values = data.angularOffset;\n\t\t\tif (values.length === 3) {\n\t\t\t\tdata.angularOffset = new Quat().setFromEulerAngles(values[0], values[1], values[2]);\n\t\t\t} else {\n\t\t\t\tdata.angularOffset = new Quat(data.angularOffset);\n\t\t\t}\n\t\t}\n\t\tconst impl = this._createImplementation(data.type);\n\t\timpl.beforeInitialize(component, data);\n\t\tsuper.initializeComponentData(component, data, properties);\n\t\timpl.afterInitialize(component, data);\n\t}\n\t_createImplementation(type) {\n\t\tif (this.implementations[type] === undefined) {\n\t\t\tlet impl;\n\t\t\tswitch (type) {\n\t\t\t\tcase 'box':\n\t\t\t\t\timpl = new CollisionBoxSystemImpl(this);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'sphere':\n\t\t\t\t\timpl = new CollisionSphereSystemImpl(this);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'capsule':\n\t\t\t\t\timpl = new CollisionCapsuleSystemImpl(this);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'cylinder':\n\t\t\t\t\timpl = new CollisionCylinderSystemImpl(this);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'cone':\n\t\t\t\t\timpl = new CollisionConeSystemImpl(this);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'mesh':\n\t\t\t\t\timpl = new CollisionMeshSystemImpl(this);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'compound':\n\t\t\t\t\timpl = new CollisionCompoundSystemImpl(this);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.implementations[type] = impl;\n\t\t}\n\t\treturn this.implementations[type];\n\t}\n\t_getImplementation(entity) {\n\t\treturn this.implementations[entity.collision.data.type];\n\t}\n\tcloneComponent(entity, clone) {\n\t\treturn this._getImplementation(entity).clone(entity, clone);\n\t}\n\tonBeforeRemove(entity, component) {\n\t\tthis.implementations[component.data.type].beforeRemove(entity, component);\n\t\tcomponent.onBeforeRemove();\n\t}\n\tonRemove(entity, data) {\n\t\tthis.implementations[data.type].remove(entity, data);\n\t}\n\tupdateCompoundChildTransform(entity, forceUpdate) {\n\t\tconst parentComponent = entity.collision._compoundParent;\n\t\tif (parentComponent === entity.collision) return;\n\t\tif (entity.enabled && entity.collision.enabled && (entity._dirtyLocal || forceUpdate)) {\n\t\t\tconst transform = this._getNodeTransform(entity, parentComponent.entity);\n\t\t\tconst idx = parentComponent.getCompoundChildShapeIndex(entity.collision.shape);\n\t\t\tif (idx === null) {\n\t\t\t\tparentComponent.shape.addChildShape(transform, entity.collision.data.shape);\n\t\t\t} else {\n\t\t\t\tparentComponent.shape.updateChildTransform(idx, transform, true);\n\t\t\t}\n\t\t\tAmmo.destroy(transform);\n\t\t}\n\t}\n\t_removeCompoundChild(collision, shape) {\n\t\tif (collision.shape.getNumChildShapes() === 0) {\n\t\t\treturn;\n\t\t}\n\t\tif (collision.shape.removeChildShape) {\n\t\t\tcollision.shape.removeChildShape(shape);\n\t\t} else {\n\t\t\tconst ind = collision.getCompoundChildShapeIndex(shape);\n\t\t\tif (ind !== null) {\n\t\t\t\tcollision.shape.removeChildShapeByIndex(ind);\n\t\t\t}\n\t\t}\n\t}\n\tonTransformChanged(component, position, rotation, scale) {\n\t\tthis.implementations[component.data.type].updateTransform(component, position, rotation, scale);\n\t}\n\tchangeType(component, previousType, newType) {\n\t\tthis.implementations[previousType].beforeRemove(component.entity, component);\n\t\tthis.implementations[previousType].remove(component.entity, component.data);\n\t\tthis._createImplementation(newType).reset(component, component.data);\n\t}\n\trecreatePhysicalShapes(component) {\n\t\tthis.implementations[component.data.type].recreatePhysicalShapes(component);\n\t}\n\t_calculateNodeRelativeTransform(node, relative) {\n\t\tif (node === relative) {\n\t\t\tconst scale = node.getWorldTransform().getScale();\n\t\t\tmat4.setScale(scale.x, scale.y, scale.z);\n\t\t} else {\n\t\t\tthis._calculateNodeRelativeTransform(node.parent, relative);\n\t\t\tmat4.mul(node.getLocalTransform());\n\t\t}\n\t}\n\t_getNodeScaling(node) {\n\t\tconst wtm = node.getWorldTransform();\n\t\tconst scl = wtm.getScale();\n\t\treturn new Ammo.btVector3(scl.x, scl.y, scl.z);\n\t}\n\t_getNodeTransform(node, relative) {\n\t\tlet pos, rot;\n\t\tif (relative) {\n\t\t\tthis._calculateNodeRelativeTransform(node, relative);\n\t\t\tpos = p1;\n\t\t\trot = quat;\n\t\t\tmat4.getTranslation(pos);\n\t\t\trot.setFromMat4(mat4);\n\t\t} else {\n\t\t\tpos = node.getPosition();\n\t\t\trot = node.getRotation();\n\t\t}\n\t\tconst ammoQuat = new Ammo.btQuaternion();\n\t\tconst transform = new Ammo.btTransform();\n\t\ttransform.setIdentity();\n\t\tconst origin = transform.getOrigin();\n\t\tconst component = node.collision;\n\t\tif (component && component._hasOffset) {\n\t\t\tconst lo = component.data.linearOffset;\n\t\t\tconst ao = component.data.angularOffset;\n\t\t\tconst newOrigin = p2;\n\t\t\tquat.copy(rot).transformVector(lo, newOrigin);\n\t\t\tnewOrigin.add(pos);\n\t\t\tquat.copy(rot).mul(ao);\n\t\t\torigin.setValue(newOrigin.x, newOrigin.y, newOrigin.z);\n\t\t\tammoQuat.setValue(quat.x, quat.y, quat.z, quat.w);\n\t\t} else {\n\t\t\torigin.setValue(pos.x, pos.y, pos.z);\n\t\t\tammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);\n\t\t}\n\t\ttransform.setRotation(ammoQuat);\n\t\tAmmo.destroy(ammoQuat);\n\t\treturn transform;\n\t}\n\tdestroy() {\n\t\tfor (const key in this._triMeshCache) {\n\t\t\tAmmo.destroy(this._triMeshCache[key]);\n\t\t}\n\t\tthis._triMeshCache = null;\n\t\tsuper.destroy();\n\t}\n}\n\nexport { CollisionComponentSystem };\n","import { BODYFLAG_NORESPONSE_OBJECT, BODYGROUP_TRIGGER, BODYMASK_NOT_STATIC, BODYSTATE_ACTIVE_TAG, BODYSTATE_DISABLE_SIMULATION } from '../rigid-body/constants.js';\n\nlet _ammoVec1, _ammoQuat, _ammoTransform;\nclass Trigger {\n\tconstructor(app, component, data) {\n\t\tthis.entity = component.entity;\n\t\tthis.component = component;\n\t\tthis.app = app;\n\t\tif (typeof Ammo !== 'undefined' && !_ammoVec1) {\n\t\t\t_ammoVec1 = new Ammo.btVector3();\n\t\t\t_ammoQuat = new Ammo.btQuaternion();\n\t\t\t_ammoTransform = new Ammo.btTransform();\n\t\t}\n\t\tthis.initialize(data);\n\t}\n\tinitialize(data) {\n\t\tconst entity = this.entity;\n\t\tconst shape = data.shape;\n\t\tif (shape && typeof Ammo !== 'undefined') {\n\t\t\tif (entity.trigger) {\n\t\t\t\tentity.trigger.destroy();\n\t\t\t}\n\t\t\tconst mass = 1;\n\t\t\tconst component = this.component;\n\t\t\tif (component) {\n\t\t\t\tconst bodyPos = component.getShapePosition();\n\t\t\t\tconst bodyRot = component.getShapeRotation();\n\t\t\t\t_ammoVec1.setValue(bodyPos.x, bodyPos.y, bodyPos.z);\n\t\t\t\t_ammoQuat.setValue(bodyRot.x, bodyRot.y, bodyRot.z, bodyRot.w);\n\t\t\t} else {\n\t\t\t\tconst pos = entity.getPosition();\n\t\t\t\tconst rot = entity.getRotation();\n\t\t\t\t_ammoVec1.setValue(pos.x, pos.y, pos.z);\n\t\t\t\t_ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);\n\t\t\t}\n\t\t\t_ammoTransform.setOrigin(_ammoVec1);\n\t\t\t_ammoTransform.setRotation(_ammoQuat);\n\t\t\tconst body = this.app.systems.rigidbody.createBody(mass, shape, _ammoTransform);\n\t\t\tbody.setRestitution(0);\n\t\t\tbody.setFriction(0);\n\t\t\tbody.setDamping(0, 0);\n\t\t\t_ammoVec1.setValue(0, 0, 0);\n\t\t\tbody.setLinearFactor(_ammoVec1);\n\t\t\tbody.setAngularFactor(_ammoVec1);\n\t\t\tbody.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_NORESPONSE_OBJECT);\n\t\t\tbody.entity = entity;\n\t\t\tthis.body = body;\n\t\t\tif (this.component.enabled && entity.enabled) {\n\t\t\t\tthis.enable();\n\t\t\t}\n\t\t}\n\t}\n\tdestroy() {\n\t\tconst body = this.body;\n\t\tif (!body) return;\n\t\tthis.disable();\n\t\tthis.app.systems.rigidbody.destroyBody(body);\n\t}\n\t_getEntityTransform(transform) {\n\t\tconst component = this.component;\n\t\tif (component) {\n\t\t\tconst bodyPos = component.getShapePosition();\n\t\t\tconst bodyRot = component.getShapeRotation();\n\t\t\t_ammoVec1.setValue(bodyPos.x, bodyPos.y, bodyPos.z);\n\t\t\t_ammoQuat.setValue(bodyRot.x, bodyRot.y, bodyRot.z, bodyRot.w);\n\t\t} else {\n\t\t\tconst pos = this.entity.getPosition();\n\t\t\tconst rot = this.entity.getRotation();\n\t\t\t_ammoVec1.setValue(pos.x, pos.y, pos.z);\n\t\t\t_ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);\n\t\t}\n\t\ttransform.setOrigin(_ammoVec1);\n\t\ttransform.setRotation(_ammoQuat);\n\t}\n\tupdateTransform() {\n\t\tthis._getEntityTransform(_ammoTransform);\n\t\tconst body = this.body;\n\t\tbody.setWorldTransform(_ammoTransform);\n\t\tbody.activate();\n\t}\n\tenable() {\n\t\tconst body = this.body;\n\t\tif (!body) return;\n\t\tconst systems = this.app.systems;\n\t\tsystems.rigidbody.addBody(body, BODYGROUP_TRIGGER, BODYMASK_NOT_STATIC ^ BODYGROUP_TRIGGER);\n\t\tsystems.rigidbody._triggers.push(this);\n\t\tbody.forceActivationState(BODYSTATE_ACTIVE_TAG);\n\t\tthis.updateTransform();\n\t}\n\tdisable() {\n\t\tconst body = this.body;\n\t\tif (!body) return;\n\t\tconst systems = this.app.systems;\n\t\tconst idx = systems.rigidbody._triggers.indexOf(this);\n\t\tif (idx > -1) {\n\t\t\tsystems.rigidbody._triggers.splice(idx, 1);\n\t\t}\n\t\tsystems.rigidbody.removeBody(body);\n\t\tbody.forceActivationState(BODYSTATE_DISABLE_SIMULATION);\n\t}\n}\n\nexport { Trigger };\n","import { EventHandler } from '../../core/event-handler.js';\n\nclass Component extends EventHandler {\n\tconstructor(system, entity) {\n\t\tsuper();\n\t\tthis.system = void 0;\n\t\tthis.entity = void 0;\n\t\tthis.system = system;\n\t\tthis.entity = entity;\n\t\tif (this.system.schema && !this._accessorsBuilt) {\n\t\t\tthis.buildAccessors(this.system.schema);\n\t\t}\n\t\tthis.on('set', function (name, oldValue, newValue) {\n\t\t\tthis.fire(`set_${name}`, name, oldValue, newValue);\n\t\t});\n\t\tthis.on('set_enabled', this.onSetEnabled, this);\n\t}\n\tstatic _buildAccessors(obj, schema) {\n\t\tschema.forEach(descriptor => {\n\t\t\tconst name = typeof descriptor === 'object' ? descriptor.name : descriptor;\n\t\t\tObject.defineProperty(obj, name, {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this.data[name];\n\t\t\t\t},\n\t\t\t\tset: function (value) {\n\t\t\t\t\tconst data = this.data;\n\t\t\t\t\tconst oldValue = data[name];\n\t\t\t\t\tdata[name] = value;\n\t\t\t\t\tthis.fire('set', name, oldValue, value);\n\t\t\t\t},\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t});\n\t\tobj._accessorsBuilt = true;\n\t}\n\tbuildAccessors(schema) {\n\t\tComponent._buildAccessors(this, schema);\n\t}\n\tonSetEnabled(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (this.entity.enabled) {\n\t\t\t\tif (newValue) {\n\t\t\t\t\tthis.onEnable();\n\t\t\t\t} else {\n\t\t\t\t\tthis.onDisable();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tonEnable() {}\n\tonDisable() {}\n\tonPostStateChange() {}\n\tget data() {\n\t\tconst record = this.system.store[this.entity.getGuid()];\n\t\treturn record ? record.data : null;\n\t}\n\tset enabled(arg) {}\n\tget enabled() {\n\t\treturn true;\n\t}\n}\n\nexport { Component };\n","import { Mat4 } from '../../../core/math/mat4.js';\nimport { Vec2 } from '../../../core/math/vec2.js';\nimport { Vec3 } from '../../../core/math/vec3.js';\nimport { Vec4 } from '../../../core/math/vec4.js';\nimport { FUNC_EQUAL, STENCILOP_INCREMENT, FUNC_ALWAYS, STENCILOP_REPLACE } from '../../../platform/graphics/constants.js';\nimport { LAYERID_UI } from '../../../scene/constants.js';\nimport { BatchGroup } from '../../../scene/batching/batch-group.js';\nimport { StencilParameters } from '../../../platform/graphics/stencil-parameters.js';\nimport { Entity } from '../../entity.js';\nimport { Component } from '../component.js';\nimport { ELEMENTTYPE_GROUP, FITMODE_STRETCH, ELEMENTTYPE_IMAGE, ELEMENTTYPE_TEXT } from './constants.js';\nimport { ImageElement } from './image-element.js';\nimport { TextElement } from './text-element.js';\n\nconst position = new Vec3();\nconst invParentWtm = new Mat4();\nconst vecA = new Vec3();\nconst vecB = new Vec3();\nconst matA = new Mat4();\nconst matB = new Mat4();\nconst matC = new Mat4();\nconst matD = new Mat4();\nclass ElementComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._evtLayersChanged = null;\n\t\tthis._evtLayerAdded = null;\n\t\tthis._evtLayerRemoved = null;\n\t\tthis._beingInitialized = false;\n\t\tthis._anchor = new Vec4();\n\t\tthis._localAnchor = new Vec4();\n\t\tthis._pivot = new Vec2();\n\t\tthis._width = this._calculatedWidth = 32;\n\t\tthis._height = this._calculatedHeight = 32;\n\t\tthis._margin = new Vec4(0, 0, -32, -32);\n\t\tthis._modelTransform = new Mat4();\n\t\tthis._screenToWorld = new Mat4();\n\t\tthis._anchorTransform = new Mat4();\n\t\tthis._anchorDirty = true;\n\t\tthis._parentWorldTransform = new Mat4();\n\t\tthis._screenTransform = new Mat4();\n\t\tthis._screenCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];\n\t\tthis._canvasCorners = [new Vec2(), new Vec2(), new Vec2(), new Vec2()];\n\t\tthis._worldCorners = [new Vec3(), new Vec3(), new Vec3(), new Vec3()];\n\t\tthis._cornersDirty = true;\n\t\tthis._canvasCornersDirty = true;\n\t\tthis._worldCornersDirty = true;\n\t\tthis.entity.on('insert', this._onInsert, this);\n\t\tthis._patch();\n\t\tthis.screen = null;\n\t\tthis._type = ELEMENTTYPE_GROUP;\n\t\tthis._image = null;\n\t\tthis._text = null;\n\t\tthis._group = null;\n\t\tthis._drawOrder = 0;\n\t\tthis._fitMode = FITMODE_STRETCH;\n\t\tthis._useInput = false;\n\t\tthis._layers = [LAYERID_UI];\n\t\tthis._addedModels = [];\n\t\tthis._batchGroupId = -1;\n\t\tthis._offsetReadAt = 0;\n\t\tthis._maskOffset = 0.5;\n\t\tthis._maskedBy = null;\n\t}\n\tget data() {\n\t\tconst record = this.system.store[this.entity.getGuid()];\n\t\treturn record ? record.data : null;\n\t}\n\tset enabled(value) {\n\t\tconst data = this.data;\n\t\tconst oldValue = data.enabled;\n\t\tdata.enabled = value;\n\t\tthis.fire('set', 'enabled', oldValue, value);\n\t}\n\tget enabled() {\n\t\treturn this.data.enabled;\n\t}\n\tget _absLeft() {\n\t\treturn this._localAnchor.x + this._margin.x;\n\t}\n\tget _absRight() {\n\t\treturn this._localAnchor.z - this._margin.z;\n\t}\n\tget _absTop() {\n\t\treturn this._localAnchor.w - this._margin.w;\n\t}\n\tget _absBottom() {\n\t\treturn this._localAnchor.y + this._margin.y;\n\t}\n\tget _hasSplitAnchorsX() {\n\t\treturn Math.abs(this._anchor.x - this._anchor.z) > 0.001;\n\t}\n\tget _hasSplitAnchorsY() {\n\t\treturn Math.abs(this._anchor.y - this._anchor.w) > 0.001;\n\t}\n\tget aabb() {\n\t\tif (this._image) {\n\t\t\treturn this._image.aabb;\n\t\t}\n\t\tif (this._text) {\n\t\t\treturn this._text.aabb;\n\t\t}\n\t\treturn null;\n\t}\n\tset anchor(value) {\n\t\tif (value instanceof Vec4) {\n\t\t\tthis._anchor.copy(value);\n\t\t} else {\n\t\t\tthis._anchor.set(...value);\n\t\t}\n\t\tif (!this.entity._parent && !this.screen) {\n\t\t\tthis._calculateLocalAnchors();\n\t\t} else {\n\t\t\tthis._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);\n\t\t}\n\t\tthis._anchorDirty = true;\n\t\tif (!this.entity._dirtyLocal) {\n\t\t\tthis.entity._dirtifyLocal();\n\t\t}\n\t\tthis.fire('set:anchor', this._anchor);\n\t}\n\tget anchor() {\n\t\treturn this._anchor;\n\t}\n\tset batchGroupId(value) {\n\t\tif (this._batchGroupId === value) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.entity.enabled && this._batchGroupId >= 0) {\n\t\t\tvar _this$system$app$batc;\n\t\t\t(_this$system$app$batc = this.system.app.batcher) == null || _this$system$app$batc.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);\n\t\t}\n\t\tif (this.entity.enabled && value >= 0) {\n\t\t\tvar _this$system$app$batc2;\n\t\t\t(_this$system$app$batc2 = this.system.app.batcher) == null || _this$system$app$batc2.insert(BatchGroup.ELEMENT, value, this.entity);\n\t\t}\n\t\tif (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {\n\t\t\tif (this._image && this._image._renderable.model) {\n\t\t\t\tthis.addModelToLayers(this._image._renderable.model);\n\t\t\t} else if (this._text && this._text._model) {\n\t\t\t\tthis.addModelToLayers(this._text._model);\n\t\t\t}\n\t\t}\n\t\tthis._batchGroupId = value;\n\t}\n\tget batchGroupId() {\n\t\treturn this._batchGroupId;\n\t}\n\tset bottom(value) {\n\t\tthis._margin.y = value;\n\t\tconst p = this.entity.getLocalPosition();\n\t\tconst wt = this._absTop;\n\t\tconst wb = this._localAnchor.y + value;\n\t\tthis._setHeight(wt - wb);\n\t\tp.y = value + this._calculatedHeight * this._pivot.y;\n\t\tthis.entity.setLocalPosition(p);\n\t}\n\tget bottom() {\n\t\treturn this._margin.y;\n\t}\n\tset calculatedWidth(value) {\n\t\tthis._setCalculatedWidth(value, true);\n\t}\n\tget calculatedWidth() {\n\t\treturn this._calculatedWidth;\n\t}\n\tset calculatedHeight(value) {\n\t\tthis._setCalculatedHeight(value, true);\n\t}\n\tget calculatedHeight() {\n\t\treturn this._calculatedHeight;\n\t}\n\tget canvasCorners() {\n\t\tif (!this._canvasCornersDirty || !this.screen || !this.screen.screen.screenSpace) {\n\t\t\treturn this._canvasCorners;\n\t\t}\n\t\tconst device = this.system.app.graphicsDevice;\n\t\tconst screenCorners = this.screenCorners;\n\t\tconst sx = device.canvas.clientWidth / device.width;\n\t\tconst sy = device.canvas.clientHeight / device.height;\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tthis._canvasCorners[i].set(screenCorners[i].x * sx, (device.height - screenCorners[i].y) * sy);\n\t\t}\n\t\tthis._canvasCornersDirty = false;\n\t\treturn this._canvasCorners;\n\t}\n\tset drawOrder(value) {\n\t\tlet priority = 0;\n\t\tif (this.screen) {\n\t\t\tpriority = this.screen.screen.priority;\n\t\t}\n\t\tif (value > 0xFFFFFF) {\n\t\t\tvalue = 0xFFFFFF;\n\t\t}\n\t\tthis._drawOrder = (priority << 24) + value;\n\t\tthis.fire('set:draworder', this._drawOrder);\n\t}\n\tget drawOrder() {\n\t\treturn this._drawOrder;\n\t}\n\tset height(value) {\n\t\tthis._height = value;\n\t\tif (!this._hasSplitAnchorsY) {\n\t\t\tthis._setCalculatedHeight(value, true);\n\t\t}\n\t\tthis.fire('set:height', this._height);\n\t}\n\tget height() {\n\t\treturn this._height;\n\t}\n\tset layers(value) {\n\t\tif (this._addedModels.length) {\n\t\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this._layers[i]);\n\t\t\t\tif (layer) {\n\t\t\t\t\tfor (let j = 0; j < this._addedModels.length; j++) {\n\t\t\t\t\t\tlayer.removeMeshInstances(this._addedModels[j].meshInstances);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._layers = value;\n\t\tif (!this.enabled || !this.entity.enabled || !this._addedModels.length) {\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this._layers[i]);\n\t\t\tif (layer) {\n\t\t\t\tfor (let j = 0; j < this._addedModels.length; j++) {\n\t\t\t\t\tlayer.addMeshInstances(this._addedModels[j].meshInstances);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\tset left(value) {\n\t\tthis._margin.x = value;\n\t\tconst p = this.entity.getLocalPosition();\n\t\tconst wr = this._absRight;\n\t\tconst wl = this._localAnchor.x + value;\n\t\tthis._setWidth(wr - wl);\n\t\tp.x = value + this._calculatedWidth * this._pivot.x;\n\t\tthis.entity.setLocalPosition(p);\n\t}\n\tget left() {\n\t\treturn this._margin.x;\n\t}\n\tset margin(value) {\n\t\tthis._margin.copy(value);\n\t\tthis._calculateSize(true, true);\n\t\tthis.fire('set:margin', this._margin);\n\t}\n\tget margin() {\n\t\treturn this._margin;\n\t}\n\tget maskedBy() {\n\t\treturn this._maskedBy;\n\t}\n\tset pivot(value) {\n\t\tconst {\n\t\t\tpivot,\n\t\t\tmargin\n\t\t} = this;\n\t\tconst prevX = pivot.x;\n\t\tconst prevY = pivot.y;\n\t\tif (value instanceof Vec2) {\n\t\t\tpivot.copy(value);\n\t\t} else {\n\t\t\tpivot.set(...value);\n\t\t}\n\t\tconst mx = margin.x + margin.z;\n\t\tconst dx = pivot.x - prevX;\n\t\tmargin.x += mx * dx;\n\t\tmargin.z -= mx * dx;\n\t\tconst my = margin.y + margin.w;\n\t\tconst dy = pivot.y - prevY;\n\t\tmargin.y += my * dy;\n\t\tmargin.w -= my * dy;\n\t\tthis._anchorDirty = true;\n\t\tthis._cornersDirty = true;\n\t\tthis._worldCornersDirty = true;\n\t\tthis._calculateSize(false, false);\n\t\tthis._flagChildrenAsDirty();\n\t\tthis.fire('set:pivot', pivot);\n\t}\n\tget pivot() {\n\t\treturn this._pivot;\n\t}\n\tset right(value) {\n\t\tthis._margin.z = value;\n\t\tconst p = this.entity.getLocalPosition();\n\t\tconst wl = this._absLeft;\n\t\tconst wr = this._localAnchor.z - value;\n\t\tthis._setWidth(wr - wl);\n\t\tp.x = this._localAnchor.z - this._localAnchor.x - value - this._calculatedWidth * (1 - this._pivot.x);\n\t\tthis.entity.setLocalPosition(p);\n\t}\n\tget right() {\n\t\treturn this._margin.z;\n\t}\n\tget screenCorners() {\n\t\tif (!this._cornersDirty || !this.screen) {\n\t\t\treturn this._screenCorners;\n\t\t}\n\t\tconst parentBottomLeft = this.entity.parent && this.entity.parent.element && this.entity.parent.element.screenCorners[0];\n\t\tthis._screenCorners[0].set(this._absLeft, this._absBottom, 0);\n\t\tthis._screenCorners[1].set(this._absRight, this._absBottom, 0);\n\t\tthis._screenCorners[2].set(this._absRight, this._absTop, 0);\n\t\tthis._screenCorners[3].set(this._absLeft, this._absTop, 0);\n\t\tconst screenSpace = this.screen.screen.screenSpace;\n\t\tfor (let i = 0; i < 4; i++) {\n\t\t\tthis._screenTransform.transformPoint(this._screenCorners[i], this._screenCorners[i]);\n\t\t\tif (screenSpace) {\n\t\t\t\tthis._screenCorners[i].mulScalar(this.screen.screen.scale);\n\t\t\t}\n\t\t\tif (parentBottomLeft) {\n\t\t\t\tthis._screenCorners[i].add(parentBottomLeft);\n\t\t\t}\n\t\t}\n\t\tthis._cornersDirty = false;\n\t\tthis._canvasCornersDirty = true;\n\t\tthis._worldCornersDirty = true;\n\t\treturn this._screenCorners;\n\t}\n\tget textWidth() {\n\t\treturn this._text ? this._text.width : 0;\n\t}\n\tget textHeight() {\n\t\treturn this._text ? this._text.height : 0;\n\t}\n\tset top(value) {\n\t\tthis._margin.w = value;\n\t\tconst p = this.entity.getLocalPosition();\n\t\tconst wb = this._absBottom;\n\t\tconst wt = this._localAnchor.w - value;\n\t\tthis._setHeight(wt - wb);\n\t\tp.y = this._localAnchor.w - this._localAnchor.y - value - this._calculatedHeight * (1 - this._pivot.y);\n\t\tthis.entity.setLocalPosition(p);\n\t}\n\tget top() {\n\t\treturn this._margin.w;\n\t}\n\tset type(value) {\n\t\tif (value !== this._type) {\n\t\t\tthis._type = value;\n\t\t\tif (this._image) {\n\t\t\t\tthis._image.destroy();\n\t\t\t\tthis._image = null;\n\t\t\t}\n\t\t\tif (this._text) {\n\t\t\t\tthis._text.destroy();\n\t\t\t\tthis._text = null;\n\t\t\t}\n\t\t\tif (value === ELEMENTTYPE_IMAGE) {\n\t\t\t\tthis._image = new ImageElement(this);\n\t\t\t} else if (value === ELEMENTTYPE_TEXT) {\n\t\t\t\tthis._text = new TextElement(this);\n\t\t\t}\n\t\t}\n\t}\n\tget type() {\n\t\treturn this._type;\n\t}\n\tset useInput(value) {\n\t\tif (this._useInput === value) {\n\t\t\treturn;\n\t\t}\n\t\tthis._useInput = value;\n\t\tif (this.system.app.elementInput) {\n\t\t\tif (value) {\n\t\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\t\tthis.system.app.elementInput.addElement(this);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.system.app.elementInput.removeElement(this);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this._useInput === true) ;\n\t\t}\n\t\tthis.fire('set:useInput', value);\n\t}\n\tget useInput() {\n\t\treturn this._useInput;\n\t}\n\tset fitMode(value) {\n\t\tthis._fitMode = value;\n\t\tthis._calculateSize(true, true);\n\t\tif (this._image) {\n\t\t\tthis._image.refreshMesh();\n\t\t}\n\t}\n\tget fitMode() {\n\t\treturn this._fitMode;\n\t}\n\tset width(value) {\n\t\tthis._width = value;\n\t\tif (!this._hasSplitAnchorsX) {\n\t\t\tthis._setCalculatedWidth(value, true);\n\t\t}\n\t\tthis.fire('set:width', this._width);\n\t}\n\tget width() {\n\t\treturn this._width;\n\t}\n\tget worldCorners() {\n\t\tif (!this._worldCornersDirty) {\n\t\t\treturn this._worldCorners;\n\t\t}\n\t\tif (this.screen) {\n\t\t\tconst screenCorners = this.screenCorners;\n\t\t\tif (!this.screen.screen.screenSpace) {\n\t\t\t\tmatA.copy(this.screen.screen._screenMatrix);\n\t\t\t\tmatA.data[13] = -matA.data[13];\n\t\t\t\tmatA.mul2(this.screen.getWorldTransform(), matA);\n\t\t\t\tfor (let i = 0; i < 4; i++) {\n\t\t\t\t\tmatA.transformPoint(screenCorners[i], this._worldCorners[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst localPos = this.entity.getLocalPosition();\n\t\t\tmatA.setTranslate(-localPos.x, -localPos.y, -localPos.z);\n\t\t\tmatB.setTRS(Vec3.ZERO, this.entity.getLocalRotation(), this.entity.getLocalScale());\n\t\t\tmatC.setTranslate(localPos.x, localPos.y, localPos.z);\n\t\t\tconst entity = this.entity.parent ? this.entity.parent : this.entity;\n\t\t\tmatD.copy(entity.getWorldTransform());\n\t\t\tmatD.mul(matC).mul(matB).mul(matA);\n\t\t\tvecA.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);\n\t\t\tmatD.transformPoint(vecA, this._worldCorners[0]);\n\t\t\tvecA.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y - this.pivot.y * this.calculatedHeight, localPos.z);\n\t\t\tmatD.transformPoint(vecA, this._worldCorners[1]);\n\t\t\tvecA.set(localPos.x + (1 - this.pivot.x) * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);\n\t\t\tmatD.transformPoint(vecA, this._worldCorners[2]);\n\t\t\tvecA.set(localPos.x - this.pivot.x * this.calculatedWidth, localPos.y + (1 - this.pivot.y) * this.calculatedHeight, localPos.z);\n\t\t\tmatD.transformPoint(vecA, this._worldCorners[3]);\n\t\t}\n\t\tthis._worldCornersDirty = false;\n\t\treturn this._worldCorners;\n\t}\n\tset fontSize(arg) {\n\t\tthis._setValue('fontSize', arg);\n\t}\n\tget fontSize() {\n\t\tif (this._text) {\n\t\t\treturn this._text.fontSize;\n\t\t}\n\t\treturn null;\n\t}\n\tset minFontSize(arg) {\n\t\tthis._setValue('minFontSize', arg);\n\t}\n\tget minFontSize() {\n\t\tif (this._text) {\n\t\t\treturn this._text.minFontSize;\n\t\t}\n\t\treturn null;\n\t}\n\tset maxFontSize(arg) {\n\t\tthis._setValue('maxFontSize', arg);\n\t}\n\tget maxFontSize() {\n\t\tif (this._text) {\n\t\t\treturn this._text.maxFontSize;\n\t\t}\n\t\treturn null;\n\t}\n\tset maxLines(arg) {\n\t\tthis._setValue('maxLines', arg);\n\t}\n\tget maxLines() {\n\t\tif (this._text) {\n\t\t\treturn this._text.maxLines;\n\t\t}\n\t\treturn null;\n\t}\n\tset autoFitWidth(arg) {\n\t\tthis._setValue('autoFitWidth', arg);\n\t}\n\tget autoFitWidth() {\n\t\tif (this._text) {\n\t\t\treturn this._text.autoFitWidth;\n\t\t}\n\t\treturn null;\n\t}\n\tset autoFitHeight(arg) {\n\t\tthis._setValue('autoFitHeight', arg);\n\t}\n\tget autoFitHeight() {\n\t\tif (this._text) {\n\t\t\treturn this._text.autoFitHeight;\n\t\t}\n\t\treturn null;\n\t}\n\tset color(arg) {\n\t\tthis._setValue('color', arg);\n\t}\n\tget color() {\n\t\tif (this._text) {\n\t\t\treturn this._text.color;\n\t\t}\n\t\tif (this._image) {\n\t\t\treturn this._image.color;\n\t\t}\n\t\treturn null;\n\t}\n\tset font(arg) {\n\t\tthis._setValue('font', arg);\n\t}\n\tget font() {\n\t\tif (this._text) {\n\t\t\treturn this._text.font;\n\t\t}\n\t\treturn null;\n\t}\n\tset fontAsset(arg) {\n\t\tthis._setValue('fontAsset', arg);\n\t}\n\tget fontAsset() {\n\t\tif (this._text && typeof this._text.fontAsset === 'number') {\n\t\t\treturn this._text.fontAsset;\n\t\t}\n\t\treturn null;\n\t}\n\tset spacing(arg) {\n\t\tthis._setValue('spacing', arg);\n\t}\n\tget spacing() {\n\t\tif (this._text) {\n\t\t\treturn this._text.spacing;\n\t\t}\n\t\treturn null;\n\t}\n\tset lineHeight(arg) {\n\t\tthis._setValue('lineHeight', arg);\n\t}\n\tget lineHeight() {\n\t\tif (this._text) {\n\t\t\treturn this._text.lineHeight;\n\t\t}\n\t\treturn null;\n\t}\n\tset wrapLines(arg) {\n\t\tthis._setValue('wrapLines', arg);\n\t}\n\tget wrapLines() {\n\t\tif (this._text) {\n\t\t\treturn this._text.wrapLines;\n\t\t}\n\t\treturn null;\n\t}\n\tset lines(arg) {\n\t\tthis._setValue('lines', arg);\n\t}\n\tget lines() {\n\t\tif (this._text) {\n\t\t\treturn this._text.lines;\n\t\t}\n\t\treturn null;\n\t}\n\tset alignment(arg) {\n\t\tthis._setValue('alignment', arg);\n\t}\n\tget alignment() {\n\t\tif (this._text) {\n\t\t\treturn this._text.alignment;\n\t\t}\n\t\treturn null;\n\t}\n\tset autoWidth(arg) {\n\t\tthis._setValue('autoWidth', arg);\n\t}\n\tget autoWidth() {\n\t\tif (this._text) {\n\t\t\treturn this._text.autoWidth;\n\t\t}\n\t\treturn null;\n\t}\n\tset autoHeight(arg) {\n\t\tthis._setValue('autoHeight', arg);\n\t}\n\tget autoHeight() {\n\t\tif (this._text) {\n\t\t\treturn this._text.autoHeight;\n\t\t}\n\t\treturn null;\n\t}\n\tset rtlReorder(arg) {\n\t\tthis._setValue('rtlReorder', arg);\n\t}\n\tget rtlReorder() {\n\t\tif (this._text) {\n\t\t\treturn this._text.rtlReorder;\n\t\t}\n\t\treturn null;\n\t}\n\tset unicodeConverter(arg) {\n\t\tthis._setValue('unicodeConverter', arg);\n\t}\n\tget unicodeConverter() {\n\t\tif (this._text) {\n\t\t\treturn this._text.unicodeConverter;\n\t\t}\n\t\treturn null;\n\t}\n\tset text(arg) {\n\t\tthis._setValue('text', arg);\n\t}\n\tget text() {\n\t\tif (this._text) {\n\t\t\treturn this._text.text;\n\t\t}\n\t\treturn null;\n\t}\n\tset key(arg) {\n\t\tthis._setValue('key', arg);\n\t}\n\tget key() {\n\t\tif (this._text) {\n\t\t\treturn this._text.key;\n\t\t}\n\t\treturn null;\n\t}\n\tset texture(arg) {\n\t\tthis._setValue('texture', arg);\n\t}\n\tget texture() {\n\t\tif (this._image) {\n\t\t\treturn this._image.texture;\n\t\t}\n\t\treturn null;\n\t}\n\tset textureAsset(arg) {\n\t\tthis._setValue('textureAsset', arg);\n\t}\n\tget textureAsset() {\n\t\tif (this._image) {\n\t\t\treturn this._image.textureAsset;\n\t\t}\n\t\treturn null;\n\t}\n\tset material(arg) {\n\t\tthis._setValue('material', arg);\n\t}\n\tget material() {\n\t\tif (this._image) {\n\t\t\treturn this._image.material;\n\t\t}\n\t\treturn null;\n\t}\n\tset materialAsset(arg) {\n\t\tthis._setValue('materialAsset', arg);\n\t}\n\tget materialAsset() {\n\t\tif (this._image) {\n\t\t\treturn this._image.materialAsset;\n\t\t}\n\t\treturn null;\n\t}\n\tset sprite(arg) {\n\t\tthis._setValue('sprite', arg);\n\t}\n\tget sprite() {\n\t\tif (this._image) {\n\t\t\treturn this._image.sprite;\n\t\t}\n\t\treturn null;\n\t}\n\tset spriteAsset(arg) {\n\t\tthis._setValue('spriteAsset', arg);\n\t}\n\tget spriteAsset() {\n\t\tif (this._image) {\n\t\t\treturn this._image.spriteAsset;\n\t\t}\n\t\treturn null;\n\t}\n\tset spriteFrame(arg) {\n\t\tthis._setValue('spriteFrame', arg);\n\t}\n\tget spriteFrame() {\n\t\tif (this._image) {\n\t\t\treturn this._image.spriteFrame;\n\t\t}\n\t\treturn null;\n\t}\n\tset pixelsPerUnit(arg) {\n\t\tthis._setValue('pixelsPerUnit', arg);\n\t}\n\tget pixelsPerUnit() {\n\t\tif (this._image) {\n\t\t\treturn this._image.pixelsPerUnit;\n\t\t}\n\t\treturn null;\n\t}\n\tset opacity(arg) {\n\t\tthis._setValue('opacity', arg);\n\t}\n\tget opacity() {\n\t\tif (this._text) {\n\t\t\treturn this._text.opacity;\n\t\t}\n\t\tif (this._image) {\n\t\t\treturn this._image.opacity;\n\t\t}\n\t\treturn null;\n\t}\n\tset rect(arg) {\n\t\tthis._setValue('rect', arg);\n\t}\n\tget rect() {\n\t\tif (this._image) {\n\t\t\treturn this._image.rect;\n\t\t}\n\t\treturn null;\n\t}\n\tset mask(arg) {\n\t\tthis._setValue('mask', arg);\n\t}\n\tget mask() {\n\t\tif (this._image) {\n\t\t\treturn this._image.mask;\n\t\t}\n\t\treturn null;\n\t}\n\tset outlineColor(arg) {\n\t\tthis._setValue('outlineColor', arg);\n\t}\n\tget outlineColor() {\n\t\tif (this._text) {\n\t\t\treturn this._text.outlineColor;\n\t\t}\n\t\treturn null;\n\t}\n\tset outlineThickness(arg) {\n\t\tthis._setValue('outlineThickness', arg);\n\t}\n\tget outlineThickness() {\n\t\tif (this._text) {\n\t\t\treturn this._text.outlineThickness;\n\t\t}\n\t\treturn null;\n\t}\n\tset shadowColor(arg) {\n\t\tthis._setValue('shadowColor', arg);\n\t}\n\tget shadowColor() {\n\t\tif (this._text) {\n\t\t\treturn this._text.shadowColor;\n\t\t}\n\t\treturn null;\n\t}\n\tset shadowOffset(arg) {\n\t\tthis._setValue('shadowOffset', arg);\n\t}\n\tget shadowOffset() {\n\t\tif (this._text) {\n\t\t\treturn this._text.shadowOffset;\n\t\t}\n\t\treturn null;\n\t}\n\tset enableMarkup(arg) {\n\t\tthis._setValue('enableMarkup', arg);\n\t}\n\tget enableMarkup() {\n\t\tif (this._text) {\n\t\t\treturn this._text.enableMarkup;\n\t\t}\n\t\treturn null;\n\t}\n\tset rangeStart(arg) {\n\t\tthis._setValue('rangeStart', arg);\n\t}\n\tget rangeStart() {\n\t\tif (this._text) {\n\t\t\treturn this._text.rangeStart;\n\t\t}\n\t\treturn null;\n\t}\n\tset rangeEnd(arg) {\n\t\tthis._setValue('rangeEnd', arg);\n\t}\n\tget rangeEnd() {\n\t\tif (this._text) {\n\t\t\treturn this._text.rangeEnd;\n\t\t}\n\t\treturn null;\n\t}\n\t_setValue(name, value) {\n\t\tif (this._text) {\n\t\t\tif (this._text[name] !== value) {\n\t\t\t\tthis._dirtyBatch();\n\t\t\t}\n\t\t\tthis._text[name] = value;\n\t\t} else if (this._image) {\n\t\t\tif (this._image[name] !== value) {\n\t\t\t\tthis._dirtyBatch();\n\t\t\t}\n\t\t\tthis._image[name] = value;\n\t\t}\n\t}\n\t_patch() {\n\t\tthis.entity._sync = this._sync;\n\t\tthis.entity.setPosition = this._setPosition;\n\t\tthis.entity.setLocalPosition = this._setLocalPosition;\n\t}\n\t_unpatch() {\n\t\tthis.entity._sync = Entity.prototype._sync;\n\t\tthis.entity.setPosition = Entity.prototype.setPosition;\n\t\tthis.entity.setLocalPosition = Entity.prototype.setLocalPosition;\n\t}\n\t_setPosition(x, y, z) {\n\t\tif (!this.element.screen) {\n\t\t\tEntity.prototype.setPosition.call(this, x, y, z);\n\t\t\treturn;\n\t\t}\n\t\tif (x instanceof Vec3) {\n\t\t\tposition.copy(x);\n\t\t} else {\n\t\t\tposition.set(x, y, z);\n\t\t}\n\t\tthis.getWorldTransform();\n\t\tinvParentWtm.copy(this.element._screenToWorld).invert();\n\t\tinvParentWtm.transformPoint(position, this.localPosition);\n\t\tif (!this._dirtyLocal) {\n\t\t\tthis._dirtifyLocal();\n\t\t}\n\t}\n\t_setLocalPosition(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\tthis.localPosition.copy(x);\n\t\t} else {\n\t\t\tthis.localPosition.set(x, y, z);\n\t\t}\n\t\tconst element = this.element;\n\t\tconst p = this.localPosition;\n\t\tconst pvt = element._pivot;\n\t\telement._margin.x = p.x - element._calculatedWidth * pvt.x;\n\t\telement._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;\n\t\telement._margin.y = p.y - element._calculatedHeight * pvt.y;\n\t\telement._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;\n\t\tif (!this._dirtyLocal) {\n\t\t\tthis._dirtifyLocal();\n\t\t}\n\t}\n\t_sync() {\n\t\tconst element = this.element;\n\t\tconst screen = element.screen;\n\t\tif (screen) {\n\t\t\tif (element._anchorDirty) {\n\t\t\t\tlet resx = 0;\n\t\t\t\tlet resy = 0;\n\t\t\t\tlet px = 0;\n\t\t\t\tlet py = 1;\n\t\t\t\tif (this._parent && this._parent.element) {\n\t\t\t\t\tresx = this._parent.element.calculatedWidth;\n\t\t\t\t\tresy = this._parent.element.calculatedHeight;\n\t\t\t\t\tpx = this._parent.element.pivot.x;\n\t\t\t\t\tpy = this._parent.element.pivot.y;\n\t\t\t\t} else {\n\t\t\t\t\tconst resolution = screen.screen.resolution;\n\t\t\t\t\tresx = resolution.x / screen.screen.scale;\n\t\t\t\t\tresy = resolution.y / screen.screen.scale;\n\t\t\t\t}\n\t\t\t\telement._anchorTransform.setTranslate(resx * (element.anchor.x - px), -(resy * (py - element.anchor.y)), 0);\n\t\t\t\telement._anchorDirty = false;\n\t\t\t\telement._calculateLocalAnchors();\n\t\t\t}\n\t\t\tif (element._sizeDirty) {\n\t\t\t\telement._calculateSize(false, false);\n\t\t\t}\n\t\t}\n\t\tif (this._dirtyLocal) {\n\t\t\tthis.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);\n\t\t\tconst p = this.localPosition;\n\t\t\tconst pvt = element._pivot;\n\t\t\telement._margin.x = p.x - element._calculatedWidth * pvt.x;\n\t\t\telement._margin.z = element._localAnchor.z - element._localAnchor.x - element._calculatedWidth - element._margin.x;\n\t\t\telement._margin.y = p.y - element._calculatedHeight * pvt.y;\n\t\t\telement._margin.w = element._localAnchor.w - element._localAnchor.y - element._calculatedHeight - element._margin.y;\n\t\t\tthis._dirtyLocal = false;\n\t\t}\n\t\tif (!screen) {\n\t\t\tif (this._dirtyWorld) {\n\t\t\t\telement._cornersDirty = true;\n\t\t\t\telement._canvasCornersDirty = true;\n\t\t\t\telement._worldCornersDirty = true;\n\t\t\t}\n\t\t\tEntity.prototype._sync.call(this);\n\t\t\treturn;\n\t\t}\n\t\tif (this._dirtyWorld) {\n\t\t\tif (this._parent === null) {\n\t\t\t\tthis.worldTransform.copy(this.localTransform);\n\t\t\t} else {\n\t\t\t\tif (this._parent.element) {\n\t\t\t\t\telement._screenToWorld.mul2(this._parent.element._modelTransform, element._anchorTransform);\n\t\t\t\t} else {\n\t\t\t\t\telement._screenToWorld.copy(element._anchorTransform);\n\t\t\t\t}\n\t\t\t\telement._modelTransform.mul2(element._screenToWorld, this.localTransform);\n\t\t\t\tif (screen) {\n\t\t\t\t\telement._screenToWorld.mul2(screen.screen._screenMatrix, element._screenToWorld);\n\t\t\t\t\tif (!screen.screen.screenSpace) {\n\t\t\t\t\t\telement._screenToWorld.mul2(screen.worldTransform, element._screenToWorld);\n\t\t\t\t\t}\n\t\t\t\t\tthis.worldTransform.mul2(element._screenToWorld, this.localTransform);\n\t\t\t\t\tconst parentWorldTransform = element._parentWorldTransform;\n\t\t\t\t\tparentWorldTransform.setIdentity();\n\t\t\t\t\tconst parent = this._parent;\n\t\t\t\t\tif (parent && parent.element && parent !== screen) {\n\t\t\t\t\t\tmatA.setTRS(Vec3.ZERO, parent.getLocalRotation(), parent.getLocalScale());\n\t\t\t\t\t\tparentWorldTransform.mul2(parent.element._parentWorldTransform, matA);\n\t\t\t\t\t}\n\t\t\t\t\tconst depthOffset = vecA;\n\t\t\t\t\tdepthOffset.set(0, 0, this.localPosition.z);\n\t\t\t\t\tconst pivotOffset = vecB;\n\t\t\t\t\tpivotOffset.set(element._absLeft + element._pivot.x * element.calculatedWidth, element._absBottom + element._pivot.y * element.calculatedHeight, 0);\n\t\t\t\t\tmatA.setTranslate(-pivotOffset.x, -pivotOffset.y, -pivotOffset.z);\n\t\t\t\t\tmatB.setTRS(depthOffset, this.getLocalRotation(), this.getLocalScale());\n\t\t\t\t\tmatC.setTranslate(pivotOffset.x, pivotOffset.y, pivotOffset.z);\n\t\t\t\t\telement._screenTransform.mul2(element._parentWorldTransform, matC).mul(matB).mul(matA);\n\t\t\t\t\telement._cornersDirty = true;\n\t\t\t\t\telement._canvasCornersDirty = true;\n\t\t\t\t\telement._worldCornersDirty = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis.worldTransform.copy(element._modelTransform);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._dirtyWorld = false;\n\t\t}\n\t}\n\t_onInsert(parent) {\n\t\tconst result = this._parseUpToScreen();\n\t\tthis.entity._dirtifyWorld();\n\t\tthis._updateScreen(result.screen);\n\t\tthis._dirtifyMask();\n\t}\n\t_dirtifyMask() {\n\t\tlet current = this.entity;\n\t\twhile (current) {\n\t\t\tconst next = current.parent;\n\t\t\tif ((next === null || next.screen) && current.element) {\n\t\t\t\tif (!this.system._prerender || !this.system._prerender.length) {\n\t\t\t\t\tthis.system._prerender = [];\n\t\t\t\t\tthis.system.app.once('prerender', this._onPrerender, this);\n\t\t\t\t}\n\t\t\t\tconst i = this.system._prerender.indexOf(this.entity);\n\t\t\t\tif (i >= 0) {\n\t\t\t\t\tthis.system._prerender.splice(i, 1);\n\t\t\t\t}\n\t\t\t\tconst j = this.system._prerender.indexOf(current);\n\t\t\t\tif (j < 0) {\n\t\t\t\t\tthis.system._prerender.push(current);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrent = next;\n\t\t}\n\t}\n\t_onPrerender() {\n\t\tfor (let i = 0; i < this.system._prerender.length; i++) {\n\t\t\tconst mask = this.system._prerender[i];\n\t\t\tif (mask.element) {\n\t\t\t\tconst depth = 1;\n\t\t\t\tmask.element.syncMask(depth);\n\t\t\t}\n\t\t}\n\t\tthis.system._prerender.length = 0;\n\t}\n\t_bindScreen(screen) {\n\t\tscreen._bindElement(this);\n\t}\n\t_unbindScreen(screen) {\n\t\tscreen._unbindElement(this);\n\t}\n\t_updateScreen(screen) {\n\t\tif (this.screen && this.screen !== screen) {\n\t\t\tthis._unbindScreen(this.screen.screen);\n\t\t}\n\t\tconst previousScreen = this.screen;\n\t\tthis.screen = screen;\n\t\tif (this.screen) {\n\t\t\tthis._bindScreen(this.screen.screen);\n\t\t}\n\t\tthis._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);\n\t\tthis.fire('set:screen', this.screen, previousScreen);\n\t\tthis._anchorDirty = true;\n\t\tconst children = this.entity.children;\n\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\tif (children[i].element) {\n\t\t\t\tchildren[i].element._updateScreen(screen);\n\t\t\t}\n\t\t}\n\t\tif (this.screen) {\n\t\t\tthis.screen.screen.syncDrawOrder();\n\t\t}\n\t}\n\tsyncMask(depth) {\n\t\tconst result = this._parseUpToScreen();\n\t\tthis._updateMask(result.mask, depth);\n\t}\n\t_setMaskedBy(mask) {\n\t\tconst renderableElement = this._image || this._text;\n\t\tif (mask) {\n\t\t\tconst ref = mask.element._image._maskRef;\n\t\t\trenderableElement == null || renderableElement._setStencil(new StencilParameters({\n\t\t\t\tref: ref,\n\t\t\t\tfunc: FUNC_EQUAL\n\t\t\t}));\n\t\t\tthis._maskedBy = mask;\n\t\t} else {\n\t\t\trenderableElement == null || renderableElement._setStencil(null);\n\t\t\tthis._maskedBy = null;\n\t\t}\n\t}\n\t_updateMask(currentMask, depth) {\n\t\tif (currentMask) {\n\t\t\tthis._setMaskedBy(currentMask);\n\t\t\tif (this.mask) {\n\t\t\t\tconst ref = currentMask.element._image._maskRef;\n\t\t\t\tconst sp = new StencilParameters({\n\t\t\t\t\tref: ref,\n\t\t\t\t\tfunc: FUNC_EQUAL,\n\t\t\t\t\tzpass: STENCILOP_INCREMENT\n\t\t\t\t});\n\t\t\t\tthis._image._setStencil(sp);\n\t\t\t\tthis._image._maskRef = depth;\n\t\t\t\tdepth++;\n\t\t\t\tcurrentMask = this.entity;\n\t\t\t}\n\t\t\tconst children = this.entity.children;\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tvar _children$i$element;\n\t\t\t\t(_children$i$element = children[i].element) == null || _children$i$element._updateMask(currentMask, depth);\n\t\t\t}\n\t\t\tif (this.mask) depth--;\n\t\t} else {\n\t\t\tthis._setMaskedBy(null);\n\t\t\tif (this.mask) {\n\t\t\t\tconst sp = new StencilParameters({\n\t\t\t\t\tref: depth,\n\t\t\t\t\tfunc: FUNC_ALWAYS,\n\t\t\t\t\tzpass: STENCILOP_REPLACE\n\t\t\t\t});\n\t\t\t\tthis._image._setStencil(sp);\n\t\t\t\tthis._image._maskRef = depth;\n\t\t\t\tdepth++;\n\t\t\t\tcurrentMask = this.entity;\n\t\t\t}\n\t\t\tconst children = this.entity.children;\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\tvar _children$i$element2;\n\t\t\t\t(_children$i$element2 = children[i].element) == null || _children$i$element2._updateMask(currentMask, depth);\n\t\t\t}\n\t\t\tif (this.mask) {\n\t\t\t\tdepth--;\n\t\t\t}\n\t\t}\n\t}\n\t_parseUpToScreen() {\n\t\tconst result = {\n\t\t\tscreen: null,\n\t\t\tmask: null\n\t\t};\n\t\tlet parent = this.entity._parent;\n\t\twhile (parent && !parent.screen) {\n\t\t\tif (parent.element && parent.element.mask) {\n\t\t\t\tif (!result.mask) result.mask = parent;\n\t\t\t}\n\t\t\tparent = parent.parent;\n\t\t}\n\t\tif (parent && parent.screen) {\n\t\t\tresult.screen = parent;\n\t\t}\n\t\treturn result;\n\t}\n\t_onScreenResize(res) {\n\t\tthis._anchorDirty = true;\n\t\tthis._cornersDirty = true;\n\t\tthis._worldCornersDirty = true;\n\t\tthis._calculateSize(this._hasSplitAnchorsX, this._hasSplitAnchorsY);\n\t\tthis.fire('screen:set:resolution', res);\n\t}\n\t_onScreenSpaceChange() {\n\t\tthis.fire('screen:set:screenspace', this.screen.screen.screenSpace);\n\t}\n\t_onScreenRemove() {\n\t\tif (this.screen) {\n\t\t\tif (this.screen._destroying) {\n\t\t\t\tthis.screen = null;\n\t\t\t} else {\n\t\t\t\tthis._updateScreen(null);\n\t\t\t}\n\t\t}\n\t}\n\t_calculateLocalAnchors() {\n\t\tlet resx = 1000;\n\t\tlet resy = 1000;\n\t\tconst parent = this.entity._parent;\n\t\tif (parent && parent.element) {\n\t\t\tresx = parent.element.calculatedWidth;\n\t\t\tresy = parent.element.calculatedHeight;\n\t\t} else if (this.screen) {\n\t\t\tconst res = this.screen.screen.resolution;\n\t\t\tconst scale = this.screen.screen.scale;\n\t\t\tresx = res.x / scale;\n\t\t\tresy = res.y / scale;\n\t\t}\n\t\tthis._localAnchor.set(this._anchor.x * resx, this._anchor.y * resy, this._anchor.z * resx, this._anchor.w * resy);\n\t}\n\tgetOffsetPosition(x, y) {\n\t\tconst p = this.entity.getLocalPosition().clone();\n\t\tp.x += x;\n\t\tp.y += y;\n\t\tthis._screenToWorld.transformPoint(p, p);\n\t\treturn p;\n\t}\n\tonLayersChanged(oldComp, newComp) {\n\t\tthis.addModelToLayers(this._image ? this._image._renderable.model : this._text._model);\n\t\toldComp.off('add', this.onLayerAdded, this);\n\t\toldComp.off('remove', this.onLayerRemoved, this);\n\t\tnewComp.on('add', this.onLayerAdded, this);\n\t\tnewComp.on('remove', this.onLayerRemoved, this);\n\t}\n\tonLayerAdded(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tif (this._image) {\n\t\t\tlayer.addMeshInstances(this._image._renderable.model.meshInstances);\n\t\t} else if (this._text) {\n\t\t\tlayer.addMeshInstances(this._text._model.meshInstances);\n\t\t}\n\t}\n\tonLayerRemoved(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tif (this._image) {\n\t\t\tlayer.removeMeshInstances(this._image._renderable.model.meshInstances);\n\t\t} else if (this._text) {\n\t\t\tlayer.removeMeshInstances(this._text._model.meshInstances);\n\t\t}\n\t}\n\tonEnable() {\n\t\tconst scene = this.system.app.scene;\n\t\tconst layers = scene.layers;\n\t\tif (this._image) {\n\t\t\tthis._image.onEnable();\n\t\t}\n\t\tif (this._text) {\n\t\t\tthis._text.onEnable();\n\t\t}\n\t\tif (this._group) {\n\t\t\tthis._group.onEnable();\n\t\t}\n\t\tif (this.useInput && this.system.app.elementInput) {\n\t\t\tthis.system.app.elementInput.addElement(this);\n\t\t}\n\t\tthis._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);\n\t\tif (layers) {\n\t\t\tthis._evtLayerAdded = layers.on('add', this.onLayerAdded, this);\n\t\t\tthis._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);\n\t\t}\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tvar _this$system$app$batc3;\n\t\t\t(_this$system$app$batc3 = this.system.app.batcher) == null || _this$system$app$batc3.insert(BatchGroup.ELEMENT, this.batchGroupId, this.entity);\n\t\t}\n\t\tthis.fire('enableelement');\n\t}\n\tonDisable() {\n\t\tvar _this$_evtLayersChang;\n\t\tconst scene = this.system.app.scene;\n\t\tconst layers = scene.layers;\n\t\t(_this$_evtLayersChang = this._evtLayersChanged) == null || _this$_evtLayersChang.off();\n\t\tthis._evtLayersChanged = null;\n\t\tif (layers) {\n\t\t\tvar _this$_evtLayerAdded, _this$_evtLayerRemove;\n\t\t\t(_this$_evtLayerAdded = this._evtLayerAdded) == null || _this$_evtLayerAdded.off();\n\t\t\tthis._evtLayerAdded = null;\n\t\t\t(_this$_evtLayerRemove = this._evtLayerRemoved) == null || _this$_evtLayerRemove.off();\n\t\t\tthis._evtLayerRemoved = null;\n\t\t}\n\t\tif (this._image) this._image.onDisable();\n\t\tif (this._text) this._text.onDisable();\n\t\tif (this._group) this._group.onDisable();\n\t\tif (this.system.app.elementInput && this.useInput) {\n\t\t\tthis.system.app.elementInput.removeElement(this);\n\t\t}\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tvar _this$system$app$batc4;\n\t\t\t(_this$system$app$batc4 = this.system.app.batcher) == null || _this$system$app$batc4.remove(BatchGroup.ELEMENT, this.batchGroupId, this.entity);\n\t\t}\n\t\tthis.fire('disableelement');\n\t}\n\tonRemove() {\n\t\tthis.entity.off('insert', this._onInsert, this);\n\t\tthis._unpatch();\n\t\tif (this._image) {\n\t\t\tthis._image.destroy();\n\t\t}\n\t\tif (this._text) {\n\t\t\tthis._text.destroy();\n\t\t}\n\t\tif (this.system.app.elementInput && this.useInput) {\n\t\t\tthis.system.app.elementInput.removeElement(this);\n\t\t}\n\t\tif (this.screen && this.screen.screen) {\n\t\t\tthis._unbindScreen(this.screen.screen);\n\t\t\tthis.screen.screen.syncDrawOrder();\n\t\t}\n\t\tthis.off();\n\t}\n\t_calculateSize(propagateCalculatedWidth, propagateCalculatedHeight) {\n\t\tif (!this.entity._parent && !this.screen) {\n\t\t\treturn;\n\t\t}\n\t\tthis._calculateLocalAnchors();\n\t\tconst newWidth = this._absRight - this._absLeft;\n\t\tconst newHeight = this._absTop - this._absBottom;\n\t\tif (propagateCalculatedWidth) {\n\t\t\tthis._setWidth(newWidth);\n\t\t} else {\n\t\t\tthis._setCalculatedWidth(newWidth, false);\n\t\t}\n\t\tif (propagateCalculatedHeight) {\n\t\t\tthis._setHeight(newHeight);\n\t\t} else {\n\t\t\tthis._setCalculatedHeight(newHeight, false);\n\t\t}\n\t\tconst p = this.entity.getLocalPosition();\n\t\tp.x = this._margin.x + this._calculatedWidth * this._pivot.x;\n\t\tp.y = this._margin.y + this._calculatedHeight * this._pivot.y;\n\t\tthis.entity.setLocalPosition(p);\n\t\tthis._sizeDirty = false;\n\t}\n\t_setWidth(w) {\n\t\tthis._width = w;\n\t\tthis._setCalculatedWidth(w, false);\n\t\tthis.fire('set:width', this._width);\n\t}\n\t_setHeight(h) {\n\t\tthis._height = h;\n\t\tthis._setCalculatedHeight(h, false);\n\t\tthis.fire('set:height', this._height);\n\t}\n\t_setCalculatedWidth(value, updateMargins) {\n\t\tif (Math.abs(value - this._calculatedWidth) <= 1e-4) {\n\t\t\treturn;\n\t\t}\n\t\tthis._calculatedWidth = value;\n\t\tthis.entity._dirtifyLocal();\n\t\tif (updateMargins) {\n\t\t\tconst p = this.entity.getLocalPosition();\n\t\t\tconst pvt = this._pivot;\n\t\t\tthis._margin.x = p.x - this._calculatedWidth * pvt.x;\n\t\t\tthis._margin.z = this._localAnchor.z - this._localAnchor.x - this._calculatedWidth - this._margin.x;\n\t\t}\n\t\tthis._flagChildrenAsDirty();\n\t\tthis.fire('set:calculatedWidth', this._calculatedWidth);\n\t\tthis.fire('resize', this._calculatedWidth, this._calculatedHeight);\n\t}\n\t_setCalculatedHeight(value, updateMargins) {\n\t\tif (Math.abs(value - this._calculatedHeight) <= 1e-4) {\n\t\t\treturn;\n\t\t}\n\t\tthis._calculatedHeight = value;\n\t\tthis.entity._dirtifyLocal();\n\t\tif (updateMargins) {\n\t\t\tconst p = this.entity.getLocalPosition();\n\t\t\tconst pvt = this._pivot;\n\t\t\tthis._margin.y = p.y - this._calculatedHeight * pvt.y;\n\t\t\tthis._margin.w = this._localAnchor.w - this._localAnchor.y - this._calculatedHeight - this._margin.y;\n\t\t}\n\t\tthis._flagChildrenAsDirty();\n\t\tthis.fire('set:calculatedHeight', this._calculatedHeight);\n\t\tthis.fire('resize', this._calculatedWidth, this._calculatedHeight);\n\t}\n\t_flagChildrenAsDirty() {\n\t\tconst c = this.entity._children;\n\t\tfor (let i = 0, l = c.length; i < l; i++) {\n\t\t\tif (c[i].element) {\n\t\t\t\tc[i].element._anchorDirty = true;\n\t\t\t\tc[i].element._sizeDirty = true;\n\t\t\t}\n\t\t}\n\t}\n\taddModelToLayers(model) {\n\t\tthis._addedModels.push(model);\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.addMeshInstances(model.meshInstances);\n\t\t}\n\t}\n\tremoveModelFromLayers(model) {\n\t\tconst idx = this._addedModels.indexOf(model);\n\t\tif (idx >= 0) {\n\t\t\tthis._addedModels.splice(idx, 1);\n\t\t}\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\t\t\tif (!layer) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlayer.removeMeshInstances(model.meshInstances);\n\t\t}\n\t}\n\tgetMaskOffset() {\n\t\tconst frame = this.system.app.frame;\n\t\tif (this._offsetReadAt !== frame) {\n\t\t\tthis._maskOffset = 0.5;\n\t\t\tthis._offsetReadAt = frame;\n\t\t}\n\t\tconst mo = this._maskOffset;\n\t\tthis._maskOffset -= 0.001;\n\t\treturn mo;\n\t}\n\tisVisibleForCamera(camera) {\n\t\tlet clipL, clipR, clipT, clipB;\n\t\tif (this.maskedBy) {\n\t\t\tconst corners = this.maskedBy.element.screenCorners;\n\t\t\tclipL = Math.min(Math.min(corners[0].x, corners[1].x), Math.min(corners[2].x, corners[3].x));\n\t\t\tclipR = Math.max(Math.max(corners[0].x, corners[1].x), Math.max(corners[2].x, corners[3].x));\n\t\t\tclipB = Math.min(Math.min(corners[0].y, corners[1].y), Math.min(corners[2].y, corners[3].y));\n\t\t\tclipT = Math.max(Math.max(corners[0].y, corners[1].y), Math.max(corners[2].y, corners[3].y));\n\t\t} else {\n\t\t\tconst sw = this.system.app.graphicsDevice.width;\n\t\t\tconst sh = this.system.app.graphicsDevice.height;\n\t\t\tconst cameraWidth = camera._rect.z * sw;\n\t\t\tconst cameraHeight = camera._rect.w * sh;\n\t\t\tclipL = camera._rect.x * sw;\n\t\t\tclipR = clipL + cameraWidth;\n\t\t\tclipT = (1 - camera._rect.y) * sh;\n\t\t\tclipB = clipT - cameraHeight;\n\t\t}\n\t\tconst hitCorners = this.screenCorners;\n\t\tconst left = Math.min(Math.min(hitCorners[0].x, hitCorners[1].x), Math.min(hitCorners[2].x, hitCorners[3].x));\n\t\tconst right = Math.max(Math.max(hitCorners[0].x, hitCorners[1].x), Math.max(hitCorners[2].x, hitCorners[3].x));\n\t\tconst bottom = Math.min(Math.min(hitCorners[0].y, hitCorners[1].y), Math.min(hitCorners[2].y, hitCorners[3].y));\n\t\tconst top = Math.max(Math.max(hitCorners[0].y, hitCorners[1].y), Math.max(hitCorners[2].y, hitCorners[3].y));\n\t\tif (right < clipL || left > clipR || bottom > clipT || top < clipB) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\t_isScreenSpace() {\n\t\tif (this.screen && this.screen.screen) {\n\t\t\treturn this.screen.screen.screenSpace;\n\t\t}\n\t\treturn false;\n\t}\n\t_isScreenCulled() {\n\t\tif (this.screen && this.screen.screen) {\n\t\t\treturn this.screen.screen.cull;\n\t\t}\n\t\treturn false;\n\t}\n\t_dirtyBatch() {\n\t\tif (this.batchGroupId !== -1) {\n\t\t\tvar _this$system$app$batc5;\n\t\t\t(_this$system$app$batc5 = this.system.app.batcher) == null || _this$system$app$batc5.markGroupDirty(this.batchGroupId);\n\t\t}\n\t}\n}\nElementComponent.EVENT_MOUSEDOWN = 'mousedown';\nElementComponent.EVENT_MOUSEUP = 'mouseup';\nElementComponent.EVENT_MOUSEENTER = 'mouseenter';\nElementComponent.EVENT_MOUSELEAVE = 'mouseleave';\nElementComponent.EVENT_MOUSEMOVE = 'mousemove';\nElementComponent.EVENT_MOUSEWHEEL = 'mousewheel';\nElementComponent.EVENT_CLICK = 'click';\nElementComponent.EVENT_TOUCHSTART = 'touchstart';\nElementComponent.EVENT_TOUCHEND = 'touchend';\nElementComponent.EVENT_TOUCHMOVE = 'touchmove';\nElementComponent.EVENT_TOUCHCANCEL = 'touchcancel';\n\nexport { ElementComponent };\n","const ELEMENTTYPE_GROUP = 'group';\nconst ELEMENTTYPE_IMAGE = 'image';\nconst ELEMENTTYPE_TEXT = 'text';\nconst FITMODE_STRETCH = 'stretch';\nconst FITMODE_CONTAIN = 'contain';\nconst FITMODE_COVER = 'cover';\n\nexport { ELEMENTTYPE_GROUP, ELEMENTTYPE_IMAGE, ELEMENTTYPE_TEXT, FITMODE_CONTAIN, FITMODE_COVER, FITMODE_STRETCH };\n","class ElementComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n}\n\nexport { ElementComponentData };\n","import { platform } from '../../../core/platform.js';\nimport { EventHandler } from '../../../core/event-handler.js';\nimport { Quat } from '../../../core/math/quat.js';\nimport { Vec2 } from '../../../core/math/vec2.js';\nimport { Vec3 } from '../../../core/math/vec3.js';\nimport { ElementComponent } from './component.js';\nimport { Ray } from '../../../core/shape/ray.js';\nimport { Plane } from '../../../core/shape/plane.js';\n\nconst _inputScreenPosition = new Vec2();\nconst _inputWorldPosition = new Vec3();\nconst _ray = new Ray();\nconst _plane = new Plane();\nconst _normal = new Vec3();\nconst _point = new Vec3();\nconst _entityRotation = new Quat();\nconst OPPOSITE_AXIS = {\n\tx: 'y',\n\ty: 'x'\n};\nclass ElementDragHelper extends EventHandler {\n\tconstructor(element, axis) {\n\t\tsuper();\n\t\tif (!element || !(element instanceof ElementComponent)) {\n\t\t\tthrow new Error('Element was null or not an ElementComponent');\n\t\t}\n\t\tif (axis && axis !== 'x' && axis !== 'y') {\n\t\t\tthrow new Error(`Unrecognized axis: ${axis}`);\n\t\t}\n\t\tthis._element = element;\n\t\tthis._app = element.system.app;\n\t\tthis._axis = axis || null;\n\t\tthis._enabled = true;\n\t\tthis._dragScale = new Vec3();\n\t\tthis._dragStartMousePosition = new Vec3();\n\t\tthis._dragStartHandlePosition = new Vec3();\n\t\tthis._deltaMousePosition = new Vec3();\n\t\tthis._deltaHandlePosition = new Vec3();\n\t\tthis._isDragging = false;\n\t\tthis._toggleLifecycleListeners('on');\n\t}\n\t_toggleLifecycleListeners(onOrOff) {\n\t\tthis._element[onOrOff]('mousedown', this._onMouseDownOrTouchStart, this);\n\t\tthis._element[onOrOff]('touchstart', this._onMouseDownOrTouchStart, this);\n\t\tthis._element[onOrOff]('selectstart', this._onMouseDownOrTouchStart, this);\n\t}\n\t_toggleDragListeners(onOrOff) {\n\t\tconst isOn = onOrOff === 'on';\n\t\tif (this._hasDragListeners && isOn) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._app.mouse) {\n\t\t\tthis._element[onOrOff]('mousemove', this._onMove, this);\n\t\t\tthis._element[onOrOff]('mouseup', this._onMouseUpOrTouchEnd, this);\n\t\t}\n\t\tif (platform.touch) {\n\t\t\tthis._element[onOrOff]('touchmove', this._onMove, this);\n\t\t\tthis._element[onOrOff]('touchend', this._onMouseUpOrTouchEnd, this);\n\t\t\tthis._element[onOrOff]('touchcancel', this._onMouseUpOrTouchEnd, this);\n\t\t}\n\t\tthis._element[onOrOff]('selectmove', this._onMove, this);\n\t\tthis._element[onOrOff]('selectend', this._onMouseUpOrTouchEnd, this);\n\t\tthis._hasDragListeners = isOn;\n\t}\n\t_onMouseDownOrTouchStart(event) {\n\t\tif (this._element && !this._isDragging && this.enabled) {\n\t\t\tthis._dragCamera = event.camera;\n\t\t\tthis._calculateDragScale();\n\t\t\tconst currentMousePosition = this._screenToLocal(event);\n\t\t\tif (currentMousePosition) {\n\t\t\t\tthis._toggleDragListeners('on');\n\t\t\t\tthis._isDragging = true;\n\t\t\t\tthis._dragStartMousePosition.copy(currentMousePosition);\n\t\t\t\tthis._dragStartHandlePosition.copy(this._element.entity.getLocalPosition());\n\t\t\t\tthis.fire('drag:start');\n\t\t\t}\n\t\t}\n\t}\n\t_onMouseUpOrTouchEnd() {\n\t\tif (this._isDragging) {\n\t\t\tthis._isDragging = false;\n\t\t\tthis._toggleDragListeners('off');\n\t\t\tthis.fire('drag:end');\n\t\t}\n\t}\n\t_screenToLocal(event) {\n\t\tif (event.inputSource) {\n\t\t\t_ray.set(event.inputSource.getOrigin(), event.inputSource.getDirection());\n\t\t} else {\n\t\t\tthis._determineInputPosition(event);\n\t\t\tthis._chooseRayOriginAndDirection();\n\t\t}\n\t\t_normal.copy(this._element.entity.forward).mulScalar(-1);\n\t\t_plane.setFromPointNormal(this._element.entity.getPosition(), _normal);\n\t\tif (_plane.intersectsRay(_ray, _point)) {\n\t\t\t_entityRotation.copy(this._element.entity.getRotation()).invert().transformVector(_point, _point);\n\t\t\t_point.mul(this._dragScale);\n\t\t\treturn _point;\n\t\t}\n\t\treturn null;\n\t}\n\t_determineInputPosition(event) {\n\t\tconst devicePixelRatio = this._app.graphicsDevice.maxPixelRatio;\n\t\tif (typeof event.x !== 'undefined' && typeof event.y !== 'undefined') {\n\t\t\t_inputScreenPosition.x = event.x * devicePixelRatio;\n\t\t\t_inputScreenPosition.y = event.y * devicePixelRatio;\n\t\t} else if (event.changedTouches) {\n\t\t\t_inputScreenPosition.x = event.changedTouches[0].x * devicePixelRatio;\n\t\t\t_inputScreenPosition.y = event.changedTouches[0].y * devicePixelRatio;\n\t\t} else {\n\t\t\tconsole.warn('Could not determine position from input event');\n\t\t}\n\t}\n\t_chooseRayOriginAndDirection() {\n\t\tif (this._element.screen && this._element.screen.screen.screenSpace) {\n\t\t\t_ray.origin.set(_inputScreenPosition.x, -_inputScreenPosition.y, 0);\n\t\t\t_ray.direction.copy(Vec3.FORWARD);\n\t\t} else {\n\t\t\t_inputWorldPosition.copy(this._dragCamera.screenToWorld(_inputScreenPosition.x, _inputScreenPosition.y, 1));\n\t\t\t_ray.origin.copy(this._dragCamera.entity.getPosition());\n\t\t\t_ray.direction.copy(_inputWorldPosition).sub(_ray.origin).normalize();\n\t\t}\n\t}\n\t_calculateDragScale() {\n\t\tlet current = this._element.entity.parent;\n\t\tconst screen = this._element.screen && this._element.screen.screen;\n\t\tconst isWithin2DScreen = screen && screen.screenSpace;\n\t\tconst screenScale = isWithin2DScreen ? screen.scale : 1;\n\t\tconst dragScale = this._dragScale;\n\t\tdragScale.set(screenScale, screenScale, screenScale);\n\t\twhile (current) {\n\t\t\tdragScale.mul(current.getLocalScale());\n\t\t\tcurrent = current.parent;\n\t\t\tif (isWithin2DScreen && current.screen) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdragScale.x = 1 / dragScale.x;\n\t\tdragScale.y = 1 / dragScale.y;\n\t\tdragScale.z = 0;\n\t}\n\t_onMove(event) {\n\t\tconst {\n\t\t\t_element: element,\n\t\t\t_deltaMousePosition: deltaMousePosition,\n\t\t\t_deltaHandlePosition: deltaHandlePosition,\n\t\t\t_axis: axis\n\t\t} = this;\n\t\tif (element && this._isDragging && this.enabled && element.enabled && element.entity.enabled) {\n\t\t\tconst currentMousePosition = this._screenToLocal(event);\n\t\t\tif (currentMousePosition) {\n\t\t\t\tdeltaMousePosition.sub2(currentMousePosition, this._dragStartMousePosition);\n\t\t\t\tdeltaHandlePosition.add2(this._dragStartHandlePosition, deltaMousePosition);\n\t\t\t\tif (axis) {\n\t\t\t\t\tconst currentPosition = element.entity.getLocalPosition();\n\t\t\t\t\tconst constrainedAxis = OPPOSITE_AXIS[axis];\n\t\t\t\t\tdeltaHandlePosition[constrainedAxis] = currentPosition[constrainedAxis];\n\t\t\t\t}\n\t\t\t\telement.entity.setLocalPosition(deltaHandlePosition);\n\t\t\t\tthis.fire('drag:move', deltaHandlePosition);\n\t\t\t}\n\t\t}\n\t}\n\tdestroy() {\n\t\tthis._toggleLifecycleListeners('off');\n\t\tthis._toggleDragListeners('off');\n\t}\n\tset enabled(value) {\n\t\tthis._enabled = value;\n\t}\n\tget enabled() {\n\t\treturn this._enabled;\n\t}\n\tget isDragging() {\n\t\treturn this._isDragging;\n\t}\n}\nElementDragHelper.EVENT_DRAGSTART = 'drag:start';\nElementDragHelper.EVENT_DRAGEND = 'drag:end';\nElementDragHelper.EVENT_DRAGMOVE = 'drag:move';\n\nexport { ElementDragHelper };\n","import { math } from '../../../core/math/math.js';\nimport { Color } from '../../../core/math/color.js';\nimport { Vec2 } from '../../../core/math/vec2.js';\nimport { Vec3 } from '../../../core/math/vec3.js';\nimport { Vec4 } from '../../../core/math/vec4.js';\nimport { SEMANTIC_POSITION, TYPE_FLOAT32, SEMANTIC_NORMAL, SEMANTIC_TEXCOORD0, PRIMITIVE_TRISTRIP, FUNC_EQUAL, STENCILOP_DECREMENT } from '../../../platform/graphics/constants.js';\nimport { VertexBuffer } from '../../../platform/graphics/vertex-buffer.js';\nimport { VertexFormat } from '../../../platform/graphics/vertex-format.js';\nimport { DeviceCache } from '../../../platform/graphics/device-cache.js';\nimport { SPRITE_RENDERMODE_SLICED, SPRITE_RENDERMODE_TILED, LAYER_HUD, LAYER_WORLD, SPRITE_RENDERMODE_SIMPLE } from '../../../scene/constants.js';\nimport { GraphNode } from '../../../scene/graph-node.js';\nimport { Mesh } from '../../../scene/mesh.js';\nimport { MeshInstance } from '../../../scene/mesh-instance.js';\nimport { Model } from '../../../scene/model.js';\nimport { StencilParameters } from '../../../platform/graphics/stencil-parameters.js';\nimport { FITMODE_STRETCH, FITMODE_CONTAIN, FITMODE_COVER } from './constants.js';\nimport { Asset } from '../../asset/asset.js';\n\nconst _vertexFormatDeviceCache = new DeviceCache();\nclass ImageRenderable {\n\tconstructor(entity, mesh, material) {\n\t\tthis._entity = entity;\n\t\tthis._element = entity.element;\n\t\tthis.model = new Model();\n\t\tthis.node = new GraphNode();\n\t\tthis.model.graph = this.node;\n\t\tthis.mesh = mesh;\n\t\tthis.meshInstance = new MeshInstance(this.mesh, material, this.node);\n\t\tthis.meshInstance.name = `ImageElement: ${entity.name}`;\n\t\tthis.meshInstance.castShadow = false;\n\t\tthis.meshInstance.receiveShadow = false;\n\t\tthis._meshDirty = false;\n\t\tthis.model.meshInstances.push(this.meshInstance);\n\t\tthis._entity.addChild(this.model.graph);\n\t\tthis.model._entity = this._entity;\n\t\tthis.unmaskMeshInstance = null;\n\t}\n\tdestroy() {\n\t\tvar _this$meshInstance, _this$unmaskMeshInsta;\n\t\tthis.setMaterial(null);\n\t\tthis._element.removeModelFromLayers(this.model);\n\t\tthis.model.destroy();\n\t\tthis.model = null;\n\t\tthis.node = null;\n\t\tthis.mesh = null;\n\t\t(_this$meshInstance = this.meshInstance) == null || _this$meshInstance.destroy();\n\t\tthis.meshInstance = null;\n\t\t(_this$unmaskMeshInsta = this.unmaskMeshInstance) == null || _this$unmaskMeshInsta.destroy();\n\t\tthis.unmaskMeshInstance = null;\n\t\tthis._entity = null;\n\t\tthis._element = null;\n\t}\n\tsetMesh(mesh) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.mesh = mesh;\n\t\tthis.meshInstance.mesh = mesh;\n\t\tthis.meshInstance.visible = !!mesh;\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance.mesh = mesh;\n\t\t}\n\t\tthis.forceUpdateAabb();\n\t}\n\tsetMask(mask) {\n\t\tif (!this.meshInstance) return;\n\t\tif (this._entity.enabled && this._element.enabled) {\n\t\t\tthis._element.removeModelFromLayers(this.model);\n\t\t}\n\t\tif (mask) {\n\t\t\tthis.unmaskMeshInstance = new MeshInstance(this.mesh, this.meshInstance.material, this.node);\n\t\t\tthis.unmaskMeshInstance.name = `Unmask: ${this._entity.name}`;\n\t\t\tthis.unmaskMeshInstance.castShadow = false;\n\t\t\tthis.unmaskMeshInstance.receiveShadow = false;\n\t\t\tthis.unmaskMeshInstance.pick = false;\n\t\t\tthis.model.meshInstances.push(this.unmaskMeshInstance);\n\t\t\tfor (const name in this.meshInstance.parameters) {\n\t\t\t\tthis.unmaskMeshInstance.setParameter(name, this.meshInstance.parameters[name].data);\n\t\t\t}\n\t\t} else {\n\t\t\tconst idx = this.model.meshInstances.indexOf(this.unmaskMeshInstance);\n\t\t\tif (idx >= 0) {\n\t\t\t\tthis.model.meshInstances.splice(idx, 1);\n\t\t\t}\n\t\t}\n\t\tif (this._entity.enabled && this._element.enabled) {\n\t\t\tthis._element.addModelToLayers(this.model);\n\t\t}\n\t\tif (!mask) {\n\t\t\tvar _this$unmaskMeshInsta2;\n\t\t\t(_this$unmaskMeshInsta2 = this.unmaskMeshInstance) == null || _this$unmaskMeshInsta2.destroy();\n\t\t\tthis.unmaskMeshInstance = null;\n\t\t}\n\t}\n\tsetMaterial(material) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.meshInstance.material = material;\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance.material = material;\n\t\t}\n\t}\n\tsetParameter(name, value) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.meshInstance.setParameter(name, value);\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance.setParameter(name, value);\n\t\t}\n\t}\n\tdeleteParameter(name) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.meshInstance.deleteParameter(name);\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance.deleteParameter(name);\n\t\t}\n\t}\n\tsetUnmaskDrawOrder() {\n\t\tif (!this.meshInstance) return;\n\t\tconst getLastChild = function getLastChild(e) {\n\t\t\tlet last;\n\t\t\tconst c = e.children;\n\t\t\tconst l = c.length;\n\t\t\tif (l) {\n\t\t\t\tfor (let i = 0; i < l; i++) {\n\t\t\t\t\tif (c[i].element) {\n\t\t\t\t\t\tlast = c[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!last) return null;\n\t\t\t\tconst child = getLastChild(last);\n\t\t\t\tif (child) {\n\t\t\t\t\treturn child;\n\t\t\t\t}\n\t\t\t\treturn last;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tconst lastChild = getLastChild(this._entity);\n\t\t\tif (lastChild && lastChild.element) {\n\t\t\t\tthis.unmaskMeshInstance.drawOrder = lastChild.element.drawOrder + lastChild.element.getMaskOffset();\n\t\t\t} else {\n\t\t\t\tthis.unmaskMeshInstance.drawOrder = this.meshInstance.drawOrder + this._element.getMaskOffset();\n\t\t\t}\n\t\t}\n\t}\n\tsetDrawOrder(drawOrder) {\n\t\tif (!this.meshInstance) {\n\t\t\treturn;\n\t\t}\n\t\tthis.meshInstance.drawOrder = drawOrder;\n\t}\n\tsetCull(cull) {\n\t\tif (!this.meshInstance) return;\n\t\tconst element = this._element;\n\t\tlet visibleFn = null;\n\t\tif (cull && element._isScreenSpace()) {\n\t\t\tvisibleFn = function (camera) {\n\t\t\t\treturn element.isVisibleForCamera(camera);\n\t\t\t};\n\t\t}\n\t\tthis.meshInstance.cull = cull;\n\t\tthis.meshInstance.isVisibleFunc = visibleFn;\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance.cull = cull;\n\t\t\tthis.unmaskMeshInstance.isVisibleFunc = visibleFn;\n\t\t}\n\t}\n\tsetScreenSpace(screenSpace) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.meshInstance.screenSpace = screenSpace;\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance.screenSpace = screenSpace;\n\t\t}\n\t}\n\tsetLayer(layer) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.meshInstance.layer = layer;\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance.layer = layer;\n\t\t}\n\t}\n\tforceUpdateAabb(mask) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.meshInstance._aabbVer = -1;\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance._aabbVer = -1;\n\t\t}\n\t}\n\tsetAabbFunc(fn) {\n\t\tif (!this.meshInstance) return;\n\t\tthis.meshInstance._updateAabbFunc = fn;\n\t\tif (this.unmaskMeshInstance) {\n\t\t\tthis.unmaskMeshInstance._updateAabbFunc = fn;\n\t\t}\n\t}\n}\nclass ImageElement {\n\tconstructor(element) {\n\t\tthis._evtSetMeshes = null;\n\t\tthis._element = element;\n\t\tthis._entity = element.entity;\n\t\tthis._system = element.system;\n\t\tthis._textureAsset = null;\n\t\tthis._texture = null;\n\t\tthis._materialAsset = null;\n\t\tthis._material = null;\n\t\tthis._spriteAsset = null;\n\t\tthis._sprite = null;\n\t\tthis._spriteFrame = 0;\n\t\tthis._pixelsPerUnit = null;\n\t\tthis._targetAspectRatio = -1;\n\t\tthis._rect = new Vec4(0, 0, 1, 1);\n\t\tthis._mask = false;\n\t\tthis._maskRef = 0;\n\t\tthis._outerScale = new Vec2();\n\t\tthis._outerScaleUniform = new Float32Array(2);\n\t\tthis._innerOffset = new Vec4();\n\t\tthis._innerOffsetUniform = new Float32Array(4);\n\t\tthis._atlasRect = new Vec4();\n\t\tthis._atlasRectUniform = new Float32Array(4);\n\t\tthis._defaultMesh = this._createMesh();\n\t\tthis._renderable = new ImageRenderable(this._entity, this._defaultMesh, this._material);\n\t\tthis._color = new Color(1, 1, 1, 1);\n\t\tthis._colorUniform = new Float32Array([1, 1, 1]);\n\t\tthis._renderable.setParameter('material_emissive', this._colorUniform);\n\t\tthis._renderable.setParameter('material_opacity', 1);\n\t\tthis._updateAabbFunc = this._updateAabb.bind(this);\n\t\tthis._onScreenChange(this._element.screen);\n\t\tthis._element.on('resize', this._onParentResizeOrPivotChange, this);\n\t\tthis._element.on('set:pivot', this._onParentResizeOrPivotChange, this);\n\t\tthis._element.on('screen:set:screenspace', this._onScreenSpaceChange, this);\n\t\tthis._element.on('set:screen', this._onScreenChange, this);\n\t\tthis._element.on('set:draworder', this._onDrawOrderChange, this);\n\t\tthis._element.on('screen:set:resolution', this._onResolutionChange, this);\n\t}\n\tdestroy() {\n\t\tthis.textureAsset = null;\n\t\tthis.spriteAsset = null;\n\t\tthis.materialAsset = null;\n\t\tthis._renderable.setMesh(this._defaultMesh);\n\t\tthis._renderable.destroy();\n\t\tthis._defaultMesh = null;\n\t\tthis._element.off('resize', this._onParentResizeOrPivotChange, this);\n\t\tthis._element.off('set:pivot', this._onParentResizeOrPivotChange, this);\n\t\tthis._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);\n\t\tthis._element.off('set:screen', this._onScreenChange, this);\n\t\tthis._element.off('set:draworder', this._onDrawOrderChange, this);\n\t\tthis._element.off('screen:set:resolution', this._onResolutionChange, this);\n\t}\n\t_onResolutionChange(res) {}\n\t_onParentResizeOrPivotChange() {\n\t\tif (this._renderable.mesh) {\n\t\t\tthis._updateMesh(this._renderable.mesh);\n\t\t}\n\t}\n\t_onScreenSpaceChange(value) {\n\t\tthis._updateMaterial(value);\n\t}\n\t_onScreenChange(screen, previous) {\n\t\tif (screen) {\n\t\t\tthis._updateMaterial(screen.screen.screenSpace);\n\t\t} else {\n\t\t\tthis._updateMaterial(false);\n\t\t}\n\t}\n\t_onDrawOrderChange(order) {\n\t\tthis._renderable.setDrawOrder(order);\n\t\tif (this.mask && this._element.screen) {\n\t\t\tthis._element.screen.screen.once('syncdraworder', function () {\n\t\t\t\tthis._renderable.setUnmaskDrawOrder();\n\t\t\t}, this);\n\t\t}\n\t}\n\t_hasUserMaterial() {\n\t\treturn !!this._materialAsset || !!this._material && this._system.defaultImageMaterials.indexOf(this._material) === -1;\n\t}\n\t_use9Slicing() {\n\t\treturn this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED);\n\t}\n\t_updateMaterial(screenSpace) {\n\t\tconst mask = !!this._mask;\n\t\tconst nineSliced = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_SLICED);\n\t\tconst nineTiled = !!(this.sprite && this.sprite.renderMode === SPRITE_RENDERMODE_TILED);\n\t\tif (!this._hasUserMaterial()) {\n\t\t\tthis._material = this._system.getImageElementMaterial(screenSpace, mask, nineSliced, nineTiled);\n\t\t}\n\t\tif (this._renderable) {\n\t\t\tthis._renderable.setCull(!this._element._isScreenSpace() || this._element._isScreenCulled());\n\t\t\tthis._renderable.setMaterial(this._material);\n\t\t\tthis._renderable.setScreenSpace(screenSpace);\n\t\t\tthis._renderable.setLayer(screenSpace ? LAYER_HUD : LAYER_WORLD);\n\t\t}\n\t}\n\t_createMesh() {\n\t\tconst element = this._element;\n\t\tconst w = element.calculatedWidth;\n\t\tconst h = element.calculatedHeight;\n\t\tconst r = this._rect;\n\t\tconst device = this._system.app.graphicsDevice;\n\t\tconst vertexData = new Float32Array([w, 0, 0, 0, 0, 1, r.x + r.z, 1.0 - r.y, w, h, 0, 0, 0, 1, r.x + r.z, 1.0 - (r.y + r.w), 0, 0, 0, 0, 0, 1, r.x, 1.0 - r.y, 0, h, 0, 0, 0, 1, r.x, 1.0 - (r.y + r.w)]);\n\t\tconst vertexFormat = _vertexFormatDeviceCache.get(device, () => {\n\t\t\treturn new VertexFormat(device, [{\n\t\t\t\tsemantic: SEMANTIC_POSITION,\n\t\t\t\tcomponents: 3,\n\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t}, {\n\t\t\t\tsemantic: SEMANTIC_NORMAL,\n\t\t\t\tcomponents: 3,\n\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t}, {\n\t\t\t\tsemantic: SEMANTIC_TEXCOORD0,\n\t\t\t\tcomponents: 2,\n\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t}]);\n\t\t});\n\t\tconst vertexBuffer = new VertexBuffer(device, vertexFormat, 4, {\n\t\t\tdata: vertexData.buffer\n\t\t});\n\t\tconst mesh = new Mesh(device);\n\t\tmesh.vertexBuffer = vertexBuffer;\n\t\tmesh.primitive[0].type = PRIMITIVE_TRISTRIP;\n\t\tmesh.primitive[0].base = 0;\n\t\tmesh.primitive[0].count = 4;\n\t\tmesh.primitive[0].indexed = false;\n\t\tmesh.aabb.setMinMax(Vec3.ZERO, new Vec3(w, h, 0));\n\t\tthis._updateMesh(mesh);\n\t\treturn mesh;\n\t}\n\t_updateMesh(mesh) {\n\t\tconst element = this._element;\n\t\tlet w = element.calculatedWidth;\n\t\tlet h = element.calculatedHeight;\n\t\tif (element.fitMode !== FITMODE_STRETCH && this._targetAspectRatio > 0) {\n\t\t\tconst actualRatio = element.calculatedWidth / element.calculatedHeight;\n\t\t\tif (element.fitMode === FITMODE_CONTAIN && actualRatio > this._targetAspectRatio || element.fitMode === FITMODE_COVER && actualRatio < this._targetAspectRatio) {\n\t\t\t\tw = element.calculatedHeight * this._targetAspectRatio;\n\t\t\t} else {\n\t\t\t\th = element.calculatedWidth / this._targetAspectRatio;\n\t\t\t}\n\t\t}\n\t\tconst screenSpace = element._isScreenSpace();\n\t\tthis._updateMaterial(screenSpace);\n\t\tif (this._renderable) this._renderable.forceUpdateAabb();\n\t\tif (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {\n\t\t\tconst frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];\n\t\t\tconst borderWidthScale = 2 / frameData.rect.z;\n\t\t\tconst borderHeightScale = 2 / frameData.rect.w;\n\t\t\tthis._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);\n\t\t\tconst tex = this.sprite.atlas.texture;\n\t\t\tthis._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);\n\t\t\tconst ppu = this._pixelsPerUnit !== null ? this._pixelsPerUnit : this.sprite.pixelsPerUnit;\n\t\t\tconst scaleMulX = frameData.rect.z / ppu;\n\t\t\tconst scaleMulY = frameData.rect.w / ppu;\n\t\t\tthis._outerScale.set(Math.max(w, this._innerOffset.x * scaleMulX), Math.max(h, this._innerOffset.y * scaleMulY));\n\t\t\tlet scaleX = scaleMulX;\n\t\t\tlet scaleY = scaleMulY;\n\t\t\tthis._outerScale.x /= scaleMulX;\n\t\t\tthis._outerScale.y /= scaleMulY;\n\t\t\tscaleX *= math.clamp(w / (this._innerOffset.x * scaleMulX), 0.0001, 1);\n\t\t\tscaleY *= math.clamp(h / (this._innerOffset.y * scaleMulY), 0.0001, 1);\n\t\t\tif (this._renderable) {\n\t\t\t\tthis._innerOffsetUniform[0] = this._innerOffset.x;\n\t\t\t\tthis._innerOffsetUniform[1] = this._innerOffset.y;\n\t\t\t\tthis._innerOffsetUniform[2] = this._innerOffset.z;\n\t\t\t\tthis._innerOffsetUniform[3] = this._innerOffset.w;\n\t\t\t\tthis._renderable.setParameter('innerOffset', this._innerOffsetUniform);\n\t\t\t\tthis._atlasRectUniform[0] = this._atlasRect.x;\n\t\t\t\tthis._atlasRectUniform[1] = this._atlasRect.y;\n\t\t\t\tthis._atlasRectUniform[2] = this._atlasRect.z;\n\t\t\t\tthis._atlasRectUniform[3] = this._atlasRect.w;\n\t\t\t\tthis._renderable.setParameter('atlasRect', this._atlasRectUniform);\n\t\t\t\tthis._outerScaleUniform[0] = this._outerScale.x;\n\t\t\t\tthis._outerScaleUniform[1] = this._outerScale.y;\n\t\t\t\tthis._renderable.setParameter('outerScale', this._outerScaleUniform);\n\t\t\t\tthis._renderable.setAabbFunc(this._updateAabbFunc);\n\t\t\t\tthis._renderable.node.setLocalScale(scaleX, scaleY, 1);\n\t\t\t\tthis._renderable.node.setLocalPosition((0.5 - element.pivot.x) * w, (0.5 - element.pivot.y) * h, 0);\n\t\t\t}\n\t\t} else {\n\t\t\tconst vb = mesh.vertexBuffer;\n\t\t\tconst vertexDataF32 = new Float32Array(vb.lock());\n\t\t\tconst hp = element.pivot.x;\n\t\t\tconst vp = element.pivot.y;\n\t\t\tvertexDataF32[0] = w - hp * w;\n\t\t\tvertexDataF32[1] = 0 - vp * h;\n\t\t\tvertexDataF32[8] = w - hp * w;\n\t\t\tvertexDataF32[9] = h - vp * h;\n\t\t\tvertexDataF32[16] = 0 - hp * w;\n\t\t\tvertexDataF32[17] = 0 - vp * h;\n\t\t\tvertexDataF32[24] = 0 - hp * w;\n\t\t\tvertexDataF32[25] = h - vp * h;\n\t\t\tlet atlasTextureWidth = 1;\n\t\t\tlet atlasTextureHeight = 1;\n\t\t\tlet rect = this._rect;\n\t\t\tif (this._sprite && this._sprite.frameKeys[this._spriteFrame] && this._sprite.atlas) {\n\t\t\t\tconst frame = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];\n\t\t\t\tif (frame) {\n\t\t\t\t\trect = frame.rect;\n\t\t\t\t\tatlasTextureWidth = this._sprite.atlas.texture.width;\n\t\t\t\t\tatlasTextureHeight = this._sprite.atlas.texture.height;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvertexDataF32[6] = (rect.x + rect.z) / atlasTextureWidth;\n\t\t\tvertexDataF32[7] = 1.0 - rect.y / atlasTextureHeight;\n\t\t\tvertexDataF32[14] = (rect.x + rect.z) / atlasTextureWidth;\n\t\t\tvertexDataF32[15] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;\n\t\t\tvertexDataF32[22] = rect.x / atlasTextureWidth;\n\t\t\tvertexDataF32[23] = 1.0 - rect.y / atlasTextureHeight;\n\t\t\tvertexDataF32[30] = rect.x / atlasTextureWidth;\n\t\t\tvertexDataF32[31] = 1.0 - (rect.y + rect.w) / atlasTextureHeight;\n\t\t\tvb.unlock();\n\t\t\tconst min = new Vec3(0 - hp * w, 0 - vp * h, 0);\n\t\t\tconst max = new Vec3(w - hp * w, h - vp * h, 0);\n\t\t\tmesh.aabb.setMinMax(min, max);\n\t\t\tif (this._renderable) {\n\t\t\t\tthis._renderable.node.setLocalScale(1, 1, 1);\n\t\t\t\tthis._renderable.node.setLocalPosition(0, 0, 0);\n\t\t\t\tthis._renderable.setAabbFunc(null);\n\t\t\t}\n\t\t}\n\t\tthis._meshDirty = false;\n\t}\n\t_updateSprite() {\n\t\tlet nineSlice = false;\n\t\tlet mesh = null;\n\t\tthis._targetAspectRatio = -1;\n\t\tif (this._sprite && this._sprite.atlas) {\n\t\t\tmesh = this._sprite.meshes[this.spriteFrame];\n\t\t\tnineSlice = this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED;\n\t\t\tconst frameData = this._sprite.atlas.frames[this._sprite.frameKeys[this._spriteFrame]];\n\t\t\tif ((frameData == null ? void 0 : frameData.rect.w) > 0) {\n\t\t\t\tthis._targetAspectRatio = frameData.rect.z / frameData.rect.w;\n\t\t\t}\n\t\t}\n\t\tthis.mesh = nineSlice ? mesh : this._defaultMesh;\n\t\tthis.refreshMesh();\n\t}\n\trefreshMesh() {\n\t\tif (this.mesh) {\n\t\t\tif (!this._element._beingInitialized) {\n\t\t\t\tthis._updateMesh(this.mesh);\n\t\t\t} else {\n\t\t\t\tthis._meshDirty = true;\n\t\t\t}\n\t\t}\n\t}\n\t_updateAabb(aabb) {\n\t\taabb.center.set(0, 0, 0);\n\t\taabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);\n\t\taabb.setFromTransformedAabb(aabb, this._renderable.node.getWorldTransform());\n\t\treturn aabb;\n\t}\n\t_toggleMask() {\n\t\tthis._element._dirtifyMask();\n\t\tconst screenSpace = this._element._isScreenSpace();\n\t\tthis._updateMaterial(screenSpace);\n\t\tthis._renderable.setMask(!!this._mask);\n\t}\n\t_onMaterialLoad(asset) {\n\t\tthis.material = asset.resource;\n\t}\n\t_onMaterialAdded(asset) {\n\t\tthis._system.app.assets.off(`add:${asset.id}`, this._onMaterialAdded, this);\n\t\tif (this._materialAsset === asset.id) {\n\t\t\tthis._bindMaterialAsset(asset);\n\t\t}\n\t}\n\t_bindMaterialAsset(asset) {\n\t\tif (!this._entity.enabled) return;\n\t\tasset.on('load', this._onMaterialLoad, this);\n\t\tasset.on('change', this._onMaterialChange, this);\n\t\tasset.on('remove', this._onMaterialRemove, this);\n\t\tif (asset.resource) {\n\t\t\tthis._onMaterialLoad(asset);\n\t\t} else {\n\t\t\tthis._system.app.assets.load(asset);\n\t\t}\n\t}\n\t_unbindMaterialAsset(asset) {\n\t\tasset.off('load', this._onMaterialLoad, this);\n\t\tasset.off('change', this._onMaterialChange, this);\n\t\tasset.off('remove', this._onMaterialRemove, this);\n\t}\n\t_onMaterialChange() {}\n\t_onMaterialRemove() {}\n\t_onTextureAdded(asset) {\n\t\tthis._system.app.assets.off(`add:${asset.id}`, this._onTextureAdded, this);\n\t\tif (this._textureAsset === asset.id) {\n\t\t\tthis._bindTextureAsset(asset);\n\t\t}\n\t}\n\t_bindTextureAsset(asset) {\n\t\tif (!this._entity.enabled) return;\n\t\tasset.on('load', this._onTextureLoad, this);\n\t\tasset.on('change', this._onTextureChange, this);\n\t\tasset.on('remove', this._onTextureRemove, this);\n\t\tif (asset.resource) {\n\t\t\tthis._onTextureLoad(asset);\n\t\t} else {\n\t\t\tthis._system.app.assets.load(asset);\n\t\t}\n\t}\n\t_unbindTextureAsset(asset) {\n\t\tasset.off('load', this._onTextureLoad, this);\n\t\tasset.off('change', this._onTextureChange, this);\n\t\tasset.off('remove', this._onTextureRemove, this);\n\t}\n\t_onTextureLoad(asset) {\n\t\tthis.texture = asset.resource;\n\t}\n\t_onTextureChange(asset) {}\n\t_onTextureRemove(asset) {}\n\t_onSpriteAssetAdded(asset) {\n\t\tthis._system.app.assets.off(`add:${asset.id}`, this._onSpriteAssetAdded, this);\n\t\tif (this._spriteAsset === asset.id) {\n\t\t\tthis._bindSpriteAsset(asset);\n\t\t}\n\t}\n\t_bindSpriteAsset(asset) {\n\t\tif (!this._entity.enabled) return;\n\t\tasset.on('load', this._onSpriteAssetLoad, this);\n\t\tasset.on('change', this._onSpriteAssetChange, this);\n\t\tasset.on('remove', this._onSpriteAssetRemove, this);\n\t\tif (asset.resource) {\n\t\t\tthis._onSpriteAssetLoad(asset);\n\t\t} else {\n\t\t\tthis._system.app.assets.load(asset);\n\t\t}\n\t}\n\t_unbindSpriteAsset(asset) {\n\t\tasset.off('load', this._onSpriteAssetLoad, this);\n\t\tasset.off('change', this._onSpriteAssetChange, this);\n\t\tasset.off('remove', this._onSpriteAssetRemove, this);\n\t\tif (asset.data.textureAtlasAsset) {\n\t\t\tthis._system.app.assets.off(`load:${asset.data.textureAtlasAsset}`, this._onTextureAtlasLoad, this);\n\t\t}\n\t}\n\t_onSpriteAssetLoad(asset) {\n\t\tif (!asset || !asset.resource) {\n\t\t\tthis.sprite = null;\n\t\t} else {\n\t\t\tif (!asset.resource.atlas) {\n\t\t\t\tconst atlasAssetId = asset.data.textureAtlasAsset;\n\t\t\t\tif (atlasAssetId) {\n\t\t\t\t\tconst assets = this._system.app.assets;\n\t\t\t\t\tassets.off(`load:${atlasAssetId}`, this._onTextureAtlasLoad, this);\n\t\t\t\t\tassets.once(`load:${atlasAssetId}`, this._onTextureAtlasLoad, this);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.sprite = asset.resource;\n\t\t\t}\n\t\t}\n\t}\n\t_onSpriteAssetChange(asset) {\n\t\tthis._onSpriteAssetLoad(asset);\n\t}\n\t_onSpriteAssetRemove(asset) {}\n\t_bindSprite(sprite) {\n\t\tthis._evtSetMeshes = sprite.on('set:meshes', this._onSpriteMeshesChange, this);\n\t\tsprite.on('set:pixelsPerUnit', this._onSpritePpuChange, this);\n\t\tsprite.on('set:atlas', this._onAtlasTextureChange, this);\n\t\tif (sprite.atlas) {\n\t\t\tsprite.atlas.on('set:texture', this._onAtlasTextureChange, this);\n\t\t}\n\t}\n\t_unbindSprite(sprite) {\n\t\tvar _this$_evtSetMeshes;\n\t\t(_this$_evtSetMeshes = this._evtSetMeshes) == null || _this$_evtSetMeshes.off();\n\t\tthis._evtSetMeshes = null;\n\t\tsprite.off('set:pixelsPerUnit', this._onSpritePpuChange, this);\n\t\tsprite.off('set:atlas', this._onAtlasTextureChange, this);\n\t\tif (sprite.atlas) {\n\t\t\tsprite.atlas.off('set:texture', this._onAtlasTextureChange, this);\n\t\t}\n\t}\n\t_onSpriteMeshesChange() {\n\t\tif (this._sprite) {\n\t\t\tthis._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);\n\t\t}\n\t\tthis._updateSprite();\n\t}\n\t_onSpritePpuChange() {\n\t\tif (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE && this._pixelsPerUnit === null) {\n\t\t\tthis._updateSprite();\n\t\t}\n\t}\n\t_onAtlasTextureChange() {\n\t\tif (this.sprite && this.sprite.atlas && this.sprite.atlas.texture) {\n\t\t\tthis._renderable.setParameter('texture_emissiveMap', this._sprite.atlas.texture);\n\t\t\tthis._renderable.setParameter('texture_opacityMap', this._sprite.atlas.texture);\n\t\t} else {\n\t\t\tthis._renderable.deleteParameter('texture_emissiveMap');\n\t\t\tthis._renderable.deleteParameter('texture_opacityMap');\n\t\t}\n\t}\n\t_onTextureAtlasLoad(atlasAsset) {\n\t\tconst spriteAsset = this._spriteAsset;\n\t\tif (spriteAsset instanceof Asset) {\n\t\t\tthis._onSpriteAssetLoad(spriteAsset);\n\t\t} else {\n\t\t\tthis._onSpriteAssetLoad(this._system.app.assets.get(spriteAsset));\n\t\t}\n\t}\n\tonEnable() {\n\t\tif (this._materialAsset) {\n\t\t\tconst asset = this._system.app.assets.get(this._materialAsset);\n\t\t\tif (asset && asset.resource !== this._material) {\n\t\t\t\tthis._bindMaterialAsset(asset);\n\t\t\t}\n\t\t}\n\t\tif (this._textureAsset) {\n\t\t\tconst asset = this._system.app.assets.get(this._textureAsset);\n\t\t\tif (asset && asset.resource !== this._texture) {\n\t\t\t\tthis._bindTextureAsset(asset);\n\t\t\t}\n\t\t}\n\t\tif (this._spriteAsset) {\n\t\t\tconst asset = this._system.app.assets.get(this._spriteAsset);\n\t\t\tif (asset && asset.resource !== this._sprite) {\n\t\t\t\tthis._bindSpriteAsset(asset);\n\t\t\t}\n\t\t}\n\t\tthis._element.addModelToLayers(this._renderable.model);\n\t}\n\tonDisable() {\n\t\tthis._element.removeModelFromLayers(this._renderable.model);\n\t}\n\t_setStencil(stencilParams) {\n\t\tthis._renderable.meshInstance.stencilFront = stencilParams;\n\t\tthis._renderable.meshInstance.stencilBack = stencilParams;\n\t\tlet ref = 0;\n\t\tif (this._element.maskedBy) {\n\t\t\tref = this._element.maskedBy.element._image._maskRef;\n\t\t}\n\t\tif (this._renderable.unmaskMeshInstance) {\n\t\t\tconst sp = new StencilParameters({\n\t\t\t\tref: ref + 1,\n\t\t\t\tfunc: FUNC_EQUAL,\n\t\t\t\tzpass: STENCILOP_DECREMENT\n\t\t\t});\n\t\t\tthis._renderable.unmaskMeshInstance.stencilFront = sp;\n\t\t\tthis._renderable.unmaskMeshInstance.stencilBack = sp;\n\t\t}\n\t}\n\tset color(value) {\n\t\tconst r = value.r;\n\t\tconst g = value.g;\n\t\tconst b = value.b;\n\t\tif (this._color.r !== r || this._color.g !== g || this._color.b !== b) {\n\t\t\tthis._color.r = r;\n\t\t\tthis._color.g = g;\n\t\t\tthis._color.b = b;\n\t\t\tthis._colorUniform[0] = r;\n\t\t\tthis._colorUniform[1] = g;\n\t\t\tthis._colorUniform[2] = b;\n\t\t\tthis._renderable.setParameter('material_emissive', this._colorUniform);\n\t\t}\n\t\tif (this._element) {\n\t\t\tthis._element.fire('set:color', this._color);\n\t\t}\n\t}\n\tget color() {\n\t\treturn this._color;\n\t}\n\tset opacity(value) {\n\t\tif (value !== this._color.a) {\n\t\t\tthis._color.a = value;\n\t\t\tthis._renderable.setParameter('material_opacity', value);\n\t\t}\n\t\tif (this._element) {\n\t\t\tthis._element.fire('set:opacity', value);\n\t\t}\n\t}\n\tget opacity() {\n\t\treturn this._color.a;\n\t}\n\tset rect(value) {\n\t\tlet x, y, z, w;\n\t\tif (value instanceof Vec4) {\n\t\t\tx = value.x;\n\t\t\ty = value.y;\n\t\t\tz = value.z;\n\t\t\tw = value.w;\n\t\t} else {\n\t\t\tx = value[0];\n\t\t\ty = value[1];\n\t\t\tz = value[2];\n\t\t\tw = value[3];\n\t\t}\n\t\tif (x === this._rect.x && y === this._rect.y && z === this._rect.z && w === this._rect.w) {\n\t\t\treturn;\n\t\t}\n\t\tthis._rect.set(x, y, z, w);\n\t\tif (this._renderable.mesh) {\n\t\t\tif (!this._element._beingInitialized) {\n\t\t\t\tthis._updateMesh(this._renderable.mesh);\n\t\t\t} else {\n\t\t\t\tthis._meshDirty = true;\n\t\t\t}\n\t\t}\n\t}\n\tget rect() {\n\t\treturn this._rect;\n\t}\n\t_removeMaterialAssetEvents() {\n\t\tif (this._materialAsset) {\n\t\t\tconst assets = this._system.app.assets;\n\t\t\tassets.off(`add:${this._materialAsset}`, this._onMaterialAdded, this);\n\t\t\tconst asset = assets.get(this._materialAsset);\n\t\t\tif (asset) {\n\t\t\t\tasset.off('load', this._onMaterialLoad, this);\n\t\t\t\tasset.off('change', this._onMaterialChange, this);\n\t\t\t\tasset.off('remove', this._onMaterialRemove, this);\n\t\t\t}\n\t\t}\n\t}\n\tset material(value) {\n\t\tif (this._material === value) return;\n\t\tif (!value) {\n\t\t\tconst screenSpace = this._element._isScreenSpace();\n\t\t\tif (this.mask) {\n\t\t\t\tvalue = screenSpace ? this._system.defaultScreenSpaceImageMaskMaterial : this._system.defaultImageMaskMaterial;\n\t\t\t} else {\n\t\t\t\tvalue = screenSpace ? this._system.defaultScreenSpaceImageMaterial : this._system.defaultImageMaterial;\n\t\t\t}\n\t\t}\n\t\tthis._material = value;\n\t\tif (this._materialAsset) {\n\t\t\tconst asset = this._system.app.assets.get(this._materialAsset);\n\t\t\tif (!asset || asset.resource !== value) {\n\t\t\t\tthis._removeMaterialAssetEvents();\n\t\t\t\tthis._materialAsset = null;\n\t\t\t}\n\t\t}\n\t\tif (value) {\n\t\t\tthis._renderable.setMaterial(value);\n\t\t\tif (this._hasUserMaterial()) {\n\t\t\t\tthis._renderable.deleteParameter('material_opacity');\n\t\t\t\tthis._renderable.deleteParameter('material_emissive');\n\t\t\t} else {\n\t\t\t\tthis._colorUniform[0] = this._color.r;\n\t\t\t\tthis._colorUniform[1] = this._color.g;\n\t\t\t\tthis._colorUniform[2] = this._color.b;\n\t\t\t\tthis._renderable.setParameter('material_emissive', this._colorUniform);\n\t\t\t\tthis._renderable.setParameter('material_opacity', this._color.a);\n\t\t\t}\n\t\t}\n\t}\n\tget material() {\n\t\treturn this._material;\n\t}\n\tset materialAsset(value) {\n\t\tconst assets = this._system.app.assets;\n\t\tlet _id = value;\n\t\tif (value instanceof Asset) {\n\t\t\t_id = value.id;\n\t\t}\n\t\tif (this._materialAsset !== _id) {\n\t\t\tthis._removeMaterialAssetEvents();\n\t\t\tthis._materialAsset = _id;\n\t\t\tif (this._materialAsset) {\n\t\t\t\tconst asset = assets.get(this._materialAsset);\n\t\t\t\tif (!asset) {\n\t\t\t\t\tthis._materialAsset = null;\n\t\t\t\t\tthis.material = null;\n\t\t\t\t\tthis._materialAsset = _id;\n\t\t\t\t\tassets.on(`add:${this._materialAsset}`, this._onMaterialAdded, this);\n\t\t\t\t} else {\n\t\t\t\t\tthis._bindMaterialAsset(asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._materialAsset = null;\n\t\t\t\tthis.material = null;\n\t\t\t\tthis._materialAsset = _id;\n\t\t\t}\n\t\t}\n\t}\n\tget materialAsset() {\n\t\treturn this._materialAsset;\n\t}\n\tset texture(value) {\n\t\tif (this._texture === value) return;\n\t\tif (this._textureAsset) {\n\t\t\tconst textureAsset = this._system.app.assets.get(this._textureAsset);\n\t\t\tif (textureAsset && textureAsset.resource !== value) {\n\t\t\t\tthis.textureAsset = null;\n\t\t\t}\n\t\t}\n\t\tthis._texture = value;\n\t\tif (value) {\n\t\t\tif (this._spriteAsset) {\n\t\t\t\tthis.spriteAsset = null;\n\t\t\t}\n\t\t\tthis._renderable.setParameter('texture_emissiveMap', this._texture);\n\t\t\tthis._renderable.setParameter('texture_opacityMap', this._texture);\n\t\t\tthis._colorUniform[0] = this._color.r;\n\t\t\tthis._colorUniform[1] = this._color.g;\n\t\t\tthis._colorUniform[2] = this._color.b;\n\t\t\tthis._renderable.setParameter('material_emissive', this._colorUniform);\n\t\t\tthis._renderable.setParameter('material_opacity', this._color.a);\n\t\t\tconst newAspectRatio = this._texture.width / this._texture.height;\n\t\t\tif (newAspectRatio !== this._targetAspectRatio) {\n\t\t\t\tthis._targetAspectRatio = newAspectRatio;\n\t\t\t\tif (this._element.fitMode !== FITMODE_STRETCH) {\n\t\t\t\t\tthis.refreshMesh();\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis._renderable.deleteParameter('texture_emissiveMap');\n\t\t\tthis._renderable.deleteParameter('texture_opacityMap');\n\t\t\tthis._targetAspectRatio = -1;\n\t\t\tif (this._element.fitMode !== FITMODE_STRETCH) {\n\t\t\t\tthis.refreshMesh();\n\t\t\t}\n\t\t}\n\t}\n\tget texture() {\n\t\treturn this._texture;\n\t}\n\tset textureAsset(value) {\n\t\tconst assets = this._system.app.assets;\n\t\tlet _id = value;\n\t\tif (value instanceof Asset) {\n\t\t\t_id = value.id;\n\t\t}\n\t\tif (this._textureAsset !== _id) {\n\t\t\tif (this._textureAsset) {\n\t\t\t\tassets.off(`add:${this._textureAsset}`, this._onTextureAdded, this);\n\t\t\t\tconst _prev = assets.get(this._textureAsset);\n\t\t\t\tif (_prev) {\n\t\t\t\t\t_prev.off('load', this._onTextureLoad, this);\n\t\t\t\t\t_prev.off('change', this._onTextureChange, this);\n\t\t\t\t\t_prev.off('remove', this._onTextureRemove, this);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._textureAsset = _id;\n\t\t\tif (this._textureAsset) {\n\t\t\t\tconst asset = assets.get(this._textureAsset);\n\t\t\t\tif (!asset) {\n\t\t\t\t\tthis.texture = null;\n\t\t\t\t\tassets.on(`add:${this._textureAsset}`, this._onTextureAdded, this);\n\t\t\t\t} else {\n\t\t\t\t\tthis._bindTextureAsset(asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.texture = null;\n\t\t\t}\n\t\t}\n\t}\n\tget textureAsset() {\n\t\treturn this._textureAsset;\n\t}\n\tset spriteAsset(value) {\n\t\tconst assets = this._system.app.assets;\n\t\tlet _id = value;\n\t\tif (value instanceof Asset) {\n\t\t\t_id = value.id;\n\t\t}\n\t\tif (this._spriteAsset !== _id) {\n\t\t\tif (this._spriteAsset) {\n\t\t\t\tassets.off(`add:${this._spriteAsset}`, this._onSpriteAssetAdded, this);\n\t\t\t\tconst _prev = assets.get(this._spriteAsset);\n\t\t\t\tif (_prev) {\n\t\t\t\t\tthis._unbindSpriteAsset(_prev);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._spriteAsset = _id;\n\t\t\tif (this._spriteAsset) {\n\t\t\t\tconst asset = assets.get(this._spriteAsset);\n\t\t\t\tif (!asset) {\n\t\t\t\t\tthis.sprite = null;\n\t\t\t\t\tassets.on(`add:${this._spriteAsset}`, this._onSpriteAssetAdded, this);\n\t\t\t\t} else {\n\t\t\t\t\tthis._bindSpriteAsset(asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.sprite = null;\n\t\t\t}\n\t\t}\n\t\tif (this._element) {\n\t\t\tthis._element.fire('set:spriteAsset', _id);\n\t\t}\n\t}\n\tget spriteAsset() {\n\t\treturn this._spriteAsset;\n\t}\n\tset sprite(value) {\n\t\tif (this._sprite === value) return;\n\t\tif (this._sprite) {\n\t\t\tthis._unbindSprite(this._sprite);\n\t\t}\n\t\tif (this._spriteAsset) {\n\t\t\tconst spriteAsset = this._system.app.assets.get(this._spriteAsset);\n\t\t\tif (spriteAsset && spriteAsset.resource !== value) {\n\t\t\t\tthis.spriteAsset = null;\n\t\t\t}\n\t\t}\n\t\tthis._sprite = value;\n\t\tif (this._sprite) {\n\t\t\tthis._bindSprite(this._sprite);\n\t\t\tif (this._textureAsset) {\n\t\t\t\tthis.textureAsset = null;\n\t\t\t}\n\t\t}\n\t\tif (this._sprite && this._sprite.atlas && this._sprite.atlas.texture) {\n\t\t\tthis._renderable.setParameter('texture_emissiveMap', this._sprite.atlas.texture);\n\t\t\tthis._renderable.setParameter('texture_opacityMap', this._sprite.atlas.texture);\n\t\t} else {\n\t\t\tthis._renderable.deleteParameter('texture_emissiveMap');\n\t\t\tthis._renderable.deleteParameter('texture_opacityMap');\n\t\t}\n\t\tif (this._sprite) {\n\t\t\tthis._spriteFrame = math.clamp(this._spriteFrame, 0, this._sprite.frameKeys.length - 1);\n\t\t}\n\t\tthis._updateSprite();\n\t}\n\tget sprite() {\n\t\treturn this._sprite;\n\t}\n\tset spriteFrame(value) {\n\t\tconst oldValue = this._spriteFrame;\n\t\tif (this._sprite) {\n\t\t\tthis._spriteFrame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);\n\t\t} else {\n\t\t\tthis._spriteFrame = value;\n\t\t}\n\t\tif (this._spriteFrame !== oldValue) {\n\t\t\tthis._updateSprite();\n\t\t}\n\t\tif (this._element) {\n\t\t\tthis._element.fire('set:spriteFrame', value);\n\t\t}\n\t}\n\tget spriteFrame() {\n\t\treturn this._spriteFrame;\n\t}\n\tset mesh(value) {\n\t\tthis._renderable.setMesh(value);\n\t\tif (this._defaultMesh === value) {\n\t\t\tthis._renderable.setAabbFunc(null);\n\t\t} else {\n\t\t\tthis._renderable.setAabbFunc(this._updateAabbFunc);\n\t\t}\n\t}\n\tget mesh() {\n\t\treturn this._renderable.mesh;\n\t}\n\tset mask(value) {\n\t\tif (this._mask !== value) {\n\t\t\tthis._mask = value;\n\t\t\tthis._toggleMask();\n\t\t}\n\t}\n\tget mask() {\n\t\treturn this._mask;\n\t}\n\tset pixelsPerUnit(value) {\n\t\tif (this._pixelsPerUnit === value) return;\n\t\tthis._pixelsPerUnit = value;\n\t\tif (this._sprite && (this._sprite.renderMode === SPRITE_RENDERMODE_SLICED || this._sprite.renderMode === SPRITE_RENDERMODE_TILED)) {\n\t\t\tthis._updateSprite();\n\t\t}\n\t}\n\tget pixelsPerUnit() {\n\t\treturn this._pixelsPerUnit;\n\t}\n\tget aabb() {\n\t\tif (this._renderable.meshInstance) {\n\t\t\treturn this._renderable.meshInstance.aabb;\n\t\t}\n\t\treturn null;\n\t}\n}\n\nexport { ImageElement };\n","const EOF_TOKEN = 0;\nconst ERROR_TOKEN = 1;\nconst TEXT_TOKEN = 2;\nconst OPEN_BRACKET_TOKEN = 3;\nconst CLOSE_BRACKET_TOKEN = 4;\nconst EQUALS_TOKEN = 5;\nconst STRING_TOKEN = 6;\nconst IDENTIFIER_TOKEN = 7;\nconst WHITESPACE_TOKEN = 8;\nconst WHITESPACE_CHARS = ' \\t\\n\\r\\v\\f';\nconst IDENTIFIER_REGEX = /[\\w|/]/;\nclass Scanner {\n\tconstructor(symbols) {\n\t\tthis._symbols = symbols;\n\t\tthis._index = 0;\n\t\tthis._last = 0;\n\t\tthis._cur = this._symbols.length > 0 ? this._symbols[0] : null;\n\t\tthis._buf = [];\n\t\tthis._mode = 'text';\n\t\tthis._error = null;\n\t}\n\tread() {\n\t\tlet token = this._read();\n\t\twhile (token === WHITESPACE_TOKEN) {\n\t\t\ttoken = this._read();\n\t\t}\n\t\tif (token !== EOF_TOKEN && token !== ERROR_TOKEN) {\n\t\t\tthis._last = this._index;\n\t\t}\n\t\treturn token;\n\t}\n\tbuf() {\n\t\treturn this._buf;\n\t}\n\tlast() {\n\t\treturn this._last;\n\t}\n\terror() {\n\t\treturn this._error;\n\t}\n\tdebugPrint() {\n\t\tconst tokenStrings = ['EOF', 'ERROR', 'TEXT', 'OPEN_BRACKET', 'CLOSE_BRACKET', 'EQUALS', 'STRING', 'IDENTIFIER', 'WHITESPACE'];\n\t\tlet token = this.read();\n\t\tlet result = '';\n\t\twhile (true) {\n\t\t\tresult += `${(result.length > 0 ? '\\n' : '') + tokenStrings[token]} '${this.buf().join('')}'`;\n\t\t\tif (token === EOF_TOKEN || token === ERROR_TOKEN) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttoken = this.read();\n\t\t}\n\t\treturn result;\n\t}\n\t_read() {\n\t\tthis._buf = [];\n\t\tif (this._eof()) {\n\t\t\treturn EOF_TOKEN;\n\t\t}\n\t\treturn this._mode === 'text' ? this._text() : this._tag();\n\t}\n\t_text() {\n\t\twhile (true) {\n\t\t\tswitch (this._cur) {\n\t\t\t\tcase null:\n\t\t\t\t\treturn this._buf.length > 0 ? TEXT_TOKEN : EOF_TOKEN;\n\t\t\t\tcase '[':\n\t\t\t\t\tthis._mode = 'tag';\n\t\t\t\t\treturn this._buf.length > 0 ? TEXT_TOKEN : this._tag();\n\t\t\t\tcase '\\\\':\n\t\t\t\t\tthis._next();\n\t\t\t\t\tswitch (this._cur) {\n\t\t\t\t\t\tcase '[':\n\t\t\t\t\t\t\tthis._store();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tthis._output('\\\\');\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthis._store();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t_tag() {\n\t\tswitch (this._cur) {\n\t\t\tcase null:\n\t\t\t\tthis._error = 'unexpected end of input reading tag';\n\t\t\t\treturn ERROR_TOKEN;\n\t\t\tcase '[':\n\t\t\t\tthis._store();\n\t\t\t\treturn OPEN_BRACKET_TOKEN;\n\t\t\tcase ']':\n\t\t\t\tthis._store();\n\t\t\t\tthis._mode = 'text';\n\t\t\t\treturn CLOSE_BRACKET_TOKEN;\n\t\t\tcase '=':\n\t\t\t\tthis._store();\n\t\t\t\treturn EQUALS_TOKEN;\n\t\t\tcase ' ':\n\t\t\tcase '\\t':\n\t\t\tcase '\\n':\n\t\t\tcase '\\r':\n\t\t\tcase '\\v':\n\t\t\tcase '\\f':\n\t\t\t\treturn this._whitespace();\n\t\t\tcase '\"':\n\t\t\t\treturn this._string();\n\t\t\tdefault:\n\t\t\t\tif (!this._isIdentifierSymbol(this._cur)) {\n\t\t\t\t\tthis._error = 'unrecognized character';\n\t\t\t\t\treturn ERROR_TOKEN;\n\t\t\t\t}\n\t\t\t\treturn this._identifier();\n\t\t}\n\t}\n\t_whitespace() {\n\t\tthis._store();\n\t\twhile (WHITESPACE_CHARS.indexOf(this._cur) !== -1) {\n\t\t\tthis._store();\n\t\t}\n\t\treturn WHITESPACE_TOKEN;\n\t}\n\t_string() {\n\t\tthis._next();\n\t\twhile (true) {\n\t\t\tswitch (this._cur) {\n\t\t\t\tcase null:\n\t\t\t\t\tthis._error = 'unexpected end of input reading string';\n\t\t\t\t\treturn ERROR_TOKEN;\n\t\t\t\tcase '\"':\n\t\t\t\t\tthis._next();\n\t\t\t\t\treturn STRING_TOKEN;\n\t\t\t\tdefault:\n\t\t\t\t\tthis._store();\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t_identifier() {\n\t\tthis._store();\n\t\twhile (this._cur !== null && this._isIdentifierSymbol(this._cur)) {\n\t\t\tthis._store();\n\t\t}\n\t\treturn IDENTIFIER_TOKEN;\n\t}\n\t_isIdentifierSymbol(s) {\n\t\treturn s.length === 1 && s.match(IDENTIFIER_REGEX) !== null;\n\t}\n\t_eof() {\n\t\treturn this._cur === null;\n\t}\n\t_next() {\n\t\tif (!this._eof()) {\n\t\t\tthis._index++;\n\t\t\tthis._cur = this._index < this._symbols.length ? this._symbols[this._index] : null;\n\t\t}\n\t\treturn this._cur;\n\t}\n\t_store() {\n\t\tthis._buf.push(this._cur);\n\t\treturn this._next();\n\t}\n\t_output(c) {\n\t\tthis._buf.push(c);\n\t}\n}\nclass Parser {\n\tconstructor(symbols) {\n\t\tthis._scanner = new Scanner(symbols);\n\t\tthis._error = null;\n\t}\n\tparse(symbols, tags) {\n\t\twhile (true) {\n\t\t\tconst token = this._scanner.read();\n\t\t\tswitch (token) {\n\t\t\t\tcase EOF_TOKEN:\n\t\t\t\t\treturn true;\n\t\t\t\tcase ERROR_TOKEN:\n\t\t\t\t\treturn false;\n\t\t\t\tcase TEXT_TOKEN:\n\t\t\t\t\tArray.prototype.push.apply(symbols, this._scanner.buf());\n\t\t\t\t\tbreak;\n\t\t\t\tcase OPEN_BRACKET_TOKEN:\n\t\t\t\t\tif (!this._parseTag(symbols, tags)) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\terror() {\n\t\treturn `Error evaluating markup at #${this._scanner.last().toString()} (${this._scanner.error() || this._error})`;\n\t}\n\t_parseTag(symbols, tags) {\n\t\tlet token = this._scanner.read();\n\t\tif (token !== IDENTIFIER_TOKEN) {\n\t\t\tthis._error = 'expected identifier';\n\t\t\treturn false;\n\t\t}\n\t\tconst name = this._scanner.buf().join('');\n\t\tif (name[0] === '/') {\n\t\t\tfor (let index = tags.length - 1; index >= 0; --index) {\n\t\t\t\tif (name === `/${tags[index].name}` && tags[index].end === null) {\n\t\t\t\t\ttags[index].end = symbols.length;\n\t\t\t\t\ttoken = this._scanner.read();\n\t\t\t\t\tif (token !== CLOSE_BRACKET_TOKEN) {\n\t\t\t\t\t\tthis._error = 'expected close bracket';\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._error = 'failed to find matching tag';\n\t\t\treturn false;\n\t\t}\n\t\tconst tag = {\n\t\t\tname: name,\n\t\t\tvalue: null,\n\t\t\tattributes: {},\n\t\t\tstart: symbols.length,\n\t\t\tend: null\n\t\t};\n\t\ttoken = this._scanner.read();\n\t\tif (token === EQUALS_TOKEN) {\n\t\t\ttoken = this._scanner.read();\n\t\t\tif (token !== STRING_TOKEN) {\n\t\t\t\tthis._error = 'expected string';\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttag.value = this._scanner.buf().join('');\n\t\t\ttoken = this._scanner.read();\n\t\t}\n\t\twhile (true) {\n\t\t\tswitch (token) {\n\t\t\t\tcase CLOSE_BRACKET_TOKEN:\n\t\t\t\t\ttags.push(tag);\n\t\t\t\t\treturn true;\n\t\t\t\tcase IDENTIFIER_TOKEN:\n\t\t\t\t\t{\n\t\t\t\t\t\tconst identifier = this._scanner.buf().join('');\n\t\t\t\t\t\ttoken = this._scanner.read();\n\t\t\t\t\t\tif (token !== EQUALS_TOKEN) {\n\t\t\t\t\t\t\tthis._error = 'expected equals';\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttoken = this._scanner.read();\n\t\t\t\t\t\tif (token !== STRING_TOKEN) {\n\t\t\t\t\t\t\tthis._error = 'expected string';\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst value = this._scanner.buf().join('');\n\t\t\t\t\t\ttag.attributes[identifier] = value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tthis._error = 'expected close bracket or identifier';\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttoken = this._scanner.read();\n\t\t}\n\t}\n}\nfunction merge(target, source) {\n\tfor (const key in source) {\n\t\tif (!source.hasOwnProperty(key)) {\n\t\t\tcontinue;\n\t\t}\n\t\tconst value = source[key];\n\t\tif (value instanceof Object) {\n\t\t\tif (!target.hasOwnProperty(key)) {\n\t\t\t\ttarget[key] = {};\n\t\t\t}\n\t\t\tmerge(target[key], source[key]);\n\t\t} else {\n\t\t\ttarget[key] = value;\n\t\t}\n\t}\n}\nfunction combineTags(tags) {\n\tif (tags.length === 0) {\n\t\treturn null;\n\t}\n\tconst result = {};\n\tfor (let index = 0; index < tags.length; ++index) {\n\t\tconst tag = tags[index];\n\t\tconst tmp = {};\n\t\ttmp[tag.name] = {\n\t\t\tvalue: tag.value,\n\t\t\tattributes: tag.attributes\n\t\t};\n\t\tmerge(result, tmp);\n\t}\n\treturn result;\n}\nfunction resolveMarkupTags(tags, numSymbols) {\n\tif (tags.length === 0) {\n\t\treturn null;\n\t}\n\tconst edges = {};\n\tfor (let index = 0; index < tags.length; ++index) {\n\t\tconst tag = tags[index];\n\t\tif (!edges.hasOwnProperty(tag.start)) {\n\t\t\tedges[tag.start] = {\n\t\t\t\topen: [tag],\n\t\t\t\tclose: null\n\t\t\t};\n\t\t} else {\n\t\t\tif (edges[tag.start].open === null) {\n\t\t\t\tedges[tag.start].open = [tag];\n\t\t\t} else {\n\t\t\t\tedges[tag.start].open.push(tag);\n\t\t\t}\n\t\t}\n\t\tif (!edges.hasOwnProperty(tag.end)) {\n\t\t\tedges[tag.end] = {\n\t\t\t\topen: null,\n\t\t\t\tclose: [tag]\n\t\t\t};\n\t\t} else {\n\t\t\tif (edges[tag.end].close === null) {\n\t\t\t\tedges[tag.end].close = [tag];\n\t\t\t} else {\n\t\t\t\tedges[tag.end].close.push(tag);\n\t\t\t}\n\t\t}\n\t}\n\tlet tagStack = [];\n\tfunction removeTags(tags) {\n\t\ttagStack = tagStack.filter(tag => {\n\t\t\treturn tags.find(t => {\n\t\t\t\treturn t === tag;\n\t\t\t}) === undefined;\n\t\t});\n\t}\n\tfunction addTags(tags) {\n\t\tfor (let index = 0; index < tags.length; ++index) {\n\t\t\ttagStack.push(tags[index]);\n\t\t}\n\t}\n\tconst edgeKeys = Object.keys(edges).sort((a, b) => {\n\t\treturn a - b;\n\t});\n\tconst resolvedTags = [];\n\tfor (let index = 0; index < edgeKeys.length; ++index) {\n\t\tconst edge = edges[edgeKeys[index]];\n\t\tif (edge.close !== null) {\n\t\t\tremoveTags(edge.close);\n\t\t}\n\t\tif (edge.open !== null) {\n\t\t\taddTags(edge.open);\n\t\t}\n\t\tresolvedTags.push({\n\t\t\tstart: edgeKeys[index],\n\t\t\ttags: combineTags(tagStack)\n\t\t});\n\t}\n\tconst result = [];\n\tlet prevTag = null;\n\tfor (let index = 0; index < resolvedTags.length; ++index) {\n\t\tconst resolvedTag = resolvedTags[index];\n\t\twhile (result.length < resolvedTag.start) {\n\t\t\tresult.push(prevTag ? prevTag.tags : null);\n\t\t}\n\t\tprevTag = resolvedTag;\n\t}\n\twhile (result.length < numSymbols) {\n\t\tresult.push(null);\n\t}\n\treturn result;\n}\nfunction evaluateMarkup(symbols) {\n\tconst parser = new Parser(symbols);\n\tconst stripped_symbols = [];\n\tconst tags = [];\n\tif (!parser.parse(stripped_symbols, tags)) {\n\t\tconsole.warn(parser.error());\n\t\treturn {\n\t\t\tsymbols: symbols,\n\t\t\ttags: null\n\t\t};\n\t}\n\tconst invalidTag = tags.find(t => {\n\t\treturn t.end === null;\n\t});\n\tif (invalidTag) {\n\t\tconsole.warn(`Markup error: found unclosed tag='${invalidTag.name}'`);\n\t\treturn {\n\t\t\tsymbols: symbols,\n\t\t\ttags: null\n\t\t};\n\t}\n\tconst resolved_tags = resolveMarkupTags(tags, stripped_symbols.length);\n\treturn {\n\t\tsymbols: stripped_symbols,\n\t\ttags: resolved_tags\n\t};\n}\nclass Markup {\n\tstatic evaluate(symbols) {\n\t\treturn evaluateMarkup(symbols);\n\t}\n}\n\nexport { Markup };\n","import { Color } from '../../../core/math/color.js';\nimport { Vec2 } from '../../../core/math/vec2.js';\nimport { Vec4 } from '../../../core/math/vec4.js';\nimport { PIXELFORMAT_RGBA8 } from '../../../platform/graphics/constants.js';\nimport { Texture } from '../../../platform/graphics/texture.js';\nimport { BLEND_PREMULTIPLIED, SPRITE_RENDERMODE_SLICED, SPRITE_RENDERMODE_TILED } from '../../../scene/constants.js';\nimport { StandardMaterial } from '../../../scene/materials/standard-material.js';\nimport { ComponentSystem } from '../system.js';\nimport { ELEMENTTYPE_IMAGE, ELEMENTTYPE_TEXT } from './constants.js';\nimport { ElementComponent } from './component.js';\nimport { ElementComponentData } from './data.js';\n\nconst _schema = ['enabled'];\nclass ElementComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'element';\n\t\tthis.ComponentType = ElementComponent;\n\t\tthis.DataType = ElementComponentData;\n\t\tthis.schema = _schema;\n\t\tthis._unicodeConverter = null;\n\t\tthis._rtlReorder = null;\n\t\tthis._defaultTexture = new Texture(app.graphicsDevice, {\n\t\t\twidth: 1,\n\t\t\theight: 1,\n\t\t\tformat: PIXELFORMAT_RGBA8,\n\t\t\tname: 'element-system'\n\t\t});\n\t\tconst pixels = this._defaultTexture.lock();\n\t\tconst pixelData = new Uint8Array(4);\n\t\tpixelData[0] = 255.0;\n\t\tpixelData[1] = 255.0;\n\t\tpixelData[2] = 255.0;\n\t\tpixelData[3] = 255.0;\n\t\tpixels.set(pixelData);\n\t\tthis._defaultTexture.unlock();\n\t\tthis.defaultImageMaterial = null;\n\t\tthis.defaultImage9SlicedMaterial = null;\n\t\tthis.defaultImage9TiledMaterial = null;\n\t\tthis.defaultImageMaskMaterial = null;\n\t\tthis.defaultImage9SlicedMaskMaterial = null;\n\t\tthis.defaultImage9TiledMaskMaterial = null;\n\t\tthis.defaultScreenSpaceImageMaterial = null;\n\t\tthis.defaultScreenSpaceImage9SlicedMaterial = null;\n\t\tthis.defaultScreenSpaceImage9TiledMaterial = null;\n\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial = null;\n\t\tthis.defaultScreenSpaceImageMask9TiledMaterial = null;\n\t\tthis.defaultScreenSpaceImageMaskMaterial = null;\n\t\tthis._defaultTextMaterials = {};\n\t\tthis.defaultImageMaterials = [];\n\t\tthis.on('add', this.onAddComponent, this);\n\t\tthis.on('beforeremove', this.onRemoveComponent, this);\n\t}\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis._defaultTexture.destroy();\n\t}\n\tinitializeComponentData(component, data, properties) {\n\t\tcomponent._beingInitialized = true;\n\t\tif (data.anchor !== undefined) {\n\t\t\tif (data.anchor instanceof Vec4) {\n\t\t\t\tcomponent.anchor.copy(data.anchor);\n\t\t\t} else {\n\t\t\t\tcomponent.anchor.set(data.anchor[0], data.anchor[1], data.anchor[2], data.anchor[3]);\n\t\t\t}\n\t\t}\n\t\tif (data.pivot !== undefined) {\n\t\t\tif (data.pivot instanceof Vec2) {\n\t\t\t\tcomponent.pivot.copy(data.pivot);\n\t\t\t} else {\n\t\t\t\tcomponent.pivot.set(data.pivot[0], data.pivot[1]);\n\t\t\t}\n\t\t}\n\t\tconst splitHorAnchors = Math.abs(component.anchor.x - component.anchor.z) > 0.001;\n\t\tconst splitVerAnchors = Math.abs(component.anchor.y - component.anchor.w) > 0.001;\n\t\tlet _marginChange = false;\n\t\tlet color;\n\t\tif (data.margin !== undefined) {\n\t\t\tif (data.margin instanceof Vec4) {\n\t\t\t\tcomponent.margin.copy(data.margin);\n\t\t\t} else {\n\t\t\t\tcomponent._margin.set(data.margin[0], data.margin[1], data.margin[2], data.margin[3]);\n\t\t\t}\n\t\t\t_marginChange = true;\n\t\t}\n\t\tif (data.left !== undefined) {\n\t\t\tcomponent._margin.x = data.left;\n\t\t\t_marginChange = true;\n\t\t}\n\t\tif (data.bottom !== undefined) {\n\t\t\tcomponent._margin.y = data.bottom;\n\t\t\t_marginChange = true;\n\t\t}\n\t\tif (data.right !== undefined) {\n\t\t\tcomponent._margin.z = data.right;\n\t\t\t_marginChange = true;\n\t\t}\n\t\tif (data.top !== undefined) {\n\t\t\tcomponent._margin.w = data.top;\n\t\t\t_marginChange = true;\n\t\t}\n\t\tif (_marginChange) {\n\t\t\tcomponent.margin = component._margin;\n\t\t}\n\t\tlet shouldForceSetAnchor = false;\n\t\tif (data.width !== undefined && !splitHorAnchors) {\n\t\t\tcomponent.width = data.width;\n\t\t} else if (splitHorAnchors) {\n\t\t\tshouldForceSetAnchor = true;\n\t\t}\n\t\tif (data.height !== undefined && !splitVerAnchors) {\n\t\t\tcomponent.height = data.height;\n\t\t} else if (splitVerAnchors) {\n\t\t\tshouldForceSetAnchor = true;\n\t\t}\n\t\tif (shouldForceSetAnchor) {\n\t\t\tcomponent.anchor = component.anchor;\n\t\t}\n\t\tif (data.enabled !== undefined) {\n\t\t\tcomponent.enabled = data.enabled;\n\t\t}\n\t\tif (data.useInput !== undefined) {\n\t\t\tcomponent.useInput = data.useInput;\n\t\t}\n\t\tif (data.fitMode !== undefined) {\n\t\t\tcomponent.fitMode = data.fitMode;\n\t\t}\n\t\tcomponent.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;\n\t\tif (data.layers && Array.isArray(data.layers)) {\n\t\t\tcomponent.layers = data.layers.slice(0);\n\t\t}\n\t\tif (data.type !== undefined) {\n\t\t\tcomponent.type = data.type;\n\t\t}\n\t\tif (component.type === ELEMENTTYPE_IMAGE) {\n\t\t\tif (data.rect !== undefined) {\n\t\t\t\tcomponent.rect = data.rect;\n\t\t\t}\n\t\t\tif (data.color !== undefined) {\n\t\t\t\tcolor = data.color;\n\t\t\t\tif (!(color instanceof Color)) {\n\t\t\t\t\tcolor = new Color(data.color[0], data.color[1], data.color[2]);\n\t\t\t\t}\n\t\t\t\tcomponent.color = color;\n\t\t\t}\n\t\t\tif (data.opacity !== undefined) component.opacity = data.opacity;\n\t\t\tif (data.textureAsset !== undefined) component.textureAsset = data.textureAsset;\n\t\t\tif (data.texture) component.texture = data.texture;\n\t\t\tif (data.spriteAsset !== undefined) component.spriteAsset = data.spriteAsset;\n\t\t\tif (data.sprite) component.sprite = data.sprite;\n\t\t\tif (data.spriteFrame !== undefined) component.spriteFrame = data.spriteFrame;\n\t\t\tif (data.pixelsPerUnit !== undefined && data.pixelsPerUnit !== null) component.pixelsPerUnit = data.pixelsPerUnit;\n\t\t\tif (data.materialAsset !== undefined) component.materialAsset = data.materialAsset;\n\t\t\tif (data.material) component.material = data.material;\n\t\t\tif (data.mask !== undefined) {\n\t\t\t\tcomponent.mask = data.mask;\n\t\t\t}\n\t\t} else if (component.type === ELEMENTTYPE_TEXT) {\n\t\t\tif (data.autoWidth !== undefined) component.autoWidth = data.autoWidth;\n\t\t\tif (data.autoHeight !== undefined) component.autoHeight = data.autoHeight;\n\t\t\tif (data.rtlReorder !== undefined) component.rtlReorder = data.rtlReorder;\n\t\t\tif (data.unicodeConverter !== undefined) component.unicodeConverter = data.unicodeConverter;\n\t\t\tif (data.text !== null && data.text !== undefined) {\n\t\t\t\tcomponent.text = data.text;\n\t\t\t} else if (data.key !== null && data.key !== undefined) {\n\t\t\t\tcomponent.key = data.key;\n\t\t\t}\n\t\t\tif (data.color !== undefined) {\n\t\t\t\tcolor = data.color;\n\t\t\t\tif (!(color instanceof Color)) {\n\t\t\t\t\tcolor = new Color(color[0], color[1], color[2]);\n\t\t\t\t}\n\t\t\t\tcomponent.color = color;\n\t\t\t}\n\t\t\tif (data.opacity !== undefined) {\n\t\t\t\tcomponent.opacity = data.opacity;\n\t\t\t}\n\t\t\tif (data.spacing !== undefined) component.spacing = data.spacing;\n\t\t\tif (data.fontSize !== undefined) {\n\t\t\t\tcomponent.fontSize = data.fontSize;\n\t\t\t\tif (!data.lineHeight) component.lineHeight = data.fontSize;\n\t\t\t}\n\t\t\tif (data.lineHeight !== undefined) component.lineHeight = data.lineHeight;\n\t\t\tif (data.maxLines !== undefined) component.maxLines = data.maxLines;\n\t\t\tif (data.wrapLines !== undefined) component.wrapLines = data.wrapLines;\n\t\t\tif (data.minFontSize !== undefined) component.minFontSize = data.minFontSize;\n\t\t\tif (data.maxFontSize !== undefined) component.maxFontSize = data.maxFontSize;\n\t\t\tif (data.autoFitWidth) component.autoFitWidth = data.autoFitWidth;\n\t\t\tif (data.autoFitHeight) component.autoFitHeight = data.autoFitHeight;\n\t\t\tif (data.fontAsset !== undefined) component.fontAsset = data.fontAsset;\n\t\t\tif (data.font !== undefined) component.font = data.font;\n\t\t\tif (data.alignment !== undefined) component.alignment = data.alignment;\n\t\t\tif (data.outlineColor !== undefined) component.outlineColor = data.outlineColor;\n\t\t\tif (data.outlineThickness !== undefined) component.outlineThickness = data.outlineThickness;\n\t\t\tif (data.shadowColor !== undefined) component.shadowColor = data.shadowColor;\n\t\t\tif (data.shadowOffset !== undefined) component.shadowOffset = data.shadowOffset;\n\t\t\tif (data.enableMarkup !== undefined) component.enableMarkup = data.enableMarkup;\n\t\t}\n\t\tconst result = component._parseUpToScreen();\n\t\tif (result.screen) {\n\t\t\tcomponent._updateScreen(result.screen);\n\t\t}\n\t\tsuper.initializeComponentData(component, data, properties);\n\t\tcomponent._beingInitialized = false;\n\t\tif (component.type === ELEMENTTYPE_IMAGE && component._image._meshDirty) {\n\t\t\tcomponent._image._updateMesh(component._image.mesh);\n\t\t}\n\t}\n\tonAddComponent(entity, component) {\n\t\tentity.fire('element:add');\n\t}\n\tonRemoveComponent(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\tcloneComponent(entity, clone) {\n\t\tconst source = entity.element;\n\t\tconst data = {\n\t\t\tenabled: source.enabled,\n\t\t\twidth: source.width,\n\t\t\theight: source.height,\n\t\t\tanchor: source.anchor.clone(),\n\t\t\tpivot: source.pivot.clone(),\n\t\t\tmargin: source.margin.clone(),\n\t\t\talignment: source.alignment && source.alignment.clone() || source.alignment,\n\t\t\tautoWidth: source.autoWidth,\n\t\t\tautoHeight: source.autoHeight,\n\t\t\ttype: source.type,\n\t\t\trect: source.rect && source.rect.clone() || source.rect,\n\t\t\trtlReorder: source.rtlReorder,\n\t\t\tunicodeConverter: source.unicodeConverter,\n\t\t\tmaterialAsset: source.materialAsset,\n\t\t\tmaterial: source.material,\n\t\t\tcolor: source.color && source.color.clone() || source.color,\n\t\t\topacity: source.opacity,\n\t\t\ttextureAsset: source.textureAsset,\n\t\t\ttexture: source.texture,\n\t\t\tspriteAsset: source.spriteAsset,\n\t\t\tsprite: source.sprite,\n\t\t\tspriteFrame: source.spriteFrame,\n\t\t\tpixelsPerUnit: source.pixelsPerUnit,\n\t\t\tspacing: source.spacing,\n\t\t\tlineHeight: source.lineHeight,\n\t\t\twrapLines: source.wrapLines,\n\t\t\tlayers: source.layers,\n\t\t\tfontSize: source.fontSize,\n\t\t\tminFontSize: source.minFontSize,\n\t\t\tmaxFontSize: source.maxFontSize,\n\t\t\tautoFitWidth: source.autoFitWidth,\n\t\t\tautoFitHeight: source.autoFitHeight,\n\t\t\tmaxLines: source.maxLines,\n\t\t\tfontAsset: source.fontAsset,\n\t\t\tfont: source.font,\n\t\t\tuseInput: source.useInput,\n\t\t\tfitMode: source.fitMode,\n\t\t\tbatchGroupId: source.batchGroupId,\n\t\t\tmask: source.mask,\n\t\t\toutlineColor: source.outlineColor && source.outlineColor.clone() || source.outlineColor,\n\t\t\toutlineThickness: source.outlineThickness,\n\t\t\tshadowColor: source.shadowColor && source.shadowColor.clone() || source.shadowColor,\n\t\t\tshadowOffset: source.shadowOffset && source.shadowOffset.clone() || source.shadowOffset,\n\t\t\tenableMarkup: source.enableMarkup\n\t\t};\n\t\tif (source.key !== undefined && source.key !== null) {\n\t\t\tdata.key = source.key;\n\t\t} else {\n\t\t\tdata.text = source.text;\n\t\t}\n\t\treturn this.addComponent(clone, data);\n\t}\n\tgetTextElementMaterial(screenSpace, msdf, textAttibutes) {\n\t\tconst hash = (screenSpace && 1 << 0) | (msdf && 1 << 1) | (textAttibutes && 1 << 2);\n\t\tlet material = this._defaultTextMaterials[hash];\n\t\tif (material) {\n\t\t\treturn material;\n\t\t}\n\t\tlet name = 'TextMaterial';\n\t\tmaterial = new StandardMaterial();\n\t\tif (msdf) {\n\t\t\tmaterial.msdfMap = this._defaultTexture;\n\t\t\tmaterial.msdfTextAttribute = textAttibutes;\n\t\t\tmaterial.emissive.set(1, 1, 1);\n\t\t} else {\n\t\t\tname = `Bitmap${name}`;\n\t\t\tmaterial.emissive.set(0.5, 0.5, 0.5);\n\t\t\tmaterial.emissiveMap = this._defaultTexture;\n\t\t\tmaterial.emissiveTint = true;\n\t\t\tmaterial.opacityMap = this._defaultTexture;\n\t\t\tmaterial.opacityMapChannel = 'a';\n\t\t}\n\t\tif (screenSpace) {\n\t\t\tname = `ScreenSpace${name}`;\n\t\t\tmaterial.depthTest = false;\n\t\t}\n\t\tmaterial.name = `default${name}`;\n\t\tmaterial.useLighting = false;\n\t\tmaterial.useGammaTonemap = false;\n\t\tmaterial.useFog = false;\n\t\tmaterial.useSkybox = false;\n\t\tmaterial.diffuse.set(0, 0, 0);\n\t\tmaterial.opacity = 0.5;\n\t\tmaterial.blendType = BLEND_PREMULTIPLIED;\n\t\tmaterial.depthWrite = false;\n\t\tmaterial.emissiveVertexColor = true;\n\t\tmaterial.update();\n\t\tthis._defaultTextMaterials[hash] = material;\n\t\treturn material;\n\t}\n\t_createBaseImageMaterial() {\n\t\tconst material = new StandardMaterial();\n\t\tmaterial.diffuse.set(0, 0, 0);\n\t\tmaterial.emissive.set(0.5, 0.5, 0.5);\n\t\tmaterial.emissiveMap = this._defaultTexture;\n\t\tmaterial.emissiveTint = true;\n\t\tmaterial.opacityMap = this._defaultTexture;\n\t\tmaterial.opacityMapChannel = 'a';\n\t\tmaterial.opacityTint = true;\n\t\tmaterial.opacity = 0;\n\t\tmaterial.useLighting = false;\n\t\tmaterial.useGammaTonemap = false;\n\t\tmaterial.useFog = false;\n\t\tmaterial.useSkybox = false;\n\t\tmaterial.blendType = BLEND_PREMULTIPLIED;\n\t\tmaterial.depthWrite = false;\n\t\treturn material;\n\t}\n\tgetImageElementMaterial(screenSpace, mask, nineSliced, nineSliceTiled) {\n\t\tif (screenSpace) {\n\t\t\tif (mask) {\n\t\t\t\tif (nineSliced) {\n\t\t\t\t\tif (!this.defaultScreenSpaceImageMask9SlicedMaterial) {\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.name = 'defaultScreenSpaceImageMask9SlicedMaterial';\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.depthTest = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.alphaTest = 1;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.redWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.greenWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.blueWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.alphaWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9SlicedMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9SlicedMaterial);\n\t\t\t\t\t}\n\t\t\t\t\treturn this.defaultScreenSpaceImageMask9SlicedMaterial;\n\t\t\t\t} else if (nineSliceTiled) {\n\t\t\t\t\tif (!this.defaultScreenSpaceImageMask9TiledMaterial) {\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial = this.defaultScreenSpaceImage9TiledMaterial.clone();\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.name = 'defaultScreenSpaceImageMask9TiledMaterial';\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.depthTest = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.alphaTest = 1;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.redWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.greenWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.blueWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.alphaWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMask9TiledMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultScreenSpaceImageMask9TiledMaterial);\n\t\t\t\t\t}\n\t\t\t\t\treturn this.defaultScreenSpaceImageMask9TiledMaterial;\n\t\t\t\t} else {\n\t\t\t\t\tif (!this.defaultScreenSpaceImageMaskMaterial) {\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.name = 'defaultScreenSpaceImageMaskMaterial';\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.depthTest = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.alphaTest = 1;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.redWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.greenWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.blueWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.alphaWrite = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaskMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultScreenSpaceImageMaskMaterial);\n\t\t\t\t\t}\n\t\t\t\t\treturn this.defaultScreenSpaceImageMaskMaterial;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (nineSliced) {\n\t\t\t\t\tif (!this.defaultScreenSpaceImage9SlicedMaterial) {\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9SlicedMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9SlicedMaterial.name = 'defaultScreenSpaceImage9SlicedMaterial';\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9SlicedMaterial.depthTest = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9SlicedMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultScreenSpaceImage9SlicedMaterial);\n\t\t\t\t\t}\n\t\t\t\t\treturn this.defaultScreenSpaceImage9SlicedMaterial;\n\t\t\t\t} else if (nineSliceTiled) {\n\t\t\t\t\tif (!this.defaultScreenSpaceImage9TiledMaterial) {\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9TiledMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9TiledMaterial.name = 'defaultScreenSpaceImage9TiledMaterial';\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9TiledMaterial.depthTest = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImage9TiledMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultScreenSpaceImage9TiledMaterial);\n\t\t\t\t\t}\n\t\t\t\t\treturn this.defaultScreenSpaceImage9TiledMaterial;\n\t\t\t\t} else {\n\t\t\t\t\tif (!this.defaultScreenSpaceImageMaterial) {\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaterial.name = 'defaultScreenSpaceImageMaterial';\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaterial.depthTest = false;\n\t\t\t\t\t\tthis.defaultScreenSpaceImageMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultScreenSpaceImageMaterial);\n\t\t\t\t\t}\n\t\t\t\t\treturn this.defaultScreenSpaceImageMaterial;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (mask) {\n\t\t\t\tif (nineSliced) {\n\t\t\t\t\tif (!this.defaultImage9SlicedMaskMaterial) {\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.name = 'defaultImage9SlicedMaskMaterial';\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.alphaTest = 1;\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.redWrite = false;\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.greenWrite = false;\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.blueWrite = false;\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.alphaWrite = false;\n\t\t\t\t\t\tthis.defaultImage9SlicedMaskMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultImage9SlicedMaskMaterial);\n\t\t\t\t\t}\n\t\t\t\t\treturn this.defaultImage9SlicedMaskMaterial;\n\t\t\t\t} else if (nineSliceTiled) {\n\t\t\t\t\tif (!this.defaultImage9TiledMaskMaterial) {\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.name = 'defaultImage9TiledMaskMaterial';\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.alphaTest = 1;\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.redWrite = false;\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.greenWrite = false;\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.blueWrite = false;\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.alphaWrite = false;\n\t\t\t\t\t\tthis.defaultImage9TiledMaskMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultImage9TiledMaskMaterial);\n\t\t\t\t\t}\n\t\t\t\t\treturn this.defaultImage9TiledMaskMaterial;\n\t\t\t\t} else {\n\t\t\t\t\tif (!this.defaultImageMaskMaterial) {\n\t\t\t\t\t\tthis.defaultImageMaskMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultImageMaskMaterial.name = 'defaultImageMaskMaterial';\n\t\t\t\t\t\tthis.defaultImageMaskMaterial.alphaTest = 1;\n\t\t\t\t\t\tthis.defaultImageMaskMaterial.redWrite = false;\n\t\t\t\t\t\tthis.defaultImageMaskMaterial.greenWrite = false;\n\t\t\t\t\t\tthis.defaultImageMaskMaterial.blueWrite = false;\n\t\t\t\t\t\tthis.defaultImageMaskMaterial.alphaWrite = false;\n\t\t\t\t\t\tthis.defaultImageMaskMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultImageMaskMaterial);\n\t\t\t\t\t}\n\t\t\t\t\treturn this.defaultImageMaskMaterial;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (nineSliced) {\n\t\t\t\t\tif (!this.defaultImage9SlicedMaterial) {\n\t\t\t\t\t\tthis.defaultImage9SlicedMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultImage9SlicedMaterial.name = 'defaultImage9SlicedMaterial';\n\t\t\t\t\t\tthis.defaultImage9SlicedMaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;\n\t\t\t\t\t\tthis.defaultImage9SlicedMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultImage9SlicedMaterial);\n\t\t\t\t\t}\n\t\t\t\t\treturn this.defaultImage9SlicedMaterial;\n\t\t\t\t} else if (nineSliceTiled) {\n\t\t\t\t\tif (!this.defaultImage9TiledMaterial) {\n\t\t\t\t\t\tthis.defaultImage9TiledMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultImage9TiledMaterial.name = 'defaultImage9TiledMaterial';\n\t\t\t\t\t\tthis.defaultImage9TiledMaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;\n\t\t\t\t\t\tthis.defaultImage9TiledMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultImage9TiledMaterial);\n\t\t\t\t\t}\n\t\t\t\t\treturn this.defaultImage9TiledMaterial;\n\t\t\t\t} else {\n\t\t\t\t\tif (!this.defaultImageMaterial) {\n\t\t\t\t\t\tthis.defaultImageMaterial = this._createBaseImageMaterial();\n\t\t\t\t\t\tthis.defaultImageMaterial.name = 'defaultImageMaterial';\n\t\t\t\t\t\tthis.defaultImageMaterial.update();\n\t\t\t\t\t\tthis.defaultImageMaterials.push(this.defaultImageMaterial);\n\t\t\t\t\t}\n\t\t\t\t\treturn this.defaultImageMaterial;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tregisterUnicodeConverter(func) {\n\t\tthis._unicodeConverter = func;\n\t}\n\tregisterRtlReorder(func) {\n\t\tthis._rtlReorder = func;\n\t}\n\tgetUnicodeConverter() {\n\t\treturn this._unicodeConverter;\n\t}\n\tgetRtlReorder() {\n\t\treturn this._rtlReorder;\n\t}\n}\n\nexport { ElementComponentSystem };\n","import { string } from '../../../core/string.js';\nimport { math } from '../../../core/math/math.js';\nimport { Color } from '../../../core/math/color.js';\nimport { Vec2 } from '../../../core/math/vec2.js';\nimport { BoundingBox } from '../../../core/shape/bounding-box.js';\nimport { SEMANTIC_POSITION, SEMANTIC_TEXCOORD0, SEMANTIC_COLOR, SEMANTIC_ATTR8, SEMANTIC_ATTR9, TYPE_FLOAT32 } from '../../../platform/graphics/constants.js';\nimport { VertexIterator } from '../../../platform/graphics/vertex-iterator.js';\nimport { GraphNode } from '../../../scene/graph-node.js';\nimport { MeshInstance } from '../../../scene/mesh-instance.js';\nimport { Model } from '../../../scene/model.js';\nimport { Mesh } from '../../../scene/mesh.js';\nimport { LocalizedAsset } from '../../asset/asset-localized.js';\nimport { FONT_MSDF, FONT_BITMAP } from '../../font/constants.js';\nimport { Markup } from './markup.js';\n\nclass MeshInfo {\n\tconstructor() {\n\t\tthis.count = 0;\n\t\tthis.quad = 0;\n\t\tthis.lines = {};\n\t\tthis.positions = [];\n\t\tthis.normals = [];\n\t\tthis.uvs = [];\n\t\tthis.colors = [];\n\t\tthis.indices = [];\n\t\tthis.outlines = [];\n\t\tthis.shadows = [];\n\t\tthis.meshInstance = null;\n\t}\n}\nfunction createTextMesh(device, meshInfo) {\n\tconst mesh = new Mesh(device);\n\tmesh.setPositions(meshInfo.positions);\n\tmesh.setNormals(meshInfo.normals);\n\tmesh.setColors32(meshInfo.colors);\n\tmesh.setUvs(0, meshInfo.uvs);\n\tmesh.setIndices(meshInfo.indices);\n\tmesh.setVertexStream(SEMANTIC_ATTR8, meshInfo.outlines, 3, undefined, TYPE_FLOAT32, false);\n\tmesh.setVertexStream(SEMANTIC_ATTR9, meshInfo.shadows, 3, undefined, TYPE_FLOAT32, false);\n\tmesh.update();\n\treturn mesh;\n}\nconst LINE_BREAK_CHAR = /^[\\r\\n]$/;\nconst WHITESPACE_CHAR = /^[ \\t]$/;\nconst WORD_BOUNDARY_CHAR = /^[ \\t\\-]|\\u200b$/;\nconst ALPHANUMERIC_CHAR = /^[a-z0-9]$/i;\nconst CJK_CHAR = /^[\\u1100-\\u11ff]|[\\u3000-\\u9fff\\ua960-\\ua97f]|[\\uac00-\\ud7ff]$/;\nconst NO_LINE_BREAK_CJK_CHAR = /^[]$/;\nconst CONTROL_CHARS = ['\\u200B', '\\u061C', '\\u200E', '\\u200F', '\\u202A', '\\u202B', '\\u202C', '\\u202D', '\\u202E', '\\u2066', '\\u2067', '\\u2068', '\\u2069'];\nconst CONTROL_GLYPH_DATA = {\n\twidth: 0,\n\theight: 0,\n\txadvance: 0,\n\txoffset: 0,\n\tyoffset: 0\n};\nconst colorTmp = new Color();\nconst vec2Tmp = new Vec2();\nclass TextElement {\n\tconstructor(element) {\n\t\tthis._element = element;\n\t\tthis._system = element.system;\n\t\tthis._entity = element.entity;\n\t\tthis._text = '';\n\t\tthis._symbols = [];\n\t\tthis._colorPalette = [];\n\t\tthis._outlinePalette = [];\n\t\tthis._shadowPalette = [];\n\t\tthis._symbolColors = null;\n\t\tthis._symbolOutlineParams = null;\n\t\tthis._symbolShadowParams = null;\n\t\tthis._i18nKey = null;\n\t\tthis._fontAsset = new LocalizedAsset(this._system.app);\n\t\tthis._fontAsset.disableLocalization = true;\n\t\tthis._fontAsset.on('load', this._onFontLoad, this);\n\t\tthis._fontAsset.on('change', this._onFontChange, this);\n\t\tthis._fontAsset.on('remove', this._onFontRemove, this);\n\t\tthis._font = null;\n\t\tthis._color = new Color(1, 1, 1, 1);\n\t\tthis._colorUniform = new Float32Array(3);\n\t\tthis._spacing = 1;\n\t\tthis._fontSize = 32;\n\t\tthis._fontMinY = 0;\n\t\tthis._fontMaxY = 0;\n\t\tthis._originalFontSize = 32;\n\t\tthis._maxFontSize = 32;\n\t\tthis._minFontSize = 8;\n\t\tthis._autoFitWidth = false;\n\t\tthis._autoFitHeight = false;\n\t\tthis._maxLines = -1;\n\t\tthis._lineHeight = 32;\n\t\tthis._scaledLineHeight = 32;\n\t\tthis._wrapLines = false;\n\t\tthis._drawOrder = 0;\n\t\tthis._alignment = new Vec2(0.5, 0.5);\n\t\tthis._autoWidth = true;\n\t\tthis._autoHeight = true;\n\t\tthis.width = 0;\n\t\tthis.height = 0;\n\t\tthis._node = new GraphNode();\n\t\tthis._model = new Model();\n\t\tthis._model.graph = this._node;\n\t\tthis._entity.addChild(this._node);\n\t\tthis._meshInfo = [];\n\t\tthis._material = null;\n\t\tthis._aabbDirty = true;\n\t\tthis._aabb = new BoundingBox();\n\t\tthis._noResize = false;\n\t\tthis._currentMaterialType = null;\n\t\tthis._maskedMaterialSrc = null;\n\t\tthis._rtlReorder = false;\n\t\tthis._unicodeConverter = false;\n\t\tthis._rtl = false;\n\t\tthis._outlineColor = new Color(0, 0, 0, 1);\n\t\tthis._outlineColorUniform = new Float32Array(4);\n\t\tthis._outlineThicknessScale = 0.2;\n\t\tthis._outlineThickness = 0.0;\n\t\tthis._shadowColor = new Color(0, 0, 0, 1);\n\t\tthis._shadowColorUniform = new Float32Array(4);\n\t\tthis._shadowOffsetScale = 0.005;\n\t\tthis._shadowOffset = new Vec2(0, 0);\n\t\tthis._shadowOffsetUniform = new Float32Array(2);\n\t\tthis._enableMarkup = false;\n\t\tthis._onScreenChange(this._element.screen);\n\t\telement.on('resize', this._onParentResize, this);\n\t\telement.on('set:screen', this._onScreenChange, this);\n\t\telement.on('screen:set:screenspace', this._onScreenSpaceChange, this);\n\t\telement.on('set:draworder', this._onDrawOrderChange, this);\n\t\telement.on('set:pivot', this._onPivotChange, this);\n\t\tthis._system.app.i18n.on('set:locale', this._onLocaleSet, this);\n\t\tthis._system.app.i18n.on('data:add', this._onLocalizationData, this);\n\t\tthis._system.app.i18n.on('data:remove', this._onLocalizationData, this);\n\t\tthis._rangeStart = 0;\n\t\tthis._rangeEnd = 0;\n\t}\n\tdestroy() {\n\t\tthis._setMaterial(null);\n\t\tif (this._model) {\n\t\t\tthis._element.removeModelFromLayers(this._model);\n\t\t\tthis._model.destroy();\n\t\t\tthis._model = null;\n\t\t}\n\t\tthis._fontAsset.destroy();\n\t\tthis.font = null;\n\t\tthis._element.off('resize', this._onParentResize, this);\n\t\tthis._element.off('set:screen', this._onScreenChange, this);\n\t\tthis._element.off('screen:set:screenspace', this._onScreenSpaceChange, this);\n\t\tthis._element.off('set:draworder', this._onDrawOrderChange, this);\n\t\tthis._element.off('set:pivot', this._onPivotChange, this);\n\t\tthis._system.app.i18n.off('set:locale', this._onLocaleSet, this);\n\t\tthis._system.app.i18n.off('data:add', this._onLocalizationData, this);\n\t\tthis._system.app.i18n.off('data:remove', this._onLocalizationData, this);\n\t}\n\t_onParentResize(width, height) {\n\t\tif (this._noResize) return;\n\t\tif (this._font) this._updateText();\n\t}\n\t_onScreenChange(screen) {\n\t\tif (screen) {\n\t\t\tthis._updateMaterial(screen.screen.screenSpace);\n\t\t} else {\n\t\t\tthis._updateMaterial(false);\n\t\t}\n\t}\n\t_onScreenSpaceChange(value) {\n\t\tthis._updateMaterial(value);\n\t}\n\t_onDrawOrderChange(order) {\n\t\tthis._drawOrder = order;\n\t\tif (this._model) {\n\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\tthis._model.meshInstances[i].drawOrder = order;\n\t\t\t}\n\t\t}\n\t}\n\t_onPivotChange(pivot) {\n\t\tif (this._font) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\t_onLocaleSet(locale) {\n\t\tif (!this._i18nKey) return;\n\t\tif (this.fontAsset) {\n\t\t\tconst asset = this._system.app.assets.get(this.fontAsset);\n\t\t\tif (!asset || !asset.resource || asset.resource !== this._font) {\n\t\t\t\tthis.font = null;\n\t\t\t}\n\t\t}\n\t\tthis._resetLocalizedText();\n\t}\n\t_onLocalizationData(locale, messages) {\n\t\tif (this._i18nKey && messages[this._i18nKey]) {\n\t\t\tthis._resetLocalizedText();\n\t\t}\n\t}\n\t_resetLocalizedText() {\n\t\tthis._setText(this._system.app.i18n.getText(this._i18nKey));\n\t}\n\t_setText(text) {\n\t\tif (this.unicodeConverter) {\n\t\t\tconst unicodeConverterFunc = this._system.getUnicodeConverter();\n\t\t\tif (unicodeConverterFunc) {\n\t\t\t\ttext = unicodeConverterFunc(text);\n\t\t\t} else {\n\t\t\t\tconsole.warn('Element created with unicodeConverter option but no unicodeConverter function registered');\n\t\t\t}\n\t\t}\n\t\tif (this._text !== text) {\n\t\t\tif (this._font) {\n\t\t\t\tthis._updateText(text);\n\t\t\t}\n\t\t\tthis._text = text;\n\t\t}\n\t}\n\t_updateText(text) {\n\t\tlet tags;\n\t\tif (text === undefined) text = this._text;\n\t\tthis._symbols = string.getSymbols(text.normalize ? text.normalize('NFC') : text);\n\t\tif (this._symbols.length === 0) {\n\t\t\tthis._symbols = [' '];\n\t\t}\n\t\tif (this._enableMarkup) {\n\t\t\tconst results = Markup.evaluate(this._symbols);\n\t\t\tthis._symbols = results.symbols;\n\t\t\ttags = results.tags || [];\n\t\t}\n\t\tif (this._rtlReorder) {\n\t\t\tconst rtlReorderFunc = this._system.app.systems.element.getRtlReorder();\n\t\t\tif (rtlReorderFunc) {\n\t\t\t\tconst results = rtlReorderFunc(this._symbols);\n\t\t\t\tthis._rtl = results.rtl;\n\t\t\t\tthis._symbols = results.mapping.map(function (v) {\n\t\t\t\t\treturn this._symbols[v];\n\t\t\t\t}, this);\n\t\t\t\tif (tags) {\n\t\t\t\t\ttags = results.mapping.map(v => {\n\t\t\t\t\t\treturn tags[v];\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.warn('Element created with rtlReorder option but no rtlReorder function registered');\n\t\t\t}\n\t\t} else {\n\t\t\tthis._rtl = false;\n\t\t}\n\t\tconst getColorThicknessHash = (color, thickness) => {\n\t\t\treturn `${color.toString(true).toLowerCase()}:${thickness.toFixed(2)}`;\n\t\t};\n\t\tconst getColorOffsetHash = (color, offset) => {\n\t\t\treturn `${color.toString(true).toLowerCase()}:${offset.x.toFixed(2)}:${offset.y.toFixed(2)}`;\n\t\t};\n\t\tif (tags) {\n\t\t\tconst paletteMap = {};\n\t\t\tconst outlinePaletteMap = {};\n\t\t\tconst shadowPaletteMap = {};\n\t\t\tthis._colorPalette = [Math.round(this._color.r * 255), Math.round(this._color.g * 255), Math.round(this._color.b * 255)];\n\t\t\tthis._outlinePalette = [Math.round(this._outlineColor.r * 255), Math.round(this._outlineColor.g * 255), Math.round(this._outlineColor.b * 255), Math.round(this._outlineColor.a * 255), Math.round(this._outlineThickness * 255)];\n\t\t\tthis._shadowPalette = [Math.round(this._shadowColor.r * 255), Math.round(this._shadowColor.g * 255), Math.round(this._shadowColor.b * 255), Math.round(this._shadowColor.a * 255), Math.round(this._shadowOffset.x * 127), Math.round(this._shadowOffset.y * 127)];\n\t\t\tthis._symbolColors = [];\n\t\t\tthis._symbolOutlineParams = [];\n\t\t\tthis._symbolShadowParams = [];\n\t\t\tpaletteMap[this._color.toString(false).toLowerCase()] = 0;\n\t\t\toutlinePaletteMap[getColorThicknessHash(this._outlineColor, this._outlineThickness)] = 0;\n\t\t\tshadowPaletteMap[getColorOffsetHash(this._shadowColor, this._shadowOffset)] = 0;\n\t\t\tfor (let i = 0, len = this._symbols.length; i < len; ++i) {\n\t\t\t\tconst tag = tags[i];\n\t\t\t\tlet color = 0;\n\t\t\t\tif (tag && tag.color && tag.color.value) {\n\t\t\t\t\tconst c = tag.color.value;\n\t\t\t\t\tif (c.length === 7 && c[0] === '#') {\n\t\t\t\t\t\tconst hex = c.substring(1).toLowerCase();\n\t\t\t\t\t\tif (paletteMap.hasOwnProperty(hex)) {\n\t\t\t\t\t\t\tcolor = paletteMap[hex];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (/^[0-9a-f]{6}$/.test(hex)) {\n\t\t\t\t\t\t\t\tcolor = this._colorPalette.length / 3;\n\t\t\t\t\t\t\t\tpaletteMap[hex] = color;\n\t\t\t\t\t\t\t\tthis._colorPalette.push(parseInt(hex.substring(0, 2), 16));\n\t\t\t\t\t\t\t\tthis._colorPalette.push(parseInt(hex.substring(2, 4), 16));\n\t\t\t\t\t\t\t\tthis._colorPalette.push(parseInt(hex.substring(4, 6), 16));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._symbolColors.push(color);\n\t\t\t\tlet outline = 0;\n\t\t\t\tif (tag && tag.outline && (tag.outline.attributes.color || tag.outline.attributes.thickness)) {\n\t\t\t\t\tlet _color = tag.outline.attributes.color ? colorTmp.fromString(tag.outline.attributes.color) : this._outlineColor;\n\t\t\t\t\tlet thickness = Number(tag.outline.attributes.thickness);\n\t\t\t\t\tif (Number.isNaN(_color.r) || Number.isNaN(_color.g) || Number.isNaN(_color.b) || Number.isNaN(_color.a)) {\n\t\t\t\t\t\t_color = this._outlineColor;\n\t\t\t\t\t}\n\t\t\t\t\tif (Number.isNaN(thickness)) {\n\t\t\t\t\t\tthickness = this._outlineThickness;\n\t\t\t\t\t}\n\t\t\t\t\tconst outlineHash = getColorThicknessHash(_color, thickness);\n\t\t\t\t\tif (outlinePaletteMap.hasOwnProperty(outlineHash)) {\n\t\t\t\t\t\toutline = outlinePaletteMap[outlineHash];\n\t\t\t\t\t} else {\n\t\t\t\t\t\toutline = this._outlinePalette.length / 5;\n\t\t\t\t\t\toutlinePaletteMap[outlineHash] = outline;\n\t\t\t\t\t\tthis._outlinePalette.push(Math.round(_color.r * 255), Math.round(_color.g * 255), Math.round(_color.b * 255), Math.round(_color.a * 255), Math.round(thickness * 255));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._symbolOutlineParams.push(outline);\n\t\t\t\tlet shadow = 0;\n\t\t\t\tif (tag && tag.shadow && (tag.shadow.attributes.color || tag.shadow.attributes.offset || tag.shadow.attributes.offsetX || tag.shadow.attributes.offsetY)) {\n\t\t\t\t\tlet _color2 = tag.shadow.attributes.color ? colorTmp.fromString(tag.shadow.attributes.color) : this._shadowColor;\n\t\t\t\t\tconst off = Number(tag.shadow.attributes.offset);\n\t\t\t\t\tconst offX = Number(tag.shadow.attributes.offsetX);\n\t\t\t\t\tconst offY = Number(tag.shadow.attributes.offsetY);\n\t\t\t\t\tif (Number.isNaN(_color2.r) || Number.isNaN(_color2.g) || Number.isNaN(_color2.b) || Number.isNaN(_color2.a)) {\n\t\t\t\t\t\t_color2 = this._shadowColor;\n\t\t\t\t\t}\n\t\t\t\t\tconst offset = vec2Tmp.set(!Number.isNaN(offX) ? offX : !Number.isNaN(off) ? off : this._shadowOffset.x, !Number.isNaN(offY) ? offY : !Number.isNaN(off) ? off : this._shadowOffset.y);\n\t\t\t\t\tconst shadowHash = getColorOffsetHash(_color2, offset);\n\t\t\t\t\tif (shadowPaletteMap.hasOwnProperty(shadowHash)) {\n\t\t\t\t\t\tshadow = shadowPaletteMap[shadowHash];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tshadow = this._shadowPalette.length / 6;\n\t\t\t\t\t\tshadowPaletteMap[shadowHash] = shadow;\n\t\t\t\t\t\tthis._shadowPalette.push(Math.round(_color2.r * 255), Math.round(_color2.g * 255), Math.round(_color2.b * 255), Math.round(_color2.a * 255), Math.round(offset.x * 127), Math.round(offset.y * 127));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._symbolShadowParams.push(shadow);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._colorPalette = [];\n\t\t\tthis._symbolColors = null;\n\t\t\tthis._symbolOutlineParams = null;\n\t\t\tthis._symbolShadowParams = null;\n\t\t}\n\t\tthis._updateMaterialEmissive();\n\t\tthis._updateMaterialOutline();\n\t\tthis._updateMaterialShadow();\n\t\tconst charactersPerTexture = this._calculateCharsPerTexture();\n\t\tlet removedModel = false;\n\t\tconst element = this._element;\n\t\tconst screenSpace = element._isScreenSpace();\n\t\tconst screenCulled = element._isScreenCulled();\n\t\tconst visibleFn = function visibleFn(camera) {\n\t\t\treturn element.isVisibleForCamera(camera);\n\t\t};\n\t\tfor (let i = 0, len = this._meshInfo.length; i < len; i++) {\n\t\t\tconst l = charactersPerTexture[i] || 0;\n\t\t\tconst meshInfo = this._meshInfo[i];\n\t\t\tif (meshInfo.count !== l) {\n\t\t\t\tif (!removedModel) {\n\t\t\t\t\telement.removeModelFromLayers(this._model);\n\t\t\t\t\tremovedModel = true;\n\t\t\t\t}\n\t\t\t\tmeshInfo.count = l;\n\t\t\t\tmeshInfo.positions.length = meshInfo.normals.length = l * 3 * 4;\n\t\t\t\tmeshInfo.indices.length = l * 3 * 2;\n\t\t\t\tmeshInfo.uvs.length = l * 2 * 4;\n\t\t\t\tmeshInfo.colors.length = l * 4 * 4;\n\t\t\t\tmeshInfo.outlines.length = l * 4 * 3;\n\t\t\t\tmeshInfo.shadows.length = l * 4 * 3;\n\t\t\t\tif (meshInfo.meshInstance) {\n\t\t\t\t\tthis._removeMeshInstance(meshInfo.meshInstance);\n\t\t\t\t}\n\t\t\t\tif (l === 0) {\n\t\t\t\t\tmeshInfo.meshInstance = null;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (let v = 0; v < l; v++) {\n\t\t\t\t\tmeshInfo.indices[v * 3 * 2 + 0] = v * 4;\n\t\t\t\t\tmeshInfo.indices[v * 3 * 2 + 1] = v * 4 + 1;\n\t\t\t\t\tmeshInfo.indices[v * 3 * 2 + 2] = v * 4 + 3;\n\t\t\t\t\tmeshInfo.indices[v * 3 * 2 + 3] = v * 4 + 2;\n\t\t\t\t\tmeshInfo.indices[v * 3 * 2 + 4] = v * 4 + 3;\n\t\t\t\t\tmeshInfo.indices[v * 3 * 2 + 5] = v * 4 + 1;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 0] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 1] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 2] = -1;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 3] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 4] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 5] = -1;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 6] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 7] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 8] = -1;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 9] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 10] = 0;\n\t\t\t\t\tmeshInfo.normals[v * 4 * 3 + 11] = -1;\n\t\t\t\t}\n\t\t\t\tconst mesh = createTextMesh(this._system.app.graphicsDevice, meshInfo);\n\t\t\t\tconst mi = new MeshInstance(mesh, this._material, this._node);\n\t\t\t\tmi.name = `Text Element: ${this._entity.name}`;\n\t\t\t\tmi.castShadow = false;\n\t\t\t\tmi.receiveShadow = false;\n\t\t\t\tmi.cull = !screenSpace;\n\t\t\t\tmi.screenSpace = screenSpace;\n\t\t\t\tmi.drawOrder = this._drawOrder;\n\t\t\t\tif (screenCulled) {\n\t\t\t\t\tmi.cull = true;\n\t\t\t\t\tmi.isVisibleFunc = visibleFn;\n\t\t\t\t}\n\t\t\t\tthis._setTextureParams(mi, this._font.textures[i]);\n\t\t\t\tmi.setParameter('material_emissive', this._colorUniform);\n\t\t\t\tmi.setParameter('material_opacity', this._color.a);\n\t\t\t\tmi.setParameter('font_sdfIntensity', this._font.intensity);\n\t\t\t\tmi.setParameter('font_pxrange', this._getPxRange(this._font));\n\t\t\t\tmi.setParameter('font_textureWidth', this._font.data.info.maps[i].width);\n\t\t\t\tmi.setParameter('outline_color', this._outlineColorUniform);\n\t\t\t\tmi.setParameter('outline_thickness', this._outlineThicknessScale * this._outlineThickness);\n\t\t\t\tmi.setParameter('shadow_color', this._shadowColorUniform);\n\t\t\t\tif (this._symbolShadowParams) {\n\t\t\t\t\tthis._shadowOffsetUniform[0] = 0;\n\t\t\t\t\tthis._shadowOffsetUniform[1] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tconst ratio = -this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;\n\t\t\t\t\tthis._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;\n\t\t\t\t\tthis._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;\n\t\t\t\t}\n\t\t\t\tmi.setParameter('shadow_offset', this._shadowOffsetUniform);\n\t\t\t\tmeshInfo.meshInstance = mi;\n\t\t\t\tthis._model.meshInstances.push(mi);\n\t\t\t}\n\t\t}\n\t\tif (this._element.maskedBy) {\n\t\t\tthis._element._setMaskedBy(this._element.maskedBy);\n\t\t}\n\t\tif (removedModel && this._element.enabled && this._entity.enabled) {\n\t\t\tthis._element.addModelToLayers(this._model);\n\t\t}\n\t\tthis._updateMeshes();\n\t\tthis._rangeStart = 0;\n\t\tthis._rangeEnd = this._symbols.length;\n\t\tthis._updateRenderRange();\n\t}\n\t_removeMeshInstance(meshInstance) {\n\t\tmeshInstance.destroy();\n\t\tconst idx = this._model.meshInstances.indexOf(meshInstance);\n\t\tif (idx !== -1) {\n\t\t\tthis._model.meshInstances.splice(idx, 1);\n\t\t}\n\t}\n\t_setMaterial(material) {\n\t\tthis._material = material;\n\t\tif (this._model) {\n\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\tmi.material = material;\n\t\t\t}\n\t\t}\n\t}\n\t_updateMaterial(screenSpace) {\n\t\tconst element = this._element;\n\t\tconst screenCulled = element._isScreenCulled();\n\t\tconst visibleFn = function visibleFn(camera) {\n\t\t\treturn element.isVisibleForCamera(camera);\n\t\t};\n\t\tconst msdf = this._font && this._font.type === FONT_MSDF;\n\t\tthis._material = this._system.getTextElementMaterial(screenSpace, msdf, this._enableMarkup);\n\t\tif (this._model) {\n\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\tmi.cull = !screenSpace;\n\t\t\t\tmi.material = this._material;\n\t\t\t\tmi.screenSpace = screenSpace;\n\t\t\t\tif (screenCulled) {\n\t\t\t\t\tmi.cull = true;\n\t\t\t\t\tmi.isVisibleFunc = visibleFn;\n\t\t\t\t} else {\n\t\t\t\t\tmi.isVisibleFunc = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t_updateMaterialEmissive() {\n\t\tif (this._symbolColors) {\n\t\t\tthis._colorUniform[0] = 1;\n\t\t\tthis._colorUniform[1] = 1;\n\t\t\tthis._colorUniform[2] = 1;\n\t\t} else {\n\t\t\tthis._colorUniform[0] = this._color.r;\n\t\t\tthis._colorUniform[1] = this._color.g;\n\t\t\tthis._colorUniform[2] = this._color.b;\n\t\t}\n\t}\n\t_updateMaterialOutline() {\n\t\tif (this._symbolOutlineParams) {\n\t\t\tthis._outlineColorUniform[0] = 0;\n\t\t\tthis._outlineColorUniform[1] = 0;\n\t\t\tthis._outlineColorUniform[2] = 0;\n\t\t\tthis._outlineColorUniform[3] = 1;\n\t\t} else {\n\t\t\tthis._outlineColorUniform[0] = this._outlineColor.r;\n\t\t\tthis._outlineColorUniform[1] = this._outlineColor.g;\n\t\t\tthis._outlineColorUniform[2] = this._outlineColor.b;\n\t\t\tthis._outlineColorUniform[3] = this._outlineColor.a;\n\t\t}\n\t}\n\t_updateMaterialShadow() {\n\t\tif (this._symbolOutlineParams) {\n\t\t\tthis._shadowColorUniform[0] = 0;\n\t\t\tthis._shadowColorUniform[1] = 0;\n\t\t\tthis._shadowColorUniform[2] = 0;\n\t\t\tthis._shadowColorUniform[3] = 0;\n\t\t} else {\n\t\t\tthis._shadowColorUniform[0] = this._shadowColor.r;\n\t\t\tthis._shadowColorUniform[1] = this._shadowColor.g;\n\t\t\tthis._shadowColorUniform[2] = this._shadowColor.b;\n\t\t\tthis._shadowColorUniform[3] = this._shadowColor.a;\n\t\t}\n\t}\n\t_isWordBoundary(char) {\n\t\treturn WORD_BOUNDARY_CHAR.test(char);\n\t}\n\t_isValidNextChar(nextchar) {\n\t\treturn nextchar !== null && !NO_LINE_BREAK_CJK_CHAR.test(nextchar);\n\t}\n\t_isNextCJKBoundary(char, nextchar) {\n\t\treturn CJK_CHAR.test(char) && (WORD_BOUNDARY_CHAR.test(nextchar) || ALPHANUMERIC_CHAR.test(nextchar));\n\t}\n\t_isNextCJKWholeWord(nextchar) {\n\t\treturn CJK_CHAR.test(nextchar);\n\t}\n\t_updateMeshes() {\n\t\tconst json = this._font.data;\n\t\tconst self = this;\n\t\tconst minFont = Math.min(this._minFontSize, this._maxFontSize);\n\t\tconst maxFont = this._maxFontSize;\n\t\tconst autoFit = this._shouldAutoFit();\n\t\tif (autoFit) {\n\t\t\tthis._fontSize = this._maxFontSize;\n\t\t}\n\t\tconst MAGIC = 32;\n\t\tconst l = this._symbols.length;\n\t\tlet _x = 0;\n\t\tlet _y = 0;\n\t\tlet _z = 0;\n\t\tlet _xMinusTrailingWhitespace = 0;\n\t\tlet lines = 1;\n\t\tlet wordStartX = 0;\n\t\tlet wordStartIndex = 0;\n\t\tlet lineStartIndex = 0;\n\t\tlet numWordsThisLine = 0;\n\t\tlet numCharsThisLine = 0;\n\t\tlet numBreaksThisLine = 0;\n\t\tconst splitHorizontalAnchors = Math.abs(this._element.anchor.x - this._element.anchor.z) >= 0.0001;\n\t\tlet maxLineWidth = this._element.calculatedWidth;\n\t\tif (this.autoWidth && !splitHorizontalAnchors || !this._wrapLines) {\n\t\t\tmaxLineWidth = Number.POSITIVE_INFINITY;\n\t\t}\n\t\tlet fontMinY = 0;\n\t\tlet fontMaxY = 0;\n\t\tlet char, data, quad, nextchar;\n\t\tfunction breakLine(symbols, lineBreakIndex, lineBreakX) {\n\t\t\tself._lineWidths.push(Math.abs(lineBreakX));\n\t\t\tconst sliceStart = lineStartIndex > lineBreakIndex ? lineBreakIndex + 1 : lineStartIndex;\n\t\t\tconst sliceEnd = lineStartIndex > lineBreakIndex ? lineStartIndex + 1 : lineBreakIndex;\n\t\t\tconst chars = symbols.slice(sliceStart, sliceEnd);\n\t\t\tif (numBreaksThisLine) {\n\t\t\t\tlet i = chars.length;\n\t\t\t\twhile (i-- && numBreaksThisLine > 0) {\n\t\t\t\t\tif (LINE_BREAK_CHAR.test(chars[i])) {\n\t\t\t\t\t\tchars.splice(i, 1);\n\t\t\t\t\t\tnumBreaksThisLine--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tself._lineContents.push(chars.join(''));\n\t\t\t_x = 0;\n\t\t\t_y -= self._scaledLineHeight;\n\t\t\tlines++;\n\t\t\tnumWordsThisLine = 0;\n\t\t\tnumCharsThisLine = 0;\n\t\t\tnumBreaksThisLine = 0;\n\t\t\twordStartX = 0;\n\t\t\tlineStartIndex = lineBreakIndex;\n\t\t}\n\t\tlet retryUpdateMeshes = true;\n\t\twhile (retryUpdateMeshes) {\n\t\t\tretryUpdateMeshes = false;\n\t\t\tif (autoFit) {\n\t\t\t\tthis._scaledLineHeight = this._lineHeight * this._fontSize / (this._maxFontSize || 0.0001);\n\t\t\t} else {\n\t\t\t\tthis._scaledLineHeight = this._lineHeight;\n\t\t\t}\n\t\t\tthis.width = 0;\n\t\t\tthis.height = 0;\n\t\t\tthis._lineWidths = [];\n\t\t\tthis._lineContents = [];\n\t\t\t_x = 0;\n\t\t\t_y = 0;\n\t\t\t_z = 0;\n\t\t\t_xMinusTrailingWhitespace = 0;\n\t\t\tlines = 1;\n\t\t\twordStartX = 0;\n\t\t\twordStartIndex = 0;\n\t\t\tlineStartIndex = 0;\n\t\t\tnumWordsThisLine = 0;\n\t\t\tnumCharsThisLine = 0;\n\t\t\tnumBreaksThisLine = 0;\n\t\t\tconst scale = this._fontSize / MAGIC;\n\t\t\tfontMinY = this._fontMinY * scale;\n\t\t\tfontMaxY = this._fontMaxY * scale;\n\t\t\tfor (let i = 0; i < this._meshInfo.length; i++) {\n\t\t\t\tthis._meshInfo[i].quad = 0;\n\t\t\t\tthis._meshInfo[i].lines = {};\n\t\t\t}\n\t\t\tlet color_r = 255;\n\t\t\tlet color_g = 255;\n\t\t\tlet color_b = 255;\n\t\t\tlet outline_color_rg = 255 + 255 * 256;\n\t\t\tlet outline_color_ba = 255 + 255 * 256;\n\t\t\tlet outline_thickness = 0;\n\t\t\tlet shadow_color_rg = 255 + 255 * 256;\n\t\t\tlet shadow_color_ba = 255 + 255 * 256;\n\t\t\tlet shadow_offset_xy = 127 + 127 * 256;\n\t\t\tfor (let i = 0; i < l; i++) {\n\t\t\t\tchar = this._symbols[i];\n\t\t\t\tnextchar = i + 1 >= l ? null : this._symbols[i + 1];\n\t\t\t\tconst isLineBreak = LINE_BREAK_CHAR.test(char);\n\t\t\t\tif (isLineBreak) {\n\t\t\t\t\tnumBreaksThisLine++;\n\t\t\t\t\tif (!this._wrapLines || this._maxLines < 0 || lines < this._maxLines) {\n\t\t\t\t\t\tbreakLine(this._symbols, i, _xMinusTrailingWhitespace);\n\t\t\t\t\t\twordStartIndex = i + 1;\n\t\t\t\t\t\tlineStartIndex = i + 1;\n\t\t\t\t\t}\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlet x = 0;\n\t\t\t\tlet y = 0;\n\t\t\t\tlet advance = 0;\n\t\t\t\tlet quadsize = 1;\n\t\t\t\tlet dataScale, size;\n\t\t\t\tdata = json.chars[char];\n\t\t\t\tif (!data) {\n\t\t\t\t\tif (CONTROL_CHARS.indexOf(char) !== -1) {\n\t\t\t\t\t\tdata = CONTROL_GLYPH_DATA;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (json.chars[' ']) {\n\t\t\t\t\t\t\tdata = json.chars[' '];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfor (const key in json.chars) {\n\t\t\t\t\t\t\t\tdata = json.chars[key];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (data) {\n\t\t\t\t\tlet kerning = 0;\n\t\t\t\t\tif (numCharsThisLine > 0) {\n\t\t\t\t\t\tconst kernTable = this._font.data.kerning;\n\t\t\t\t\t\tif (kernTable) {\n\t\t\t\t\t\t\tconst kernLeft = kernTable[string.getCodePoint(this._symbols[i - 1]) || 0];\n\t\t\t\t\t\t\tif (kernLeft) {\n\t\t\t\t\t\t\t\tkerning = kernLeft[string.getCodePoint(this._symbols[i]) || 0] || 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdataScale = data.scale || 1;\n\t\t\t\t\tsize = (data.width + data.height) / 2;\n\t\t\t\t\tquadsize = scale * size / dataScale;\n\t\t\t\t\tadvance = (data.xadvance + kerning) * scale;\n\t\t\t\t\tx = (data.xoffset - kerning) * scale;\n\t\t\t\t\ty = data.yoffset * scale;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(`Couldn't substitute missing character: '${char}'`);\n\t\t\t\t}\n\t\t\t\tconst isWhitespace = WHITESPACE_CHAR.test(char);\n\t\t\t\tconst meshInfoId = data && data.map || 0;\n\t\t\t\tconst ratio = -this._font.data.info.maps[meshInfoId].width / this._font.data.info.maps[meshInfoId].height;\n\t\t\t\tconst meshInfo = this._meshInfo[meshInfoId];\n\t\t\t\tconst candidateLineWidth = _x + this._spacing * advance;\n\t\t\t\tif (candidateLineWidth > maxLineWidth && numCharsThisLine > 0 && !isWhitespace) {\n\t\t\t\t\tif (this._maxLines < 0 || lines < this._maxLines) {\n\t\t\t\t\t\tif (numWordsThisLine === 0) {\n\t\t\t\t\t\t\twordStartIndex = i;\n\t\t\t\t\t\t\tbreakLine(this._symbols, i, _xMinusTrailingWhitespace);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst backtrack = Math.max(i - wordStartIndex, 0);\n\t\t\t\t\t\t\tif (this._meshInfo.length <= 1) {\n\t\t\t\t\t\t\t\tmeshInfo.lines[lines - 1] -= backtrack;\n\t\t\t\t\t\t\t\tmeshInfo.quad -= backtrack;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tconst backtrackStart = wordStartIndex;\n\t\t\t\t\t\t\t\tconst backtrackEnd = i;\n\t\t\t\t\t\t\t\tfor (let j = backtrackStart; j < backtrackEnd; j++) {\n\t\t\t\t\t\t\t\t\tconst backChar = this._symbols[j];\n\t\t\t\t\t\t\t\t\tconst backCharData = json.chars[backChar];\n\t\t\t\t\t\t\t\t\tconst backMeshInfo = this._meshInfo[backCharData && backCharData.map || 0];\n\t\t\t\t\t\t\t\t\tbackMeshInfo.lines[lines - 1] -= 1;\n\t\t\t\t\t\t\t\t\tbackMeshInfo.quad -= 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti -= backtrack + 1;\n\t\t\t\t\t\t\tbreakLine(this._symbols, wordStartIndex, wordStartX);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tquad = meshInfo.quad;\n\t\t\t\tmeshInfo.lines[lines - 1] = quad;\n\t\t\t\tlet left = _x - x;\n\t\t\t\tlet right = left + quadsize;\n\t\t\t\tconst bottom = _y - y;\n\t\t\t\tconst top = bottom + quadsize;\n\t\t\t\tif (this._rtl) {\n\t\t\t\t\tconst shift = quadsize - x - this._spacing * advance - x;\n\t\t\t\t\tleft -= shift;\n\t\t\t\t\tright -= shift;\n\t\t\t\t}\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 0] = left;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 1] = bottom;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 2] = _z;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 3] = right;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 4] = bottom;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 5] = _z;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 6] = right;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 7] = top;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 8] = _z;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 9] = left;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 10] = top;\n\t\t\t\tmeshInfo.positions[quad * 4 * 3 + 11] = _z;\n\t\t\t\tthis.width = Math.max(this.width, candidateLineWidth);\n\t\t\t\tlet fontSize;\n\t\t\t\tif (this._shouldAutoFitWidth() && this.width > this._element.calculatedWidth) {\n\t\t\t\t\tfontSize = Math.floor(this._element.fontSize * this._element.calculatedWidth / (this.width || 0.0001));\n\t\t\t\t\tfontSize = math.clamp(fontSize, minFont, maxFont);\n\t\t\t\t\tif (fontSize !== this._element.fontSize) {\n\t\t\t\t\t\tthis._fontSize = fontSize;\n\t\t\t\t\t\tretryUpdateMeshes = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.height = Math.max(this.height, fontMaxY - (_y + fontMinY));\n\t\t\t\tif (this._shouldAutoFitHeight() && this.height > this._element.calculatedHeight) {\n\t\t\t\t\tfontSize = math.clamp(this._fontSize - 1, minFont, maxFont);\n\t\t\t\t\tif (fontSize !== this._element.fontSize) {\n\t\t\t\t\t\tthis._fontSize = fontSize;\n\t\t\t\t\t\tretryUpdateMeshes = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t_x += this._spacing * advance;\n\t\t\t\tif (!isWhitespace) {\n\t\t\t\t\t_xMinusTrailingWhitespace = _x;\n\t\t\t\t}\n\t\t\t\tif (this._isWordBoundary(char) || this._isValidNextChar(nextchar) && (this._isNextCJKBoundary(char, nextchar) || this._isNextCJKWholeWord(nextchar))) {\n\t\t\t\t\tnumWordsThisLine++;\n\t\t\t\t\twordStartX = _xMinusTrailingWhitespace;\n\t\t\t\t\twordStartIndex = i + 1;\n\t\t\t\t}\n\t\t\t\tnumCharsThisLine++;\n\t\t\t\tconst uv = this._getUv(char);\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 0] = uv[0];\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 1] = 1.0 - uv[1];\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 2] = uv[2];\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 3] = 1.0 - uv[1];\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 4] = uv[2];\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 5] = 1.0 - uv[3];\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 6] = uv[0];\n\t\t\t\tmeshInfo.uvs[quad * 4 * 2 + 7] = 1.0 - uv[3];\n\t\t\t\tif (this._symbolColors) {\n\t\t\t\t\tconst colorIdx = this._symbolColors[i] * 3;\n\t\t\t\t\tcolor_r = this._colorPalette[colorIdx];\n\t\t\t\t\tcolor_g = this._colorPalette[colorIdx + 1];\n\t\t\t\t\tcolor_b = this._colorPalette[colorIdx + 2];\n\t\t\t\t}\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 0] = color_r;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 1] = color_g;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 2] = color_b;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 3] = 255;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 4] = color_r;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 5] = color_g;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 6] = color_b;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 7] = 255;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 8] = color_r;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 9] = color_g;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 10] = color_b;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 11] = 255;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 12] = color_r;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 13] = color_g;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 14] = color_b;\n\t\t\t\tmeshInfo.colors[quad * 4 * 4 + 15] = 255;\n\t\t\t\tif (this._symbolOutlineParams) {\n\t\t\t\t\tconst outlineIdx = this._symbolOutlineParams[i] * 5;\n\t\t\t\t\toutline_color_rg = this._outlinePalette[outlineIdx] + this._outlinePalette[outlineIdx + 1] * 256;\n\t\t\t\t\toutline_color_ba = this._outlinePalette[outlineIdx + 2] + this._outlinePalette[outlineIdx + 3] * 256;\n\t\t\t\t\toutline_thickness = this._outlinePalette[outlineIdx + 4];\n\t\t\t\t}\n\t\t\t\tmeshInfo.outlines[quad * 4 * 3 + 0] = outline_color_rg;\n\t\t\t\tmeshInfo.outlines[quad * 4 * 3 + 1] = outline_color_ba;\n\t\t\t\tmeshInfo.outlines[quad * 4 * 3 + 2] = outline_thickness;\n\t\t\t\tmeshInfo.outlines[quad * 4 * 3 + 3] = outline_color_rg;\n\t\t\t\tmeshInfo.outlines[quad * 4 * 3 + 4] = outline_color_ba;\n\t\t\t\tmeshInfo.outlines[quad * 4 * 3 + 5] = outline_thickness;\n\t\t\t\tmeshInfo.outlines[quad * 4 * 3 + 6] = outline_color_rg;\n\t\t\t\tmeshInfo.outlines[quad * 4 * 3 + 7] = outline_color_ba;\n\t\t\t\tmeshInfo.outlines[quad * 4 * 3 + 8] = outline_thickness;\n\t\t\t\tmeshInfo.outlines[quad * 4 * 3 + 9] = outline_color_rg;\n\t\t\t\tmeshInfo.outlines[quad * 4 * 3 + 10] = outline_color_ba;\n\t\t\t\tmeshInfo.outlines[quad * 4 * 3 + 11] = outline_thickness;\n\t\t\t\tif (this._symbolShadowParams) {\n\t\t\t\t\tconst shadowIdx = this._symbolShadowParams[i] * 6;\n\t\t\t\t\tshadow_color_rg = this._shadowPalette[shadowIdx] + this._shadowPalette[shadowIdx + 1] * 256;\n\t\t\t\t\tshadow_color_ba = this._shadowPalette[shadowIdx + 2] + this._shadowPalette[shadowIdx + 3] * 256;\n\t\t\t\t\tshadow_offset_xy = this._shadowPalette[shadowIdx + 4] + 127 + Math.round(ratio * this._shadowPalette[shadowIdx + 5] + 127) * 256;\n\t\t\t\t}\n\t\t\t\tmeshInfo.shadows[quad * 4 * 3 + 0] = shadow_color_rg;\n\t\t\t\tmeshInfo.shadows[quad * 4 * 3 + 1] = shadow_color_ba;\n\t\t\t\tmeshInfo.shadows[quad * 4 * 3 + 2] = shadow_offset_xy;\n\t\t\t\tmeshInfo.shadows[quad * 4 * 3 + 3] = shadow_color_rg;\n\t\t\t\tmeshInfo.shadows[quad * 4 * 3 + 4] = shadow_color_ba;\n\t\t\t\tmeshInfo.shadows[quad * 4 * 3 + 5] = shadow_offset_xy;\n\t\t\t\tmeshInfo.shadows[quad * 4 * 3 + 6] = shadow_color_rg;\n\t\t\t\tmeshInfo.shadows[quad * 4 * 3 + 7] = shadow_color_ba;\n\t\t\t\tmeshInfo.shadows[quad * 4 * 3 + 8] = shadow_offset_xy;\n\t\t\t\tmeshInfo.shadows[quad * 4 * 3 + 9] = shadow_color_rg;\n\t\t\t\tmeshInfo.shadows[quad * 4 * 3 + 10] = shadow_color_ba;\n\t\t\t\tmeshInfo.shadows[quad * 4 * 3 + 11] = shadow_offset_xy;\n\t\t\t\tmeshInfo.quad++;\n\t\t\t}\n\t\t\tif (retryUpdateMeshes) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (lineStartIndex < l) {\n\t\t\t\tbreakLine(this._symbols, l, _x);\n\t\t\t}\n\t\t}\n\t\tthis._noResize = true;\n\t\tthis.autoWidth = this._autoWidth;\n\t\tthis.autoHeight = this._autoHeight;\n\t\tthis._noResize = false;\n\t\tconst hp = this._element.pivot.x;\n\t\tconst vp = this._element.pivot.y;\n\t\tconst ha = this._alignment.x;\n\t\tconst va = this._alignment.y;\n\t\tfor (let i = 0; i < this._meshInfo.length; i++) {\n\t\t\tif (this._meshInfo[i].count === 0) continue;\n\t\t\tlet prevQuad = 0;\n\t\t\tfor (const line in this._meshInfo[i].lines) {\n\t\t\t\tconst index = this._meshInfo[i].lines[line];\n\t\t\t\tconst lw = this._lineWidths[parseInt(line, 10)];\n\t\t\t\tconst hoffset = -hp * this._element.calculatedWidth + ha * (this._element.calculatedWidth - lw) * (this._rtl ? -1 : 1);\n\t\t\t\tconst voffset = (1 - vp) * this._element.calculatedHeight - fontMaxY - (1 - va) * (this._element.calculatedHeight - this.height);\n\t\t\t\tfor (let _quad = prevQuad; _quad <= index; _quad++) {\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3] += hoffset;\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3 + 3] += hoffset;\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3 + 6] += hoffset;\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3 + 9] += hoffset;\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3 + 1] += voffset;\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3 + 4] += voffset;\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3 + 7] += voffset;\n\t\t\t\t\tthis._meshInfo[i].positions[_quad * 4 * 3 + 10] += voffset;\n\t\t\t\t}\n\t\t\t\tif (this._rtl) {\n\t\t\t\t\tfor (let _quad2 = prevQuad; _quad2 <= index; _quad2++) {\n\t\t\t\t\t\tconst idx = _quad2 * 4 * 3;\n\t\t\t\t\t\tfor (let vert = 0; vert < 4; ++vert) {\n\t\t\t\t\t\t\tthis._meshInfo[i].positions[idx + vert * 3] = this._element.calculatedWidth - this._meshInfo[i].positions[idx + vert * 3] + hoffset * 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst tmp0 = this._meshInfo[i].positions[idx + 3];\n\t\t\t\t\t\tconst tmp1 = this._meshInfo[i].positions[idx + 6];\n\t\t\t\t\t\tthis._meshInfo[i].positions[idx + 3] = this._meshInfo[i].positions[idx + 0];\n\t\t\t\t\t\tthis._meshInfo[i].positions[idx + 6] = this._meshInfo[i].positions[idx + 9];\n\t\t\t\t\t\tthis._meshInfo[i].positions[idx + 0] = tmp0;\n\t\t\t\t\t\tthis._meshInfo[i].positions[idx + 9] = tmp1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprevQuad = index + 1;\n\t\t\t}\n\t\t\tconst numVertices = this._meshInfo[i].count * 4;\n\t\t\tconst vertMax = this._meshInfo[i].quad * 4;\n\t\t\tconst it = new VertexIterator(this._meshInfo[i].meshInstance.mesh.vertexBuffer);\n\t\t\tfor (let v = 0; v < numVertices; v++) {\n\t\t\t\tif (v >= vertMax) {\n\t\t\t\t\tit.element[SEMANTIC_POSITION].set(0, 0, 0);\n\t\t\t\t\tit.element[SEMANTIC_TEXCOORD0].set(0, 0);\n\t\t\t\t\tit.element[SEMANTIC_COLOR].set(0, 0, 0, 0);\n\t\t\t\t\tit.element[SEMANTIC_ATTR8].set(0, 0, 0, 0);\n\t\t\t\t\tit.element[SEMANTIC_ATTR9].set(0, 0, 0, 0);\n\t\t\t\t} else {\n\t\t\t\t\tit.element[SEMANTIC_POSITION].set(this._meshInfo[i].positions[v * 3 + 0], this._meshInfo[i].positions[v * 3 + 1], this._meshInfo[i].positions[v * 3 + 2]);\n\t\t\t\t\tit.element[SEMANTIC_TEXCOORD0].set(this._meshInfo[i].uvs[v * 2 + 0], this._meshInfo[i].uvs[v * 2 + 1]);\n\t\t\t\t\tit.element[SEMANTIC_COLOR].set(this._meshInfo[i].colors[v * 4 + 0], this._meshInfo[i].colors[v * 4 + 1], this._meshInfo[i].colors[v * 4 + 2], this._meshInfo[i].colors[v * 4 + 3]);\n\t\t\t\t\tit.element[SEMANTIC_ATTR8].set(this._meshInfo[i].outlines[v * 3 + 0], this._meshInfo[i].outlines[v * 3 + 1], this._meshInfo[i].outlines[v * 3 + 2]);\n\t\t\t\t\tit.element[SEMANTIC_ATTR9].set(this._meshInfo[i].shadows[v * 3 + 0], this._meshInfo[i].shadows[v * 3 + 1], this._meshInfo[i].shadows[v * 3 + 2]);\n\t\t\t\t}\n\t\t\t\tit.next();\n\t\t\t}\n\t\t\tit.end();\n\t\t\tthis._meshInfo[i].meshInstance.mesh.aabb.compute(this._meshInfo[i].positions);\n\t\t\tthis._meshInfo[i].meshInstance._aabbVer = -1;\n\t\t}\n\t\tthis._aabbDirty = true;\n\t}\n\t_onFontRender() {\n\t\tthis.font = this._font;\n\t}\n\t_onFontLoad(asset) {\n\t\tif (this.font !== asset.resource) {\n\t\t\tthis.font = asset.resource;\n\t\t}\n\t}\n\t_onFontChange(asset, name, _new, _old) {\n\t\tif (name === 'data') {\n\t\t\tthis._font.data = _new;\n\t\t\tconst maps = this._font.data.info.maps.length;\n\t\t\tfor (let i = 0; i < maps; i++) {\n\t\t\t\tif (!this._meshInfo[i]) continue;\n\t\t\t\tconst mi = this._meshInfo[i].meshInstance;\n\t\t\t\tif (mi) {\n\t\t\t\t\tmi.setParameter('font_sdfIntensity', this._font.intensity);\n\t\t\t\t\tmi.setParameter('font_pxrange', this._getPxRange(this._font));\n\t\t\t\t\tmi.setParameter('font_textureWidth', this._font.data.info.maps[i].width);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t_onFontRemove(asset) {}\n\t_setTextureParams(mi, texture) {\n\t\tif (this._font) {\n\t\t\tif (this._font.type === FONT_MSDF) {\n\t\t\t\tmi.deleteParameter('texture_emissiveMap');\n\t\t\t\tmi.deleteParameter('texture_opacityMap');\n\t\t\t\tmi.setParameter('texture_msdfMap', texture);\n\t\t\t} else if (this._font.type === FONT_BITMAP) {\n\t\t\t\tmi.deleteParameter('texture_msdfMap');\n\t\t\t\tmi.setParameter('texture_emissiveMap', texture);\n\t\t\t\tmi.setParameter('texture_opacityMap', texture);\n\t\t\t}\n\t\t}\n\t}\n\t_getPxRange(font) {\n\t\tconst keys = Object.keys(this._font.data.chars);\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tconst char = this._font.data.chars[keys[i]];\n\t\t\tif (char.range) {\n\t\t\t\treturn (char.scale || 1) * char.range;\n\t\t\t}\n\t\t}\n\t\treturn 2;\n\t}\n\t_getUv(char) {\n\t\tconst data = this._font.data;\n\t\tif (!data.chars[char]) {\n\t\t\tconst space = ' ';\n\t\t\tif (data.chars[space]) {\n\t\t\t\treturn this._getUv(space);\n\t\t\t}\n\t\t\treturn [0, 0, 0, 0];\n\t\t}\n\t\tconst map = data.chars[char].map;\n\t\tconst width = data.info.maps[map].width;\n\t\tconst height = data.info.maps[map].height;\n\t\tconst x = data.chars[char].x;\n\t\tconst y = data.chars[char].y;\n\t\tconst x1 = x;\n\t\tconst y1 = y;\n\t\tconst x2 = x + data.chars[char].width;\n\t\tconst y2 = y - data.chars[char].height;\n\t\tconst edge = 1 - data.chars[char].height / height;\n\t\treturn [x1 / width, edge - y1 / height, x2 / width, edge - y2 / height];\n\t}\n\tonEnable() {\n\t\tthis._fontAsset.autoLoad = true;\n\t\tif (this._model) {\n\t\t\tthis._element.addModelToLayers(this._model);\n\t\t}\n\t}\n\tonDisable() {\n\t\tthis._fontAsset.autoLoad = false;\n\t\tif (this._model) {\n\t\t\tthis._element.removeModelFromLayers(this._model);\n\t\t}\n\t}\n\t_setStencil(stencilParams) {\n\t\tif (this._model) {\n\t\t\tconst instances = this._model.meshInstances;\n\t\t\tfor (let i = 0; i < instances.length; i++) {\n\t\t\t\tinstances[i].stencilFront = stencilParams;\n\t\t\t\tinstances[i].stencilBack = stencilParams;\n\t\t\t}\n\t\t}\n\t}\n\t_shouldAutoFitWidth() {\n\t\treturn this._autoFitWidth && !this._autoWidth;\n\t}\n\t_shouldAutoFitHeight() {\n\t\treturn this._autoFitHeight && !this._autoHeight;\n\t}\n\t_shouldAutoFit() {\n\t\treturn this._autoFitWidth && !this._autoWidth || this._autoFitHeight && !this._autoHeight;\n\t}\n\t_calculateCharsPerTexture(symbolIndex) {\n\t\tconst charactersPerTexture = {};\n\t\tif (symbolIndex === undefined) {\n\t\t\tsymbolIndex = this._symbols.length;\n\t\t}\n\t\tfor (let i = 0, len = symbolIndex; i < len; i++) {\n\t\t\tconst char = this._symbols[i];\n\t\t\tlet info = this._font.data.chars[char];\n\t\t\tif (!info) {\n\t\t\t\tinfo = this._font.data.chars[' '];\n\t\t\t\tif (!info) {\n\t\t\t\t\tinfo = this._font.data.chars[Object.keys(this._font.data.chars)[0]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst map = info.map;\n\t\t\tif (!charactersPerTexture[map]) {\n\t\t\t\tcharactersPerTexture[map] = 1;\n\t\t\t} else {\n\t\t\t\tcharactersPerTexture[map]++;\n\t\t\t}\n\t\t}\n\t\treturn charactersPerTexture;\n\t}\n\t_updateRenderRange() {\n\t\tconst startChars = this._rangeStart === 0 ? 0 : this._calculateCharsPerTexture(this._rangeStart);\n\t\tconst endChars = this._rangeEnd === 0 ? 0 : this._calculateCharsPerTexture(this._rangeEnd);\n\t\tfor (let i = 0, len = this._meshInfo.length; i < len; i++) {\n\t\t\tconst start = startChars[i] || 0;\n\t\t\tconst end = endChars[i] || 0;\n\t\t\tconst instance = this._meshInfo[i].meshInstance;\n\t\t\tif (instance) {\n\t\t\t\tconst mesh = instance.mesh;\n\t\t\t\tif (mesh) {\n\t\t\t\t\tmesh.primitive[0].base = start * 3 * 2;\n\t\t\t\t\tmesh.primitive[0].count = (end - start) * 3 * 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tset text(value) {\n\t\tthis._i18nKey = null;\n\t\tconst str = value != null && value.toString() || '';\n\t\tthis._setText(str);\n\t}\n\tget text() {\n\t\treturn this._text;\n\t}\n\tset key(value) {\n\t\tconst str = value !== null ? value.toString() : null;\n\t\tif (this._i18nKey === str) {\n\t\t\treturn;\n\t\t}\n\t\tthis._i18nKey = str;\n\t\tif (str) {\n\t\t\tthis._fontAsset.disableLocalization = false;\n\t\t\tthis._resetLocalizedText();\n\t\t} else {\n\t\t\tthis._fontAsset.disableLocalization = true;\n\t\t}\n\t}\n\tget key() {\n\t\treturn this._i18nKey;\n\t}\n\tset color(value) {\n\t\tconst r = value.r;\n\t\tconst g = value.g;\n\t\tconst b = value.b;\n\t\tif (this._color.r === r && this._color.g === g && this._color.b === b) {\n\t\t\treturn;\n\t\t}\n\t\tthis._color.r = r;\n\t\tthis._color.g = g;\n\t\tthis._color.b = b;\n\t\tif (!this._model) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._symbolColors) {\n\t\t\tif (this._font) {\n\t\t\t\tthis._updateText();\n\t\t\t}\n\t\t} else {\n\t\t\tthis._colorUniform[0] = this._color.r;\n\t\t\tthis._colorUniform[1] = this._color.g;\n\t\t\tthis._colorUniform[2] = this._color.b;\n\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\tmi.setParameter('material_emissive', this._colorUniform);\n\t\t\t}\n\t\t}\n\t\tif (this._element) {\n\t\t\tthis._element.fire('set:color', this._color);\n\t\t}\n\t}\n\tget color() {\n\t\treturn this._color;\n\t}\n\tset opacity(value) {\n\t\tif (this._color.a !== value) {\n\t\t\tthis._color.a = value;\n\t\t\tif (this._model) {\n\t\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\t\tmi.setParameter('material_opacity', value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this._element) {\n\t\t\tthis._element.fire('set:opacity', value);\n\t\t}\n\t}\n\tget opacity() {\n\t\treturn this._color.a;\n\t}\n\tset lineHeight(value) {\n\t\tconst _prev = this._lineHeight;\n\t\tthis._lineHeight = value;\n\t\tthis._scaledLineHeight = value;\n\t\tif (_prev !== value && this._font) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\tget lineHeight() {\n\t\treturn this._lineHeight;\n\t}\n\tset wrapLines(value) {\n\t\tconst _prev = this._wrapLines;\n\t\tthis._wrapLines = value;\n\t\tif (_prev !== value && this._font) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\tget wrapLines() {\n\t\treturn this._wrapLines;\n\t}\n\tget lines() {\n\t\treturn this._lineContents;\n\t}\n\tset spacing(value) {\n\t\tconst _prev = this._spacing;\n\t\tthis._spacing = value;\n\t\tif (_prev !== value && this._font) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\tget spacing() {\n\t\treturn this._spacing;\n\t}\n\tset fontSize(value) {\n\t\tconst _prev = this._fontSize;\n\t\tthis._fontSize = value;\n\t\tthis._originalFontSize = value;\n\t\tif (_prev !== value && this._font) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\tget fontSize() {\n\t\treturn this._fontSize;\n\t}\n\tset fontAsset(value) {\n\t\tthis._fontAsset.defaultAsset = value;\n\t}\n\tget fontAsset() {\n\t\treturn this._fontAsset.localizedAsset;\n\t}\n\tset font(value) {\n\t\tlet previousFontType;\n\t\tif (this._font) {\n\t\t\tpreviousFontType = this._font.type;\n\t\t\tif (this._font.off) this._font.off('render', this._onFontRender, this);\n\t\t}\n\t\tthis._font = value;\n\t\tthis._fontMinY = 0;\n\t\tthis._fontMaxY = 0;\n\t\tif (!value) return;\n\t\tconst json = this._font.data;\n\t\tfor (const charId in json.chars) {\n\t\t\tconst data = json.chars[charId];\n\t\t\tif (data.bounds) {\n\t\t\t\tthis._fontMinY = Math.min(this._fontMinY, data.bounds[1]);\n\t\t\t\tthis._fontMaxY = Math.max(this._fontMaxY, data.bounds[3]);\n\t\t\t}\n\t\t}\n\t\tif (this._font.on) this._font.on('render', this._onFontRender, this);\n\t\tif (this._fontAsset.localizedAsset) {\n\t\t\tconst asset = this._system.app.assets.get(this._fontAsset.localizedAsset);\n\t\t\tif (asset.resource !== this._font) {\n\t\t\t\tthis._fontAsset.defaultAsset = null;\n\t\t\t}\n\t\t}\n\t\tif (value.type !== previousFontType) {\n\t\t\tconst screenSpace = this._element._isScreenSpace();\n\t\t\tthis._updateMaterial(screenSpace);\n\t\t}\n\t\tfor (let i = 0, len = this._font.textures.length; i < len; i++) {\n\t\t\tif (!this._meshInfo[i]) {\n\t\t\t\tthis._meshInfo[i] = new MeshInfo();\n\t\t\t} else {\n\t\t\t\tconst mi = this._meshInfo[i].meshInstance;\n\t\t\t\tif (mi) {\n\t\t\t\t\tmi.setParameter('font_sdfIntensity', this._font.intensity);\n\t\t\t\t\tmi.setParameter('font_pxrange', this._getPxRange(this._font));\n\t\t\t\t\tmi.setParameter('font_textureWidth', this._font.data.info.maps[i].width);\n\t\t\t\t\tthis._setTextureParams(mi, this._font.textures[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet removedModel = false;\n\t\tfor (let i = this._font.textures.length; i < this._meshInfo.length; i++) {\n\t\t\tif (this._meshInfo[i].meshInstance) {\n\t\t\t\tif (!removedModel) {\n\t\t\t\t\tthis._element.removeModelFromLayers(this._model);\n\t\t\t\t\tremovedModel = true;\n\t\t\t\t}\n\t\t\t\tthis._removeMeshInstance(this._meshInfo[i].meshInstance);\n\t\t\t}\n\t\t}\n\t\tif (this._meshInfo.length > this._font.textures.length) {\n\t\t\tthis._meshInfo.length = this._font.textures.length;\n\t\t}\n\t\tthis._updateText();\n\t}\n\tget font() {\n\t\treturn this._font;\n\t}\n\tset alignment(value) {\n\t\tif (value instanceof Vec2) {\n\t\t\tthis._alignment.set(value.x, value.y);\n\t\t} else {\n\t\t\tthis._alignment.set(value[0], value[1]);\n\t\t}\n\t\tif (this._font) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\tget alignment() {\n\t\treturn this._alignment;\n\t}\n\tset autoWidth(value) {\n\t\tconst old = this._autoWidth;\n\t\tthis._autoWidth = value;\n\t\tif (value && Math.abs(this._element.anchor.x - this._element.anchor.z) < 0.0001) {\n\t\t\tthis._element.width = this.width;\n\t\t}\n\t\tif (old !== value) {\n\t\t\tconst newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;\n\t\t\tif (newFontSize !== this._fontSize) {\n\t\t\t\tthis._fontSize = newFontSize;\n\t\t\t\tif (this._font) {\n\t\t\t\t\tthis._updateText();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tget autoWidth() {\n\t\treturn this._autoWidth;\n\t}\n\tset autoHeight(value) {\n\t\tconst old = this._autoHeight;\n\t\tthis._autoHeight = value;\n\t\tif (value && Math.abs(this._element.anchor.y - this._element.anchor.w) < 0.0001) {\n\t\t\tthis._element.height = this.height;\n\t\t}\n\t\tif (old !== value) {\n\t\t\tconst newFontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;\n\t\t\tif (newFontSize !== this._fontSize) {\n\t\t\t\tthis._fontSize = newFontSize;\n\t\t\t\tif (this._font) {\n\t\t\t\t\tthis._updateText();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tget autoHeight() {\n\t\treturn this._autoHeight;\n\t}\n\tset rtlReorder(value) {\n\t\tif (this._rtlReorder !== value) {\n\t\t\tthis._rtlReorder = value;\n\t\t\tif (this._font) {\n\t\t\t\tthis._updateText();\n\t\t\t}\n\t\t}\n\t}\n\tget rtlReorder() {\n\t\treturn this._rtlReorder;\n\t}\n\tset unicodeConverter(value) {\n\t\tif (this._unicodeConverter !== value) {\n\t\t\tthis._unicodeConverter = value;\n\t\t\tthis._setText(this._text);\n\t\t}\n\t}\n\tget unicodeConverter() {\n\t\treturn this._unicodeConverter;\n\t}\n\tget aabb() {\n\t\tif (this._aabbDirty) {\n\t\t\tlet initialized = false;\n\t\t\tfor (let i = 0; i < this._meshInfo.length; i++) {\n\t\t\t\tif (!this._meshInfo[i].meshInstance) continue;\n\t\t\t\tif (!initialized) {\n\t\t\t\t\tthis._aabb.copy(this._meshInfo[i].meshInstance.aabb);\n\t\t\t\t\tinitialized = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis._aabb.add(this._meshInfo[i].meshInstance.aabb);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._aabbDirty = false;\n\t\t}\n\t\treturn this._aabb;\n\t}\n\tset outlineColor(value) {\n\t\tconst r = value instanceof Color ? value.r : value[0];\n\t\tconst g = value instanceof Color ? value.g : value[1];\n\t\tconst b = value instanceof Color ? value.b : value[2];\n\t\tconst a = value instanceof Color ? value.a : value[3];\n\t\tif (this._outlineColor.r === r && this._outlineColor.g === g && this._outlineColor.b === b && this._outlineColor.a === a) {\n\t\t\treturn;\n\t\t}\n\t\tthis._outlineColor.r = r;\n\t\tthis._outlineColor.g = g;\n\t\tthis._outlineColor.b = b;\n\t\tthis._outlineColor.a = a;\n\t\tif (!this._model) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._symbolOutlineParams) {\n\t\t\tif (this._font) {\n\t\t\t\tthis._updateText();\n\t\t\t}\n\t\t} else {\n\t\t\tthis._outlineColorUniform[0] = this._outlineColor.r;\n\t\t\tthis._outlineColorUniform[1] = this._outlineColor.g;\n\t\t\tthis._outlineColorUniform[2] = this._outlineColor.b;\n\t\t\tthis._outlineColorUniform[3] = this._outlineColor.a;\n\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\tmi.setParameter('outline_color', this._outlineColorUniform);\n\t\t\t}\n\t\t}\n\t\tif (this._element) {\n\t\t\tthis._element.fire('set:outline', this._color);\n\t\t}\n\t}\n\tget outlineColor() {\n\t\treturn this._outlineColor;\n\t}\n\tset outlineThickness(value) {\n\t\tconst _prev = this._outlineThickness;\n\t\tthis._outlineThickness = value;\n\t\tif (_prev !== value && this._font) {\n\t\t\tif (!this._model) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._symbolOutlineParams) {\n\t\t\t\tif (this._font) {\n\t\t\t\t\tthis._updateText();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\t\tmi.setParameter('outline_thickness', this._outlineThicknessScale * this._outlineThickness);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tget outlineThickness() {\n\t\treturn this._outlineThickness;\n\t}\n\tset shadowColor(value) {\n\t\tconst r = value instanceof Color ? value.r : value[0];\n\t\tconst g = value instanceof Color ? value.g : value[1];\n\t\tconst b = value instanceof Color ? value.b : value[2];\n\t\tconst a = value instanceof Color ? value.a : value[3];\n\t\tif (this._shadowColor.r === r && this._shadowColor.g === g && this._shadowColor.b === b && this._shadowColor.a === a) {\n\t\t\treturn;\n\t\t}\n\t\tthis._shadowColor.r = r;\n\t\tthis._shadowColor.g = g;\n\t\tthis._shadowColor.b = b;\n\t\tthis._shadowColor.a = a;\n\t\tif (!this._model) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._symbolShadowParams) {\n\t\t\tif (this._font) {\n\t\t\t\tthis._updateText();\n\t\t\t}\n\t\t} else {\n\t\t\tthis._shadowColorUniform[0] = this._shadowColor.r;\n\t\t\tthis._shadowColorUniform[1] = this._shadowColor.g;\n\t\t\tthis._shadowColorUniform[2] = this._shadowColor.b;\n\t\t\tthis._shadowColorUniform[3] = this._shadowColor.a;\n\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\tmi.setParameter('shadow_color', this._shadowColorUniform);\n\t\t\t}\n\t\t}\n\t}\n\tget shadowColor() {\n\t\treturn this._shadowColor;\n\t}\n\tset shadowOffset(value) {\n\t\tconst x = value instanceof Vec2 ? value.x : value[0],\n\t\t\ty = value instanceof Vec2 ? value.y : value[1];\n\t\tif (this._shadowOffset.x === x && this._shadowOffset.y === y) {\n\t\t\treturn;\n\t\t}\n\t\tthis._shadowOffset.set(x, y);\n\t\tif (this._font && this._model) {\n\t\t\tif (this._symbolShadowParams) {\n\t\t\t\tthis._updateText();\n\t\t\t} else {\n\t\t\t\tfor (let i = 0, len = this._model.meshInstances.length; i < len; i++) {\n\t\t\t\t\tconst ratio = -this._font.data.info.maps[i].width / this._font.data.info.maps[i].height;\n\t\t\t\t\tthis._shadowOffsetUniform[0] = this._shadowOffsetScale * this._shadowOffset.x;\n\t\t\t\t\tthis._shadowOffsetUniform[1] = ratio * this._shadowOffsetScale * this._shadowOffset.y;\n\t\t\t\t\tconst mi = this._model.meshInstances[i];\n\t\t\t\t\tmi.setParameter('shadow_offset', this._shadowOffsetUniform);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tget shadowOffset() {\n\t\treturn this._shadowOffset;\n\t}\n\tset minFontSize(value) {\n\t\tif (this._minFontSize === value) return;\n\t\tthis._minFontSize = value;\n\t\tif (this.font && this._shouldAutoFit()) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\tget minFontSize() {\n\t\treturn this._minFontSize;\n\t}\n\tset maxFontSize(value) {\n\t\tif (this._maxFontSize === value) return;\n\t\tthis._maxFontSize = value;\n\t\tif (this.font && this._shouldAutoFit()) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\tget maxFontSize() {\n\t\treturn this._maxFontSize;\n\t}\n\tset autoFitWidth(value) {\n\t\tif (this._autoFitWidth === value) return;\n\t\tthis._autoFitWidth = value;\n\t\tthis._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;\n\t\tif (this.font) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\tget autoFitWidth() {\n\t\treturn this._autoFitWidth;\n\t}\n\tset autoFitHeight(value) {\n\t\tif (this._autoFitHeight === value) return;\n\t\tthis._autoFitHeight = value;\n\t\tthis._fontSize = this._shouldAutoFit() ? this._maxFontSize : this._originalFontSize;\n\t\tif (this.font) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\tget autoFitHeight() {\n\t\treturn this._autoFitHeight;\n\t}\n\tset maxLines(value) {\n\t\tif (this._maxLines === value) return;\n\t\tif (value === null && this._maxLines === -1) return;\n\t\tthis._maxLines = value === null ? -1 : value;\n\t\tif (this.font && this._wrapLines) {\n\t\t\tthis._updateText();\n\t\t}\n\t}\n\tget maxLines() {\n\t\treturn this._maxLines;\n\t}\n\tset enableMarkup(value) {\n\t\tvalue = !!value;\n\t\tif (this._enableMarkup === value) return;\n\t\tthis._enableMarkup = value;\n\t\tif (this.font) {\n\t\t\tthis._updateText();\n\t\t}\n\t\tconst screenSpace = this._element._isScreenSpace();\n\t\tthis._updateMaterial(screenSpace);\n\t}\n\tget enableMarkup() {\n\t\treturn this._enableMarkup;\n\t}\n\tget symbols() {\n\t\treturn this._symbols;\n\t}\n\tget symbolColors() {\n\t\tif (this._symbolColors === null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._symbolColors.map(function (c) {\n\t\t\treturn this._colorPalette.slice(c * 3, c * 3 + 3);\n\t\t}, this);\n\t}\n\tget symbolOutlineParams() {\n\t\tif (this._symbolOutlineParams === null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._symbolOutlineParams.map(function (paramId) {\n\t\t\treturn this._outlinePalette.slice(paramId * 5, paramId * 5 + 5);\n\t\t}, this);\n\t}\n\tget symbolShadowParams() {\n\t\tif (this._symbolShadowParams === null) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._symbolShadowParams.map(function (paramId) {\n\t\t\treturn this._shadowPalette.slice(paramId * 6, paramId * 6 + 6);\n\t\t}, this);\n\t}\n\tget rtl() {\n\t\treturn this._rtl;\n\t}\n\tset rangeStart(rangeStart) {\n\t\trangeStart = Math.max(0, Math.min(rangeStart, this._symbols.length));\n\t\tif (rangeStart !== this._rangeStart) {\n\t\t\tthis._rangeStart = rangeStart;\n\t\t\tthis._updateRenderRange();\n\t\t}\n\t}\n\tget rangeStart() {\n\t\treturn this._rangeStart;\n\t}\n\tset rangeEnd(rangeEnd) {\n\t\trangeEnd = Math.max(this._rangeStart, Math.min(rangeEnd, this._symbols.length));\n\t\tif (rangeEnd !== this._rangeEnd) {\n\t\t\tthis._rangeEnd = rangeEnd;\n\t\t\tthis._updateRenderRange();\n\t\t}\n\t}\n\tget rangeEnd() {\n\t\treturn this._rangeEnd;\n\t}\n}\n\nexport { TextElement };\n","import { LAYERID_WORLD } from '../../../scene/constants.js';\nimport { Asset } from '../../asset/asset.js';\nimport { AssetReference } from '../../asset/asset-reference.js';\nimport { Component } from '../component.js';\n\nclass GSplatComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._layers = [LAYERID_WORLD];\n\t\tthis._instance = null;\n\t\tthis._customAabb = null;\n\t\tthis._assetReference = void 0;\n\t\tthis._materialOptions = null;\n\t\tthis._evtLayersChanged = null;\n\t\tthis._evtLayerAdded = null;\n\t\tthis._evtLayerRemoved = null;\n\t\tthis._assetReference = new AssetReference('asset', this, system.app.assets, {\n\t\t\tadd: this._onGSplatAssetAdded,\n\t\t\tload: this._onGSplatAssetLoad,\n\t\t\tremove: this._onGSplatAssetRemove,\n\t\t\tunload: this._onGSplatAssetUnload\n\t\t}, this);\n\t\tentity.on('remove', this.onRemoveChild, this);\n\t\tentity.on('removehierarchy', this.onRemoveChild, this);\n\t\tentity.on('insert', this.onInsertChild, this);\n\t\tentity.on('inserthierarchy', this.onInsertChild, this);\n\t}\n\tset customAabb(value) {\n\t\tvar _this$_instance;\n\t\tthis._customAabb = value;\n\t\t(_this$_instance = this._instance) == null || (_this$_instance = _this$_instance.meshInstance) == null || _this$_instance.setCustomAabb(this._customAabb);\n\t}\n\tget customAabb() {\n\t\treturn this._customAabb;\n\t}\n\tset instance(value) {\n\t\tvar _this$_instance2;\n\t\tthis.destroyInstance();\n\t\tthis._instance = value;\n\t\tif ((_this$_instance2 = this._instance) != null && _this$_instance2.meshInstance) {\n\t\t\tconst mi = this._instance.meshInstance;\n\t\t\tif (!mi.node) {\n\t\t\t\tmi.node = this.entity;\n\t\t\t}\n\t\t\tmi.setCustomAabb(this._customAabb);\n\t\t\tif (this._materialOptions) {\n\t\t\t\tthis._instance.createMaterial(this._materialOptions);\n\t\t\t}\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis.addToLayers();\n\t\t\t}\n\t\t}\n\t}\n\tget instance() {\n\t\treturn this._instance;\n\t}\n\tset materialOptions(value) {\n\t\tthis._materialOptions = Object.assign({}, value);\n\t\tif (this._instance) {\n\t\t\tthis._instance.createMaterial(this._materialOptions);\n\t\t}\n\t}\n\tget materialOptions() {\n\t\treturn this._materialOptions;\n\t}\n\tget material() {\n\t\tvar _this$_instance3;\n\t\treturn (_this$_instance3 = this._instance) == null ? void 0 : _this$_instance3.material;\n\t}\n\tset layers(value) {\n\t\tthis.removeFromLayers();\n\t\tthis._layers.length = 0;\n\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\tthis._layers[i] = value[i];\n\t\t}\n\t\tif (!this.enabled || !this.entity.enabled) {\n\t\t\treturn;\n\t\t}\n\t\tthis.addToLayers();\n\t}\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\tset asset(value) {\n\t\tconst id = value instanceof Asset ? value.id : value;\n\t\tif (this._assetReference.id === id) return;\n\t\tif (this._assetReference.asset && this._assetReference.asset.resource) {\n\t\t\tthis._onGSplatAssetRemove();\n\t\t}\n\t\tthis._assetReference.id = id;\n\t\tif (this._assetReference.asset) {\n\t\t\tthis._onGSplatAssetAdded();\n\t\t}\n\t}\n\tget asset() {\n\t\treturn this._assetReference.id;\n\t}\n\tassignAsset(asset) {\n\t\tconst id = asset instanceof Asset ? asset.id : asset;\n\t\tthis._assetReference.id = id;\n\t}\n\tdestroyInstance() {\n\t\tif (this._instance) {\n\t\t\tvar _this$_instance4;\n\t\t\tthis.removeFromLayers();\n\t\t\t(_this$_instance4 = this._instance) == null || _this$_instance4.destroy();\n\t\t\tthis._instance = null;\n\t\t}\n\t}\n\taddToLayers() {\n\t\tvar _this$instance;\n\t\tconst meshInstance = (_this$instance = this.instance) == null ? void 0 : _this$instance.meshInstance;\n\t\tif (meshInstance) {\n\t\t\tconst layers = this.system.app.scene.layers;\n\t\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\t\tvar _layers$getLayerById;\n\t\t\t\t(_layers$getLayerById = layers.getLayerById(this._layers[i])) == null || _layers$getLayerById.addMeshInstances([meshInstance]);\n\t\t\t}\n\t\t}\n\t}\n\tremoveFromLayers() {\n\t\tvar _this$instance2;\n\t\tconst meshInstance = (_this$instance2 = this.instance) == null ? void 0 : _this$instance2.meshInstance;\n\t\tif (meshInstance) {\n\t\t\tconst layers = this.system.app.scene.layers;\n\t\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\t\tvar _layers$getLayerById2;\n\t\t\t\t(_layers$getLayerById2 = layers.getLayerById(this._layers[i])) == null || _layers$getLayerById2.removeMeshInstances([meshInstance]);\n\t\t\t}\n\t\t}\n\t}\n\tonRemoveChild() {\n\t\tthis.removeFromLayers();\n\t}\n\tonInsertChild() {\n\t\tif (this._instance && this.enabled && this.entity.enabled) {\n\t\t\tthis.addToLayers();\n\t\t}\n\t}\n\tonRemove() {\n\t\tthis.destroyInstance();\n\t\tthis.asset = null;\n\t\tthis._assetReference.id = null;\n\t\tthis.entity.off('remove', this.onRemoveChild, this);\n\t\tthis.entity.off('insert', this.onInsertChild, this);\n\t}\n\tonLayersChanged(oldComp, newComp) {\n\t\tthis.addToLayers();\n\t\toldComp.off('add', this.onLayerAdded, this);\n\t\toldComp.off('remove', this.onLayerRemoved, this);\n\t\tnewComp.on('add', this.onLayerAdded, this);\n\t\tnewComp.on('remove', this.onLayerRemoved, this);\n\t}\n\tonLayerAdded(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tif (this._instance) {\n\t\t\tlayer.addMeshInstances(this._instance.meshInstance);\n\t\t}\n\t}\n\tonLayerRemoved(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tif (this._instance) {\n\t\t\tlayer.removeMeshInstances(this._instance.meshInstance);\n\t\t}\n\t}\n\tonEnable() {\n\t\tconst scene = this.system.app.scene;\n\t\tconst layers = scene.layers;\n\t\tthis._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);\n\t\tif (layers) {\n\t\t\tthis._evtLayerAdded = layers.on('add', this.onLayerAdded, this);\n\t\t\tthis._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);\n\t\t}\n\t\tif (this._instance) {\n\t\t\tthis.addToLayers();\n\t\t} else if (this.asset) {\n\t\t\tthis._onGSplatAssetAdded();\n\t\t}\n\t}\n\tonDisable() {\n\t\tvar _this$_evtLayersChang;\n\t\tconst scene = this.system.app.scene;\n\t\tconst layers = scene.layers;\n\t\t(_this$_evtLayersChang = this._evtLayersChanged) == null || _this$_evtLayersChang.off();\n\t\tthis._evtLayersChanged = null;\n\t\tif (layers) {\n\t\t\tvar _this$_evtLayerAdded, _this$_evtLayerRemove;\n\t\t\t(_this$_evtLayerAdded = this._evtLayerAdded) == null || _this$_evtLayerAdded.off();\n\t\t\tthis._evtLayerAdded = null;\n\t\t\t(_this$_evtLayerRemove = this._evtLayerRemoved) == null || _this$_evtLayerRemove.off();\n\t\t\tthis._evtLayerRemoved = null;\n\t\t}\n\t\tthis.removeFromLayers();\n\t}\n\thide() {\n\t\tif (this._instance) {\n\t\t\tthis._instance.meshInstance.visible = false;\n\t\t}\n\t}\n\tshow() {\n\t\tif (this._instance) {\n\t\t\tthis._instance.meshInstance.visible = true;\n\t\t}\n\t}\n\t_onGSplatAssetAdded() {\n\t\tif (!this._assetReference.asset) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._assetReference.asset.resource) {\n\t\t\tthis._onGSplatAssetLoad();\n\t\t} else if (this.enabled && this.entity.enabled) {\n\t\t\tthis.system.app.assets.load(this._assetReference.asset);\n\t\t}\n\t}\n\t_onGSplatAssetLoad() {\n\t\tthis.destroyInstance();\n\t\tconst asset = this._assetReference.asset;\n\t\tif (asset) {\n\t\t\tthis.instance = asset.resource.createInstance();\n\t\t}\n\t}\n\t_onGSplatAssetUnload() {\n\t\tthis.destroyInstance();\n\t}\n\t_onGSplatAssetRemove() {\n\t\tthis._onGSplatAssetUnload();\n\t}\n}\n\nexport { GSplatComponent };\n","class GSplatComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n}\n\nexport { GSplatComponentData };\n","import { Vec3 } from '../../../core/math/vec3.js';\nimport { BoundingBox } from '../../../core/shape/bounding-box.js';\nimport { Component } from '../component.js';\nimport { ComponentSystem } from '../system.js';\nimport { GSplatComponent } from './component.js';\nimport { GSplatComponentData } from './data.js';\n\nconst _schema = ['enabled'];\nconst _properties = ['instance', 'asset', 'layers'];\nclass GSplatComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'gsplat';\n\t\tthis.ComponentType = GSplatComponent;\n\t\tthis.DataType = GSplatComponentData;\n\t\tthis.schema = _schema;\n\t\tthis.on('beforeremove', this.onRemove, this);\n\t}\n\tinitializeComponentData(component, _data, properties) {\n\t\tif (_data.layers && _data.layers.length) {\n\t\t\t_data.layers = _data.layers.slice(0);\n\t\t}\n\t\tfor (let i = 0; i < _properties.length; i++) {\n\t\t\tif (_data.hasOwnProperty(_properties[i])) {\n\t\t\t\tcomponent[_properties[i]] = _data[_properties[i]];\n\t\t\t}\n\t\t}\n\t\tif (_data.aabbCenter && _data.aabbHalfExtents) {\n\t\t\tcomponent.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));\n\t\t}\n\t\tsuper.initializeComponentData(component, _data, _schema);\n\t}\n\tcloneComponent(entity, clone) {\n\t\tconst gSplatComponent = entity.gsplat;\n\t\tconst data = {};\n\t\tfor (let i = 0; i < _properties.length; i++) {\n\t\t\tdata[_properties[i]] = gSplatComponent[_properties[i]];\n\t\t}\n\t\tdata.enabled = gSplatComponent.enabled;\n\t\tdelete data.instance;\n\t\tconst component = this.addComponent(clone, data);\n\t\tcomponent.instance = gSplatComponent.instance.clone();\n\t\tif (gSplatComponent.customAabb) {\n\t\t\tcomponent.customAabb = gSplatComponent.customAabb.clone();\n\t\t}\n\t\treturn component;\n\t}\n\tonRemove(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n}\nComponent._buildAccessors(GSplatComponent.prototype, _schema);\n\nexport { GSplatComponentSystem };\n","import { math } from '../../../core/math/math.js';\nimport { Mat4 } from '../../../core/math/mat4.js';\nimport { Quat } from '../../../core/math/quat.js';\nimport { Vec2 } from '../../../core/math/vec2.js';\nimport { Component } from '../component.js';\nimport { MOTION_LOCKED, MOTION_LIMITED, MOTION_FREE } from './constants.js';\n\nconst properties = ['angularDampingX', 'angularDampingY', 'angularDampingZ', 'angularEquilibriumX', 'angularEquilibriumY', 'angularEquilibriumZ', 'angularLimitsX', 'angularLimitsY', 'angularLimitsZ', 'angularMotionX', 'angularMotionY', 'angularMotionZ', 'angularSpringX', 'angularSpringY', 'angularSpringZ', 'angularStiffnessX', 'angularStiffnessY', 'angularStiffnessZ', 'breakForce', 'enableCollision', 'enabled', 'entityA', 'entityB', 'linearDampingX', 'linearDampingY', 'linearDampingZ', 'linearEquilibriumX', 'linearEquilibriumY', 'linearEquilibriumZ', 'linearLimitsX', 'linearLimitsY', 'linearLimitsZ', 'linearMotionX', 'linearMotionY', 'linearMotionZ', 'linearSpringX', 'linearSpringY', 'linearSpringZ', 'linearStiffnessX', 'linearStiffnessY', 'linearStiffnessZ'];\nclass JointComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._constraint = null;\n\t\tthis._entityA = null;\n\t\tthis._entityB = null;\n\t\tthis._breakForce = 3.4e+38;\n\t\tthis._enableCollision = true;\n\t\tthis._linearMotionX = MOTION_LOCKED;\n\t\tthis._linearLimitsX = new Vec2(0, 0);\n\t\tthis._linearSpringX = false;\n\t\tthis._linearStiffnessX = 0;\n\t\tthis._linearDampingX = 1;\n\t\tthis._linearEquilibriumX = 0;\n\t\tthis._linearMotionY = MOTION_LOCKED;\n\t\tthis._linearLimitsY = new Vec2(0, 0);\n\t\tthis._linearSpringY = false;\n\t\tthis._linearStiffnessY = 0;\n\t\tthis._linearDampingY = 1;\n\t\tthis._linearEquilibriumY = 0;\n\t\tthis._linearMotionZ = MOTION_LOCKED;\n\t\tthis._linearLimitsZ = new Vec2(0, 0);\n\t\tthis._linearSpringZ = false;\n\t\tthis._linearStiffnessZ = 0;\n\t\tthis._linearDampingZ = 1;\n\t\tthis._linearEquilibriumZ = 0;\n\t\tthis._angularMotionX = MOTION_LOCKED;\n\t\tthis._angularLimitsX = new Vec2(0, 0);\n\t\tthis._angularSpringX = false;\n\t\tthis._angularStiffnessX = 0;\n\t\tthis._angularDampingX = 1;\n\t\tthis._angularEquilibriumX = 0;\n\t\tthis._angularMotionY = MOTION_LOCKED;\n\t\tthis._angularLimitsY = new Vec2(0, 0);\n\t\tthis._angularSpringY = false;\n\t\tthis._angularStiffnessY = 0;\n\t\tthis._angularDampingY = 1;\n\t\tthis._angularEquilibriumY = 0;\n\t\tthis._angularMotionZ = MOTION_LOCKED;\n\t\tthis._angularLimitsZ = new Vec2(0, 0);\n\t\tthis._angularSpringZ = false;\n\t\tthis._angularEquilibriumZ = 0;\n\t\tthis._angularDampingZ = 1;\n\t\tthis._angularStiffnessZ = 0;\n\t\tthis.on('set_enabled', this._onSetEnabled, this);\n\t}\n\tset entityA(body) {\n\t\tthis._destroyConstraint();\n\t\tthis._entityA = body;\n\t\tthis._createConstraint();\n\t}\n\tget entityA() {\n\t\treturn this._entityA;\n\t}\n\tset entityB(body) {\n\t\tthis._destroyConstraint();\n\t\tthis._entityB = body;\n\t\tthis._createConstraint();\n\t}\n\tget entityB() {\n\t\treturn this._entityB;\n\t}\n\tset breakForce(force) {\n\t\tif (this._constraint && this._breakForce !== force) {\n\t\t\tthis._constraint.setBreakingImpulseThreshold(force);\n\t\t\tthis._breakForce = force;\n\t\t}\n\t}\n\tget breakForce() {\n\t\treturn this._breakForce;\n\t}\n\tset enableCollision(enableCollision) {\n\t\tthis._destroyConstraint();\n\t\tthis._enableCollision = enableCollision;\n\t\tthis._createConstraint();\n\t}\n\tget enableCollision() {\n\t\treturn this._enableCollision;\n\t}\n\tset angularLimitsX(limits) {\n\t\tif (!this._angularLimitsX.equals(limits)) {\n\t\t\tthis._angularLimitsX.copy(limits);\n\t\t\tthis._updateAngularLimits();\n\t\t}\n\t}\n\tget angularLimitsX() {\n\t\treturn this._angularLimitsX;\n\t}\n\tset angularMotionX(value) {\n\t\tif (this._angularMotionX !== value) {\n\t\t\tthis._angularMotionX = value;\n\t\t\tthis._updateAngularLimits();\n\t\t}\n\t}\n\tget angularMotionX() {\n\t\treturn this._angularMotionX;\n\t}\n\tset angularLimitsY(limits) {\n\t\tif (!this._angularLimitsY.equals(limits)) {\n\t\t\tthis._angularLimitsY.copy(limits);\n\t\t\tthis._updateAngularLimits();\n\t\t}\n\t}\n\tget angularLimitsY() {\n\t\treturn this._angularLimitsY;\n\t}\n\tset angularMotionY(value) {\n\t\tif (this._angularMotionY !== value) {\n\t\t\tthis._angularMotionY = value;\n\t\t\tthis._updateAngularLimits();\n\t\t}\n\t}\n\tget angularMotionY() {\n\t\treturn this._angularMotionY;\n\t}\n\tset angularLimitsZ(limits) {\n\t\tif (!this._angularLimitsZ.equals(limits)) {\n\t\t\tthis._angularLimitsZ.copy(limits);\n\t\t\tthis._updateAngularLimits();\n\t\t}\n\t}\n\tget angularLimitsZ() {\n\t\treturn this._angularLimitsZ;\n\t}\n\tset angularMotionZ(value) {\n\t\tif (this._angularMotionZ !== value) {\n\t\t\tthis._angularMotionZ = value;\n\t\t\tthis._updateAngularLimits();\n\t\t}\n\t}\n\tget angularMotionZ() {\n\t\treturn this._angularMotionZ;\n\t}\n\tset linearLimitsX(limits) {\n\t\tif (!this._linearLimitsX.equals(limits)) {\n\t\t\tthis._linearLimitsX.copy(limits);\n\t\t\tthis._updateLinearLimits();\n\t\t}\n\t}\n\tget linearLimitsX() {\n\t\treturn this._linearLimitsX;\n\t}\n\tset linearMotionX(value) {\n\t\tif (this._linearMotionX !== value) {\n\t\t\tthis._linearMotionX = value;\n\t\t\tthis._updateLinearLimits();\n\t\t}\n\t}\n\tget linearMotionX() {\n\t\treturn this._linearMotionX;\n\t}\n\tset linearLimitsY(limits) {\n\t\tif (!this._linearLimitsY.equals(limits)) {\n\t\t\tthis._linearLimitsY.copy(limits);\n\t\t\tthis._updateLinearLimits();\n\t\t}\n\t}\n\tget linearLimitsY() {\n\t\treturn this._linearLimitsY;\n\t}\n\tset linearMotionY(value) {\n\t\tif (this._linearMotionY !== value) {\n\t\t\tthis._linearMotionY = value;\n\t\t\tthis._updateLinearLimits();\n\t\t}\n\t}\n\tget linearMotionY() {\n\t\treturn this._linearMotionY;\n\t}\n\tset linearLimitsZ(limits) {\n\t\tif (!this._linearLimitsZ.equals(limits)) {\n\t\t\tthis._linearLimitsZ.copy(limits);\n\t\t\tthis._updateLinearLimits();\n\t\t}\n\t}\n\tget linearLimitsZ() {\n\t\treturn this._linearLimitsZ;\n\t}\n\tset linearMotionZ(value) {\n\t\tif (this._linearMotionZ !== value) {\n\t\t\tthis._linearMotionZ = value;\n\t\t\tthis._updateLinearLimits();\n\t\t}\n\t}\n\tget linearMotionZ() {\n\t\treturn this._linearMotionZ;\n\t}\n\t_convertTransform(pcTransform, ammoTransform) {\n\t\tconst pos = pcTransform.getTranslation();\n\t\tconst rot = new Quat();\n\t\trot.setFromMat4(pcTransform);\n\t\tconst ammoVec = new Ammo.btVector3(pos.x, pos.y, pos.z);\n\t\tconst ammoQuat = new Ammo.btQuaternion(rot.x, rot.y, rot.z, rot.w);\n\t\tammoTransform.setOrigin(ammoVec);\n\t\tammoTransform.setRotation(ammoQuat);\n\t\tAmmo.destroy(ammoVec);\n\t\tAmmo.destroy(ammoQuat);\n\t}\n\t_updateAngularLimits() {\n\t\tconst constraint = this._constraint;\n\t\tif (constraint) {\n\t\t\tlet lx, ly, lz, ux, uy, uz;\n\t\t\tif (this._angularMotionX === MOTION_LIMITED) {\n\t\t\t\tlx = this._angularLimitsX.x * math.DEG_TO_RAD;\n\t\t\t\tux = this._angularLimitsX.y * math.DEG_TO_RAD;\n\t\t\t} else if (this._angularMotionX === MOTION_FREE) {\n\t\t\t\tlx = 1;\n\t\t\t\tux = 0;\n\t\t\t} else {\n\t\t\t\tlx = ux = 0;\n\t\t\t}\n\t\t\tif (this._angularMotionY === MOTION_LIMITED) {\n\t\t\t\tly = this._angularLimitsY.x * math.DEG_TO_RAD;\n\t\t\t\tuy = this._angularLimitsY.y * math.DEG_TO_RAD;\n\t\t\t} else if (this._angularMotionY === MOTION_FREE) {\n\t\t\t\tly = 1;\n\t\t\t\tuy = 0;\n\t\t\t} else {\n\t\t\t\tly = uy = 0;\n\t\t\t}\n\t\t\tif (this._angularMotionZ === MOTION_LIMITED) {\n\t\t\t\tlz = this._angularLimitsZ.x * math.DEG_TO_RAD;\n\t\t\t\tuz = this._angularLimitsZ.y * math.DEG_TO_RAD;\n\t\t\t} else if (this._angularMotionZ === MOTION_FREE) {\n\t\t\t\tlz = 1;\n\t\t\t\tuz = 0;\n\t\t\t} else {\n\t\t\t\tlz = uz = 0;\n\t\t\t}\n\t\t\tconst limits = new Ammo.btVector3(lx, ly, lz);\n\t\t\tconstraint.setAngularLowerLimit(limits);\n\t\t\tlimits.setValue(ux, uy, uz);\n\t\t\tconstraint.setAngularUpperLimit(limits);\n\t\t\tAmmo.destroy(limits);\n\t\t}\n\t}\n\t_updateLinearLimits() {\n\t\tconst constraint = this._constraint;\n\t\tif (constraint) {\n\t\t\tlet lx, ly, lz, ux, uy, uz;\n\t\t\tif (this._linearMotionX === MOTION_LIMITED) {\n\t\t\t\tlx = this._linearLimitsX.x;\n\t\t\t\tux = this._linearLimitsX.y;\n\t\t\t} else if (this._linearMotionX === MOTION_FREE) {\n\t\t\t\tlx = 1;\n\t\t\t\tux = 0;\n\t\t\t} else {\n\t\t\t\tlx = ux = 0;\n\t\t\t}\n\t\t\tif (this._linearMotionY === MOTION_LIMITED) {\n\t\t\t\tly = this._linearLimitsY.x;\n\t\t\t\tuy = this._linearLimitsY.y;\n\t\t\t} else if (this._linearMotionY === MOTION_FREE) {\n\t\t\t\tly = 1;\n\t\t\t\tuy = 0;\n\t\t\t} else {\n\t\t\t\tly = uy = 0;\n\t\t\t}\n\t\t\tif (this._linearMotionZ === MOTION_LIMITED) {\n\t\t\t\tlz = this._linearLimitsZ.x;\n\t\t\t\tuz = this._linearLimitsZ.y;\n\t\t\t} else if (this._linearMotionZ === MOTION_FREE) {\n\t\t\t\tlz = 1;\n\t\t\t\tuz = 0;\n\t\t\t} else {\n\t\t\t\tlz = uz = 0;\n\t\t\t}\n\t\t\tconst limits = new Ammo.btVector3(lx, ly, lz);\n\t\t\tconstraint.setLinearLowerLimit(limits);\n\t\t\tlimits.setValue(ux, uy, uz);\n\t\t\tconstraint.setLinearUpperLimit(limits);\n\t\t\tAmmo.destroy(limits);\n\t\t}\n\t}\n\t_createConstraint() {\n\t\tif (this._entityA && this._entityA.rigidbody) {\n\t\t\tthis._destroyConstraint();\n\t\t\tconst mat = new Mat4();\n\t\t\tconst bodyA = this._entityA.rigidbody.body;\n\t\t\tbodyA.activate();\n\t\t\tconst jointWtm = this.entity.getWorldTransform();\n\t\t\tconst entityAWtm = this._entityA.getWorldTransform();\n\t\t\tconst invEntityAWtm = entityAWtm.clone().invert();\n\t\t\tmat.mul2(invEntityAWtm, jointWtm);\n\t\t\tconst frameA = new Ammo.btTransform();\n\t\t\tthis._convertTransform(mat, frameA);\n\t\t\tif (this._entityB && this._entityB.rigidbody) {\n\t\t\t\tconst bodyB = this._entityB.rigidbody.body;\n\t\t\t\tbodyB.activate();\n\t\t\t\tconst entityBWtm = this._entityB.getWorldTransform();\n\t\t\t\tconst invEntityBWtm = entityBWtm.clone().invert();\n\t\t\t\tmat.mul2(invEntityBWtm, jointWtm);\n\t\t\t\tconst frameB = new Ammo.btTransform();\n\t\t\t\tthis._convertTransform(mat, frameB);\n\t\t\t\tthis._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, bodyB, frameA, frameB, !this._enableCollision);\n\t\t\t\tAmmo.destroy(frameB);\n\t\t\t} else {\n\t\t\t\tthis._constraint = new Ammo.btGeneric6DofSpringConstraint(bodyA, frameA, !this._enableCollision);\n\t\t\t}\n\t\t\tAmmo.destroy(frameA);\n\t\t\tconst axis = ['X', 'Y', 'Z', 'X', 'Y', 'Z'];\n\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\tconst type = i < 3 ? '_linear' : '_angular';\n\t\t\t\tthis._constraint.enableSpring(i, this[`${type}Spring${axis[i]}`]);\n\t\t\t\tthis._constraint.setDamping(i, this[`${type}Damping${axis[i]}`]);\n\t\t\t\tthis._constraint.setEquilibriumPoint(i, this[`${type}Equilibrium${axis[i]}`]);\n\t\t\t\tthis._constraint.setStiffness(i, this[`${type}Stiffness${axis[i]}`]);\n\t\t\t}\n\t\t\tthis._constraint.setBreakingImpulseThreshold(this._breakForce);\n\t\t\tthis._updateLinearLimits();\n\t\t\tthis._updateAngularLimits();\n\t\t\tconst app = this.system.app;\n\t\t\tconst dynamicsWorld = app.systems.rigidbody.dynamicsWorld;\n\t\t\tdynamicsWorld.addConstraint(this._constraint, !this._enableCollision);\n\t\t}\n\t}\n\t_destroyConstraint() {\n\t\tif (this._constraint) {\n\t\t\tconst app = this.system.app;\n\t\t\tconst dynamicsWorld = app.systems.rigidbody.dynamicsWorld;\n\t\t\tdynamicsWorld.removeConstraint(this._constraint);\n\t\t\tAmmo.destroy(this._constraint);\n\t\t\tthis._constraint = null;\n\t\t}\n\t}\n\tinitFromData(data) {\n\t\tfor (const prop of properties) {\n\t\t\tif (data.hasOwnProperty(prop)) {\n\t\t\t\tif (data[prop] instanceof Vec2) {\n\t\t\t\t\tthis[`_${prop}`].copy(data[prop]);\n\t\t\t\t} else {\n\t\t\t\t\tthis[`_${prop}`] = data[prop];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._createConstraint();\n\t}\n\tonEnable() {\n\t\tthis._createConstraint();\n\t}\n\tonDisable() {\n\t\tthis._destroyConstraint();\n\t}\n\t_onSetEnabled(prop, old, value) {}\n\t_onBeforeRemove() {\n\t\tthis.fire('remove');\n\t}\n}\nconst functionMap = {\n\tDamping: 'setDamping',\n\tEquilibrium: 'setEquilibriumPoint',\n\tSpring: 'enableSpring',\n\tStiffness: 'setStiffness'\n};\n['linear', 'angular'].forEach(type => {\n\t['Damping', 'Equilibrium', 'Spring', 'Stiffness'].forEach(name => {\n\t\t['X', 'Y', 'Z'].forEach(axis => {\n\t\t\tconst prop = type + name + axis;\n\t\t\tconst propInternal = `_${prop}`;\n\t\t\tlet index = type === 'linear' ? 0 : 3;\n\t\t\tif (axis === 'Y') index += 1;\n\t\t\tif (axis === 'Z') index += 2;\n\t\t\tObject.defineProperty(JointComponent.prototype, prop, {\n\t\t\t\tget: function () {\n\t\t\t\t\treturn this[propInternal];\n\t\t\t\t},\n\t\t\t\tset: function (value) {\n\t\t\t\t\tif (this[propInternal] !== value) {\n\t\t\t\t\t\tthis[propInternal] = value;\n\t\t\t\t\t\tthis._constraint[functionMap[name]](index, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n});\n\nexport { JointComponent };\n","const MOTION_FREE = 'free';\nconst MOTION_LIMITED = 'limited';\nconst MOTION_LOCKED = 'locked';\n\nexport { MOTION_FREE, MOTION_LIMITED, MOTION_LOCKED };\n","class JointComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n}\n\nexport { JointComponentData };\n","import { Component } from '../component.js';\nimport { ComponentSystem } from '../system.js';\nimport { JointComponent } from './component.js';\nimport { JointComponentData } from './data.js';\n\nconst _schema = ['enabled'];\nclass JointComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'joint';\n\t\tthis.app = app;\n\t\tthis.ComponentType = JointComponent;\n\t\tthis.DataType = JointComponentData;\n\t\tthis.schema = _schema;\n\t}\n\tinitializeComponentData(component, data, properties) {\n\t\tcomponent.initFromData(data);\n\t}\n}\nComponent._buildAccessors(JointComponent.prototype, _schema);\n\nexport { JointComponentSystem };\n","import { Component } from '../component.js';\n\nclass LayoutChildComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._minWidth = 0;\n\t\tthis._minHeight = 0;\n\t\tthis._maxWidth = null;\n\t\tthis._maxHeight = null;\n\t\tthis._fitWidthProportion = 0;\n\t\tthis._fitHeightProportion = 0;\n\t\tthis._excludeFromLayout = false;\n\t}\n\tset minWidth(value) {\n\t\tif (value !== this._minWidth) {\n\t\t\tthis._minWidth = value;\n\t\t\tthis.fire('resize');\n\t\t}\n\t}\n\tget minWidth() {\n\t\treturn this._minWidth;\n\t}\n\tset minHeight(value) {\n\t\tif (value !== this._minHeight) {\n\t\t\tthis._minHeight = value;\n\t\t\tthis.fire('resize');\n\t\t}\n\t}\n\tget minHeight() {\n\t\treturn this._minHeight;\n\t}\n\tset maxWidth(value) {\n\t\tif (value !== this._maxWidth) {\n\t\t\tthis._maxWidth = value;\n\t\t\tthis.fire('resize');\n\t\t}\n\t}\n\tget maxWidth() {\n\t\treturn this._maxWidth;\n\t}\n\tset maxHeight(value) {\n\t\tif (value !== this._maxHeight) {\n\t\t\tthis._maxHeight = value;\n\t\t\tthis.fire('resize');\n\t\t}\n\t}\n\tget maxHeight() {\n\t\treturn this._maxHeight;\n\t}\n\tset fitWidthProportion(value) {\n\t\tif (value !== this._fitWidthProportion) {\n\t\t\tthis._fitWidthProportion = value;\n\t\t\tthis.fire('resize');\n\t\t}\n\t}\n\tget fitWidthProportion() {\n\t\treturn this._fitWidthProportion;\n\t}\n\tset fitHeightProportion(value) {\n\t\tif (value !== this._fitHeightProportion) {\n\t\t\tthis._fitHeightProportion = value;\n\t\t\tthis.fire('resize');\n\t\t}\n\t}\n\tget fitHeightProportion() {\n\t\treturn this._fitHeightProportion;\n\t}\n\tset excludeFromLayout(value) {\n\t\tif (value !== this._excludeFromLayout) {\n\t\t\tthis._excludeFromLayout = value;\n\t\t\tthis.fire('resize');\n\t\t}\n\t}\n\tget excludeFromLayout() {\n\t\treturn this._excludeFromLayout;\n\t}\n}\n\nexport { LayoutChildComponent };\n","class LayoutChildComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n}\n\nexport { LayoutChildComponentData };\n","import { Component } from '../component.js';\nimport { ComponentSystem } from '../system.js';\nimport { LayoutChildComponent } from './component.js';\nimport { LayoutChildComponentData } from './data.js';\n\nconst _schema = ['enabled'];\nclass LayoutChildComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'layoutchild';\n\t\tthis.ComponentType = LayoutChildComponent;\n\t\tthis.DataType = LayoutChildComponentData;\n\t\tthis.schema = _schema;\n\t}\n\tinitializeComponentData(component, data, properties) {\n\t\tif (data.enabled !== undefined) component.enabled = data.enabled;\n\t\tif (data.minWidth !== undefined) component.minWidth = data.minWidth;\n\t\tif (data.minHeight !== undefined) component.minHeight = data.minHeight;\n\t\tif (data.maxWidth !== undefined) component.maxWidth = data.maxWidth;\n\t\tif (data.maxHeight !== undefined) component.maxHeight = data.maxHeight;\n\t\tif (data.fitWidthProportion !== undefined) component.fitWidthProportion = data.fitWidthProportion;\n\t\tif (data.fitHeightProportion !== undefined) component.fitHeightProportion = data.fitHeightProportion;\n\t\tif (data.excludeFromLayout !== undefined) component.excludeFromLayout = data.excludeFromLayout;\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\tcloneComponent(entity, clone) {\n\t\tconst layoutChild = entity.layoutchild;\n\t\treturn this.addComponent(clone, {\n\t\t\tenabled: layoutChild.enabled,\n\t\t\tminWidth: layoutChild.minWidth,\n\t\t\tminHeight: layoutChild.minHeight,\n\t\t\tmaxWidth: layoutChild.maxWidth,\n\t\t\tmaxHeight: layoutChild.maxHeight,\n\t\t\tfitWidthProportion: layoutChild.fitWidthProportion,\n\t\t\tfitHeightProportion: layoutChild.fitHeightProportion,\n\t\t\texcludeFromLayout: layoutChild.excludeFromLayout\n\t\t});\n\t}\n}\nComponent._buildAccessors(LayoutChildComponent.prototype, _schema);\n\nexport { LayoutChildComponentSystem };\n","import { Vec2 } from '../../../core/math/vec2.js';\nimport { Vec4 } from '../../../core/math/vec4.js';\nimport { ORIENTATION_HORIZONTAL } from '../../../scene/constants.js';\nimport { FITTING_NONE } from './constants.js';\nimport { Component } from '../component.js';\nimport { LayoutCalculator } from './layout-calculator.js';\n\nfunction getElement(entity) {\n\treturn entity.element;\n}\nfunction isEnabledAndHasEnabledElement(entity) {\n\treturn entity.enabled && entity.element && entity.element.enabled;\n}\nclass LayoutGroupComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._orientation = ORIENTATION_HORIZONTAL;\n\t\tthis._reverseX = false;\n\t\tthis._reverseY = true;\n\t\tthis._alignment = new Vec2(0, 1);\n\t\tthis._padding = new Vec4();\n\t\tthis._spacing = new Vec2();\n\t\tthis._widthFitting = FITTING_NONE;\n\t\tthis._heightFitting = FITTING_NONE;\n\t\tthis._wrap = false;\n\t\tthis._layoutCalculator = new LayoutCalculator();\n\t\tthis._listenForReflowEvents(this.entity, 'on');\n\t\tthis.entity.children.forEach(child => {\n\t\t\tthis._listenForReflowEvents(child, 'on');\n\t\t});\n\t\tthis.entity.on('childinsert', this._onChildInsert, this);\n\t\tthis.entity.on('childremove', this._onChildRemove, this);\n\t\tsystem.app.systems.element.on('add', this._onElementOrLayoutComponentAdd, this);\n\t\tsystem.app.systems.element.on('beforeremove', this._onElementOrLayoutComponentRemove, this);\n\t\tsystem.app.systems.layoutchild.on('add', this._onElementOrLayoutComponentAdd, this);\n\t\tsystem.app.systems.layoutchild.on('beforeremove', this._onElementOrLayoutComponentRemove, this);\n\t}\n\tset orientation(value) {\n\t\tif (value !== this._orientation) {\n\t\t\tthis._orientation = value;\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\tget orientation() {\n\t\treturn this._orientation;\n\t}\n\tset reverseX(value) {\n\t\tif (value !== this._reverseX) {\n\t\t\tthis._reverseX = value;\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\tget reverseX() {\n\t\treturn this._reverseX;\n\t}\n\tset reverseY(value) {\n\t\tif (value !== this._reverseY) {\n\t\t\tthis._reverseY = value;\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\tget reverseY() {\n\t\treturn this._reverseY;\n\t}\n\tset alignment(value) {\n\t\tif (!value.equals(this._alignment)) {\n\t\t\tthis._alignment.copy(value);\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\tget alignment() {\n\t\treturn this._alignment;\n\t}\n\tset padding(value) {\n\t\tif (!value.equals(this._padding)) {\n\t\t\tthis._padding.copy(value);\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\tget padding() {\n\t\treturn this._padding;\n\t}\n\tset spacing(value) {\n\t\tif (!value.equals(this._spacing)) {\n\t\t\tthis._spacing.copy(value);\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\tget spacing() {\n\t\treturn this._spacing;\n\t}\n\tset widthFitting(value) {\n\t\tif (value !== this._widthFitting) {\n\t\t\tthis._widthFitting = value;\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\tget widthFitting() {\n\t\treturn this._widthFitting;\n\t}\n\tset heightFitting(value) {\n\t\tif (value !== this._heightFitting) {\n\t\t\tthis._heightFitting = value;\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\tget heightFitting() {\n\t\treturn this._heightFitting;\n\t}\n\tset wrap(value) {\n\t\tif (value !== this._wrap) {\n\t\t\tthis._wrap = value;\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\tget wrap() {\n\t\treturn this._wrap;\n\t}\n\t_isSelfOrChild(entity) {\n\t\treturn entity === this.entity || this.entity.children.indexOf(entity) !== -1;\n\t}\n\t_listenForReflowEvents(target, onOff) {\n\t\tif (target.element) {\n\t\t\ttarget.element[onOff]('enableelement', this._scheduleReflow, this);\n\t\t\ttarget.element[onOff]('disableelement', this._scheduleReflow, this);\n\t\t\ttarget.element[onOff]('resize', this._scheduleReflow, this);\n\t\t\ttarget.element[onOff]('set:pivot', this._scheduleReflow, this);\n\t\t}\n\t\tif (target.layoutchild) {\n\t\t\ttarget.layoutchild[onOff]('set_enabled', this._scheduleReflow, this);\n\t\t\ttarget.layoutchild[onOff]('resize', this._scheduleReflow, this);\n\t\t}\n\t}\n\t_onElementOrLayoutComponentAdd(entity) {\n\t\tif (this._isSelfOrChild(entity)) {\n\t\t\tthis._listenForReflowEvents(entity, 'on');\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\t_onElementOrLayoutComponentRemove(entity) {\n\t\tif (this._isSelfOrChild(entity)) {\n\t\t\tthis._listenForReflowEvents(entity, 'off');\n\t\t\tthis._scheduleReflow();\n\t\t}\n\t}\n\t_onChildInsert(child) {\n\t\tthis._listenForReflowEvents(child, 'on');\n\t\tthis._scheduleReflow();\n\t}\n\t_onChildRemove(child) {\n\t\tthis._listenForReflowEvents(child, 'off');\n\t\tthis._scheduleReflow();\n\t}\n\t_scheduleReflow() {\n\t\tif (this.enabled && this.entity && this.entity.enabled && !this._isPerformingReflow) {\n\t\t\tthis.system.scheduleReflow(this);\n\t\t}\n\t}\n\treflow() {\n\t\tconst container = getElement(this.entity);\n\t\tconst elements = this.entity.children.filter(isEnabledAndHasEnabledElement).map(getElement);\n\t\tif (!container || elements.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tconst containerWidth = Math.max(container.calculatedWidth, 0);\n\t\tconst containerHeight = Math.max(container.calculatedHeight, 0);\n\t\tconst options = {\n\t\t\torientation: this._orientation,\n\t\t\treverseX: this._reverseX,\n\t\t\treverseY: this._reverseY,\n\t\t\talignment: this._alignment,\n\t\t\tpadding: this._padding,\n\t\t\tspacing: this._spacing,\n\t\t\twidthFitting: this._widthFitting,\n\t\t\theightFitting: this._heightFitting,\n\t\t\twrap: this._wrap,\n\t\t\tcontainerSize: new Vec2(containerWidth, containerHeight)\n\t\t};\n\t\tthis._isPerformingReflow = true;\n\t\tconst layoutInfo = this._layoutCalculator.calculateLayout(elements, options);\n\t\tthis._isPerformingReflow = false;\n\t\tthis.fire('reflow', layoutInfo);\n\t}\n\tonEnable() {\n\t\tthis._scheduleReflow();\n\t}\n\tonRemove() {\n\t\tthis.entity.off('childinsert', this._onChildInsert, this);\n\t\tthis.entity.off('childremove', this._onChildRemove, this);\n\t\tthis._listenForReflowEvents(this.entity, 'off');\n\t\tthis.entity.children.forEach(child => {\n\t\t\tthis._listenForReflowEvents(child, 'off');\n\t\t});\n\t\tthis.system.app.systems.element.off('add', this._onElementOrLayoutComponentAdd, this);\n\t\tthis.system.app.systems.element.off('beforeremove', this._onElementOrLayoutComponentRemove, this);\n\t\tthis.system.app.systems.layoutchild.off('add', this._onElementOrLayoutComponentAdd, this);\n\t\tthis.system.app.systems.layoutchild.off('beforeremove', this._onElementOrLayoutComponentRemove, this);\n\t}\n}\n\nexport { LayoutGroupComponent };\n","const FITTING_NONE = 0;\nconst FITTING_STRETCH = 1;\nconst FITTING_SHRINK = 2;\nconst FITTING_BOTH = 3;\n\nexport { FITTING_BOTH, FITTING_NONE, FITTING_SHRINK, FITTING_STRETCH };\n","class LayoutGroupComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n}\n\nexport { LayoutGroupComponentData };\n","import { Vec2 } from '../../../core/math/vec2.js';\nimport { Vec4 } from '../../../core/math/vec4.js';\nimport { ORIENTATION_HORIZONTAL, ORIENTATION_VERTICAL } from '../../../scene/constants.js';\nimport { FITTING_SHRINK, FITTING_BOTH, FITTING_STRETCH, FITTING_NONE } from './constants.js';\n\nconst AXIS_MAPPINGS = {};\nAXIS_MAPPINGS[ORIENTATION_HORIZONTAL] = {\n\taxis: 'x',\n\tsize: 'width',\n\tcalculatedSize: 'calculatedWidth',\n\tminSize: 'minWidth',\n\tmaxSize: 'maxWidth',\n\tfitting: 'widthFitting',\n\tfittingProportion: 'fitWidthProportion'\n};\nAXIS_MAPPINGS[ORIENTATION_VERTICAL] = {\n\taxis: 'y',\n\tsize: 'height',\n\tcalculatedSize: 'calculatedHeight',\n\tminSize: 'minHeight',\n\tmaxSize: 'maxHeight',\n\tfitting: 'heightFitting',\n\tfittingProportion: 'fitHeightProportion'\n};\nconst OPPOSITE_ORIENTATION = {};\nOPPOSITE_ORIENTATION[ORIENTATION_HORIZONTAL] = ORIENTATION_VERTICAL;\nOPPOSITE_ORIENTATION[ORIENTATION_VERTICAL] = ORIENTATION_HORIZONTAL;\nconst PROPERTY_DEFAULTS = {\n\tminWidth: 0,\n\tminHeight: 0,\n\tmaxWidth: Number.POSITIVE_INFINITY,\n\tmaxHeight: Number.POSITIVE_INFINITY,\n\twidth: null,\n\theight: null,\n\tfitWidthProportion: 0,\n\tfitHeightProportion: 0\n};\nconst FITTING_ACTION = {\n\tNONE: 'NONE',\n\tAPPLY_STRETCHING: 'APPLY_STRETCHING',\n\tAPPLY_SHRINKING: 'APPLY_SHRINKING'\n};\nconst availableSpace = new Vec2();\nfunction createCalculator(orientation) {\n\tlet options;\n\tconst a = AXIS_MAPPINGS[orientation];\n\tconst b = AXIS_MAPPINGS[OPPOSITE_ORIENTATION[orientation]];\n\tfunction minExtentA(element, size) {\n\t\treturn -size[a.size] * element.pivot[a.axis];\n\t}\n\tfunction minExtentB(element, size) {\n\t\treturn -size[b.size] * element.pivot[b.axis];\n\t}\n\tfunction maxExtentA(element, size) {\n\t\treturn size[a.size] * (1 - element.pivot[a.axis]);\n\t}\n\tfunction calculateAll(allElements, layoutOptions) {\n\t\tallElements = allElements.filter(shouldIncludeInLayout);\n\t\toptions = layoutOptions;\n\t\tavailableSpace.x = options.containerSize.x - options.padding.x - options.padding.z;\n\t\tavailableSpace.y = options.containerSize.y - options.padding.y - options.padding.w;\n\t\tresetAnchors(allElements);\n\t\tconst lines = reverseLinesIfRequired(splitLines(allElements));\n\t\tconst sizes = calculateSizesOnAxisB(lines, calculateSizesOnAxisA(lines));\n\t\tconst positions = calculateBasePositions(lines, sizes);\n\t\tapplyAlignmentAndPadding(lines, sizes, positions);\n\t\tapplySizesAndPositions(lines, sizes, positions);\n\t\treturn createLayoutInfo(lines);\n\t}\n\tfunction shouldIncludeInLayout(element) {\n\t\tconst layoutChildComponent = element.entity.layoutchild;\n\t\treturn !layoutChildComponent || !layoutChildComponent.enabled || !layoutChildComponent.excludeFromLayout;\n\t}\n\tfunction resetAnchors(allElements) {\n\t\tfor (let i = 0; i < allElements.length; ++i) {\n\t\t\tconst element = allElements[i];\n\t\t\tconst anchor = element.anchor;\n\t\t\tif (anchor.x !== 0 || anchor.y !== 0 || anchor.z !== 0 || anchor.w !== 0) {\n\t\t\t\telement.anchor = Vec4.ZERO;\n\t\t\t}\n\t\t}\n\t}\n\tfunction splitLines(allElements) {\n\t\tif (!options.wrap) {\n\t\t\treturn [allElements];\n\t\t}\n\t\tconst lines = [[]];\n\t\tconst sizes = getElementSizeProperties(allElements);\n\t\tlet runningSize = 0;\n\t\tconst allowOverrun = options[a.fitting] === FITTING_SHRINK;\n\t\tfor (let i = 0; i < allElements.length; ++i) {\n\t\t\tif (lines[lines.length - 1].length > 0) {\n\t\t\t\trunningSize += options.spacing[a.axis];\n\t\t\t}\n\t\t\tconst idealElementSize = sizes[i][a.size];\n\t\t\trunningSize += idealElementSize;\n\t\t\tif (!allowOverrun && runningSize > availableSpace[a.axis] && lines[lines.length - 1].length !== 0) {\n\t\t\t\trunningSize = idealElementSize;\n\t\t\t\tlines.push([]);\n\t\t\t}\n\t\t\tlines[lines.length - 1].push(allElements[i]);\n\t\t\tif (allowOverrun && runningSize > availableSpace[a.axis] && i !== allElements.length - 1) {\n\t\t\t\trunningSize = 0;\n\t\t\t\tlines.push([]);\n\t\t\t}\n\t\t}\n\t\treturn lines;\n\t}\n\tfunction reverseLinesIfRequired(lines) {\n\t\tconst reverseAxisA = options.orientation === ORIENTATION_HORIZONTAL && options.reverseX || options.orientation === ORIENTATION_VERTICAL && options.reverseY;\n\t\tconst reverseAxisB = options.orientation === ORIENTATION_HORIZONTAL && options.reverseY || options.orientation === ORIENTATION_VERTICAL && options.reverseX;\n\t\tif (reverseAxisA) {\n\t\t\tfor (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n\t\t\t\tif (reverseAxisA) {\n\t\t\t\t\tlines[lineIndex].reverse();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (reverseAxisB) {\n\t\t\tlines.reverse();\n\t\t}\n\t\treturn lines;\n\t}\n\tfunction calculateSizesOnAxisA(lines) {\n\t\tconst sizesAllLines = [];\n\t\tfor (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n\t\t\tconst line = lines[lineIndex];\n\t\t\tconst sizesThisLine = getElementSizeProperties(line);\n\t\t\tconst idealRequiredSpace = calculateTotalSpace(sizesThisLine, a);\n\t\t\tconst fittingAction = determineFittingAction(options[a.fitting], idealRequiredSpace, availableSpace[a.axis]);\n\t\t\tif (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {\n\t\t\t\tstretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);\n\t\t\t} else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {\n\t\t\t\tshrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, a);\n\t\t\t}\n\t\t\tsizesAllLines.push(sizesThisLine);\n\t\t}\n\t\treturn sizesAllLines;\n\t}\n\tfunction calculateSizesOnAxisB(lines, sizesAllLines) {\n\t\tconst largestElementsForEachLine = [];\n\t\tconst largestSizesForEachLine = [];\n\t\tfor (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n\t\t\tconst line = lines[lineIndex];\n\t\t\tline.largestElement = null;\n\t\t\tline.largestSize = {\n\t\t\t\twidth: Number.NEGATIVE_INFINITY,\n\t\t\t\theight: Number.NEGATIVE_INFINITY\n\t\t\t};\n\t\t\tfor (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {\n\t\t\t\tconst sizesThisElement = sizesAllLines[lineIndex][elementIndex];\n\t\t\t\tif (sizesThisElement[b.size] > line.largestSize[b.size]) {\n\t\t\t\t\tline.largestElement = line[elementIndex];\n\t\t\t\t\tline.largestSize = sizesThisElement;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlargestElementsForEachLine.push(line.largestElement);\n\t\t\tlargestSizesForEachLine.push(line.largestSize);\n\t\t}\n\t\tconst idealRequiredSpace = calculateTotalSpace(largestSizesForEachLine, b);\n\t\tconst fittingAction = determineFittingAction(options[b.fitting], idealRequiredSpace, availableSpace[b.axis]);\n\t\tif (fittingAction === FITTING_ACTION.APPLY_STRETCHING) {\n\t\t\tstretchSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);\n\t\t} else if (fittingAction === FITTING_ACTION.APPLY_SHRINKING) {\n\t\t\tshrinkSizesToFitContainer(largestSizesForEachLine, idealRequiredSpace, b);\n\t\t}\n\t\tfor (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n\t\t\tconst line = lines[lineIndex];\n\t\t\tfor (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {\n\t\t\t\tconst sizesForThisElement = sizesAllLines[lineIndex][elementIndex];\n\t\t\t\tconst currentSize = sizesForThisElement[b.size];\n\t\t\t\tconst availableSize = lines.length === 1 ? availableSpace[b.axis] : line.largestSize[b.size];\n\t\t\t\tconst elementFittingAction = determineFittingAction(options[b.fitting], currentSize, availableSize);\n\t\t\t\tif (elementFittingAction === FITTING_ACTION.APPLY_STRETCHING) {\n\t\t\t\t\tsizesForThisElement[b.size] = Math.min(availableSize, sizesForThisElement[b.maxSize]);\n\t\t\t\t} else if (elementFittingAction === FITTING_ACTION.APPLY_SHRINKING) {\n\t\t\t\t\tsizesForThisElement[b.size] = Math.max(availableSize, sizesForThisElement[b.minSize]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sizesAllLines;\n\t}\n\tfunction determineFittingAction(fittingMode, currentSize, availableSize) {\n\t\tswitch (fittingMode) {\n\t\t\tcase FITTING_NONE:\n\t\t\t\treturn FITTING_ACTION.NONE;\n\t\t\tcase FITTING_STRETCH:\n\t\t\t\tif (currentSize < availableSize) {\n\t\t\t\t\treturn FITTING_ACTION.APPLY_STRETCHING;\n\t\t\t\t}\n\t\t\t\treturn FITTING_ACTION.NONE;\n\t\t\tcase FITTING_SHRINK:\n\t\t\t\tif (currentSize >= availableSize) {\n\t\t\t\t\treturn FITTING_ACTION.APPLY_SHRINKING;\n\t\t\t\t}\n\t\t\t\treturn FITTING_ACTION.NONE;\n\t\t\tcase FITTING_BOTH:\n\t\t\t\tif (currentSize < availableSize) {\n\t\t\t\t\treturn FITTING_ACTION.APPLY_STRETCHING;\n\t\t\t\t}\n\t\t\t\treturn FITTING_ACTION.APPLY_SHRINKING;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unrecognized fitting mode: ${fittingMode}`);\n\t\t}\n\t}\n\tfunction calculateTotalSpace(sizes, axis) {\n\t\tconst totalSizes = sumValues(sizes, axis.size);\n\t\tconst totalSpacing = (sizes.length - 1) * options.spacing[axis.axis];\n\t\treturn totalSizes + totalSpacing;\n\t}\n\tfunction stretchSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {\n\t\tconst ascendingMaxSizeOrder = getTraversalOrder(sizesThisLine, axis.maxSize);\n\t\tconst fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);\n\t\tconst fittingProportionSums = createSumArray(fittingProportions, ascendingMaxSizeOrder);\n\t\tlet remainingUndershoot = availableSpace[axis.axis] - idealRequiredSpace;\n\t\tfor (let i = 0; i < sizesThisLine.length; ++i) {\n\t\t\tconst index = ascendingMaxSizeOrder[i];\n\t\t\tconst targetIncrease = calculateAdjustment(index, remainingUndershoot, fittingProportions, fittingProportionSums);\n\t\t\tconst targetSize = sizesThisLine[index][axis.size] + targetIncrease;\n\t\t\tconst maxSize = sizesThisLine[index][axis.maxSize];\n\t\t\tconst actualSize = Math.min(targetSize, maxSize);\n\t\t\tsizesThisLine[index][axis.size] = actualSize;\n\t\t\tconst actualIncrease = Math.max(targetSize - actualSize, 0);\n\t\t\tconst appliedIncrease = targetIncrease - actualIncrease;\n\t\t\tremainingUndershoot -= appliedIncrease;\n\t\t}\n\t}\n\tfunction shrinkSizesToFitContainer(sizesThisLine, idealRequiredSpace, axis) {\n\t\tconst descendingMinSizeOrder = getTraversalOrder(sizesThisLine, axis.minSize, true);\n\t\tconst fittingProportions = getNormalizedValues(sizesThisLine, axis.fittingProportion);\n\t\tconst inverseFittingProportions = invertNormalizedValues(fittingProportions);\n\t\tconst inverseFittingProportionSums = createSumArray(inverseFittingProportions, descendingMinSizeOrder);\n\t\tlet remainingOvershoot = idealRequiredSpace - availableSpace[axis.axis];\n\t\tfor (let i = 0; i < sizesThisLine.length; ++i) {\n\t\t\tconst index = descendingMinSizeOrder[i];\n\t\t\tconst targetReduction = calculateAdjustment(index, remainingOvershoot, inverseFittingProportions, inverseFittingProportionSums);\n\t\t\tconst targetSize = sizesThisLine[index][axis.size] - targetReduction;\n\t\t\tconst minSize = sizesThisLine[index][axis.minSize];\n\t\t\tconst actualSize = Math.max(targetSize, minSize);\n\t\t\tsizesThisLine[index][axis.size] = actualSize;\n\t\t\tconst actualReduction = Math.max(actualSize - targetSize, 0);\n\t\t\tconst appliedReduction = targetReduction - actualReduction;\n\t\t\tremainingOvershoot -= appliedReduction;\n\t\t}\n\t}\n\tfunction calculateAdjustment(index, remainingAdjustment, fittingProportions, fittingProportionSums) {\n\t\tconst proportion = fittingProportions[index];\n\t\tconst sumOfRemainingProportions = fittingProportionSums[index];\n\t\tif (Math.abs(proportion) < 1e-5 && Math.abs(sumOfRemainingProportions) < 1e-5) {\n\t\t\treturn remainingAdjustment;\n\t\t}\n\t\treturn remainingAdjustment * proportion / sumOfRemainingProportions;\n\t}\n\tfunction calculateBasePositions(lines, sizes) {\n\t\tconst cursor = {};\n\t\tcursor[a.axis] = 0;\n\t\tcursor[b.axis] = 0;\n\t\tlines[a.size] = Number.NEGATIVE_INFINITY;\n\t\tconst positionsAllLines = [];\n\t\tfor (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n\t\t\tconst line = lines[lineIndex];\n\t\t\tif (line.length === 0) {\n\t\t\t\tpositionsAllLines.push([]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst positionsThisLine = [];\n\t\t\tconst sizesThisLine = sizes[lineIndex];\n\t\t\tfor (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {\n\t\t\t\tconst element = line[elementIndex];\n\t\t\t\tconst sizesThisElement = sizesThisLine[elementIndex];\n\t\t\t\tcursor[b.axis] -= minExtentB(element, sizesThisElement);\n\t\t\t\tcursor[a.axis] -= minExtentA(element, sizesThisElement);\n\t\t\t\tpositionsThisLine[elementIndex] = {};\n\t\t\t\tpositionsThisLine[elementIndex][a.axis] = cursor[a.axis];\n\t\t\t\tpositionsThisLine[elementIndex][b.axis] = cursor[b.axis];\n\t\t\t\tcursor[b.axis] += minExtentB(element, sizesThisElement);\n\t\t\t\tcursor[a.axis] += maxExtentA(element, sizesThisElement) + options.spacing[a.axis];\n\t\t\t}\n\t\t\tline[a.size] = cursor[a.axis] - options.spacing[a.axis];\n\t\t\tline[b.size] = line.largestSize[b.size];\n\t\t\tlines[a.size] = Math.max(lines[a.size], line[a.size]);\n\t\t\tcursor[a.axis] = 0;\n\t\t\tcursor[b.axis] += line[b.size] + options.spacing[b.axis];\n\t\t\tpositionsAllLines.push(positionsThisLine);\n\t\t}\n\t\tlines[b.size] = cursor[b.axis] - options.spacing[b.axis];\n\t\treturn positionsAllLines;\n\t}\n\tfunction applyAlignmentAndPadding(lines, sizes, positions) {\n\t\tconst alignmentA = options.alignment[a.axis];\n\t\tconst alignmentB = options.alignment[b.axis];\n\t\tconst paddingA = options.padding[a.axis];\n\t\tconst paddingB = options.padding[b.axis];\n\t\tfor (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n\t\t\tconst line = lines[lineIndex];\n\t\t\tconst sizesThisLine = sizes[lineIndex];\n\t\t\tconst positionsThisLine = positions[lineIndex];\n\t\t\tconst axisAOffset = (availableSpace[a.axis] - line[a.size]) * alignmentA + paddingA;\n\t\t\tconst axisBOffset = (availableSpace[b.axis] - lines[b.size]) * alignmentB + paddingB;\n\t\t\tfor (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {\n\t\t\t\tconst withinLineAxisBOffset = (line[b.size] - sizesThisLine[elementIndex][b.size]) * options.alignment[b.axis];\n\t\t\t\tpositionsThisLine[elementIndex][a.axis] += axisAOffset;\n\t\t\t\tpositionsThisLine[elementIndex][b.axis] += axisBOffset + withinLineAxisBOffset;\n\t\t\t}\n\t\t}\n\t}\n\tfunction applySizesAndPositions(lines, sizes, positions) {\n\t\tfor (let lineIndex = 0; lineIndex < lines.length; ++lineIndex) {\n\t\t\tconst line = lines[lineIndex];\n\t\t\tconst sizesThisLine = sizes[lineIndex];\n\t\t\tconst positionsThisLine = positions[lineIndex];\n\t\t\tfor (let elementIndex = 0; elementIndex < line.length; ++elementIndex) {\n\t\t\t\tconst element = line[elementIndex];\n\t\t\t\telement[a.calculatedSize] = sizesThisLine[elementIndex][a.size];\n\t\t\t\telement[b.calculatedSize] = sizesThisLine[elementIndex][b.size];\n\t\t\t\tif (options.orientation === ORIENTATION_HORIZONTAL) {\n\t\t\t\t\telement.entity.setLocalPosition(positionsThisLine[elementIndex][a.axis], positionsThisLine[elementIndex][b.axis], element.entity.getLocalPosition().z);\n\t\t\t\t} else {\n\t\t\t\t\telement.entity.setLocalPosition(positionsThisLine[elementIndex][b.axis], positionsThisLine[elementIndex][a.axis], element.entity.getLocalPosition().z);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfunction createLayoutInfo(lines) {\n\t\tconst layoutWidth = lines.width;\n\t\tconst layoutHeight = lines.height;\n\t\tconst xOffset = (availableSpace.x - layoutWidth) * options.alignment.x + options.padding.x;\n\t\tconst yOffset = (availableSpace.y - layoutHeight) * options.alignment.y + options.padding.y;\n\t\treturn {\n\t\t\tbounds: new Vec4(xOffset, yOffset, layoutWidth, layoutHeight)\n\t\t};\n\t}\n\tfunction getElementSizeProperties(elements) {\n\t\tconst sizeProperties = [];\n\t\tfor (let i = 0; i < elements.length; ++i) {\n\t\t\tconst element = elements[i];\n\t\t\tconst minWidth = Math.max(getProperty(element, 'minWidth'), 0);\n\t\t\tconst minHeight = Math.max(getProperty(element, 'minHeight'), 0);\n\t\t\tconst maxWidth = Math.max(getProperty(element, 'maxWidth'), minWidth);\n\t\t\tconst maxHeight = Math.max(getProperty(element, 'maxHeight'), minHeight);\n\t\t\tconst width = clamp(getProperty(element, 'width'), minWidth, maxWidth);\n\t\t\tconst height = clamp(getProperty(element, 'height'), minHeight, maxHeight);\n\t\t\tconst fitWidthProportion = getProperty(element, 'fitWidthProportion');\n\t\t\tconst fitHeightProportion = getProperty(element, 'fitHeightProportion');\n\t\t\tsizeProperties.push({\n\t\t\t\tminWidth: minWidth,\n\t\t\t\tminHeight: minHeight,\n\t\t\t\tmaxWidth: maxWidth,\n\t\t\t\tmaxHeight: maxHeight,\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tfitWidthProportion: fitWidthProportion,\n\t\t\t\tfitHeightProportion: fitHeightProportion\n\t\t\t});\n\t\t}\n\t\treturn sizeProperties;\n\t}\n\tfunction getProperty(element, propertyName) {\n\t\tconst layoutChildComponent = element.entity.layoutchild;\n\t\tif (layoutChildComponent && layoutChildComponent.enabled && layoutChildComponent[propertyName] !== undefined && layoutChildComponent[propertyName] !== null) {\n\t\t\treturn layoutChildComponent[propertyName];\n\t\t} else if (element[propertyName] !== undefined) {\n\t\t\treturn element[propertyName];\n\t\t}\n\t\treturn PROPERTY_DEFAULTS[propertyName];\n\t}\n\tfunction clamp(value, min, max) {\n\t\treturn Math.min(Math.max(value, min), max);\n\t}\n\tfunction sumValues(items, propertyName) {\n\t\treturn items.reduce((accumulator, current) => {\n\t\t\treturn accumulator + current[propertyName];\n\t\t}, 0);\n\t}\n\tfunction getNormalizedValues(items, propertyName) {\n\t\tconst sum = sumValues(items, propertyName);\n\t\tconst normalizedValues = [];\n\t\tconst numItems = items.length;\n\t\tif (sum === 0) {\n\t\t\tfor (let i = 0; i < numItems; ++i) {\n\t\t\t\tnormalizedValues.push(1 / numItems);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < numItems; ++i) {\n\t\t\t\tnormalizedValues.push(items[i][propertyName] / sum);\n\t\t\t}\n\t\t}\n\t\treturn normalizedValues;\n\t}\n\tfunction invertNormalizedValues(values) {\n\t\tif (values.length === 1) {\n\t\t\treturn [1];\n\t\t}\n\t\tconst invertedValues = [];\n\t\tconst numValues = values.length;\n\t\tfor (let i = 0; i < numValues; ++i) {\n\t\t\tinvertedValues.push((1 - values[i]) / (numValues - 1));\n\t\t}\n\t\treturn invertedValues;\n\t}\n\tfunction getTraversalOrder(items, orderBy, descending) {\n\t\titems.forEach(assignIndex);\n\t\treturn items.slice().sort((itemA, itemB) => {\n\t\t\treturn descending ? itemB[orderBy] - itemA[orderBy] : itemA[orderBy] - itemB[orderBy];\n\t\t}).map(getIndex);\n\t}\n\tfunction assignIndex(item, index) {\n\t\titem.index = index;\n\t}\n\tfunction getIndex(item) {\n\t\treturn item.index;\n\t}\n\tfunction createSumArray(values, order) {\n\t\tconst sumArray = [];\n\t\tsumArray[order[values.length - 1]] = values[order[values.length - 1]];\n\t\tfor (let i = values.length - 2; i >= 0; --i) {\n\t\t\tsumArray[order[i]] = sumArray[order[i + 1]] + values[order[i]];\n\t\t}\n\t\treturn sumArray;\n\t}\n\treturn calculateAll;\n}\nconst CALCULATE_FNS = {};\nCALCULATE_FNS[ORIENTATION_HORIZONTAL] = createCalculator(ORIENTATION_HORIZONTAL);\nCALCULATE_FNS[ORIENTATION_VERTICAL] = createCalculator(ORIENTATION_VERTICAL);\nclass LayoutCalculator {\n\tcalculateLayout(elements, options) {\n\t\tconst calculateFn = CALCULATE_FNS[options.orientation];\n\t\tif (!calculateFn) {\n\t\t\tthrow new Error(`Unrecognized orientation value: ${options.orientation}`);\n\t\t} else {\n\t\t\treturn calculateFn(elements, options);\n\t\t}\n\t}\n}\n\nexport { LayoutCalculator };\n","import { Vec2 } from '../../../core/math/vec2.js';\nimport { Vec4 } from '../../../core/math/vec4.js';\nimport { Component } from '../component.js';\nimport { ComponentSystem } from '../system.js';\nimport { LayoutGroupComponent } from './component.js';\nimport { LayoutGroupComponentData } from './data.js';\n\nconst _schema = ['enabled'];\nconst MAX_ITERATIONS = 100;\nclass LayoutGroupComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'layoutgroup';\n\t\tthis.ComponentType = LayoutGroupComponent;\n\t\tthis.DataType = LayoutGroupComponentData;\n\t\tthis.schema = _schema;\n\t\tthis._reflowQueue = [];\n\t\tthis.on('beforeremove', this._onRemoveComponent, this);\n\t\tthis.app.systems.on('postUpdate', this._onPostUpdate, this);\n\t}\n\tinitializeComponentData(component, data, properties) {\n\t\tif (data.enabled !== undefined) component.enabled = data.enabled;\n\t\tif (data.orientation !== undefined) component.orientation = data.orientation;\n\t\tif (data.reverseX !== undefined) component.reverseX = data.reverseX;\n\t\tif (data.reverseY !== undefined) component.reverseY = data.reverseY;\n\t\tif (data.alignment !== undefined) {\n\t\t\tcomponent.alignment = Array.isArray(data.alignment) ? new Vec2(data.alignment) : data.alignment;\n\t\t}\n\t\tif (data.padding !== undefined) {\n\t\t\tcomponent.padding = Array.isArray(data.padding) ? new Vec4(data.padding) : data.padding;\n\t\t}\n\t\tif (data.spacing !== undefined) {\n\t\t\tcomponent.spacing = Array.isArray(data.spacing) ? new Vec2(data.spacing) : data.spacing;\n\t\t}\n\t\tif (data.widthFitting !== undefined) component.widthFitting = data.widthFitting;\n\t\tif (data.heightFitting !== undefined) component.heightFitting = data.heightFitting;\n\t\tif (data.wrap !== undefined) component.wrap = data.wrap;\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\tcloneComponent(entity, clone) {\n\t\tconst layoutGroup = entity.layoutgroup;\n\t\treturn this.addComponent(clone, {\n\t\t\tenabled: layoutGroup.enabled,\n\t\t\torientation: layoutGroup.orientation,\n\t\t\treverseX: layoutGroup.reverseX,\n\t\t\treverseY: layoutGroup.reverseY,\n\t\t\talignment: layoutGroup.alignment,\n\t\t\tpadding: layoutGroup.padding,\n\t\t\tspacing: layoutGroup.spacing,\n\t\t\twidthFitting: layoutGroup.widthFitting,\n\t\t\theightFitting: layoutGroup.heightFitting,\n\t\t\twrap: layoutGroup.wrap\n\t\t});\n\t}\n\tscheduleReflow(component) {\n\t\tif (this._reflowQueue.indexOf(component) === -1) {\n\t\t\tthis._reflowQueue.push(component);\n\t\t}\n\t}\n\t_onPostUpdate() {\n\t\tthis._processReflowQueue();\n\t}\n\t_processReflowQueue() {\n\t\tif (this._reflowQueue.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tlet iterationCount = 0;\n\t\twhile (this._reflowQueue.length > 0) {\n\t\t\tconst queue = this._reflowQueue.slice();\n\t\t\tthis._reflowQueue.length = 0;\n\t\t\tqueue.sort((componentA, componentB) => {\n\t\t\t\treturn componentA.entity.graphDepth - componentB.entity.graphDepth;\n\t\t\t});\n\t\t\tfor (let i = 0; i < queue.length; ++i) {\n\t\t\t\tqueue[i].reflow();\n\t\t\t}\n\t\t\tif (++iterationCount >= MAX_ITERATIONS) {\n\t\t\t\tconsole.warn('Max reflow iterations limit reached, bailing.');\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t_onRemoveComponent(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('postUpdate', this._onPostUpdate, this);\n\t}\n}\nComponent._buildAccessors(LayoutGroupComponent.prototype, _schema);\n\nexport { LayoutGroupComponentSystem };\n","import { math } from '../../../core/math/math.js';\nimport { Vec4 } from '../../../core/math/vec4.js';\nimport { MASK_AFFECT_DYNAMIC, MASK_AFFECT_LIGHTMAPPED, MASK_BAKE } from '../../../scene/constants.js';\nimport { Asset } from '../../asset/asset.js';\nimport { Component } from '../component.js';\nimport { properties } from './data.js';\n\nclass LightComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._evtLayersChanged = null;\n\t\tthis._evtLayerAdded = null;\n\t\tthis._evtLayerRemoved = null;\n\t\tthis._cookieAsset = null;\n\t\tthis._cookieAssetId = null;\n\t\tthis._cookieAssetAdd = false;\n\t\tthis._cookieMatrix = null;\n\t}\n\tget data() {\n\t\tconst record = this.system.store[this.entity.getGuid()];\n\t\treturn record ? record.data : null;\n\t}\n\tset enabled(arg) {\n\t\tthis._setValue('enabled', arg, function (newValue, oldValue) {\n\t\t\tthis.onSetEnabled(null, oldValue, newValue);\n\t\t});\n\t}\n\tget enabled() {\n\t\treturn this.data.enabled;\n\t}\n\tset light(arg) {\n\t\tthis._setValue('light', arg);\n\t}\n\tget light() {\n\t\treturn this.data.light;\n\t}\n\tset type(arg) {\n\t\tthis._setValue('type', arg, function (newValue, oldValue) {\n\t\t\tthis.system.changeType(this, oldValue, newValue);\n\t\t\tthis.refreshProperties();\n\t\t});\n\t}\n\tget type() {\n\t\treturn this.data.type;\n\t}\n\tset color(arg) {\n\t\tthis._setValue('color', arg, function (newValue, oldValue) {\n\t\t\tthis.light.setColor(newValue);\n\t\t}, true);\n\t}\n\tget color() {\n\t\treturn this.data.color;\n\t}\n\tset intensity(arg) {\n\t\tthis._setValue('intensity', arg, function (newValue, oldValue) {\n\t\t\tthis.light.intensity = newValue;\n\t\t});\n\t}\n\tget intensity() {\n\t\treturn this.data.intensity;\n\t}\n\tset luminance(arg) {\n\t\tthis._setValue('luminance', arg, function (newValue, oldValue) {\n\t\t\tthis.light.luminance = newValue;\n\t\t});\n\t}\n\tget luminance() {\n\t\treturn this.data.luminance;\n\t}\n\tset shape(arg) {\n\t\tthis._setValue('shape', arg, function (newValue, oldValue) {\n\t\t\tthis.light.shape = newValue;\n\t\t});\n\t}\n\tget shape() {\n\t\treturn this.data.shape;\n\t}\n\tset affectSpecularity(arg) {\n\t\tthis._setValue('affectSpecularity', arg, function (newValue, oldValue) {\n\t\t\tthis.light.affectSpecularity = newValue;\n\t\t});\n\t}\n\tget affectSpecularity() {\n\t\treturn this.data.affectSpecularity;\n\t}\n\tset castShadows(arg) {\n\t\tthis._setValue('castShadows', arg, function (newValue, oldValue) {\n\t\t\tthis.light.castShadows = newValue;\n\t\t});\n\t}\n\tget castShadows() {\n\t\treturn this.data.castShadows;\n\t}\n\tset shadowDistance(arg) {\n\t\tthis._setValue('shadowDistance', arg, function (newValue, oldValue) {\n\t\t\tthis.light.shadowDistance = newValue;\n\t\t});\n\t}\n\tget shadowDistance() {\n\t\treturn this.data.shadowDistance;\n\t}\n\tset shadowIntensity(arg) {\n\t\tthis._setValue('shadowIntensity', arg, function (newValue, oldValue) {\n\t\t\tthis.light.shadowIntensity = newValue;\n\t\t});\n\t}\n\tget shadowIntensity() {\n\t\treturn this.data.shadowIntensity;\n\t}\n\tset shadowResolution(arg) {\n\t\tthis._setValue('shadowResolution', arg, function (newValue, oldValue) {\n\t\t\tthis.light.shadowResolution = newValue;\n\t\t});\n\t}\n\tget shadowResolution() {\n\t\treturn this.data.shadowResolution;\n\t}\n\tset shadowBias(arg) {\n\t\tthis._setValue('shadowBias', arg, function (newValue, oldValue) {\n\t\t\tthis.light.shadowBias = -0.01 * math.clamp(newValue, 0, 1);\n\t\t});\n\t}\n\tget shadowBias() {\n\t\treturn this.data.shadowBias;\n\t}\n\tset numCascades(arg) {\n\t\tthis._setValue('numCascades', arg, function (newValue, oldValue) {\n\t\t\tthis.light.numCascades = math.clamp(Math.floor(newValue), 1, 4);\n\t\t});\n\t}\n\tget numCascades() {\n\t\treturn this.data.numCascades;\n\t}\n\tset bakeNumSamples(arg) {\n\t\tthis._setValue('bakeNumSamples', arg, function (newValue, oldValue) {\n\t\t\tthis.light.bakeNumSamples = math.clamp(Math.floor(newValue), 1, 255);\n\t\t});\n\t}\n\tget bakeNumSamples() {\n\t\treturn this.data.bakeNumSamples;\n\t}\n\tset bakeArea(arg) {\n\t\tthis._setValue('bakeArea', arg, function (newValue, oldValue) {\n\t\t\tthis.light.bakeArea = math.clamp(newValue, 0, 180);\n\t\t});\n\t}\n\tget bakeArea() {\n\t\treturn this.data.bakeArea;\n\t}\n\tset cascadeDistribution(arg) {\n\t\tthis._setValue('cascadeDistribution', arg, function (newValue, oldValue) {\n\t\t\tthis.light.cascadeDistribution = math.clamp(newValue, 0, 1);\n\t\t});\n\t}\n\tget cascadeDistribution() {\n\t\treturn this.data.cascadeDistribution;\n\t}\n\tset normalOffsetBias(arg) {\n\t\tthis._setValue('normalOffsetBias', arg, function (newValue, oldValue) {\n\t\t\tthis.light.normalOffsetBias = math.clamp(newValue, 0, 1);\n\t\t});\n\t}\n\tget normalOffsetBias() {\n\t\treturn this.data.normalOffsetBias;\n\t}\n\tset range(arg) {\n\t\tthis._setValue('range', arg, function (newValue, oldValue) {\n\t\t\tthis.light.attenuationEnd = newValue;\n\t\t});\n\t}\n\tget range() {\n\t\treturn this.data.range;\n\t}\n\tset innerConeAngle(arg) {\n\t\tthis._setValue('innerConeAngle', arg, function (newValue, oldValue) {\n\t\t\tthis.light.innerConeAngle = newValue;\n\t\t});\n\t}\n\tget innerConeAngle() {\n\t\treturn this.data.innerConeAngle;\n\t}\n\tset outerConeAngle(arg) {\n\t\tthis._setValue('outerConeAngle', arg, function (newValue, oldValue) {\n\t\t\tthis.light.outerConeAngle = newValue;\n\t\t});\n\t}\n\tget outerConeAngle() {\n\t\treturn this.data.outerConeAngle;\n\t}\n\tset falloffMode(arg) {\n\t\tthis._setValue('falloffMode', arg, function (newValue, oldValue) {\n\t\t\tthis.light.falloffMode = newValue;\n\t\t});\n\t}\n\tget falloffMode() {\n\t\treturn this.data.falloffMode;\n\t}\n\tset shadowType(arg) {\n\t\tthis._setValue('shadowType', arg, function (newValue, oldValue) {\n\t\t\tthis.light.shadowType = newValue;\n\t\t});\n\t}\n\tget shadowType() {\n\t\treturn this.data.shadowType;\n\t}\n\tset vsmBlurSize(arg) {\n\t\tthis._setValue('vsmBlurSize', arg, function (newValue, oldValue) {\n\t\t\tthis.light.vsmBlurSize = newValue;\n\t\t});\n\t}\n\tget vsmBlurSize() {\n\t\treturn this.data.vsmBlurSize;\n\t}\n\tset vsmBlurMode(arg) {\n\t\tthis._setValue('vsmBlurMode', arg, function (newValue, oldValue) {\n\t\t\tthis.light.vsmBlurMode = newValue;\n\t\t});\n\t}\n\tget vsmBlurMode() {\n\t\treturn this.data.vsmBlurMode;\n\t}\n\tset vsmBias(arg) {\n\t\tthis._setValue('vsmBias', arg, function (newValue, oldValue) {\n\t\t\tthis.light.vsmBias = math.clamp(newValue, 0, 1);\n\t\t});\n\t}\n\tget vsmBias() {\n\t\treturn this.data.vsmBias;\n\t}\n\tset cookieAsset(arg) {\n\t\tthis._setValue('cookieAsset', arg, function (newValue, oldValue) {\n\t\t\tif (this._cookieAssetId && (newValue instanceof Asset && newValue.id === this._cookieAssetId || newValue === this._cookieAssetId)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.onCookieAssetRemove();\n\t\t\tthis._cookieAssetId = null;\n\t\t\tif (newValue instanceof Asset) {\n\t\t\t\tthis.data.cookieAsset = newValue.id;\n\t\t\t\tthis._cookieAssetId = newValue.id;\n\t\t\t\tthis.onCookieAssetAdd(newValue);\n\t\t\t} else if (typeof newValue === 'number') {\n\t\t\t\tthis._cookieAssetId = newValue;\n\t\t\t\tconst asset = this.system.app.assets.get(newValue);\n\t\t\t\tif (asset) {\n\t\t\t\t\tthis.onCookieAssetAdd(asset);\n\t\t\t\t} else {\n\t\t\t\t\tthis._cookieAssetAdd = true;\n\t\t\t\t\tthis.system.app.assets.on(`add:${this._cookieAssetId}`, this.onCookieAssetAdd, this);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\tget cookieAsset() {\n\t\treturn this.data.cookieAsset;\n\t}\n\tset cookie(arg) {\n\t\tthis._setValue('cookie', arg, function (newValue, oldValue) {\n\t\t\tthis.light.cookie = newValue;\n\t\t});\n\t}\n\tget cookie() {\n\t\treturn this.data.cookie;\n\t}\n\tset cookieIntensity(arg) {\n\t\tthis._setValue('cookieIntensity', arg, function (newValue, oldValue) {\n\t\t\tthis.light.cookieIntensity = math.clamp(newValue, 0, 1);\n\t\t});\n\t}\n\tget cookieIntensity() {\n\t\treturn this.data.cookieIntensity;\n\t}\n\tset cookieFalloff(arg) {\n\t\tthis._setValue('cookieFalloff', arg, function (newValue, oldValue) {\n\t\t\tthis.light.cookieFalloff = newValue;\n\t\t});\n\t}\n\tget cookieFalloff() {\n\t\treturn this.data.cookieFalloff;\n\t}\n\tset cookieChannel(arg) {\n\t\tthis._setValue('cookieChannel', arg, function (newValue, oldValue) {\n\t\t\tthis.light.cookieChannel = newValue;\n\t\t});\n\t}\n\tget cookieChannel() {\n\t\treturn this.data.cookieChannel;\n\t}\n\tset cookieAngle(arg) {\n\t\tthis._setValue('cookieAngle', arg, function (newValue, oldValue) {\n\t\t\tif (newValue !== 0 || this.cookieScale !== null) {\n\t\t\t\tif (!this._cookieMatrix) this._cookieMatrix = new Vec4();\n\t\t\t\tlet scx = 1;\n\t\t\t\tlet scy = 1;\n\t\t\t\tif (this.cookieScale) {\n\t\t\t\t\tscx = this.cookieScale.x;\n\t\t\t\t\tscy = this.cookieScale.y;\n\t\t\t\t}\n\t\t\t\tconst c = Math.cos(newValue * math.DEG_TO_RAD);\n\t\t\t\tconst s = Math.sin(newValue * math.DEG_TO_RAD);\n\t\t\t\tthis._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);\n\t\t\t\tthis.light.cookieTransform = this._cookieMatrix;\n\t\t\t} else {\n\t\t\t\tthis.light.cookieTransform = null;\n\t\t\t}\n\t\t});\n\t}\n\tget cookieAngle() {\n\t\treturn this.data.cookieAngle;\n\t}\n\tset cookieScale(arg) {\n\t\tthis._setValue('cookieScale', arg, function (newValue, oldValue) {\n\t\t\tif (newValue !== null || this.cookieAngle !== 0) {\n\t\t\t\tif (!this._cookieMatrix) this._cookieMatrix = new Vec4();\n\t\t\t\tconst scx = newValue.x;\n\t\t\t\tconst scy = newValue.y;\n\t\t\t\tconst c = Math.cos(this.cookieAngle * math.DEG_TO_RAD);\n\t\t\t\tconst s = Math.sin(this.cookieAngle * math.DEG_TO_RAD);\n\t\t\t\tthis._cookieMatrix.set(c / scx, -s / scx, s / scy, c / scy);\n\t\t\t\tthis.light.cookieTransform = this._cookieMatrix;\n\t\t\t} else {\n\t\t\t\tthis.light.cookieTransform = null;\n\t\t\t}\n\t\t}, true);\n\t}\n\tget cookieScale() {\n\t\treturn this.data.cookieScale;\n\t}\n\tset cookieOffset(arg) {\n\t\tthis._setValue('cookieOffset', arg, function (newValue, oldValue) {\n\t\t\tthis.light.cookieOffset = newValue;\n\t\t}, true);\n\t}\n\tget cookieOffset() {\n\t\treturn this.data.cookieOffset;\n\t}\n\tset shadowUpdateMode(arg) {\n\t\tthis._setValue('shadowUpdateMode', arg, function (newValue, oldValue) {\n\t\t\tthis.light.shadowUpdateMode = newValue;\n\t\t}, true);\n\t}\n\tget shadowUpdateMode() {\n\t\treturn this.data.shadowUpdateMode;\n\t}\n\tset mask(arg) {\n\t\tthis._setValue('mask', arg, function (newValue, oldValue) {\n\t\t\tthis.light.mask = newValue;\n\t\t});\n\t}\n\tget mask() {\n\t\treturn this.data.mask;\n\t}\n\tset affectDynamic(arg) {\n\t\tthis._setValue('affectDynamic', arg, function (newValue, oldValue) {\n\t\t\tif (newValue) {\n\t\t\t\tthis.light.mask |= MASK_AFFECT_DYNAMIC;\n\t\t\t} else {\n\t\t\t\tthis.light.mask &= ~MASK_AFFECT_DYNAMIC;\n\t\t\t}\n\t\t\tthis.light.layersDirty();\n\t\t});\n\t}\n\tget affectDynamic() {\n\t\treturn this.data.affectDynamic;\n\t}\n\tset affectLightmapped(arg) {\n\t\tthis._setValue('affectLightmapped', arg, function (newValue, oldValue) {\n\t\t\tif (newValue) {\n\t\t\t\tthis.light.mask |= MASK_AFFECT_LIGHTMAPPED;\n\t\t\t\tif (this.bake) this.light.mask &= ~MASK_BAKE;\n\t\t\t} else {\n\t\t\t\tthis.light.mask &= ~MASK_AFFECT_LIGHTMAPPED;\n\t\t\t\tif (this.bake) this.light.mask |= MASK_BAKE;\n\t\t\t}\n\t\t});\n\t}\n\tget affectLightmapped() {\n\t\treturn this.data.affectLightmapped;\n\t}\n\tset bake(arg) {\n\t\tthis._setValue('bake', arg, function (newValue, oldValue) {\n\t\t\tif (newValue) {\n\t\t\t\tthis.light.mask |= MASK_BAKE;\n\t\t\t\tif (this.affectLightmapped) this.light.mask &= ~MASK_AFFECT_LIGHTMAPPED;\n\t\t\t} else {\n\t\t\t\tthis.light.mask &= ~MASK_BAKE;\n\t\t\t\tif (this.affectLightmapped) this.light.mask |= MASK_AFFECT_LIGHTMAPPED;\n\t\t\t}\n\t\t\tthis.light.layersDirty();\n\t\t});\n\t}\n\tget bake() {\n\t\treturn this.data.bake;\n\t}\n\tset bakeDir(arg) {\n\t\tthis._setValue('bakeDir', arg, function (newValue, oldValue) {\n\t\t\tthis.light.bakeDir = newValue;\n\t\t});\n\t}\n\tget bakeDir() {\n\t\treturn this.data.bakeDir;\n\t}\n\tset isStatic(arg) {\n\t\tthis._setValue('isStatic', arg, function (newValue, oldValue) {\n\t\t\tthis.light.isStatic = newValue;\n\t\t});\n\t}\n\tget isStatic() {\n\t\treturn this.data.isStatic;\n\t}\n\tset layers(arg) {\n\t\tthis._setValue('layers', arg, function (newValue, oldValue) {\n\t\t\tfor (let i = 0; i < oldValue.length; i++) {\n\t\t\t\tconst layer = this.system.app.scene.layers.getLayerById(oldValue[i]);\n\t\t\t\tif (!layer) continue;\n\t\t\t\tlayer.removeLight(this);\n\t\t\t\tthis.light.removeLayer(layer);\n\t\t\t}\n\t\t\tfor (let i = 0; i < newValue.length; i++) {\n\t\t\t\tconst layer = this.system.app.scene.layers.getLayerById(newValue[i]);\n\t\t\t\tif (!layer) continue;\n\t\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\t\tlayer.addLight(this);\n\t\t\t\t\tthis.light.addLayer(layer);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\tget layers() {\n\t\treturn this.data.layers;\n\t}\n\tset shadowUpdateOverrides(values) {\n\t\tthis.light.shadowUpdateOverrides = values;\n\t}\n\tget shadowUpdateOverrides() {\n\t\treturn this.light.shadowUpdateOverrides;\n\t}\n\tset penumbraSize(value) {\n\t\tthis.light.penumbraSize = value;\n\t}\n\tget penumbraSize() {\n\t\treturn this.light.penumbraSize;\n\t}\n\t_setValue(name, value, setFunc, skipEqualsCheck) {\n\t\tconst data = this.data;\n\t\tconst oldValue = data[name];\n\t\tif (!skipEqualsCheck && oldValue === value) return;\n\t\tdata[name] = value;\n\t\tif (setFunc) setFunc.call(this, value, oldValue);\n\t}\n\taddLightToLayers() {\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\t\t\tif (layer) {\n\t\t\t\tlayer.addLight(this);\n\t\t\t\tthis.light.addLayer(layer);\n\t\t\t}\n\t\t}\n\t}\n\tremoveLightFromLayers() {\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\t\t\tif (layer) {\n\t\t\t\tlayer.removeLight(this);\n\t\t\t\tthis.light.removeLayer(layer);\n\t\t\t}\n\t\t}\n\t}\n\tonLayersChanged(oldComp, newComp) {\n\t\tif (this.enabled && this.entity.enabled) {\n\t\t\tthis.addLightToLayers();\n\t\t}\n\t\toldComp.off('add', this.onLayerAdded, this);\n\t\toldComp.off('remove', this.onLayerRemoved, this);\n\t\tnewComp.on('add', this.onLayerAdded, this);\n\t\tnewComp.on('remove', this.onLayerRemoved, this);\n\t}\n\tonLayerAdded(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index >= 0 && this.enabled && this.entity.enabled) {\n\t\t\tlayer.addLight(this);\n\t\t\tthis.light.addLayer(layer);\n\t\t}\n\t}\n\tonLayerRemoved(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index >= 0) {\n\t\t\tlayer.removeLight(this);\n\t\t\tthis.light.removeLayer(layer);\n\t\t}\n\t}\n\trefreshProperties() {\n\t\tfor (let i = 0; i < properties.length; i++) {\n\t\t\tconst name = properties[i];\n\t\t\tthis[name] = this[name];\n\t\t}\n\t\tif (this.enabled && this.entity.enabled) {\n\t\t\tthis.onEnable();\n\t\t}\n\t}\n\tonCookieAssetSet() {\n\t\tlet forceLoad = false;\n\t\tif (this._cookieAsset.type === 'cubemap' && !this._cookieAsset.loadFaces) {\n\t\t\tthis._cookieAsset.loadFaces = true;\n\t\t\tforceLoad = true;\n\t\t}\n\t\tif (!this._cookieAsset.resource || forceLoad) this.system.app.assets.load(this._cookieAsset);\n\t\tif (this._cookieAsset.resource) {\n\t\t\tthis.onCookieAssetLoad();\n\t\t}\n\t}\n\tonCookieAssetAdd(asset) {\n\t\tif (this._cookieAssetId !== asset.id) return;\n\t\tthis._cookieAsset = asset;\n\t\tif (this.light.enabled) {\n\t\t\tthis.onCookieAssetSet();\n\t\t}\n\t\tthis._cookieAsset.on('load', this.onCookieAssetLoad, this);\n\t\tthis._cookieAsset.on('remove', this.onCookieAssetRemove, this);\n\t}\n\tonCookieAssetLoad() {\n\t\tif (!this._cookieAsset || !this._cookieAsset.resource) {\n\t\t\treturn;\n\t\t}\n\t\tthis.cookie = this._cookieAsset.resource;\n\t}\n\tonCookieAssetRemove() {\n\t\tif (!this._cookieAssetId) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._cookieAssetAdd) {\n\t\t\tthis.system.app.assets.off(`add:${this._cookieAssetId}`, this.onCookieAssetAdd, this);\n\t\t\tthis._cookieAssetAdd = false;\n\t\t}\n\t\tif (this._cookieAsset) {\n\t\t\tthis._cookieAsset.off('load', this.onCookieAssetLoad, this);\n\t\t\tthis._cookieAsset.off('remove', this.onCookieAssetRemove, this);\n\t\t\tthis._cookieAsset = null;\n\t\t}\n\t\tthis.cookie = null;\n\t}\n\tonEnable() {\n\t\tconst scene = this.system.app.scene;\n\t\tconst layers = scene.layers;\n\t\tthis.light.enabled = true;\n\t\tthis._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);\n\t\tif (layers) {\n\t\t\tthis._evtLayerAdded = layers.on('add', this.onLayerAdded, this);\n\t\t\tthis._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);\n\t\t}\n\t\tif (this.enabled && this.entity.enabled) {\n\t\t\tthis.addLightToLayers();\n\t\t}\n\t\tif (this._cookieAsset && !this.cookie) {\n\t\t\tthis.onCookieAssetSet();\n\t\t}\n\t}\n\tonDisable() {\n\t\tvar _this$_evtLayersChang;\n\t\tconst scene = this.system.app.scene;\n\t\tconst layers = scene.layers;\n\t\tthis.light.enabled = false;\n\t\t(_this$_evtLayersChang = this._evtLayersChanged) == null || _this$_evtLayersChang.off();\n\t\tthis._evtLayersChanged = null;\n\t\tif (layers) {\n\t\t\tvar _this$_evtLayerAdded, _this$_evtLayerRemove;\n\t\t\t(_this$_evtLayerAdded = this._evtLayerAdded) == null || _this$_evtLayerAdded.off();\n\t\t\tthis._evtLayerAdded = null;\n\t\t\t(_this$_evtLayerRemove = this._evtLayerRemoved) == null || _this$_evtLayerRemove.off();\n\t\t\tthis._evtLayerRemoved = null;\n\t\t}\n\t\tthis.removeLightFromLayers();\n\t}\n\tonRemove() {\n\t\tthis.onDisable();\n\t\tthis.light.destroy();\n\t\tthis.cookieAsset = null;\n\t}\n}\n\nexport { LightComponent };\n","import { LIGHTSHAPE_PUNCTUAL, LIGHTFALLOFF_LINEAR, SHADOW_PCF3, BLUR_GAUSSIAN, SHADOWUPDATE_REALTIME, LAYERID_WORLD } from '../../../scene/constants.js';\nimport { Color } from '../../../core/math/color.js';\n\nclass LightComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t\tthis.light = void 0;\n\t\tthis.type = 'directional';\n\t\tthis.color = new Color(1, 1, 1);\n\t\tthis.intensity = 1;\n\t\tthis.luminance = 0;\n\t\tthis.shape = LIGHTSHAPE_PUNCTUAL;\n\t\tthis.affectSpecularity = true;\n\t\tthis.castShadows = false;\n\t\tthis.shadowDistance = 40;\n\t\tthis.shadowIntensity = 1;\n\t\tthis.shadowResolution = 1024;\n\t\tthis.shadowBias = 0.05;\n\t\tthis.numCascades = 1;\n\t\tthis.bakeNumSamples = 1;\n\t\tthis.bakeArea = 0;\n\t\tthis.cascadeDistribution = 0.5;\n\t\tthis.normalOffsetBias = 0;\n\t\tthis.range = 10;\n\t\tthis.innerConeAngle = 40;\n\t\tthis.outerConeAngle = 45;\n\t\tthis.falloffMode = LIGHTFALLOFF_LINEAR;\n\t\tthis.shadowType = SHADOW_PCF3;\n\t\tthis.vsmBlurSize = 11;\n\t\tthis.vsmBlurMode = BLUR_GAUSSIAN;\n\t\tthis.vsmBias = 0.01 * 0.25;\n\t\tthis.cookieAsset = null;\n\t\tthis.cookie = null;\n\t\tthis.cookieIntensity = 1;\n\t\tthis.cookieFalloff = true;\n\t\tthis.cookieChannel = 'rgb';\n\t\tthis.cookieAngle = 0;\n\t\tthis.cookieScale = null;\n\t\tthis.cookieOffset = null;\n\t\tthis.shadowUpdateMode = SHADOWUPDATE_REALTIME;\n\t\tthis.mask = 1;\n\t\tthis.affectDynamic = true;\n\t\tthis.affectLightmapped = false;\n\t\tthis.bake = false;\n\t\tthis.bakeDir = true;\n\t\tthis.isStatic = false;\n\t\tthis.layers = [LAYERID_WORLD];\n\t\tthis.penumbraSize = 1;\n\t}\n}\nconst properties = Object.keys(new LightComponentData());\n\nexport { LightComponentData, properties };\n","import { extends as _extends } from '../../../../_virtual/_rollupPluginBabelHelpers.js';\nimport { Color } from '../../../core/math/color.js';\nimport { Vec2 } from '../../../core/math/vec2.js';\nimport { LIGHTSHAPE_PUNCTUAL } from '../../../scene/constants.js';\nimport { Light, lightTypes } from '../../../scene/light.js';\nimport { ComponentSystem } from '../system.js';\nimport { LightComponent } from './component.js';\nimport { LightComponentData, properties } from './data.js';\n\nclass LightComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'light';\n\t\tthis.ComponentType = LightComponent;\n\t\tthis.DataType = LightComponentData;\n\t\tthis.on('beforeremove', this._onRemoveComponent, this);\n\t}\n\tinitializeComponentData(component, _data) {\n\t\tconst data = _extends({}, _data);\n\t\tif (!data.type) {\n\t\t\tdata.type = component.data.type;\n\t\t}\n\t\tcomponent.data.type = data.type;\n\t\tif (data.layers && Array.isArray(data.layers)) {\n\t\t\tdata.layers = data.layers.slice(0);\n\t\t}\n\t\tif (data.color && Array.isArray(data.color)) {\n\t\t\tdata.color = new Color(data.color[0], data.color[1], data.color[2]);\n\t\t}\n\t\tif (data.cookieOffset && data.cookieOffset instanceof Array) {\n\t\t\tdata.cookieOffset = new Vec2(data.cookieOffset[0], data.cookieOffset[1]);\n\t\t}\n\t\tif (data.cookieScale && data.cookieScale instanceof Array) {\n\t\t\tdata.cookieScale = new Vec2(data.cookieScale[0], data.cookieScale[1]);\n\t\t}\n\t\tif (data.enable) {\n\t\t\tconsole.warn('WARNING: enable: Property is deprecated. Set enabled property instead.');\n\t\t\tdata.enabled = data.enable;\n\t\t}\n\t\tif (!data.shape) {\n\t\t\tdata.shape = LIGHTSHAPE_PUNCTUAL;\n\t\t}\n\t\tconst light = new Light(this.app.graphicsDevice, this.app.scene.clusteredLightingEnabled);\n\t\tlight.type = lightTypes[data.type];\n\t\tlight._node = component.entity;\n\t\tcomponent.data.light = light;\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\t_onRemoveComponent(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\tcloneComponent(entity, clone) {\n\t\tconst light = entity.light;\n\t\tconst data = [];\n\t\tlet name;\n\t\tfor (let i = 0; i < properties.length; i++) {\n\t\t\tname = properties[i];\n\t\t\tif (name === 'light') {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (light[name] && light[name].clone) {\n\t\t\t\tdata[name] = light[name].clone();\n\t\t\t} else {\n\t\t\t\tdata[name] = light[name];\n\t\t\t}\n\t\t}\n\t\treturn this.addComponent(clone, data);\n\t}\n\tchangeType(component, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tcomponent.light.type = lightTypes[newValue];\n\t\t}\n\t}\n}\n\nexport { LightComponentSystem };\n","import { LAYERID_WORLD } from '../../../scene/constants.js';\nimport { BatchGroup } from '../../../scene/batching/batch-group.js';\nimport { GraphNode } from '../../../scene/graph-node.js';\nimport { MeshInstance } from '../../../scene/mesh-instance.js';\nimport { Model } from '../../../scene/model.js';\nimport { getShapePrimitive } from '../../graphics/primitive-cache.js';\nimport { Asset } from '../../asset/asset.js';\nimport { Component } from '../component.js';\n\nclass ModelComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._type = 'asset';\n\t\tthis._asset = null;\n\t\tthis._model = null;\n\t\tthis._mapping = {};\n\t\tthis._castShadows = true;\n\t\tthis._receiveShadows = true;\n\t\tthis._materialAsset = null;\n\t\tthis._material = void 0;\n\t\tthis._castShadowsLightmap = true;\n\t\tthis._lightmapped = false;\n\t\tthis._lightmapSizeMultiplier = 1;\n\t\tthis.isStatic = false;\n\t\tthis._layers = [LAYERID_WORLD];\n\t\tthis._batchGroupId = -1;\n\t\tthis._customAabb = null;\n\t\tthis._area = null;\n\t\tthis._materialEvents = null;\n\t\tthis._clonedModel = false;\n\t\tthis._evtLayersChanged = null;\n\t\tthis._evtLayerAdded = null;\n\t\tthis._evtLayerRemoved = null;\n\t\tthis._material = system.defaultMaterial;\n\t\tentity.on('remove', this.onRemoveChild, this);\n\t\tentity.on('removehierarchy', this.onRemoveChild, this);\n\t\tentity.on('insert', this.onInsertChild, this);\n\t\tentity.on('inserthierarchy', this.onInsertChild, this);\n\t}\n\tset meshInstances(value) {\n\t\tif (!this._model) {\n\t\t\treturn;\n\t\t}\n\t\tthis._model.meshInstances = value;\n\t}\n\tget meshInstances() {\n\t\tif (!this._model) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._model.meshInstances;\n\t}\n\tset customAabb(value) {\n\t\tthis._customAabb = value;\n\t\tif (this._model) {\n\t\t\tconst mi = this._model.meshInstances;\n\t\t\tif (mi) {\n\t\t\t\tfor (let i = 0; i < mi.length; i++) {\n\t\t\t\t\tmi[i].setCustomAabb(this._customAabb);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tget customAabb() {\n\t\treturn this._customAabb;\n\t}\n\tset type(value) {\n\t\tif (this._type === value) return;\n\t\tthis._area = null;\n\t\tthis._type = value;\n\t\tif (value === 'asset') {\n\t\t\tif (this._asset !== null) {\n\t\t\t\tthis._bindModelAsset(this._asset);\n\t\t\t} else {\n\t\t\t\tthis.model = null;\n\t\t\t}\n\t\t} else {\n\t\t\tconst primData = getShapePrimitive(this.system.app.graphicsDevice, value);\n\t\t\tthis._area = primData.area;\n\t\t\tconst mesh = primData.mesh;\n\t\t\tconst node = new GraphNode();\n\t\t\tconst model = new Model();\n\t\t\tmodel.graph = node;\n\t\t\tmodel.meshInstances = [new MeshInstance(mesh, this._material, node)];\n\t\t\tthis.model = model;\n\t\t\tthis._asset = null;\n\t\t}\n\t}\n\tget type() {\n\t\treturn this._type;\n\t}\n\tset asset(value) {\n\t\tconst assets = this.system.app.assets;\n\t\tlet _id = value;\n\t\tif (value instanceof Asset) {\n\t\t\t_id = value.id;\n\t\t}\n\t\tif (this._asset !== _id) {\n\t\t\tif (this._asset) {\n\t\t\t\tassets.off(`add:${this._asset}`, this._onModelAssetAdded, this);\n\t\t\t\tconst _prev = assets.get(this._asset);\n\t\t\t\tif (_prev) {\n\t\t\t\t\tthis._unbindModelAsset(_prev);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._asset = _id;\n\t\t\tif (this._asset) {\n\t\t\t\tconst asset = assets.get(this._asset);\n\t\t\t\tif (!asset) {\n\t\t\t\t\tthis.model = null;\n\t\t\t\t\tassets.on(`add:${this._asset}`, this._onModelAssetAdded, this);\n\t\t\t\t} else {\n\t\t\t\t\tthis._bindModelAsset(asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.model = null;\n\t\t\t}\n\t\t}\n\t}\n\tget asset() {\n\t\treturn this._asset;\n\t}\n\tset model(value) {\n\t\tif (this._model === value) {\n\t\t\treturn;\n\t\t}\n\t\tif (value && value._immutable) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._model) {\n\t\t\tthis._model._immutable = false;\n\t\t\tthis.removeModelFromLayers();\n\t\t\tthis._model.getGraph().destroy();\n\t\t\tdelete this._model._entity;\n\t\t\tif (this._clonedModel) {\n\t\t\t\tthis._model.destroy();\n\t\t\t\tthis._clonedModel = false;\n\t\t\t}\n\t\t}\n\t\tthis._model = value;\n\t\tif (this._model) {\n\t\t\tthis._model._immutable = true;\n\t\t\tconst meshInstances = this._model.meshInstances;\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tmeshInstances[i].castShadow = this._castShadows;\n\t\t\t\tmeshInstances[i].receiveShadow = this._receiveShadows;\n\t\t\t\tmeshInstances[i].setCustomAabb(this._customAabb);\n\t\t\t}\n\t\t\tthis.lightmapped = this._lightmapped;\n\t\t\tthis.entity.addChild(this._model.graph);\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis.addModelToLayers();\n\t\t\t}\n\t\t\tthis._model._entity = this.entity;\n\t\t\tif (this.entity.animation) {\n\t\t\t\tthis.entity.animation.setModel(this._model);\n\t\t\t}\n\t\t\tif (this.entity.anim) {\n\t\t\t\tthis.entity.anim.rebind();\n\t\t\t}\n\t\t\tif (this.type === 'asset') {\n\t\t\t\tthis.mapping = this._mapping;\n\t\t\t} else {\n\t\t\t\tthis._unsetMaterialEvents();\n\t\t\t}\n\t\t}\n\t}\n\tget model() {\n\t\treturn this._model;\n\t}\n\tset lightmapped(value) {\n\t\tif (value !== this._lightmapped) {\n\t\t\tthis._lightmapped = value;\n\t\t\tif (this._model) {\n\t\t\t\tconst mi = this._model.meshInstances;\n\t\t\t\tfor (let i = 0; i < mi.length; i++) {\n\t\t\t\t\tmi[i].setLightmapped(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tget lightmapped() {\n\t\treturn this._lightmapped;\n\t}\n\tset castShadows(value) {\n\t\tif (this._castShadows === value) return;\n\t\tconst model = this._model;\n\t\tif (model) {\n\t\t\tconst layers = this.layers;\n\t\t\tconst scene = this.system.app.scene;\n\t\t\tif (this._castShadows && !value) {\n\t\t\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\t\t\t\t\tif (!layer) continue;\n\t\t\t\t\tlayer.removeShadowCasters(model.meshInstances);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst meshInstances = model.meshInstances;\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tmeshInstances[i].castShadow = value;\n\t\t\t}\n\t\t\tif (!this._castShadows && value) {\n\t\t\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\t\t\tconst layer = scene.layers.getLayerById(layers[i]);\n\t\t\t\t\tif (!layer) continue;\n\t\t\t\t\tlayer.addShadowCasters(model.meshInstances);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._castShadows = value;\n\t}\n\tget castShadows() {\n\t\treturn this._castShadows;\n\t}\n\tset receiveShadows(value) {\n\t\tif (this._receiveShadows === value) return;\n\t\tthis._receiveShadows = value;\n\t\tif (this._model) {\n\t\t\tconst meshInstances = this._model.meshInstances;\n\t\t\tfor (let i = 0, len = meshInstances.length; i < len; i++) {\n\t\t\t\tmeshInstances[i].receiveShadow = value;\n\t\t\t}\n\t\t}\n\t}\n\tget receiveShadows() {\n\t\treturn this._receiveShadows;\n\t}\n\tset castShadowsLightmap(value) {\n\t\tthis._castShadowsLightmap = value;\n\t}\n\tget castShadowsLightmap() {\n\t\treturn this._castShadowsLightmap;\n\t}\n\tset lightmapSizeMultiplier(value) {\n\t\tthis._lightmapSizeMultiplier = value;\n\t}\n\tget lightmapSizeMultiplier() {\n\t\treturn this._lightmapSizeMultiplier;\n\t}\n\tset layers(value) {\n\t\tconst layers = this.system.app.scene.layers;\n\t\tif (this.meshInstances) {\n\t\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\t\tconst layer = layers.getLayerById(this._layers[i]);\n\t\t\t\tif (!layer) continue;\n\t\t\t\tlayer.removeMeshInstances(this.meshInstances);\n\t\t\t}\n\t\t}\n\t\tthis._layers.length = 0;\n\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\tthis._layers[i] = value[i];\n\t\t}\n\t\tif (!this.enabled || !this.entity.enabled || !this.meshInstances) return;\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layer = layers.getLayerById(this._layers[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.addMeshInstances(this.meshInstances);\n\t\t}\n\t}\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\tset batchGroupId(value) {\n\t\tif (this._batchGroupId === value) return;\n\t\tif (this.entity.enabled && this._batchGroupId >= 0) {\n\t\t\tvar _this$system$app$batc;\n\t\t\t(_this$system$app$batc = this.system.app.batcher) == null || _this$system$app$batc.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);\n\t\t}\n\t\tif (this.entity.enabled && value >= 0) {\n\t\t\tvar _this$system$app$batc2;\n\t\t\t(_this$system$app$batc2 = this.system.app.batcher) == null || _this$system$app$batc2.insert(BatchGroup.MODEL, value, this.entity);\n\t\t}\n\t\tif (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {\n\t\t\tthis.addModelToLayers();\n\t\t}\n\t\tthis._batchGroupId = value;\n\t}\n\tget batchGroupId() {\n\t\treturn this._batchGroupId;\n\t}\n\tset materialAsset(value) {\n\t\tlet _id = value;\n\t\tif (value instanceof Asset) {\n\t\t\t_id = value.id;\n\t\t}\n\t\tconst assets = this.system.app.assets;\n\t\tif (_id !== this._materialAsset) {\n\t\t\tif (this._materialAsset) {\n\t\t\t\tassets.off(`add:${this._materialAsset}`, this._onMaterialAssetAdd, this);\n\t\t\t\tconst _prev = assets.get(this._materialAsset);\n\t\t\t\tif (_prev) {\n\t\t\t\t\tthis._unbindMaterialAsset(_prev);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._materialAsset = _id;\n\t\t\tif (this._materialAsset) {\n\t\t\t\tconst asset = assets.get(this._materialAsset);\n\t\t\t\tif (!asset) {\n\t\t\t\t\tthis._setMaterial(this.system.defaultMaterial);\n\t\t\t\t\tassets.on(`add:${this._materialAsset}`, this._onMaterialAssetAdd, this);\n\t\t\t\t} else {\n\t\t\t\t\tthis._bindMaterialAsset(asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._setMaterial(this.system.defaultMaterial);\n\t\t\t}\n\t\t}\n\t}\n\tget materialAsset() {\n\t\treturn this._materialAsset;\n\t}\n\tset material(value) {\n\t\tif (this._material === value) {\n\t\t\treturn;\n\t\t}\n\t\tthis.materialAsset = null;\n\t\tthis._setMaterial(value);\n\t}\n\tget material() {\n\t\treturn this._material;\n\t}\n\tset mapping(value) {\n\t\tif (this._type !== 'asset') {\n\t\t\treturn;\n\t\t}\n\t\tthis._unsetMaterialEvents();\n\t\tif (!value) {\n\t\t\tvalue = {};\n\t\t}\n\t\tthis._mapping = value;\n\t\tif (!this._model) return;\n\t\tconst meshInstances = this._model.meshInstances;\n\t\tconst modelAsset = this.asset ? this.system.app.assets.get(this.asset) : null;\n\t\tconst assetMapping = modelAsset ? modelAsset.data.mapping : null;\n\t\tlet asset = null;\n\t\tfor (let i = 0, len = meshInstances.length; i < len; i++) {\n\t\t\tif (value[i] !== undefined) {\n\t\t\t\tif (value[i]) {\n\t\t\t\t\tasset = this.system.app.assets.get(value[i]);\n\t\t\t\t\tthis._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);\n\t\t\t\t} else {\n\t\t\t\t\tmeshInstances[i].material = this.system.defaultMaterial;\n\t\t\t\t}\n\t\t\t} else if (assetMapping) {\n\t\t\t\tif (assetMapping[i] && (assetMapping[i].material || assetMapping[i].path)) {\n\t\t\t\t\tif (assetMapping[i].material !== undefined) {\n\t\t\t\t\t\tasset = this.system.app.assets.get(assetMapping[i].material);\n\t\t\t\t\t} else if (assetMapping[i].path !== undefined) {\n\t\t\t\t\t\tconst url = this._getMaterialAssetUrl(assetMapping[i].path);\n\t\t\t\t\t\tif (url) {\n\t\t\t\t\t\t\tasset = this.system.app.assets.getByUrl(url);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._loadAndSetMeshInstanceMaterial(asset, meshInstances[i], i);\n\t\t\t\t} else {\n\t\t\t\t\tmeshInstances[i].material = this.system.defaultMaterial;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tget mapping() {\n\t\treturn this._mapping;\n\t}\n\taddModelToLayers() {\n\t\tconst layers = this.system.app.scene.layers;\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layer = layers.getLayerById(this._layers[i]);\n\t\t\tif (layer) {\n\t\t\t\tlayer.addMeshInstances(this.meshInstances);\n\t\t\t}\n\t\t}\n\t}\n\tremoveModelFromLayers() {\n\t\tconst layers = this.system.app.scene.layers;\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layer = layers.getLayerById(this._layers[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.removeMeshInstances(this.meshInstances);\n\t\t}\n\t}\n\tonRemoveChild() {\n\t\tif (this._model) {\n\t\t\tthis.removeModelFromLayers();\n\t\t}\n\t}\n\tonInsertChild() {\n\t\tif (this._model && this.enabled && this.entity.enabled) {\n\t\t\tthis.addModelToLayers();\n\t\t}\n\t}\n\tonRemove() {\n\t\tthis.asset = null;\n\t\tthis.model = null;\n\t\tthis.materialAsset = null;\n\t\tthis._unsetMaterialEvents();\n\t\tthis.entity.off('remove', this.onRemoveChild, this);\n\t\tthis.entity.off('insert', this.onInsertChild, this);\n\t}\n\tonLayersChanged(oldComp, newComp) {\n\t\tthis.addModelToLayers();\n\t\toldComp.off('add', this.onLayerAdded, this);\n\t\toldComp.off('remove', this.onLayerRemoved, this);\n\t\tnewComp.on('add', this.onLayerAdded, this);\n\t\tnewComp.on('remove', this.onLayerRemoved, this);\n\t}\n\tonLayerAdded(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.addMeshInstances(this.meshInstances);\n\t}\n\tonLayerRemoved(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.removeMeshInstances(this.meshInstances);\n\t}\n\t_setMaterialEvent(index, event, id, handler) {\n\t\tconst evt = `${event}:${id}`;\n\t\tthis.system.app.assets.on(evt, handler, this);\n\t\tif (!this._materialEvents) {\n\t\t\tthis._materialEvents = [];\n\t\t}\n\t\tif (!this._materialEvents[index]) {\n\t\t\tthis._materialEvents[index] = {};\n\t\t}\n\t\tthis._materialEvents[index][evt] = {\n\t\t\tid: id,\n\t\t\thandler: handler\n\t\t};\n\t}\n\t_unsetMaterialEvents() {\n\t\tconst assets = this.system.app.assets;\n\t\tconst events = this._materialEvents;\n\t\tif (!events) {\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0, len = events.length; i < len; i++) {\n\t\t\tif (!events[i]) continue;\n\t\t\tconst evt = events[i];\n\t\t\tfor (const key in evt) {\n\t\t\t\tassets.off(key, evt[key].handler, this);\n\t\t\t}\n\t\t}\n\t\tthis._materialEvents = null;\n\t}\n\t_getAssetByIdOrPath(idOrPath) {\n\t\tlet asset = null;\n\t\tconst isPath = isNaN(parseInt(idOrPath, 10));\n\t\tif (!isPath) {\n\t\t\tasset = this.system.app.assets.get(idOrPath);\n\t\t} else if (this.asset) {\n\t\t\tconst url = this._getMaterialAssetUrl(idOrPath);\n\t\t\tif (url) {\n\t\t\t\tasset = this.system.app.assets.getByUrl(url);\n\t\t\t}\n\t\t}\n\t\treturn asset;\n\t}\n\t_getMaterialAssetUrl(path) {\n\t\tif (!this.asset) return null;\n\t\tconst modelAsset = this.system.app.assets.get(this.asset);\n\t\treturn modelAsset ? modelAsset.getAbsoluteUrl(path) : null;\n\t}\n\t_loadAndSetMeshInstanceMaterial(materialAsset, meshInstance, index) {\n\t\tconst assets = this.system.app.assets;\n\t\tif (!materialAsset) {\n\t\t\treturn;\n\t\t}\n\t\tif (materialAsset.resource) {\n\t\t\tmeshInstance.material = materialAsset.resource;\n\t\t\tthis._setMaterialEvent(index, 'remove', materialAsset.id, function () {\n\t\t\t\tmeshInstance.material = this.system.defaultMaterial;\n\t\t\t});\n\t\t} else {\n\t\t\tthis._setMaterialEvent(index, 'load', materialAsset.id, function (asset) {\n\t\t\t\tmeshInstance.material = asset.resource;\n\t\t\t\tthis._setMaterialEvent(index, 'remove', materialAsset.id, function () {\n\t\t\t\t\tmeshInstance.material = this.system.defaultMaterial;\n\t\t\t\t});\n\t\t\t});\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tassets.load(materialAsset);\n\t\t\t}\n\t\t}\n\t}\n\tonEnable() {\n\t\tconst app = this.system.app;\n\t\tconst scene = app.scene;\n\t\tconst layers = scene == null ? void 0 : scene.layers;\n\t\tthis._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);\n\t\tif (layers) {\n\t\t\tthis._evtLayerAdded = layers.on('add', this.onLayerAdded, this);\n\t\t\tthis._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);\n\t\t}\n\t\tconst isAsset = this._type === 'asset';\n\t\tlet asset;\n\t\tif (this._model) {\n\t\t\tthis.addModelToLayers();\n\t\t} else if (isAsset && this._asset) {\n\t\t\tasset = app.assets.get(this._asset);\n\t\t\tif (asset && asset.resource !== this._model) {\n\t\t\t\tthis._bindModelAsset(asset);\n\t\t\t}\n\t\t}\n\t\tif (this._materialAsset) {\n\t\t\tasset = app.assets.get(this._materialAsset);\n\t\t\tif (asset && asset.resource !== this._material) {\n\t\t\t\tthis._bindMaterialAsset(asset);\n\t\t\t}\n\t\t}\n\t\tif (isAsset) {\n\t\t\tif (this._mapping) {\n\t\t\t\tfor (const index in this._mapping) {\n\t\t\t\t\tif (this._mapping[index]) {\n\t\t\t\t\t\tasset = this._getAssetByIdOrPath(this._mapping[index]);\n\t\t\t\t\t\tif (asset && !asset.resource) {\n\t\t\t\t\t\t\tapp.assets.load(asset);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tvar _app$batcher;\n\t\t\t(_app$batcher = app.batcher) == null || _app$batcher.insert(BatchGroup.MODEL, this.batchGroupId, this.entity);\n\t\t}\n\t}\n\tonDisable() {\n\t\tvar _this$_evtLayersChang;\n\t\tconst app = this.system.app;\n\t\tconst scene = app.scene;\n\t\tconst layers = scene.layers;\n\t\t(_this$_evtLayersChang = this._evtLayersChanged) == null || _this$_evtLayersChang.off();\n\t\tthis._evtLayersChanged = null;\n\t\tif (layers) {\n\t\t\tvar _this$_evtLayerAdded, _this$_evtLayerRemove;\n\t\t\t(_this$_evtLayerAdded = this._evtLayerAdded) == null || _this$_evtLayerAdded.off();\n\t\t\tthis._evtLayerAdded = null;\n\t\t\t(_this$_evtLayerRemove = this._evtLayerRemoved) == null || _this$_evtLayerRemove.off();\n\t\t\tthis._evtLayerRemoved = null;\n\t\t}\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tvar _app$batcher2;\n\t\t\t(_app$batcher2 = app.batcher) == null || _app$batcher2.remove(BatchGroup.MODEL, this.batchGroupId, this.entity);\n\t\t}\n\t\tif (this._model) {\n\t\t\tthis.removeModelFromLayers();\n\t\t}\n\t}\n\thide() {\n\t\tif (this._model) {\n\t\t\tconst instances = this._model.meshInstances;\n\t\t\tfor (let i = 0, l = instances.length; i < l; i++) {\n\t\t\t\tinstances[i].visible = false;\n\t\t\t}\n\t\t}\n\t}\n\tshow() {\n\t\tif (this._model) {\n\t\t\tconst instances = this._model.meshInstances;\n\t\t\tfor (let i = 0, l = instances.length; i < l; i++) {\n\t\t\t\tinstances[i].visible = true;\n\t\t\t}\n\t\t}\n\t}\n\t_bindMaterialAsset(asset) {\n\t\tasset.on('load', this._onMaterialAssetLoad, this);\n\t\tasset.on('unload', this._onMaterialAssetUnload, this);\n\t\tasset.on('remove', this._onMaterialAssetRemove, this);\n\t\tasset.on('change', this._onMaterialAssetChange, this);\n\t\tif (asset.resource) {\n\t\t\tthis._onMaterialAssetLoad(asset);\n\t\t} else {\n\t\t\tif (!this.enabled || !this.entity.enabled) return;\n\t\t\tthis.system.app.assets.load(asset);\n\t\t}\n\t}\n\t_unbindMaterialAsset(asset) {\n\t\tasset.off('load', this._onMaterialAssetLoad, this);\n\t\tasset.off('unload', this._onMaterialAssetUnload, this);\n\t\tasset.off('remove', this._onMaterialAssetRemove, this);\n\t\tasset.off('change', this._onMaterialAssetChange, this);\n\t}\n\t_onMaterialAssetAdd(asset) {\n\t\tthis.system.app.assets.off(`add:${asset.id}`, this._onMaterialAssetAdd, this);\n\t\tif (this._materialAsset === asset.id) {\n\t\t\tthis._bindMaterialAsset(asset);\n\t\t}\n\t}\n\t_onMaterialAssetLoad(asset) {\n\t\tthis._setMaterial(asset.resource);\n\t}\n\t_onMaterialAssetUnload(asset) {\n\t\tthis._setMaterial(this.system.defaultMaterial);\n\t}\n\t_onMaterialAssetRemove(asset) {\n\t\tthis._onMaterialAssetUnload(asset);\n\t}\n\t_onMaterialAssetChange(asset) {}\n\t_bindModelAsset(asset) {\n\t\tthis._unbindModelAsset(asset);\n\t\tasset.on('load', this._onModelAssetLoad, this);\n\t\tasset.on('unload', this._onModelAssetUnload, this);\n\t\tasset.on('change', this._onModelAssetChange, this);\n\t\tasset.on('remove', this._onModelAssetRemove, this);\n\t\tif (asset.resource) {\n\t\t\tthis._onModelAssetLoad(asset);\n\t\t} else {\n\t\t\tif (!this.enabled || !this.entity.enabled) return;\n\t\t\tthis.system.app.assets.load(asset);\n\t\t}\n\t}\n\t_unbindModelAsset(asset) {\n\t\tasset.off('load', this._onModelAssetLoad, this);\n\t\tasset.off('unload', this._onModelAssetUnload, this);\n\t\tasset.off('change', this._onModelAssetChange, this);\n\t\tasset.off('remove', this._onModelAssetRemove, this);\n\t}\n\t_onModelAssetAdded(asset) {\n\t\tthis.system.app.assets.off(`add:${asset.id}`, this._onModelAssetAdded, this);\n\t\tif (asset.id === this._asset) {\n\t\t\tthis._bindModelAsset(asset);\n\t\t}\n\t}\n\t_onModelAssetLoad(asset) {\n\t\tthis.model = asset.resource.clone();\n\t\tthis._clonedModel = true;\n\t}\n\t_onModelAssetUnload(asset) {\n\t\tthis.model = null;\n\t}\n\t_onModelAssetChange(asset, attr, _new, _old) {\n\t\tif (attr === 'data') {\n\t\t\tthis.mapping = this._mapping;\n\t\t}\n\t}\n\t_onModelAssetRemove(asset) {\n\t\tthis.model = null;\n\t}\n\t_setMaterial(material) {\n\t\tif (this._material === material) {\n\t\t\treturn;\n\t\t}\n\t\tthis._material = material;\n\t\tconst model = this._model;\n\t\tif (model && this._type !== 'asset') {\n\t\t\tconst meshInstances = model.meshInstances;\n\t\t\tfor (let i = 0, len = meshInstances.length; i < len; i++) {\n\t\t\t\tmeshInstances[i].material = material;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { ModelComponent };\n","class ModelComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n}\n\nexport { ModelComponentData };\n","import { extend } from '../../../core/core.js';\nimport { Vec3 } from '../../../core/math/vec3.js';\nimport { BoundingBox } from '../../../core/shape/bounding-box.js';\nimport { getDefaultMaterial } from '../../../scene/materials/default-material.js';\nimport { Asset } from '../../asset/asset.js';\nimport { Component } from '../component.js';\nimport { ComponentSystem } from '../system.js';\nimport { ModelComponent } from './component.js';\nimport { ModelComponentData } from './data.js';\n\nconst _schema = ['enabled'];\nclass ModelComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'model';\n\t\tthis.ComponentType = ModelComponent;\n\t\tthis.DataType = ModelComponentData;\n\t\tthis.schema = _schema;\n\t\tthis.defaultMaterial = getDefaultMaterial(app.graphicsDevice);\n\t\tthis.on('beforeremove', this.onRemove, this);\n\t}\n\tinitializeComponentData(component, _data, properties) {\n\t\tproperties = ['material', 'materialAsset', 'asset', 'castShadows', 'receiveShadows', 'castShadowsLightmap', 'lightmapped', 'lightmapSizeMultiplier', 'type', 'mapping', 'layers', 'isStatic', 'batchGroupId'];\n\t\tif (_data.batchGroupId === null || _data.batchGroupId === undefined) {\n\t\t\t_data.batchGroupId = -1;\n\t\t}\n\t\tif (_data.layers && _data.layers.length) {\n\t\t\t_data.layers = _data.layers.slice(0);\n\t\t}\n\t\tfor (let i = 0; i < properties.length; i++) {\n\t\t\tif (_data.hasOwnProperty(properties[i])) {\n\t\t\t\tcomponent[properties[i]] = _data[properties[i]];\n\t\t\t}\n\t\t}\n\t\tif (_data.aabbCenter && _data.aabbHalfExtents) {\n\t\t\tcomponent.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));\n\t\t}\n\t\tsuper.initializeComponentData(component, _data, ['enabled']);\n\t}\n\tcloneComponent(entity, clone) {\n\t\tconst data = {\n\t\t\ttype: entity.model.type,\n\t\t\tasset: entity.model.asset,\n\t\t\tcastShadows: entity.model.castShadows,\n\t\t\treceiveShadows: entity.model.receiveShadows,\n\t\t\tcastShadowsLightmap: entity.model.castShadowsLightmap,\n\t\t\tlightmapped: entity.model.lightmapped,\n\t\t\tlightmapSizeMultiplier: entity.model.lightmapSizeMultiplier,\n\t\t\tisStatic: entity.model.isStatic,\n\t\t\tenabled: entity.model.enabled,\n\t\t\tlayers: entity.model.layers,\n\t\t\tbatchGroupId: entity.model.batchGroupId,\n\t\t\tmapping: extend({}, entity.model.mapping)\n\t\t};\n\t\tlet materialAsset = entity.model.materialAsset;\n\t\tif (!(materialAsset instanceof Asset) && materialAsset != null) {\n\t\t\tmaterialAsset = this.app.assets.get(materialAsset);\n\t\t}\n\t\tconst material = entity.model.material;\n\t\tif (!material || material === this.defaultMaterial || !materialAsset || material === materialAsset.resource) {\n\t\t\tdata.materialAsset = materialAsset;\n\t\t}\n\t\tconst component = this.addComponent(clone, data);\n\t\tif (entity.model.model && entity.model.type === 'asset' && !entity.model.asset) {\n\t\t\tcomponent.model = entity.model.model.clone();\n\t\t\tcomponent._clonedModel = true;\n\t\t}\n\t\tif (!data.materialAsset) {\n\t\t\tcomponent.material = material;\n\t\t}\n\t\tif (entity.model.model) {\n\t\t\tconst meshInstances = entity.model.model.meshInstances;\n\t\t\tconst meshInstancesClone = component.model.meshInstances;\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tmeshInstancesClone[i].mask = meshInstances[i].mask;\n\t\t\t\tmeshInstancesClone[i].material = meshInstances[i].material;\n\t\t\t\tmeshInstancesClone[i].layer = meshInstances[i].layer;\n\t\t\t\tmeshInstancesClone[i].receiveShadow = meshInstances[i].receiveShadow;\n\t\t\t}\n\t\t}\n\t\tif (entity.model.customAabb) {\n\t\t\tcomponent.customAabb = entity.model.customAabb.clone();\n\t\t}\n\t\treturn component;\n\t}\n\tonRemove(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n}\nComponent._buildAccessors(ModelComponent.prototype, _schema);\n\nexport { ModelComponentSystem };\n","import { LAYERID_DEPTH } from '../../../scene/constants.js';\nimport { Mesh } from '../../../scene/mesh.js';\nimport { ParticleEmitter } from '../../../scene/particle-system/particle-emitter.js';\nimport { Asset } from '../../asset/asset.js';\nimport { Component } from '../component.js';\n\nconst SIMPLE_PROPERTIES = ['emitterExtents', 'emitterRadius', 'emitterExtentsInner', 'emitterRadiusInner', 'loop', 'initialVelocity', 'animSpeed', 'normalMap', 'particleNormal'];\nconst COMPLEX_PROPERTIES = ['numParticles', 'lifetime', 'rate', 'rate2', 'startAngle', 'startAngle2', 'lighting', 'halfLambert', 'intensity', 'wrap', 'wrapBounds', 'depthWrite', 'noFog', 'sort', 'stretch', 'alignToMotion', 'preWarm', 'emitterShape', 'animTilesX', 'animTilesY', 'animStartFrame', 'animNumFrames', 'animNumAnimations', 'animIndex', 'randomizeAnimIndex', 'animLoop', 'colorMap', 'localSpace', 'screenSpace', 'orientation'];\nconst GRAPH_PROPERTIES = ['scaleGraph', 'scaleGraph2', 'colorGraph', 'colorGraph2', 'alphaGraph', 'alphaGraph2', 'velocityGraph', 'velocityGraph2', 'localVelocityGraph', 'localVelocityGraph2', 'rotationSpeedGraph', 'rotationSpeedGraph2', 'radialSpeedGraph', 'radialSpeedGraph2'];\nconst ASSET_PROPERTIES = ['colorMapAsset', 'normalMapAsset', 'meshAsset', 'renderAsset'];\nlet depthLayer;\nclass ParticleSystemComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._requestedDepth = false;\n\t\tthis._drawOrder = 0;\n\t\tthis._evtLayersChanged = null;\n\t\tthis._evtLayerAdded = null;\n\t\tthis._evtLayerRemoved = null;\n\t\tthis._evtSetMeshes = null;\n\t\tthis.on('set_colorMapAsset', this.onSetColorMapAsset, this);\n\t\tthis.on('set_normalMapAsset', this.onSetNormalMapAsset, this);\n\t\tthis.on('set_meshAsset', this.onSetMeshAsset, this);\n\t\tthis.on('set_mesh', this.onSetMesh, this);\n\t\tthis.on('set_renderAsset', this.onSetRenderAsset, this);\n\t\tthis.on('set_loop', this.onSetLoop, this);\n\t\tthis.on('set_blendType', this.onSetBlendType, this);\n\t\tthis.on('set_depthSoftening', this.onSetDepthSoftening, this);\n\t\tthis.on('set_layers', this.onSetLayers, this);\n\t\tSIMPLE_PROPERTIES.forEach(prop => {\n\t\t\tthis.on(`set_${prop}`, this.onSetSimpleProperty, this);\n\t\t});\n\t\tCOMPLEX_PROPERTIES.forEach(prop => {\n\t\t\tthis.on(`set_${prop}`, this.onSetComplexProperty, this);\n\t\t});\n\t\tGRAPH_PROPERTIES.forEach(prop => {\n\t\t\tthis.on(`set_${prop}`, this.onSetGraphProperty, this);\n\t\t});\n\t}\n\tget data() {\n\t\tconst record = this.system.store[this.entity.getGuid()];\n\t\treturn record ? record.data : null;\n\t}\n\tset enabled(arg) {\n\t\tthis._setValue('enabled', arg);\n\t}\n\tget enabled() {\n\t\treturn this.data.enabled;\n\t}\n\tset autoPlay(arg) {\n\t\tthis._setValue('autoPlay', arg);\n\t}\n\tget autoPlay() {\n\t\treturn this.data.autoPlay;\n\t}\n\tset numParticles(arg) {\n\t\tthis._setValue('numParticles', arg);\n\t}\n\tget numParticles() {\n\t\treturn this.data.numParticles;\n\t}\n\tset lifetime(arg) {\n\t\tthis._setValue('lifetime', arg);\n\t}\n\tget lifetime() {\n\t\treturn this.data.lifetime;\n\t}\n\tset rate(arg) {\n\t\tthis._setValue('rate', arg);\n\t}\n\tget rate() {\n\t\treturn this.data.rate;\n\t}\n\tset rate2(arg) {\n\t\tthis._setValue('rate2', arg);\n\t}\n\tget rate2() {\n\t\treturn this.data.rate2;\n\t}\n\tset startAngle(arg) {\n\t\tthis._setValue('startAngle', arg);\n\t}\n\tget startAngle() {\n\t\treturn this.data.startAngle;\n\t}\n\tset startAngle2(arg) {\n\t\tthis._setValue('startAngle2', arg);\n\t}\n\tget startAngle2() {\n\t\treturn this.data.startAngle2;\n\t}\n\tset loop(arg) {\n\t\tthis._setValue('loop', arg);\n\t}\n\tget loop() {\n\t\treturn this.data.loop;\n\t}\n\tset preWarm(arg) {\n\t\tthis._setValue('preWarm', arg);\n\t}\n\tget preWarm() {\n\t\treturn this.data.preWarm;\n\t}\n\tset lighting(arg) {\n\t\tthis._setValue('lighting', arg);\n\t}\n\tget lighting() {\n\t\treturn this.data.lighting;\n\t}\n\tset halfLambert(arg) {\n\t\tthis._setValue('halfLambert', arg);\n\t}\n\tget halfLambert() {\n\t\treturn this.data.halfLambert;\n\t}\n\tset intensity(arg) {\n\t\tthis._setValue('intensity', arg);\n\t}\n\tget intensity() {\n\t\treturn this.data.intensity;\n\t}\n\tset depthWrite(arg) {\n\t\tthis._setValue('depthWrite', arg);\n\t}\n\tget depthWrite() {\n\t\treturn this.data.depthWrite;\n\t}\n\tset noFog(arg) {\n\t\tthis._setValue('noFog', arg);\n\t}\n\tget noFog() {\n\t\treturn this.data.noFog;\n\t}\n\tset depthSoftening(arg) {\n\t\tthis._setValue('depthSoftening', arg);\n\t}\n\tget depthSoftening() {\n\t\treturn this.data.depthSoftening;\n\t}\n\tset sort(arg) {\n\t\tthis._setValue('sort', arg);\n\t}\n\tget sort() {\n\t\treturn this.data.sort;\n\t}\n\tset blendType(arg) {\n\t\tthis._setValue('blendType', arg);\n\t}\n\tget blendType() {\n\t\treturn this.data.blendType;\n\t}\n\tset stretch(arg) {\n\t\tthis._setValue('stretch', arg);\n\t}\n\tget stretch() {\n\t\treturn this.data.stretch;\n\t}\n\tset alignToMotion(arg) {\n\t\tthis._setValue('alignToMotion', arg);\n\t}\n\tget alignToMotion() {\n\t\treturn this.data.alignToMotion;\n\t}\n\tset emitterShape(arg) {\n\t\tthis._setValue('emitterShape', arg);\n\t}\n\tget emitterShape() {\n\t\treturn this.data.emitterShape;\n\t}\n\tset emitterExtents(arg) {\n\t\tthis._setValue('emitterExtents', arg);\n\t}\n\tget emitterExtents() {\n\t\treturn this.data.emitterExtents;\n\t}\n\tset emitterExtentsInner(arg) {\n\t\tthis._setValue('emitterExtentsInner', arg);\n\t}\n\tget emitterExtentsInner() {\n\t\treturn this.data.emitterExtentsInner;\n\t}\n\tset emitterRadius(arg) {\n\t\tthis._setValue('emitterRadius', arg);\n\t}\n\tget emitterRadius() {\n\t\treturn this.data.emitterRadius;\n\t}\n\tset emitterRadiusInner(arg) {\n\t\tthis._setValue('emitterRadiusInner', arg);\n\t}\n\tget emitterRadiusInner() {\n\t\treturn this.data.emitterRadiusInner;\n\t}\n\tset initialVelocity(arg) {\n\t\tthis._setValue('initialVelocity', arg);\n\t}\n\tget initialVelocity() {\n\t\treturn this.data.initialVelocity;\n\t}\n\tset wrap(arg) {\n\t\tthis._setValue('wrap', arg);\n\t}\n\tget wrap() {\n\t\treturn this.data.wrap;\n\t}\n\tset wrapBounds(arg) {\n\t\tthis._setValue('wrapBounds', arg);\n\t}\n\tget wrapBounds() {\n\t\treturn this.data.wrapBounds;\n\t}\n\tset localSpace(arg) {\n\t\tthis._setValue('localSpace', arg);\n\t}\n\tget localSpace() {\n\t\treturn this.data.localSpace;\n\t}\n\tset screenSpace(arg) {\n\t\tthis._setValue('screenSpace', arg);\n\t}\n\tget screenSpace() {\n\t\treturn this.data.screenSpace;\n\t}\n\tset colorMapAsset(arg) {\n\t\tthis._setValue('colorMapAsset', arg);\n\t}\n\tget colorMapAsset() {\n\t\treturn this.data.colorMapAsset;\n\t}\n\tset normalMapAsset(arg) {\n\t\tthis._setValue('normalMapAsset', arg);\n\t}\n\tget normalMapAsset() {\n\t\treturn this.data.normalMapAsset;\n\t}\n\tset mesh(arg) {\n\t\tthis._setValue('mesh', arg);\n\t}\n\tget mesh() {\n\t\treturn this.data.mesh;\n\t}\n\tset meshAsset(arg) {\n\t\tthis._setValue('meshAsset', arg);\n\t}\n\tget meshAsset() {\n\t\treturn this.data.meshAsset;\n\t}\n\tset renderAsset(arg) {\n\t\tthis._setValue('renderAsset', arg);\n\t}\n\tget renderAsset() {\n\t\treturn this.data.renderAsset;\n\t}\n\tset orientation(arg) {\n\t\tthis._setValue('orientation', arg);\n\t}\n\tget orientation() {\n\t\treturn this.data.orientation;\n\t}\n\tset particleNormal(arg) {\n\t\tthis._setValue('particleNormal', arg);\n\t}\n\tget particleNormal() {\n\t\treturn this.data.particleNormal;\n\t}\n\tset localVelocityGraph(arg) {\n\t\tthis._setValue('localVelocityGraph', arg);\n\t}\n\tget localVelocityGraph() {\n\t\treturn this.data.localVelocityGraph;\n\t}\n\tset localVelocityGraph2(arg) {\n\t\tthis._setValue('localVelocityGraph2', arg);\n\t}\n\tget localVelocityGraph2() {\n\t\treturn this.data.localVelocityGraph2;\n\t}\n\tset velocityGraph(arg) {\n\t\tthis._setValue('velocityGraph', arg);\n\t}\n\tget velocityGraph() {\n\t\treturn this.data.velocityGraph;\n\t}\n\tset velocityGraph2(arg) {\n\t\tthis._setValue('velocityGraph2', arg);\n\t}\n\tget velocityGraph2() {\n\t\treturn this.data.velocityGraph2;\n\t}\n\tset rotationSpeedGraph(arg) {\n\t\tthis._setValue('rotationSpeedGraph', arg);\n\t}\n\tget rotationSpeedGraph() {\n\t\treturn this.data.rotationSpeedGraph;\n\t}\n\tset rotationSpeedGraph2(arg) {\n\t\tthis._setValue('rotationSpeedGraph2', arg);\n\t}\n\tget rotationSpeedGraph2() {\n\t\treturn this.data.rotationSpeedGraph2;\n\t}\n\tset radialSpeedGraph(arg) {\n\t\tthis._setValue('radialSpeedGraph', arg);\n\t}\n\tget radialSpeedGraph() {\n\t\treturn this.data.radialSpeedGraph;\n\t}\n\tset radialSpeedGraph2(arg) {\n\t\tthis._setValue('radialSpeedGraph2', arg);\n\t}\n\tget radialSpeedGraph2() {\n\t\treturn this.data.radialSpeedGraph2;\n\t}\n\tset scaleGraph(arg) {\n\t\tthis._setValue('scaleGraph', arg);\n\t}\n\tget scaleGraph() {\n\t\treturn this.data.scaleGraph;\n\t}\n\tset scaleGraph2(arg) {\n\t\tthis._setValue('scaleGraph2', arg);\n\t}\n\tget scaleGraph2() {\n\t\treturn this.data.scaleGraph2;\n\t}\n\tset colorGraph(arg) {\n\t\tthis._setValue('colorGraph', arg);\n\t}\n\tget colorGraph() {\n\t\treturn this.data.colorGraph;\n\t}\n\tset colorGraph2(arg) {\n\t\tthis._setValue('colorGraph2', arg);\n\t}\n\tget colorGraph2() {\n\t\treturn this.data.colorGraph2;\n\t}\n\tset alphaGraph(arg) {\n\t\tthis._setValue('alphaGraph', arg);\n\t}\n\tget alphaGraph() {\n\t\treturn this.data.alphaGraph;\n\t}\n\tset alphaGraph2(arg) {\n\t\tthis._setValue('alphaGraph2', arg);\n\t}\n\tget alphaGraph2() {\n\t\treturn this.data.alphaGraph2;\n\t}\n\tset colorMap(arg) {\n\t\tthis._setValue('colorMap', arg);\n\t}\n\tget colorMap() {\n\t\treturn this.data.colorMap;\n\t}\n\tset normalMap(arg) {\n\t\tthis._setValue('normalMap', arg);\n\t}\n\tget normalMap() {\n\t\treturn this.data.normalMap;\n\t}\n\tset animTilesX(arg) {\n\t\tthis._setValue('animTilesX', arg);\n\t}\n\tget animTilesX() {\n\t\treturn this.data.animTilesX;\n\t}\n\tset animTilesY(arg) {\n\t\tthis._setValue('animTilesY', arg);\n\t}\n\tget animTilesY() {\n\t\treturn this.data.animTilesY;\n\t}\n\tset animStartFrame(arg) {\n\t\tthis._setValue('animStartFrame', arg);\n\t}\n\tget animStartFrame() {\n\t\treturn this.data.animStartFrame;\n\t}\n\tset animNumFrames(arg) {\n\t\tthis._setValue('animNumFrames', arg);\n\t}\n\tget animNumFrames() {\n\t\treturn this.data.animNumFrames;\n\t}\n\tset animNumAnimations(arg) {\n\t\tthis._setValue('animNumAnimations', arg);\n\t}\n\tget animNumAnimations() {\n\t\treturn this.data.animNumAnimations;\n\t}\n\tset animIndex(arg) {\n\t\tthis._setValue('animIndex', arg);\n\t}\n\tget animIndex() {\n\t\treturn this.data.animIndex;\n\t}\n\tset randomizeAnimIndex(arg) {\n\t\tthis._setValue('randomizeAnimIndex', arg);\n\t}\n\tget randomizeAnimIndex() {\n\t\treturn this.data.randomizeAnimIndex;\n\t}\n\tset animSpeed(arg) {\n\t\tthis._setValue('animSpeed', arg);\n\t}\n\tget animSpeed() {\n\t\treturn this.data.animSpeed;\n\t}\n\tset animLoop(arg) {\n\t\tthis._setValue('animLoop', arg);\n\t}\n\tget animLoop() {\n\t\treturn this.data.animLoop;\n\t}\n\tset layers(arg) {\n\t\tthis._setValue('layers', arg);\n\t}\n\tget layers() {\n\t\treturn this.data.layers;\n\t}\n\tset drawOrder(drawOrder) {\n\t\tthis._drawOrder = drawOrder;\n\t\tif (this.emitter) {\n\t\t\tthis.emitter.drawOrder = drawOrder;\n\t\t}\n\t}\n\tget drawOrder() {\n\t\treturn this._drawOrder;\n\t}\n\t_setValue(name, value) {\n\t\tconst data = this.data;\n\t\tconst oldValue = data[name];\n\t\tdata[name] = value;\n\t\tthis.fire('set', name, oldValue, value);\n\t}\n\taddMeshInstanceToLayers() {\n\t\tif (!this.emitter) return;\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.addMeshInstances([this.emitter.meshInstance]);\n\t\t\tthis.emitter._layer = layer;\n\t\t}\n\t}\n\tremoveMeshInstanceFromLayers() {\n\t\tif (!this.emitter) return;\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.removeMeshInstances([this.emitter.meshInstance]);\n\t\t}\n\t}\n\tonSetLayers(name, oldValue, newValue) {\n\t\tif (!this.emitter) return;\n\t\tfor (let i = 0; i < oldValue.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(oldValue[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.removeMeshInstances([this.emitter.meshInstance]);\n\t\t}\n\t\tif (!this.enabled || !this.entity.enabled) return;\n\t\tfor (let i = 0; i < newValue.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(newValue[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.addMeshInstances([this.emitter.meshInstance]);\n\t\t}\n\t}\n\tonLayersChanged(oldComp, newComp) {\n\t\tthis.addMeshInstanceToLayers();\n\t\toldComp.off('add', this.onLayerAdded, this);\n\t\toldComp.off('remove', this.onLayerRemoved, this);\n\t\tnewComp.on('add', this.onLayerAdded, this);\n\t\tnewComp.on('remove', this.onLayerRemoved, this);\n\t}\n\tonLayerAdded(layer) {\n\t\tif (!this.emitter) return;\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.addMeshInstances([this.emitter.meshInstance]);\n\t}\n\tonLayerRemoved(layer) {\n\t\tif (!this.emitter) return;\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.removeMeshInstances([this.emitter.meshInstance]);\n\t}\n\t_bindColorMapAsset(asset) {\n\t\tasset.on('load', this._onColorMapAssetLoad, this);\n\t\tasset.on('unload', this._onColorMapAssetUnload, this);\n\t\tasset.on('remove', this._onColorMapAssetRemove, this);\n\t\tasset.on('change', this._onColorMapAssetChange, this);\n\t\tif (asset.resource) {\n\t\t\tthis._onColorMapAssetLoad(asset);\n\t\t} else {\n\t\t\tif (!this.enabled || !this.entity.enabled) return;\n\t\t\tthis.system.app.assets.load(asset);\n\t\t}\n\t}\n\t_unbindColorMapAsset(asset) {\n\t\tasset.off('load', this._onColorMapAssetLoad, this);\n\t\tasset.off('unload', this._onColorMapAssetUnload, this);\n\t\tasset.off('remove', this._onColorMapAssetRemove, this);\n\t\tasset.off('change', this._onColorMapAssetChange, this);\n\t}\n\t_onColorMapAssetLoad(asset) {\n\t\tthis.colorMap = asset.resource;\n\t}\n\t_onColorMapAssetUnload(asset) {\n\t\tthis.colorMap = null;\n\t}\n\t_onColorMapAssetRemove(asset) {\n\t\tthis._onColorMapAssetUnload(asset);\n\t}\n\t_onColorMapAssetChange(asset) {}\n\tonSetColorMapAsset(name, oldValue, newValue) {\n\t\tconst assets = this.system.app.assets;\n\t\tif (oldValue) {\n\t\t\tconst asset = assets.get(oldValue);\n\t\t\tif (asset) {\n\t\t\t\tthis._unbindColorMapAsset(asset);\n\t\t\t}\n\t\t}\n\t\tif (newValue) {\n\t\t\tif (newValue instanceof Asset) {\n\t\t\t\tthis.data.colorMapAsset = newValue.id;\n\t\t\t\tnewValue = newValue.id;\n\t\t\t}\n\t\t\tconst asset = assets.get(newValue);\n\t\t\tif (asset) {\n\t\t\t\tthis._bindColorMapAsset(asset);\n\t\t\t} else {\n\t\t\t\tassets.once(`add:${newValue}`, asset => {\n\t\t\t\t\tthis._bindColorMapAsset(asset);\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tthis.colorMap = null;\n\t\t}\n\t}\n\t_bindNormalMapAsset(asset) {\n\t\tasset.on('load', this._onNormalMapAssetLoad, this);\n\t\tasset.on('unload', this._onNormalMapAssetUnload, this);\n\t\tasset.on('remove', this._onNormalMapAssetRemove, this);\n\t\tasset.on('change', this._onNormalMapAssetChange, this);\n\t\tif (asset.resource) {\n\t\t\tthis._onNormalMapAssetLoad(asset);\n\t\t} else {\n\t\t\tif (!this.enabled || !this.entity.enabled) return;\n\t\t\tthis.system.app.assets.load(asset);\n\t\t}\n\t}\n\t_unbindNormalMapAsset(asset) {\n\t\tasset.off('load', this._onNormalMapAssetLoad, this);\n\t\tasset.off('unload', this._onNormalMapAssetUnload, this);\n\t\tasset.off('remove', this._onNormalMapAssetRemove, this);\n\t\tasset.off('change', this._onNormalMapAssetChange, this);\n\t}\n\t_onNormalMapAssetLoad(asset) {\n\t\tthis.normalMap = asset.resource;\n\t}\n\t_onNormalMapAssetUnload(asset) {\n\t\tthis.normalMap = null;\n\t}\n\t_onNormalMapAssetRemove(asset) {\n\t\tthis._onNormalMapAssetUnload(asset);\n\t}\n\t_onNormalMapAssetChange(asset) {}\n\tonSetNormalMapAsset(name, oldValue, newValue) {\n\t\tconst assets = this.system.app.assets;\n\t\tif (oldValue) {\n\t\t\tconst asset = assets.get(oldValue);\n\t\t\tif (asset) {\n\t\t\t\tthis._unbindNormalMapAsset(asset);\n\t\t\t}\n\t\t}\n\t\tif (newValue) {\n\t\t\tif (newValue instanceof Asset) {\n\t\t\t\tthis.data.normalMapAsset = newValue.id;\n\t\t\t\tnewValue = newValue.id;\n\t\t\t}\n\t\t\tconst asset = assets.get(newValue);\n\t\t\tif (asset) {\n\t\t\t\tthis._bindNormalMapAsset(asset);\n\t\t\t} else {\n\t\t\t\tassets.once(`add:${newValue}`, asset => {\n\t\t\t\t\tthis._bindNormalMapAsset(asset);\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tthis.normalMap = null;\n\t\t}\n\t}\n\t_bindMeshAsset(asset) {\n\t\tasset.on('load', this._onMeshAssetLoad, this);\n\t\tasset.on('unload', this._onMeshAssetUnload, this);\n\t\tasset.on('remove', this._onMeshAssetRemove, this);\n\t\tasset.on('change', this._onMeshAssetChange, this);\n\t\tif (asset.resource) {\n\t\t\tthis._onMeshAssetLoad(asset);\n\t\t} else {\n\t\t\tif (!this.enabled || !this.entity.enabled) return;\n\t\t\tthis.system.app.assets.load(asset);\n\t\t}\n\t}\n\t_unbindMeshAsset(asset) {\n\t\tasset.off('load', this._onMeshAssetLoad, this);\n\t\tasset.off('unload', this._onMeshAssetUnload, this);\n\t\tasset.off('remove', this._onMeshAssetRemove, this);\n\t\tasset.off('change', this._onMeshAssetChange, this);\n\t}\n\t_onMeshAssetLoad(asset) {\n\t\tthis._onMeshChanged(asset.resource);\n\t}\n\t_onMeshAssetUnload(asset) {\n\t\tthis.mesh = null;\n\t}\n\t_onMeshAssetRemove(asset) {\n\t\tthis._onMeshAssetUnload(asset);\n\t}\n\t_onMeshAssetChange(asset) {}\n\tonSetMeshAsset(name, oldValue, newValue) {\n\t\tconst assets = this.system.app.assets;\n\t\tif (oldValue) {\n\t\t\tconst asset = assets.get(oldValue);\n\t\t\tif (asset) {\n\t\t\t\tthis._unbindMeshAsset(asset);\n\t\t\t}\n\t\t}\n\t\tif (newValue) {\n\t\t\tif (newValue instanceof Asset) {\n\t\t\t\tthis.data.meshAsset = newValue.id;\n\t\t\t\tnewValue = newValue.id;\n\t\t\t}\n\t\t\tconst asset = assets.get(newValue);\n\t\t\tif (asset) {\n\t\t\t\tthis._bindMeshAsset(asset);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._onMeshChanged(null);\n\t\t}\n\t}\n\tonSetMesh(name, oldValue, newValue) {\n\t\tif (!newValue || newValue instanceof Asset || typeof newValue === 'number') {\n\t\t\tthis.meshAsset = newValue;\n\t\t} else {\n\t\t\tthis._onMeshChanged(newValue);\n\t\t}\n\t}\n\t_onMeshChanged(mesh) {\n\t\tif (mesh && !(mesh instanceof Mesh)) {\n\t\t\tif (mesh.meshInstances[0]) {\n\t\t\t\tmesh = mesh.meshInstances[0].mesh;\n\t\t\t} else {\n\t\t\t\tmesh = null;\n\t\t\t}\n\t\t}\n\t\tthis.data.mesh = mesh;\n\t\tif (this.emitter) {\n\t\t\tthis.emitter.mesh = mesh;\n\t\t\tthis.emitter.resetMaterial();\n\t\t\tthis.rebuild();\n\t\t}\n\t}\n\tonSetRenderAsset(name, oldValue, newValue) {\n\t\tconst assets = this.system.app.assets;\n\t\tif (oldValue) {\n\t\t\tconst asset = assets.get(oldValue);\n\t\t\tif (asset) {\n\t\t\t\tthis._unbindRenderAsset(asset);\n\t\t\t}\n\t\t}\n\t\tif (newValue) {\n\t\t\tif (newValue instanceof Asset) {\n\t\t\t\tthis.data.renderAsset = newValue.id;\n\t\t\t\tnewValue = newValue.id;\n\t\t\t}\n\t\t\tconst asset = assets.get(newValue);\n\t\t\tif (asset) {\n\t\t\t\tthis._bindRenderAsset(asset);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._onRenderChanged(null);\n\t\t}\n\t}\n\t_bindRenderAsset(asset) {\n\t\tasset.on('load', this._onRenderAssetLoad, this);\n\t\tasset.on('unload', this._onRenderAssetUnload, this);\n\t\tasset.on('remove', this._onRenderAssetRemove, this);\n\t\tif (asset.resource) {\n\t\t\tthis._onRenderAssetLoad(asset);\n\t\t} else {\n\t\t\tif (!this.enabled || !this.entity.enabled) return;\n\t\t\tthis.system.app.assets.load(asset);\n\t\t}\n\t}\n\t_unbindRenderAsset(asset) {\n\t\tvar _this$_evtSetMeshes;\n\t\tasset.off('load', this._onRenderAssetLoad, this);\n\t\tasset.off('unload', this._onRenderAssetUnload, this);\n\t\tasset.off('remove', this._onRenderAssetRemove, this);\n\t\t(_this$_evtSetMeshes = this._evtSetMeshes) == null || _this$_evtSetMeshes.off();\n\t\tthis._evtSetMeshes = null;\n\t}\n\t_onRenderAssetLoad(asset) {\n\t\tthis._onRenderChanged(asset.resource);\n\t}\n\t_onRenderAssetUnload(asset) {\n\t\tthis._onRenderChanged(null);\n\t}\n\t_onRenderAssetRemove(asset) {\n\t\tthis._onRenderAssetUnload(asset);\n\t}\n\t_onRenderChanged(render) {\n\t\tvar _this$_evtSetMeshes2;\n\t\tif (!render) {\n\t\t\tthis._onMeshChanged(null);\n\t\t\treturn;\n\t\t}\n\t\t(_this$_evtSetMeshes2 = this._evtSetMeshes) == null || _this$_evtSetMeshes2.off();\n\t\tthis._evtSetMeshes = render.on('set:meshes', this._onRenderSetMeshes, this);\n\t\tif (render.meshes) {\n\t\t\tthis._onRenderSetMeshes(render.meshes);\n\t\t}\n\t}\n\t_onRenderSetMeshes(meshes) {\n\t\tthis._onMeshChanged(meshes && meshes[0]);\n\t}\n\tonSetLoop(name, oldValue, newValue) {\n\t\tif (this.emitter) {\n\t\t\tthis.emitter[name] = newValue;\n\t\t\tthis.emitter.resetTime();\n\t\t}\n\t}\n\tonSetBlendType(name, oldValue, newValue) {\n\t\tif (this.emitter) {\n\t\t\tthis.emitter[name] = newValue;\n\t\t\tthis.emitter.material.blendType = newValue;\n\t\t\tthis.emitter.resetMaterial();\n\t\t\tthis.rebuild();\n\t\t}\n\t}\n\t_requestDepth() {\n\t\tif (this._requestedDepth) return;\n\t\tif (!depthLayer) depthLayer = this.system.app.scene.layers.getLayerById(LAYERID_DEPTH);\n\t\tif (depthLayer) {\n\t\t\tdepthLayer.incrementCounter();\n\t\t\tthis._requestedDepth = true;\n\t\t}\n\t}\n\t_releaseDepth() {\n\t\tif (!this._requestedDepth) return;\n\t\tif (depthLayer) {\n\t\t\tdepthLayer.decrementCounter();\n\t\t\tthis._requestedDepth = false;\n\t\t}\n\t}\n\tonSetDepthSoftening(name, oldValue, newValue) {\n\t\tif (oldValue !== newValue) {\n\t\t\tif (newValue) {\n\t\t\t\tif (this.enabled && this.entity.enabled) this._requestDepth();\n\t\t\t\tif (this.emitter) this.emitter[name] = newValue;\n\t\t\t} else {\n\t\t\t\tif (this.enabled && this.entity.enabled) this._releaseDepth();\n\t\t\t\tif (this.emitter) this.emitter[name] = newValue;\n\t\t\t}\n\t\t\tif (this.emitter) {\n\t\t\t\tthis.reset();\n\t\t\t\tthis.emitter.resetMaterial();\n\t\t\t\tthis.rebuild();\n\t\t\t}\n\t\t}\n\t}\n\tonSetSimpleProperty(name, oldValue, newValue) {\n\t\tif (this.emitter) {\n\t\t\tthis.emitter[name] = newValue;\n\t\t\tthis.emitter.resetMaterial();\n\t\t}\n\t}\n\tonSetComplexProperty(name, oldValue, newValue) {\n\t\tif (this.emitter) {\n\t\t\tthis.emitter[name] = newValue;\n\t\t\tthis.emitter.resetMaterial();\n\t\t\tthis.rebuild();\n\t\t\tthis.reset();\n\t\t}\n\t}\n\tonSetGraphProperty(name, oldValue, newValue) {\n\t\tif (this.emitter) {\n\t\t\tthis.emitter[name] = newValue;\n\t\t\tthis.emitter.rebuildGraphs();\n\t\t\tthis.emitter.resetMaterial();\n\t\t}\n\t}\n\tonEnable() {\n\t\tconst scene = this.system.app.scene;\n\t\tconst layers = scene.layers;\n\t\tconst data = this.data;\n\t\tfor (let i = 0, len = ASSET_PROPERTIES.length; i < len; i++) {\n\t\t\tlet asset = data[ASSET_PROPERTIES[i]];\n\t\t\tif (asset) {\n\t\t\t\tif (!(asset instanceof Asset)) {\n\t\t\t\t\tconst id = parseInt(asset, 10);\n\t\t\t\t\tif (id >= 0) {\n\t\t\t\t\t\tasset = this.system.app.assets.get(asset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (asset && !asset.resource) {\n\t\t\t\t\tthis.system.app.assets.load(asset);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.system.app.graphicsDevice.disableParticleSystem) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this.emitter) {\n\t\t\tlet mesh = data.mesh;\n\t\t\tif (!(mesh instanceof Mesh)) {\n\t\t\t\tmesh = null;\n\t\t\t}\n\t\t\tthis.emitter = new ParticleEmitter(this.system.app.graphicsDevice, {\n\t\t\t\tnumParticles: data.numParticles,\n\t\t\t\temitterExtents: data.emitterExtents,\n\t\t\t\temitterExtentsInner: data.emitterExtentsInner,\n\t\t\t\temitterRadius: data.emitterRadius,\n\t\t\t\temitterRadiusInner: data.emitterRadiusInner,\n\t\t\t\temitterShape: data.emitterShape,\n\t\t\t\tinitialVelocity: data.initialVelocity,\n\t\t\t\twrap: data.wrap,\n\t\t\t\tlocalSpace: data.localSpace,\n\t\t\t\tscreenSpace: data.screenSpace,\n\t\t\t\twrapBounds: data.wrapBounds,\n\t\t\t\tlifetime: data.lifetime,\n\t\t\t\trate: data.rate,\n\t\t\t\trate2: data.rate2,\n\t\t\t\torientation: data.orientation,\n\t\t\t\tparticleNormal: data.particleNormal,\n\t\t\t\tanimTilesX: data.animTilesX,\n\t\t\t\tanimTilesY: data.animTilesY,\n\t\t\t\tanimStartFrame: data.animStartFrame,\n\t\t\t\tanimNumFrames: data.animNumFrames,\n\t\t\t\tanimNumAnimations: data.animNumAnimations,\n\t\t\t\tanimIndex: data.animIndex,\n\t\t\t\trandomizeAnimIndex: data.randomizeAnimIndex,\n\t\t\t\tanimSpeed: data.animSpeed,\n\t\t\t\tanimLoop: data.animLoop,\n\t\t\t\tstartAngle: data.startAngle,\n\t\t\t\tstartAngle2: data.startAngle2,\n\t\t\t\tscaleGraph: data.scaleGraph,\n\t\t\t\tscaleGraph2: data.scaleGraph2,\n\t\t\t\tcolorGraph: data.colorGraph,\n\t\t\t\tcolorGraph2: data.colorGraph2,\n\t\t\t\talphaGraph: data.alphaGraph,\n\t\t\t\talphaGraph2: data.alphaGraph2,\n\t\t\t\tlocalVelocityGraph: data.localVelocityGraph,\n\t\t\t\tlocalVelocityGraph2: data.localVelocityGraph2,\n\t\t\t\tvelocityGraph: data.velocityGraph,\n\t\t\t\tvelocityGraph2: data.velocityGraph2,\n\t\t\t\trotationSpeedGraph: data.rotationSpeedGraph,\n\t\t\t\trotationSpeedGraph2: data.rotationSpeedGraph2,\n\t\t\t\tradialSpeedGraph: data.radialSpeedGraph,\n\t\t\t\tradialSpeedGraph2: data.radialSpeedGraph2,\n\t\t\t\tcolorMap: data.colorMap,\n\t\t\t\tnormalMap: data.normalMap,\n\t\t\t\tloop: data.loop,\n\t\t\t\tpreWarm: data.preWarm,\n\t\t\t\tsort: data.sort,\n\t\t\t\tstretch: data.stretch,\n\t\t\t\talignToMotion: data.alignToMotion,\n\t\t\t\tlighting: data.lighting,\n\t\t\t\thalfLambert: data.halfLambert,\n\t\t\t\tintensity: data.intensity,\n\t\t\t\tdepthSoftening: data.depthSoftening,\n\t\t\t\tscene: this.system.app.scene,\n\t\t\t\tmesh: mesh,\n\t\t\t\tdepthWrite: data.depthWrite,\n\t\t\t\tnoFog: data.noFog,\n\t\t\t\tnode: this.entity,\n\t\t\t\tblendType: data.blendType\n\t\t\t});\n\t\t\tthis.emitter.meshInstance.node = this.entity;\n\t\t\tthis.emitter.drawOrder = this.drawOrder;\n\t\t\tif (!data.autoPlay) {\n\t\t\t\tthis.pause();\n\t\t\t\tthis.emitter.meshInstance.visible = false;\n\t\t\t}\n\t\t}\n\t\tif (this.emitter.colorMap) {\n\t\t\tthis.addMeshInstanceToLayers();\n\t\t}\n\t\tthis._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);\n\t\tif (layers) {\n\t\t\tthis._evtLayerAdded = layers.on('add', this.onLayerAdded, this);\n\t\t\tthis._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);\n\t\t}\n\t\tif (this.enabled && this.entity.enabled && data.depthSoftening) {\n\t\t\tthis._requestDepth();\n\t\t}\n\t}\n\tonDisable() {\n\t\tvar _this$_evtLayersChang;\n\t\tconst scene = this.system.app.scene;\n\t\tconst layers = scene.layers;\n\t\t(_this$_evtLayersChang = this._evtLayersChanged) == null || _this$_evtLayersChang.off();\n\t\tthis._evtLayersChanged = null;\n\t\tif (layers) {\n\t\t\tvar _this$_evtLayerAdded, _this$_evtLayerRemove;\n\t\t\t(_this$_evtLayerAdded = this._evtLayerAdded) == null || _this$_evtLayerAdded.off();\n\t\t\tthis._evtLayerAdded = null;\n\t\t\t(_this$_evtLayerRemove = this._evtLayerRemoved) == null || _this$_evtLayerRemove.off();\n\t\t\tthis._evtLayerRemoved = null;\n\t\t}\n\t\tif (this.emitter) {\n\t\t\tthis.removeMeshInstanceFromLayers();\n\t\t\tif (this.data.depthSoftening) this._releaseDepth();\n\t\t\tthis.emitter.camera = null;\n\t\t}\n\t}\n\tonBeforeRemove() {\n\t\tif (this.enabled) {\n\t\t\tthis.enabled = false;\n\t\t}\n\t\tif (this.emitter) {\n\t\t\tthis.emitter.destroy();\n\t\t\tthis.emitter = null;\n\t\t}\n\t\tfor (let i = 0; i < ASSET_PROPERTIES.length; i++) {\n\t\t\tconst prop = ASSET_PROPERTIES[i];\n\t\t\tif (this.data[prop]) {\n\t\t\t\tthis[prop] = null;\n\t\t\t}\n\t\t}\n\t\tthis.off();\n\t}\n\treset() {\n\t\tif (this.emitter) {\n\t\t\tthis.emitter.reset();\n\t\t}\n\t}\n\tstop() {\n\t\tif (this.emitter) {\n\t\t\tthis.emitter.loop = false;\n\t\t\tthis.emitter.resetTime();\n\t\t\tthis.emitter.addTime(0, true);\n\t\t}\n\t}\n\tpause() {\n\t\tthis.data.paused = true;\n\t}\n\tunpause() {\n\t\tthis.data.paused = false;\n\t}\n\tplay() {\n\t\tthis.data.paused = false;\n\t\tif (this.emitter) {\n\t\t\tthis.emitter.meshInstance.visible = true;\n\t\t\tthis.emitter.loop = this.data.loop;\n\t\t\tthis.emitter.resetTime();\n\t\t}\n\t}\n\tisPlaying() {\n\t\tif (this.data.paused) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this.emitter && this.emitter.loop) {\n\t\t\treturn true;\n\t\t}\n\t\treturn Date.now() <= this.emitter.endTime;\n\t}\n\trebuild() {\n\t\tconst enabled = this.enabled;\n\t\tthis.enabled = false;\n\t\tif (this.emitter) {\n\t\t\tthis.emitter.rebuild();\n\t\t\tthis.emitter.meshInstance.node = this.entity;\n\t\t}\n\t\tthis.enabled = enabled;\n\t}\n}\n\nexport { ParticleSystemComponent };\n","import { Vec3 } from '../../../core/math/vec3.js';\nimport { EMITTERSHAPE_BOX, PARTICLEMODE_GPU, PARTICLEORIENTATION_SCREEN, BLEND_NORMAL, LAYERID_WORLD } from '../../../scene/constants.js';\n\nclass ParticleSystemComponentData {\n\tconstructor() {\n\t\tthis.numParticles = 1;\n\t\tthis.rate = 1;\n\t\tthis.rate2 = null;\n\t\tthis.startAngle = 0;\n\t\tthis.startAngle2 = null;\n\t\tthis.lifetime = 50;\n\t\tthis.emitterExtents = new Vec3();\n\t\tthis.emitterExtentsInner = new Vec3();\n\t\tthis.emitterRadius = 0;\n\t\tthis.emitterRadiusInner = 0;\n\t\tthis.emitterShape = EMITTERSHAPE_BOX;\n\t\tthis.initialVelocity = 0;\n\t\tthis.wrap = false;\n\t\tthis.wrapBounds = new Vec3();\n\t\tthis.localSpace = false;\n\t\tthis.screenSpace = false;\n\t\tthis.colorMap = null;\n\t\tthis.colorMapAsset = null;\n\t\tthis.normalMap = null;\n\t\tthis.normalMapAsset = null;\n\t\tthis.loop = true;\n\t\tthis.preWarm = false;\n\t\tthis.sort = 0;\n\t\tthis.mode = PARTICLEMODE_GPU;\n\t\tthis.scene = null;\n\t\tthis.lighting = false;\n\t\tthis.halfLambert = false;\n\t\tthis.intensity = 1;\n\t\tthis.stretch = 0.0;\n\t\tthis.alignToMotion = false;\n\t\tthis.depthSoftening = 0;\n\t\tthis.renderAsset = null;\n\t\tthis.meshAsset = null;\n\t\tthis.mesh = null;\n\t\tthis.depthWrite = false;\n\t\tthis.noFog = false;\n\t\tthis.orientation = PARTICLEORIENTATION_SCREEN;\n\t\tthis.particleNormal = new Vec3(0, 1, 0);\n\t\tthis.animTilesX = 1;\n\t\tthis.animTilesY = 1;\n\t\tthis.animStartFrame = 0;\n\t\tthis.animNumFrames = 1;\n\t\tthis.animNumAnimations = 1;\n\t\tthis.animIndex = 0;\n\t\tthis.randomizeAnimIndex = false;\n\t\tthis.animSpeed = 1;\n\t\tthis.animLoop = true;\n\t\tthis.scaleGraph = null;\n\t\tthis.scaleGraph2 = null;\n\t\tthis.colorGraph = null;\n\t\tthis.colorGraph2 = null;\n\t\tthis.alphaGraph = null;\n\t\tthis.alphaGraph2 = null;\n\t\tthis.localVelocityGraph = null;\n\t\tthis.localVelocityGraph2 = null;\n\t\tthis.velocityGraph = null;\n\t\tthis.velocityGraph2 = null;\n\t\tthis.rotationSpeedGraph = null;\n\t\tthis.rotationSpeedGraph2 = null;\n\t\tthis.radialSpeedGraph = null;\n\t\tthis.radialSpeedGraph2 = null;\n\t\tthis.blendType = BLEND_NORMAL;\n\t\tthis.enabled = true;\n\t\tthis.paused = false;\n\t\tthis.autoPlay = true;\n\t\tthis.layers = [LAYERID_WORLD];\n\t}\n}\n\nexport { ParticleSystemComponentData };\n","import { Curve } from '../../../core/math/curve.js';\nimport { CurveSet } from '../../../core/math/curve-set.js';\nimport { Vec3 } from '../../../core/math/vec3.js';\nimport { Asset } from '../../asset/asset.js';\nimport { ComponentSystem } from '../system.js';\nimport { ParticleSystemComponent } from './component.js';\nimport { ParticleSystemComponentData } from './data.js';\n\nconst _schema = ['enabled', 'autoPlay', 'numParticles', 'lifetime', 'rate', 'rate2', 'startAngle', 'startAngle2', 'loop', 'preWarm', 'lighting', 'halfLambert', 'intensity', 'depthWrite', 'noFog', 'depthSoftening', 'sort', 'blendType', 'stretch', 'alignToMotion', 'emitterShape', 'emitterExtents', 'emitterExtentsInner', 'emitterRadius', 'emitterRadiusInner', 'initialVelocity', 'wrap', 'wrapBounds', 'localSpace', 'screenSpace', 'colorMapAsset', 'normalMapAsset', 'mesh', 'meshAsset', 'renderAsset', 'orientation', 'particleNormal', 'localVelocityGraph', 'localVelocityGraph2', 'velocityGraph', 'velocityGraph2', 'rotationSpeedGraph', 'rotationSpeedGraph2', 'radialSpeedGraph', 'radialSpeedGraph2', 'scaleGraph', 'scaleGraph2', 'colorGraph', 'colorGraph2', 'alphaGraph', 'alphaGraph2', 'colorMap', 'normalMap', 'animTilesX', 'animTilesY', 'animStartFrame', 'animNumFrames', 'animNumAnimations', 'animIndex', 'randomizeAnimIndex', 'animSpeed', 'animLoop', 'layers'];\nclass ParticleSystemComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'particlesystem';\n\t\tthis.ComponentType = ParticleSystemComponent;\n\t\tthis.DataType = ParticleSystemComponentData;\n\t\tthis.schema = _schema;\n\t\tthis.propertyTypes = {\n\t\t\temitterExtents: 'vec3',\n\t\t\temitterExtentsInner: 'vec3',\n\t\t\tparticleNormal: 'vec3',\n\t\t\twrapBounds: 'vec3',\n\t\t\tlocalVelocityGraph: 'curveset',\n\t\t\tlocalVelocityGraph2: 'curveset',\n\t\t\tvelocityGraph: 'curveset',\n\t\t\tvelocityGraph2: 'curveset',\n\t\t\tcolorGraph: 'curveset',\n\t\t\tcolorGraph2: 'curveset',\n\t\t\talphaGraph: 'curve',\n\t\t\talphaGraph2: 'curve',\n\t\t\trotationSpeedGraph: 'curve',\n\t\t\trotationSpeedGraph2: 'curve',\n\t\t\tradialSpeedGraph: 'curve',\n\t\t\tradialSpeedGraph2: 'curve',\n\t\t\tscaleGraph: 'curve',\n\t\t\tscaleGraph2: 'curve'\n\t\t};\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t}\n\tinitializeComponentData(component, _data, properties) {\n\t\tconst data = {};\n\t\tproperties = [];\n\t\tconst types = this.propertyTypes;\n\t\tif (_data.mesh instanceof Asset || typeof _data.mesh === 'number') {\n\t\t\t_data.meshAsset = _data.mesh;\n\t\t\tdelete _data.mesh;\n\t\t}\n\t\tfor (const prop in _data) {\n\t\t\tif (_data.hasOwnProperty(prop)) {\n\t\t\t\tproperties.push(prop);\n\t\t\t\tdata[prop] = _data[prop];\n\t\t\t}\n\t\t\tif (types[prop] === 'vec3') {\n\t\t\t\tif (Array.isArray(data[prop])) {\n\t\t\t\t\tdata[prop] = new Vec3(data[prop][0], data[prop][1], data[prop][2]);\n\t\t\t\t}\n\t\t\t} else if (types[prop] === 'curve') {\n\t\t\t\tif (!(data[prop] instanceof Curve)) {\n\t\t\t\t\tconst t = data[prop].type;\n\t\t\t\t\tdata[prop] = new Curve(data[prop].keys);\n\t\t\t\t\tdata[prop].type = t;\n\t\t\t\t}\n\t\t\t} else if (types[prop] === 'curveset') {\n\t\t\t\tif (!(data[prop] instanceof CurveSet)) {\n\t\t\t\t\tconst t = data[prop].type;\n\t\t\t\t\tdata[prop] = new CurveSet(data[prop].keys);\n\t\t\t\t\tdata[prop].type = t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (data.layers && Array.isArray(data.layers)) {\n\t\t\t\tdata.layers = data.layers.slice(0);\n\t\t\t}\n\t\t}\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\tcloneComponent(entity, clone) {\n\t\tconst source = entity.particlesystem.data;\n\t\tconst schema = this.schema;\n\t\tconst data = {};\n\t\tfor (let i = 0, len = schema.length; i < len; i++) {\n\t\t\tconst prop = schema[i];\n\t\t\tlet sourceProp = source[prop];\n\t\t\tif (sourceProp instanceof Vec3 || sourceProp instanceof Curve || sourceProp instanceof CurveSet) {\n\t\t\t\tsourceProp = sourceProp.clone();\n\t\t\t\tdata[prop] = sourceProp;\n\t\t\t} else if (prop === 'layers') {\n\t\t\t\tdata.layers = source.layers.slice(0);\n\t\t\t} else {\n\t\t\t\tif (sourceProp !== null && sourceProp !== undefined) {\n\t\t\t\t\tdata[prop] = sourceProp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.addComponent(clone, data);\n\t}\n\tonUpdate(dt) {\n\t\tconst components = this.store;\n\t\tlet numSteps;\n\t\tconst stats = this.app.stats.particles;\n\t\tconst composition = this.app.scene.layers;\n\t\tfor (let i = 0; i < composition.layerList.length; i++) {\n\t\t\tcomposition.layerList[i].requiresLightCube = false;\n\t\t}\n\t\tfor (const id in components) {\n\t\t\tif (components.hasOwnProperty(id)) {\n\t\t\t\tconst component = components[id];\n\t\t\t\tconst entity = component.entity;\n\t\t\t\tconst data = component.data;\n\t\t\t\tif (data.enabled && entity.enabled) {\n\t\t\t\t\tconst emitter = entity.particlesystem.emitter;\n\t\t\t\t\tif (!(emitter != null && emitter.meshInstance.visible)) continue;\n\t\t\t\t\tif (emitter.lighting) {\n\t\t\t\t\t\tconst layers = data.layers;\n\t\t\t\t\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\t\t\t\t\tconst layer = composition.getLayerById(layers[i]);\n\t\t\t\t\t\t\tif (layer) {\n\t\t\t\t\t\t\t\tlayer.requiresLightCube = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!data.paused) {\n\t\t\t\t\t\temitter.simTime += dt;\n\t\t\t\t\t\tif (emitter.simTime > emitter.fixedTimeStep) {\n\t\t\t\t\t\t\tnumSteps = Math.floor(emitter.simTime / emitter.fixedTimeStep);\n\t\t\t\t\t\t\temitter.simTime -= numSteps * emitter.fixedTimeStep;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (numSteps) {\n\t\t\t\t\t\t\tnumSteps = Math.min(numSteps, emitter.maxSubSteps);\n\t\t\t\t\t\t\tfor (let i = 0; i < numSteps; i++) {\n\t\t\t\t\t\t\t\temitter.addTime(emitter.fixedTimeStep, false);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstats._updatesPerFrame += numSteps;\n\t\t\t\t\t\t\tstats._frameTime += emitter._addTimeTime;\n\t\t\t\t\t\t\temitter._addTimeTime = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\temitter.finishFrame();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tonBeforeRemove(entity, component) {\n\t\tcomponent.onBeforeRemove();\n\t}\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n}\n\nexport { ParticleSystemComponentSystem };\n","import { EventHandler } from '../../core/event-handler.js';\n\nclass ComponentSystemRegistry extends EventHandler {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.anim = void 0;\n\t\tthis.animation = void 0;\n\t\tthis.audiolistener = void 0;\n\t\tthis.audiosource = void 0;\n\t\tthis.button = void 0;\n\t\tthis.camera = void 0;\n\t\tthis.collision = void 0;\n\t\tthis.element = void 0;\n\t\tthis.joint = void 0;\n\t\tthis.layoutchild = void 0;\n\t\tthis.layoutgroup = void 0;\n\t\tthis.light = void 0;\n\t\tthis.model = void 0;\n\t\tthis.particlesystem = void 0;\n\t\tthis.render = void 0;\n\t\tthis.rigidbody = void 0;\n\t\tthis.screen = void 0;\n\t\tthis.script = void 0;\n\t\tthis.scrollbar = void 0;\n\t\tthis.scrollview = void 0;\n\t\tthis.sound = void 0;\n\t\tthis.sprite = void 0;\n\t\tthis.zone = void 0;\n\t\tthis.list = [];\n\t}\n\tadd(system) {\n\t\tconst id = system.id;\n\t\tif (this[id]) {\n\t\t\tthrow new Error(`ComponentSystem name '${id}' already registered or not allowed`);\n\t\t}\n\t\tthis[id] = system;\n\t\tthis.list.push(system);\n\t}\n\tremove(system) {\n\t\tconst id = system.id;\n\t\tif (!this[id]) {\n\t\t\tthrow new Error(`No ComponentSystem named '${id}' registered`);\n\t\t}\n\t\tdelete this[id];\n\t\tconst index = this.list.indexOf(this[id]);\n\t\tif (index !== -1) {\n\t\t\tthis.list.splice(index, 1);\n\t\t}\n\t}\n\tdestroy() {\n\t\tthis.off();\n\t\tfor (let i = 0; i < this.list.length; i++) {\n\t\t\tthis.list[i].destroy();\n\t\t}\n\t}\n}\n\nexport { ComponentSystemRegistry };\n","import { LAYERID_WORLD, RENDERSTYLE_SOLID } from '../../../scene/constants.js';\nimport { BatchGroup } from '../../../scene/batching/batch-group.js';\nimport { MeshInstance } from '../../../scene/mesh-instance.js';\nimport { MorphInstance } from '../../../scene/morph-instance.js';\nimport { getShapePrimitive } from '../../graphics/primitive-cache.js';\nimport { GraphNode } from '../../../scene/graph-node.js';\nimport { SkinInstanceCache } from '../../../scene/skin-instance-cache.js';\nimport { Asset } from '../../asset/asset.js';\nimport { AssetReference } from '../../asset/asset-reference.js';\nimport { Component } from '../component.js';\n\nclass RenderComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._type = 'asset';\n\t\tthis._castShadows = true;\n\t\tthis._receiveShadows = true;\n\t\tthis._castShadowsLightmap = true;\n\t\tthis._lightmapped = false;\n\t\tthis._lightmapSizeMultiplier = 1;\n\t\tthis.isStatic = false;\n\t\tthis._batchGroupId = -1;\n\t\tthis._layers = [LAYERID_WORLD];\n\t\tthis._renderStyle = RENDERSTYLE_SOLID;\n\t\tthis._meshInstances = [];\n\t\tthis._customAabb = null;\n\t\tthis._area = null;\n\t\tthis._assetReference = void 0;\n\t\tthis._materialReferences = [];\n\t\tthis._material = void 0;\n\t\tthis._rootBone = null;\n\t\tthis._evtLayersChanged = null;\n\t\tthis._evtLayerAdded = null;\n\t\tthis._evtLayerRemoved = null;\n\t\tthis._evtSetMeshes = null;\n\t\tthis._assetReference = new AssetReference('asset', this, system.app.assets, {\n\t\t\tadd: this._onRenderAssetAdded,\n\t\t\tload: this._onRenderAssetLoad,\n\t\t\tremove: this._onRenderAssetRemove,\n\t\t\tunload: this._onRenderAssetUnload\n\t\t}, this);\n\t\tthis._material = system.defaultMaterial;\n\t\tentity.on('remove', this.onRemoveChild, this);\n\t\tentity.on('removehierarchy', this.onRemoveChild, this);\n\t\tentity.on('insert', this.onInsertChild, this);\n\t\tentity.on('inserthierarchy', this.onInsertChild, this);\n\t}\n\tset renderStyle(renderStyle) {\n\t\tif (this._renderStyle !== renderStyle) {\n\t\t\tthis._renderStyle = renderStyle;\n\t\t\tMeshInstance._prepareRenderStyleForArray(this._meshInstances, renderStyle);\n\t\t}\n\t}\n\tget renderStyle() {\n\t\treturn this._renderStyle;\n\t}\n\tset customAabb(value) {\n\t\tthis._customAabb = value;\n\t\tconst mi = this._meshInstances;\n\t\tif (mi) {\n\t\t\tfor (let i = 0; i < mi.length; i++) {\n\t\t\t\tmi[i].setCustomAabb(this._customAabb);\n\t\t\t}\n\t\t}\n\t}\n\tget customAabb() {\n\t\treturn this._customAabb;\n\t}\n\tset type(value) {\n\t\tif (this._type !== value) {\n\t\t\tthis._area = null;\n\t\t\tthis._type = value;\n\t\t\tthis.destroyMeshInstances();\n\t\t\tif (value !== 'asset') {\n\t\t\t\tlet material = this._material;\n\t\t\t\tif (!material || material === this.system.defaultMaterial) {\n\t\t\t\t\tmaterial = this._materialReferences[0] && this._materialReferences[0].asset && this._materialReferences[0].asset.resource;\n\t\t\t\t}\n\t\t\t\tconst primData = getShapePrimitive(this.system.app.graphicsDevice, value);\n\t\t\t\tthis._area = primData.area;\n\t\t\t\tthis.meshInstances = [new MeshInstance(primData.mesh, material || this.system.defaultMaterial, this.entity)];\n\t\t\t}\n\t\t}\n\t}\n\tget type() {\n\t\treturn this._type;\n\t}\n\tset meshInstances(value) {\n\t\tthis.destroyMeshInstances();\n\t\tthis._meshInstances = value;\n\t\tif (this._meshInstances) {\n\t\t\tconst mi = this._meshInstances;\n\t\t\tfor (let i = 0; i < mi.length; i++) {\n\t\t\t\tif (!mi[i].node) {\n\t\t\t\t\tmi[i].node = this.entity;\n\t\t\t\t}\n\t\t\t\tmi[i].castShadow = this._castShadows;\n\t\t\t\tmi[i].receiveShadow = this._receiveShadows;\n\t\t\t\tmi[i].renderStyle = this._renderStyle;\n\t\t\t\tmi[i].setLightmapped(this._lightmapped);\n\t\t\t\tmi[i].setCustomAabb(this._customAabb);\n\t\t\t}\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis.addToLayers();\n\t\t\t}\n\t\t}\n\t}\n\tget meshInstances() {\n\t\treturn this._meshInstances;\n\t}\n\tset lightmapped(value) {\n\t\tif (value !== this._lightmapped) {\n\t\t\tthis._lightmapped = value;\n\t\t\tconst mi = this._meshInstances;\n\t\t\tif (mi) {\n\t\t\t\tfor (let i = 0; i < mi.length; i++) {\n\t\t\t\t\tmi[i].setLightmapped(value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tget lightmapped() {\n\t\treturn this._lightmapped;\n\t}\n\tset castShadows(value) {\n\t\tif (this._castShadows !== value) {\n\t\t\tconst mi = this._meshInstances;\n\t\t\tif (mi) {\n\t\t\t\tconst layers = this.layers;\n\t\t\t\tconst scene = this.system.app.scene;\n\t\t\t\tif (this._castShadows && !value) {\n\t\t\t\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\t\t\t\tconst layer = scene.layers.getLayerById(this.layers[i]);\n\t\t\t\t\t\tif (layer) {\n\t\t\t\t\t\t\tlayer.removeShadowCasters(mi);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < mi.length; i++) {\n\t\t\t\t\tmi[i].castShadow = value;\n\t\t\t\t}\n\t\t\t\tif (!this._castShadows && value) {\n\t\t\t\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\t\t\t\tconst layer = scene.layers.getLayerById(layers[i]);\n\t\t\t\t\t\tif (layer) {\n\t\t\t\t\t\t\tlayer.addShadowCasters(mi);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._castShadows = value;\n\t\t}\n\t}\n\tget castShadows() {\n\t\treturn this._castShadows;\n\t}\n\tset receiveShadows(value) {\n\t\tif (this._receiveShadows !== value) {\n\t\t\tthis._receiveShadows = value;\n\t\t\tconst mi = this._meshInstances;\n\t\t\tif (mi) {\n\t\t\t\tfor (let i = 0; i < mi.length; i++) {\n\t\t\t\t\tmi[i].receiveShadow = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tget receiveShadows() {\n\t\treturn this._receiveShadows;\n\t}\n\tset castShadowsLightmap(value) {\n\t\tthis._castShadowsLightmap = value;\n\t}\n\tget castShadowsLightmap() {\n\t\treturn this._castShadowsLightmap;\n\t}\n\tset lightmapSizeMultiplier(value) {\n\t\tthis._lightmapSizeMultiplier = value;\n\t}\n\tget lightmapSizeMultiplier() {\n\t\treturn this._lightmapSizeMultiplier;\n\t}\n\tset layers(value) {\n\t\tconst layers = this.system.app.scene.layers;\n\t\tlet layer;\n\t\tif (this._meshInstances) {\n\t\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\t\tlayer = layers.getLayerById(this._layers[i]);\n\t\t\t\tif (layer) {\n\t\t\t\t\tlayer.removeMeshInstances(this._meshInstances);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._layers.length = 0;\n\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\tthis._layers[i] = value[i];\n\t\t}\n\t\tif (!this.enabled || !this.entity.enabled || !this._meshInstances) return;\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tlayer = layers.getLayerById(this._layers[i]);\n\t\t\tif (layer) {\n\t\t\t\tlayer.addMeshInstances(this._meshInstances);\n\t\t\t}\n\t\t}\n\t}\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\tset batchGroupId(value) {\n\t\tif (this._batchGroupId !== value) {\n\t\t\tif (this.entity.enabled && this._batchGroupId >= 0) {\n\t\t\t\tvar _this$system$app$batc;\n\t\t\t\t(_this$system$app$batc = this.system.app.batcher) == null || _this$system$app$batc.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);\n\t\t\t}\n\t\t\tif (this.entity.enabled && value >= 0) {\n\t\t\t\tvar _this$system$app$batc2;\n\t\t\t\t(_this$system$app$batc2 = this.system.app.batcher) == null || _this$system$app$batc2.insert(BatchGroup.RENDER, value, this.entity);\n\t\t\t}\n\t\t\tif (value < 0 && this._batchGroupId >= 0 && this.enabled && this.entity.enabled) {\n\t\t\t\tthis.addToLayers();\n\t\t\t}\n\t\t\tthis._batchGroupId = value;\n\t\t}\n\t}\n\tget batchGroupId() {\n\t\treturn this._batchGroupId;\n\t}\n\tset material(value) {\n\t\tif (this._material !== value) {\n\t\t\tthis._material = value;\n\t\t\tif (this._meshInstances && this._type !== 'asset') {\n\t\t\t\tfor (let i = 0; i < this._meshInstances.length; i++) {\n\t\t\t\t\tthis._meshInstances[i].material = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tget material() {\n\t\treturn this._material;\n\t}\n\tset materialAssets(value = []) {\n\t\tif (this._materialReferences.length > value.length) {\n\t\t\tfor (let i = value.length; i < this._materialReferences.length; i++) {\n\t\t\t\tthis._materialReferences[i].id = null;\n\t\t\t}\n\t\t\tthis._materialReferences.length = value.length;\n\t\t}\n\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\tif (!this._materialReferences[i]) {\n\t\t\t\tthis._materialReferences.push(new AssetReference(i, this, this.system.app.assets, {\n\t\t\t\t\tadd: this._onMaterialAdded,\n\t\t\t\t\tload: this._onMaterialLoad,\n\t\t\t\t\tremove: this._onMaterialRemove,\n\t\t\t\t\tunload: this._onMaterialUnload\n\t\t\t\t}, this));\n\t\t\t}\n\t\t\tif (value[i]) {\n\t\t\t\tconst id = value[i] instanceof Asset ? value[i].id : value[i];\n\t\t\t\tif (this._materialReferences[i].id !== id) {\n\t\t\t\t\tthis._materialReferences[i].id = id;\n\t\t\t\t}\n\t\t\t\tif (this._materialReferences[i].asset) {\n\t\t\t\t\tthis._onMaterialAdded(i, this, this._materialReferences[i].asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._materialReferences[i].id = null;\n\t\t\t\tif (this._meshInstances[i]) {\n\t\t\t\t\tthis._meshInstances[i].material = this.system.defaultMaterial;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tget materialAssets() {\n\t\treturn this._materialReferences.map(ref => {\n\t\t\treturn ref.id;\n\t\t});\n\t}\n\tset asset(value) {\n\t\tconst id = value instanceof Asset ? value.id : value;\n\t\tif (this._assetReference.id === id) return;\n\t\tif (this._assetReference.asset && this._assetReference.asset.resource) {\n\t\t\tthis._onRenderAssetRemove();\n\t\t}\n\t\tthis._assetReference.id = id;\n\t\tif (this._assetReference.asset) {\n\t\t\tthis._onRenderAssetAdded();\n\t\t}\n\t}\n\tget asset() {\n\t\treturn this._assetReference.id;\n\t}\n\tassignAsset(asset) {\n\t\tconst id = asset instanceof Asset ? asset.id : asset;\n\t\tthis._assetReference.id = id;\n\t}\n\tset rootBone(value) {\n\t\tif (this._rootBone !== value) {\n\t\t\tconst isString = typeof value === 'string';\n\t\t\tif (this._rootBone && isString && this._rootBone.getGuid() === value) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this._rootBone) {\n\t\t\t\tthis._clearSkinInstances();\n\t\t\t}\n\t\t\tif (value instanceof GraphNode) {\n\t\t\t\tthis._rootBone = value;\n\t\t\t} else if (isString) {\n\t\t\t\tthis._rootBone = this.system.app.getEntityFromIndex(value) || null;\n\t\t\t\tif (!this._rootBone) ;\n\t\t\t} else {\n\t\t\t\tthis._rootBone = null;\n\t\t\t}\n\t\t\tif (this._rootBone) {\n\t\t\t\tthis._cloneSkinInstances();\n\t\t\t}\n\t\t}\n\t}\n\tget rootBone() {\n\t\treturn this._rootBone;\n\t}\n\tdestroyMeshInstances() {\n\t\tconst meshInstances = this._meshInstances;\n\t\tif (meshInstances) {\n\t\t\tthis.removeFromLayers();\n\t\t\tthis._clearSkinInstances();\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tmeshInstances[i].destroy();\n\t\t\t}\n\t\t\tthis._meshInstances.length = 0;\n\t\t}\n\t}\n\taddToLayers() {\n\t\tconst layers = this.system.app.scene.layers;\n\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\tconst layer = layers.getLayerById(this._layers[i]);\n\t\t\tif (layer) {\n\t\t\t\tlayer.addMeshInstances(this._meshInstances);\n\t\t\t}\n\t\t}\n\t}\n\tremoveFromLayers() {\n\t\tif (this._meshInstances && this._meshInstances.length) {\n\t\t\tconst layers = this.system.app.scene.layers;\n\t\t\tfor (let i = 0; i < this._layers.length; i++) {\n\t\t\t\tconst layer = layers.getLayerById(this._layers[i]);\n\t\t\t\tif (layer) {\n\t\t\t\t\tlayer.removeMeshInstances(this._meshInstances);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tonRemoveChild() {\n\t\tthis.removeFromLayers();\n\t}\n\tonInsertChild() {\n\t\tif (this._meshInstances && this.enabled && this.entity.enabled) {\n\t\t\tthis.addToLayers();\n\t\t}\n\t}\n\tonRemove() {\n\t\tthis.destroyMeshInstances();\n\t\tthis.asset = null;\n\t\tthis.materialAsset = null;\n\t\tthis._assetReference.id = null;\n\t\tfor (let i = 0; i < this._materialReferences.length; i++) {\n\t\t\tthis._materialReferences[i].id = null;\n\t\t}\n\t\tthis.entity.off('remove', this.onRemoveChild, this);\n\t\tthis.entity.off('insert', this.onInsertChild, this);\n\t}\n\tonLayersChanged(oldComp, newComp) {\n\t\tthis.addToLayers();\n\t\toldComp.off('add', this.onLayerAdded, this);\n\t\toldComp.off('remove', this.onLayerRemoved, this);\n\t\tnewComp.on('add', this.onLayerAdded, this);\n\t\tnewComp.on('remove', this.onLayerRemoved, this);\n\t}\n\tonLayerAdded(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.addMeshInstances(this._meshInstances);\n\t}\n\tonLayerRemoved(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.removeMeshInstances(this._meshInstances);\n\t}\n\tonEnable() {\n\t\tconst app = this.system.app;\n\t\tconst scene = app.scene;\n\t\tconst layers = scene.layers;\n\t\tif (this._rootBone) {\n\t\t\tthis._cloneSkinInstances();\n\t\t}\n\t\tthis._evtLayersChanged = scene.on('set:layers', this.onLayersChanged, this);\n\t\tif (layers) {\n\t\t\tthis._evtLayerAdded = layers.on('add', this.onLayerAdded, this);\n\t\t\tthis._evtLayerRemoved = layers.on('remove', this.onLayerRemoved, this);\n\t\t}\n\t\tconst isAsset = this._type === 'asset';\n\t\tif (this._meshInstances && this._meshInstances.length) {\n\t\t\tthis.addToLayers();\n\t\t} else if (isAsset && this.asset) {\n\t\t\tthis._onRenderAssetAdded();\n\t\t}\n\t\tfor (let i = 0; i < this._materialReferences.length; i++) {\n\t\t\tif (this._materialReferences[i].asset) {\n\t\t\t\tthis.system.app.assets.load(this._materialReferences[i].asset);\n\t\t\t}\n\t\t}\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tvar _app$batcher;\n\t\t\t(_app$batcher = app.batcher) == null || _app$batcher.insert(BatchGroup.RENDER, this.batchGroupId, this.entity);\n\t\t}\n\t}\n\tonDisable() {\n\t\tvar _this$_evtLayersChang;\n\t\tconst app = this.system.app;\n\t\tconst scene = app.scene;\n\t\tconst layers = scene.layers;\n\t\t(_this$_evtLayersChang = this._evtLayersChanged) == null || _this$_evtLayersChang.off();\n\t\tthis._evtLayersChanged = null;\n\t\tif (this._rootBone) {\n\t\t\tthis._clearSkinInstances();\n\t\t}\n\t\tif (layers) {\n\t\t\tvar _this$_evtLayerAdded, _this$_evtLayerRemove;\n\t\t\t(_this$_evtLayerAdded = this._evtLayerAdded) == null || _this$_evtLayerAdded.off();\n\t\t\tthis._evtLayerAdded = null;\n\t\t\t(_this$_evtLayerRemove = this._evtLayerRemoved) == null || _this$_evtLayerRemove.off();\n\t\t\tthis._evtLayerRemoved = null;\n\t\t}\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tvar _app$batcher2;\n\t\t\t(_app$batcher2 = app.batcher) == null || _app$batcher2.remove(BatchGroup.RENDER, this.batchGroupId, this.entity);\n\t\t}\n\t\tthis.removeFromLayers();\n\t}\n\thide() {\n\t\tif (this._meshInstances) {\n\t\t\tfor (let i = 0; i < this._meshInstances.length; i++) {\n\t\t\t\tthis._meshInstances[i].visible = false;\n\t\t\t}\n\t\t}\n\t}\n\tshow() {\n\t\tif (this._meshInstances) {\n\t\t\tfor (let i = 0; i < this._meshInstances.length; i++) {\n\t\t\t\tthis._meshInstances[i].visible = true;\n\t\t\t}\n\t\t}\n\t}\n\t_onRenderAssetAdded() {\n\t\tif (!this._assetReference.asset) return;\n\t\tif (this._assetReference.asset.resource) {\n\t\t\tthis._onRenderAssetLoad();\n\t\t} else if (this.enabled && this.entity.enabled) {\n\t\t\tthis.system.app.assets.load(this._assetReference.asset);\n\t\t}\n\t}\n\t_onRenderAssetLoad() {\n\t\tthis.destroyMeshInstances();\n\t\tif (this._assetReference.asset) {\n\t\t\tvar _this$_evtSetMeshes;\n\t\t\tconst render = this._assetReference.asset.resource;\n\t\t\t(_this$_evtSetMeshes = this._evtSetMeshes) == null || _this$_evtSetMeshes.off();\n\t\t\tthis._evtSetMeshes = render.on('set:meshes', this._onSetMeshes, this);\n\t\t\tif (render.meshes) {\n\t\t\t\tthis._onSetMeshes(render.meshes);\n\t\t\t}\n\t\t}\n\t}\n\t_onSetMeshes(meshes) {\n\t\tthis._cloneMeshes(meshes);\n\t}\n\t_clearSkinInstances() {\n\t\tfor (let i = 0; i < this._meshInstances.length; i++) {\n\t\t\tconst meshInstance = this._meshInstances[i];\n\t\t\tSkinInstanceCache.removeCachedSkinInstance(meshInstance.skinInstance);\n\t\t\tmeshInstance.skinInstance = null;\n\t\t}\n\t}\n\t_cloneSkinInstances() {\n\t\tif (this._meshInstances.length && this._rootBone instanceof GraphNode) {\n\t\t\tfor (let i = 0; i < this._meshInstances.length; i++) {\n\t\t\t\tconst meshInstance = this._meshInstances[i];\n\t\t\t\tconst mesh = meshInstance.mesh;\n\t\t\t\tif (mesh.skin && !meshInstance.skinInstance) {\n\t\t\t\t\tmeshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(mesh.skin, this._rootBone, this.entity);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t_cloneMeshes(meshes) {\n\t\tif (meshes && meshes.length) {\n\t\t\tconst meshInstances = [];\n\t\t\tfor (let i = 0; i < meshes.length; i++) {\n\t\t\t\tconst mesh = meshes[i];\n\t\t\t\tconst material = this._materialReferences[i] && this._materialReferences[i].asset && this._materialReferences[i].asset.resource;\n\t\t\t\tconst meshInst = new MeshInstance(mesh, material || this.system.defaultMaterial, this.entity);\n\t\t\t\tmeshInstances.push(meshInst);\n\t\t\t\tif (mesh.morph) {\n\t\t\t\t\tmeshInst.morphInstance = new MorphInstance(mesh.morph);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.meshInstances = meshInstances;\n\t\t\tthis._cloneSkinInstances();\n\t\t}\n\t}\n\t_onRenderAssetUnload() {\n\t\tif (this._type === 'asset') {\n\t\t\tthis.destroyMeshInstances();\n\t\t}\n\t}\n\t_onRenderAssetRemove() {\n\t\tvar _this$_evtSetMeshes2;\n\t\t(_this$_evtSetMeshes2 = this._evtSetMeshes) == null || _this$_evtSetMeshes2.off();\n\t\tthis._evtSetMeshes = null;\n\t\tthis._onRenderAssetUnload();\n\t}\n\t_onMaterialAdded(index, component, asset) {\n\t\tif (asset.resource) {\n\t\t\tthis._onMaterialLoad(index, component, asset);\n\t\t} else {\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis.system.app.assets.load(asset);\n\t\t\t}\n\t\t}\n\t}\n\t_updateMainMaterial(index, material) {\n\t\tif (index === 0) {\n\t\t\tthis.material = material;\n\t\t}\n\t}\n\t_onMaterialLoad(index, component, asset) {\n\t\tif (this._meshInstances[index]) {\n\t\t\tthis._meshInstances[index].material = asset.resource;\n\t\t}\n\t\tthis._updateMainMaterial(index, asset.resource);\n\t}\n\t_onMaterialRemove(index, component, asset) {\n\t\tif (this._meshInstances[index]) {\n\t\t\tthis._meshInstances[index].material = this.system.defaultMaterial;\n\t\t}\n\t\tthis._updateMainMaterial(index, this.system.defaultMaterial);\n\t}\n\t_onMaterialUnload(index, component, asset) {\n\t\tif (this._meshInstances[index]) {\n\t\t\tthis._meshInstances[index].material = this.system.defaultMaterial;\n\t\t}\n\t\tthis._updateMainMaterial(index, this.system.defaultMaterial);\n\t}\n\tresolveDuplicatedEntityReferenceProperties(oldRender, duplicatedIdsMap) {\n\t\tif (oldRender.rootBone) {\n\t\t\tthis.rootBone = duplicatedIdsMap[oldRender.rootBone.getGuid()];\n\t\t}\n\t}\n}\n\nexport { RenderComponent };\n","class RenderComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n}\n\nexport { RenderComponentData };\n","import { Vec3 } from '../../../core/math/vec3.js';\nimport { BoundingBox } from '../../../core/shape/bounding-box.js';\nimport { getDefaultMaterial } from '../../../scene/materials/default-material.js';\nimport { Component } from '../component.js';\nimport { ComponentSystem } from '../system.js';\nimport { RenderComponent } from './component.js';\nimport { RenderComponentData } from './data.js';\n\nconst _schema = ['enabled'];\nconst _properties = ['material', 'meshInstances', 'asset', 'materialAssets', 'castShadows', 'receiveShadows', 'castShadowsLightmap', 'lightmapped', 'lightmapSizeMultiplier', 'renderStyle', 'type', 'layers', 'isStatic', 'batchGroupId', 'rootBone'];\nclass RenderComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'render';\n\t\tthis.ComponentType = RenderComponent;\n\t\tthis.DataType = RenderComponentData;\n\t\tthis.schema = _schema;\n\t\tthis.defaultMaterial = getDefaultMaterial(app.graphicsDevice);\n\t\tthis.on('beforeremove', this.onRemove, this);\n\t}\n\tinitializeComponentData(component, _data, properties) {\n\t\tif (_data.batchGroupId === null || _data.batchGroupId === undefined) {\n\t\t\t_data.batchGroupId = -1;\n\t\t}\n\t\tif (_data.layers && _data.layers.length) {\n\t\t\t_data.layers = _data.layers.slice(0);\n\t\t}\n\t\tfor (let i = 0; i < _properties.length; i++) {\n\t\t\tif (_data.hasOwnProperty(_properties[i])) {\n\t\t\t\tcomponent[_properties[i]] = _data[_properties[i]];\n\t\t\t}\n\t\t}\n\t\tif (_data.aabbCenter && _data.aabbHalfExtents) {\n\t\t\tcomponent.customAabb = new BoundingBox(new Vec3(_data.aabbCenter), new Vec3(_data.aabbHalfExtents));\n\t\t}\n\t\tsuper.initializeComponentData(component, _data, _schema);\n\t}\n\tcloneComponent(entity, clone) {\n\t\tconst data = {};\n\t\tfor (let i = 0; i < _properties.length; i++) {\n\t\t\tdata[_properties[i]] = entity.render[_properties[i]];\n\t\t}\n\t\tdata.enabled = entity.render.enabled;\n\t\tdelete data.meshInstances;\n\t\tconst component = this.addComponent(clone, data);\n\t\tconst srcMeshInstances = entity.render.meshInstances;\n\t\tconst meshes = srcMeshInstances.map(mi => mi.mesh);\n\t\tcomponent._onSetMeshes(meshes);\n\t\tfor (let m = 0; m < srcMeshInstances.length; m++) {\n\t\t\tcomponent.meshInstances[m].material = srcMeshInstances[m].material;\n\t\t}\n\t\tif (entity.render.customAabb) {\n\t\t\tcomponent.customAabb = entity.render.customAabb.clone();\n\t\t}\n\t\treturn component;\n\t}\n\tonRemove(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n}\nComponent._buildAccessors(RenderComponent.prototype, _schema);\n\nexport { RenderComponentSystem };\n","import { Quat } from '../../../core/math/quat.js';\nimport { Vec3 } from '../../../core/math/vec3.js';\nimport { BODYGROUP_STATIC, BODYMASK_NOT_STATIC, BODYTYPE_STATIC, BODYTYPE_DYNAMIC, BODYTYPE_KINEMATIC, BODYGROUP_KINEMATIC, BODYMASK_ALL, BODYGROUP_DYNAMIC, BODYFLAG_KINEMATIC_OBJECT, BODYSTATE_DISABLE_DEACTIVATION, BODYSTATE_ACTIVE_TAG, BODYSTATE_DISABLE_SIMULATION } from './constants.js';\nimport { Component } from '../component.js';\n\nlet _ammoTransform;\nlet _ammoVec1, _ammoVec2, _ammoQuat;\nconst _quat1 = new Quat();\nconst _quat2 = new Quat();\nconst _vec3 = new Vec3();\nclass RigidBodyComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._angularDamping = 0;\n\t\tthis._angularFactor = new Vec3(1, 1, 1);\n\t\tthis._angularVelocity = new Vec3();\n\t\tthis._body = null;\n\t\tthis._friction = 0.5;\n\t\tthis._group = BODYGROUP_STATIC;\n\t\tthis._linearDamping = 0;\n\t\tthis._linearFactor = new Vec3(1, 1, 1);\n\t\tthis._linearVelocity = new Vec3();\n\t\tthis._mask = BODYMASK_NOT_STATIC;\n\t\tthis._mass = 1;\n\t\tthis._restitution = 0;\n\t\tthis._rollingFriction = 0;\n\t\tthis._simulationEnabled = false;\n\t\tthis._type = BODYTYPE_STATIC;\n\t}\n\tstatic onLibraryLoaded() {\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\t_ammoTransform = new Ammo.btTransform();\n\t\t\t_ammoVec1 = new Ammo.btVector3();\n\t\t\t_ammoVec2 = new Ammo.btVector3();\n\t\t\t_ammoQuat = new Ammo.btQuaternion();\n\t\t}\n\t}\n\tstatic onAppDestroy() {\n\t\tAmmo.destroy(_ammoTransform);\n\t\tAmmo.destroy(_ammoVec1);\n\t\tAmmo.destroy(_ammoVec2);\n\t\tAmmo.destroy(_ammoQuat);\n\t\t_ammoTransform = null;\n\t\t_ammoVec1 = null;\n\t\t_ammoVec2 = null;\n\t\t_ammoQuat = null;\n\t}\n\tset angularDamping(damping) {\n\t\tif (this._angularDamping !== damping) {\n\t\t\tthis._angularDamping = damping;\n\t\t\tif (this._body) {\n\t\t\t\tthis._body.setDamping(this._linearDamping, damping);\n\t\t\t}\n\t\t}\n\t}\n\tget angularDamping() {\n\t\treturn this._angularDamping;\n\t}\n\tset angularFactor(factor) {\n\t\tif (!this._angularFactor.equals(factor)) {\n\t\t\tthis._angularFactor.copy(factor);\n\t\t\tif (this._body && this._type === BODYTYPE_DYNAMIC) {\n\t\t\t\t_ammoVec1.setValue(factor.x, factor.y, factor.z);\n\t\t\t\tthis._body.setAngularFactor(_ammoVec1);\n\t\t\t}\n\t\t}\n\t}\n\tget angularFactor() {\n\t\treturn this._angularFactor;\n\t}\n\tset angularVelocity(velocity) {\n\t\tif (this._body && this._type === BODYTYPE_DYNAMIC) {\n\t\t\tthis._body.activate();\n\t\t\t_ammoVec1.setValue(velocity.x, velocity.y, velocity.z);\n\t\t\tthis._body.setAngularVelocity(_ammoVec1);\n\t\t\tthis._angularVelocity.copy(velocity);\n\t\t}\n\t}\n\tget angularVelocity() {\n\t\tif (this._body && this._type === BODYTYPE_DYNAMIC) {\n\t\t\tconst velocity = this._body.getAngularVelocity();\n\t\t\tthis._angularVelocity.set(velocity.x(), velocity.y(), velocity.z());\n\t\t}\n\t\treturn this._angularVelocity;\n\t}\n\tset body(body) {\n\t\tif (this._body !== body) {\n\t\t\tthis._body = body;\n\t\t\tif (body && this._simulationEnabled) {\n\t\t\t\tbody.activate();\n\t\t\t}\n\t\t}\n\t}\n\tget body() {\n\t\treturn this._body;\n\t}\n\tset friction(friction) {\n\t\tif (this._friction !== friction) {\n\t\t\tthis._friction = friction;\n\t\t\tif (this._body) {\n\t\t\t\tthis._body.setFriction(friction);\n\t\t\t}\n\t\t}\n\t}\n\tget friction() {\n\t\treturn this._friction;\n\t}\n\tset group(group) {\n\t\tif (this._group !== group) {\n\t\t\tthis._group = group;\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis.disableSimulation();\n\t\t\t\tthis.enableSimulation();\n\t\t\t}\n\t\t}\n\t}\n\tget group() {\n\t\treturn this._group;\n\t}\n\tset linearDamping(damping) {\n\t\tif (this._linearDamping !== damping) {\n\t\t\tthis._linearDamping = damping;\n\t\t\tif (this._body) {\n\t\t\t\tthis._body.setDamping(damping, this._angularDamping);\n\t\t\t}\n\t\t}\n\t}\n\tget linearDamping() {\n\t\treturn this._linearDamping;\n\t}\n\tset linearFactor(factor) {\n\t\tif (!this._linearFactor.equals(factor)) {\n\t\t\tthis._linearFactor.copy(factor);\n\t\t\tif (this._body && this._type === BODYTYPE_DYNAMIC) {\n\t\t\t\t_ammoVec1.setValue(factor.x, factor.y, factor.z);\n\t\t\t\tthis._body.setLinearFactor(_ammoVec1);\n\t\t\t}\n\t\t}\n\t}\n\tget linearFactor() {\n\t\treturn this._linearFactor;\n\t}\n\tset linearVelocity(velocity) {\n\t\tif (this._body && this._type === BODYTYPE_DYNAMIC) {\n\t\t\tthis._body.activate();\n\t\t\t_ammoVec1.setValue(velocity.x, velocity.y, velocity.z);\n\t\t\tthis._body.setLinearVelocity(_ammoVec1);\n\t\t\tthis._linearVelocity.copy(velocity);\n\t\t}\n\t}\n\tget linearVelocity() {\n\t\tif (this._body && this._type === BODYTYPE_DYNAMIC) {\n\t\t\tconst velocity = this._body.getLinearVelocity();\n\t\t\tthis._linearVelocity.set(velocity.x(), velocity.y(), velocity.z());\n\t\t}\n\t\treturn this._linearVelocity;\n\t}\n\tset mask(mask) {\n\t\tif (this._mask !== mask) {\n\t\t\tthis._mask = mask;\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis.disableSimulation();\n\t\t\t\tthis.enableSimulation();\n\t\t\t}\n\t\t}\n\t}\n\tget mask() {\n\t\treturn this._mask;\n\t}\n\tset mass(mass) {\n\t\tif (this._mass !== mass) {\n\t\t\tthis._mass = mass;\n\t\t\tif (this._body && this._type === BODYTYPE_DYNAMIC) {\n\t\t\t\tconst enabled = this.enabled && this.entity.enabled;\n\t\t\t\tif (enabled) {\n\t\t\t\t\tthis.disableSimulation();\n\t\t\t\t}\n\t\t\t\tthis._body.getCollisionShape().calculateLocalInertia(mass, _ammoVec1);\n\t\t\t\tthis._body.setMassProps(mass, _ammoVec1);\n\t\t\t\tthis._body.updateInertiaTensor();\n\t\t\t\tif (enabled) {\n\t\t\t\t\tthis.enableSimulation();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tget mass() {\n\t\treturn this._mass;\n\t}\n\tset restitution(restitution) {\n\t\tif (this._restitution !== restitution) {\n\t\t\tthis._restitution = restitution;\n\t\t\tif (this._body) {\n\t\t\t\tthis._body.setRestitution(restitution);\n\t\t\t}\n\t\t}\n\t}\n\tget restitution() {\n\t\treturn this._restitution;\n\t}\n\tset rollingFriction(friction) {\n\t\tif (this._rollingFriction !== friction) {\n\t\t\tthis._rollingFriction = friction;\n\t\t\tif (this._body) {\n\t\t\t\tthis._body.setRollingFriction(friction);\n\t\t\t}\n\t\t}\n\t}\n\tget rollingFriction() {\n\t\treturn this._rollingFriction;\n\t}\n\tset type(type) {\n\t\tif (this._type !== type) {\n\t\t\tthis._type = type;\n\t\t\tthis.disableSimulation();\n\t\t\tswitch (type) {\n\t\t\t\tcase BODYTYPE_DYNAMIC:\n\t\t\t\t\tthis._group = BODYGROUP_DYNAMIC;\n\t\t\t\t\tthis._mask = BODYMASK_ALL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BODYTYPE_KINEMATIC:\n\t\t\t\t\tthis._group = BODYGROUP_KINEMATIC;\n\t\t\t\t\tthis._mask = BODYMASK_ALL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BODYTYPE_STATIC:\n\t\t\t\tdefault:\n\t\t\t\t\tthis._group = BODYGROUP_STATIC;\n\t\t\t\t\tthis._mask = BODYMASK_NOT_STATIC;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.createBody();\n\t\t}\n\t}\n\tget type() {\n\t\treturn this._type;\n\t}\n\tcreateBody() {\n\t\tconst entity = this.entity;\n\t\tlet shape;\n\t\tif (entity.collision) {\n\t\t\tshape = entity.collision.shape;\n\t\t\tif (entity.trigger) {\n\t\t\t\tentity.trigger.destroy();\n\t\t\t\tdelete entity.trigger;\n\t\t\t}\n\t\t}\n\t\tif (shape) {\n\t\t\tif (this._body) {\n\t\t\t\tthis.system.removeBody(this._body);\n\t\t\t\tthis.system.destroyBody(this._body);\n\t\t\t\tthis._body = null;\n\t\t\t}\n\t\t\tconst mass = this._type === BODYTYPE_DYNAMIC ? this._mass : 0;\n\t\t\tthis._getEntityTransform(_ammoTransform);\n\t\t\tconst body = this.system.createBody(mass, shape, _ammoTransform);\n\t\t\tbody.setRestitution(this._restitution);\n\t\t\tbody.setFriction(this._friction);\n\t\t\tbody.setRollingFriction(this._rollingFriction);\n\t\t\tbody.setDamping(this._linearDamping, this._angularDamping);\n\t\t\tif (this._type === BODYTYPE_DYNAMIC) {\n\t\t\t\tconst linearFactor = this._linearFactor;\n\t\t\t\t_ammoVec1.setValue(linearFactor.x, linearFactor.y, linearFactor.z);\n\t\t\t\tbody.setLinearFactor(_ammoVec1);\n\t\t\t\tconst angularFactor = this._angularFactor;\n\t\t\t\t_ammoVec1.setValue(angularFactor.x, angularFactor.y, angularFactor.z);\n\t\t\t\tbody.setAngularFactor(_ammoVec1);\n\t\t\t} else if (this._type === BODYTYPE_KINEMATIC) {\n\t\t\t\tbody.setCollisionFlags(body.getCollisionFlags() | BODYFLAG_KINEMATIC_OBJECT);\n\t\t\t\tbody.setActivationState(BODYSTATE_DISABLE_DEACTIVATION);\n\t\t\t}\n\t\t\tbody.entity = entity;\n\t\t\tthis.body = body;\n\t\t\tif (this.enabled && entity.enabled) {\n\t\t\t\tthis.enableSimulation();\n\t\t\t}\n\t\t}\n\t}\n\tisActive() {\n\t\treturn this._body ? this._body.isActive() : false;\n\t}\n\tactivate() {\n\t\tif (this._body) {\n\t\t\tthis._body.activate();\n\t\t}\n\t}\n\tenableSimulation() {\n\t\tconst entity = this.entity;\n\t\tif (entity.collision && entity.collision.enabled && !this._simulationEnabled) {\n\t\t\tconst body = this._body;\n\t\t\tif (body) {\n\t\t\t\tthis.system.addBody(body, this._group, this._mask);\n\t\t\t\tswitch (this._type) {\n\t\t\t\t\tcase BODYTYPE_DYNAMIC:\n\t\t\t\t\t\tthis.system._dynamic.push(this);\n\t\t\t\t\t\tbody.forceActivationState(BODYSTATE_ACTIVE_TAG);\n\t\t\t\t\t\tthis.syncEntityToBody();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase BODYTYPE_KINEMATIC:\n\t\t\t\t\t\tthis.system._kinematic.push(this);\n\t\t\t\t\t\tbody.forceActivationState(BODYSTATE_DISABLE_DEACTIVATION);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase BODYTYPE_STATIC:\n\t\t\t\t\t\tbody.forceActivationState(BODYSTATE_ACTIVE_TAG);\n\t\t\t\t\t\tthis.syncEntityToBody();\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (entity.collision.type === 'compound') {\n\t\t\t\t\tthis.system._compounds.push(entity.collision);\n\t\t\t\t}\n\t\t\t\tbody.activate();\n\t\t\t\tthis._simulationEnabled = true;\n\t\t\t}\n\t\t}\n\t}\n\tdisableSimulation() {\n\t\tconst body = this._body;\n\t\tif (body && this._simulationEnabled) {\n\t\t\tconst system = this.system;\n\t\t\tlet idx = system._compounds.indexOf(this.entity.collision);\n\t\t\tif (idx > -1) {\n\t\t\t\tsystem._compounds.splice(idx, 1);\n\t\t\t}\n\t\t\tidx = system._dynamic.indexOf(this);\n\t\t\tif (idx > -1) {\n\t\t\t\tsystem._dynamic.splice(idx, 1);\n\t\t\t}\n\t\t\tidx = system._kinematic.indexOf(this);\n\t\t\tif (idx > -1) {\n\t\t\t\tsystem._kinematic.splice(idx, 1);\n\t\t\t}\n\t\t\tsystem.removeBody(body);\n\t\t\tbody.forceActivationState(BODYSTATE_DISABLE_SIMULATION);\n\t\t\tthis._simulationEnabled = false;\n\t\t}\n\t}\n\tapplyForce(x, y, z, px, py, pz) {\n\t\tconst body = this._body;\n\t\tif (body) {\n\t\t\tbody.activate();\n\t\t\tif (x instanceof Vec3) {\n\t\t\t\t_ammoVec1.setValue(x.x, x.y, x.z);\n\t\t\t} else {\n\t\t\t\t_ammoVec1.setValue(x, y, z);\n\t\t\t}\n\t\t\tif (y instanceof Vec3) {\n\t\t\t\t_ammoVec2.setValue(y.x, y.y, y.z);\n\t\t\t} else if (px !== undefined) {\n\t\t\t\t_ammoVec2.setValue(px, py, pz);\n\t\t\t} else {\n\t\t\t\t_ammoVec2.setValue(0, 0, 0);\n\t\t\t}\n\t\t\tbody.applyForce(_ammoVec1, _ammoVec2);\n\t\t}\n\t}\n\tapplyTorque(x, y, z) {\n\t\tconst body = this._body;\n\t\tif (body) {\n\t\t\tbody.activate();\n\t\t\tif (x instanceof Vec3) {\n\t\t\t\t_ammoVec1.setValue(x.x, x.y, x.z);\n\t\t\t} else {\n\t\t\t\t_ammoVec1.setValue(x, y, z);\n\t\t\t}\n\t\t\tbody.applyTorque(_ammoVec1);\n\t\t}\n\t}\n\tapplyImpulse(x, y, z, px, py, pz) {\n\t\tconst body = this._body;\n\t\tif (body) {\n\t\t\tbody.activate();\n\t\t\tif (x instanceof Vec3) {\n\t\t\t\t_ammoVec1.setValue(x.x, x.y, x.z);\n\t\t\t} else {\n\t\t\t\t_ammoVec1.setValue(x, y, z);\n\t\t\t}\n\t\t\tif (y instanceof Vec3) {\n\t\t\t\t_ammoVec2.setValue(y.x, y.y, y.z);\n\t\t\t} else if (px !== undefined) {\n\t\t\t\t_ammoVec2.setValue(px, py, pz);\n\t\t\t} else {\n\t\t\t\t_ammoVec2.setValue(0, 0, 0);\n\t\t\t}\n\t\t\tbody.applyImpulse(_ammoVec1, _ammoVec2);\n\t\t}\n\t}\n\tapplyTorqueImpulse(x, y, z) {\n\t\tconst body = this._body;\n\t\tif (body) {\n\t\t\tbody.activate();\n\t\t\tif (x instanceof Vec3) {\n\t\t\t\t_ammoVec1.setValue(x.x, x.y, x.z);\n\t\t\t} else {\n\t\t\t\t_ammoVec1.setValue(x, y, z);\n\t\t\t}\n\t\t\tbody.applyTorqueImpulse(_ammoVec1);\n\t\t}\n\t}\n\tisStatic() {\n\t\treturn this._type === BODYTYPE_STATIC;\n\t}\n\tisStaticOrKinematic() {\n\t\treturn this._type === BODYTYPE_STATIC || this._type === BODYTYPE_KINEMATIC;\n\t}\n\tisKinematic() {\n\t\treturn this._type === BODYTYPE_KINEMATIC;\n\t}\n\t_getEntityTransform(transform) {\n\t\tconst entity = this.entity;\n\t\tconst component = entity.collision;\n\t\tif (component) {\n\t\t\tconst bodyPos = component.getShapePosition();\n\t\t\tconst bodyRot = component.getShapeRotation();\n\t\t\t_ammoVec1.setValue(bodyPos.x, bodyPos.y, bodyPos.z);\n\t\t\t_ammoQuat.setValue(bodyRot.x, bodyRot.y, bodyRot.z, bodyRot.w);\n\t\t} else {\n\t\t\tconst pos = entity.getPosition();\n\t\t\tconst rot = entity.getRotation();\n\t\t\t_ammoVec1.setValue(pos.x, pos.y, pos.z);\n\t\t\t_ammoQuat.setValue(rot.x, rot.y, rot.z, rot.w);\n\t\t}\n\t\ttransform.setOrigin(_ammoVec1);\n\t\ttransform.setRotation(_ammoQuat);\n\t}\n\tsyncEntityToBody() {\n\t\tconst body = this._body;\n\t\tif (body) {\n\t\t\tthis._getEntityTransform(_ammoTransform);\n\t\t\tbody.setWorldTransform(_ammoTransform);\n\t\t\tif (this._type === BODYTYPE_KINEMATIC) {\n\t\t\t\tconst motionState = body.getMotionState();\n\t\t\t\tif (motionState) {\n\t\t\t\t\tmotionState.setWorldTransform(_ammoTransform);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbody.activate();\n\t\t}\n\t}\n\t_updateDynamic() {\n\t\tconst body = this._body;\n\t\tif (body.isActive()) {\n\t\t\tconst motionState = body.getMotionState();\n\t\t\tif (motionState) {\n\t\t\t\tconst entity = this.entity;\n\t\t\t\tmotionState.getWorldTransform(_ammoTransform);\n\t\t\t\tconst p = _ammoTransform.getOrigin();\n\t\t\t\tconst q = _ammoTransform.getRotation();\n\t\t\t\tconst component = entity.collision;\n\t\t\t\tif (component && component._hasOffset) {\n\t\t\t\t\tconst lo = component.data.linearOffset;\n\t\t\t\t\tconst ao = component.data.angularOffset;\n\t\t\t\t\tconst invertedAo = _quat2.copy(ao).invert();\n\t\t\t\t\tconst entityRot = _quat1.set(q.x(), q.y(), q.z(), q.w()).mul(invertedAo);\n\t\t\t\t\tentityRot.transformVector(lo, _vec3);\n\t\t\t\t\tentity.setPosition(p.x() - _vec3.x, p.y() - _vec3.y, p.z() - _vec3.z);\n\t\t\t\t\tentity.setRotation(entityRot);\n\t\t\t\t} else {\n\t\t\t\t\tentity.setPosition(p.x(), p.y(), p.z());\n\t\t\t\t\tentity.setRotation(q.x(), q.y(), q.z(), q.w());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t_updateKinematic() {\n\t\tconst motionState = this._body.getMotionState();\n\t\tif (motionState) {\n\t\t\tthis._getEntityTransform(_ammoTransform);\n\t\t\tmotionState.setWorldTransform(_ammoTransform);\n\t\t}\n\t}\n\tteleport(x, y, z, rx, ry, rz) {\n\t\tif (x instanceof Vec3) {\n\t\t\tthis.entity.setPosition(x);\n\t\t} else {\n\t\t\tthis.entity.setPosition(x, y, z);\n\t\t}\n\t\tif (y instanceof Quat) {\n\t\t\tthis.entity.setRotation(y);\n\t\t} else if (y instanceof Vec3) {\n\t\t\tthis.entity.setEulerAngles(y);\n\t\t} else if (rx !== undefined) {\n\t\t\tthis.entity.setEulerAngles(rx, ry, rz);\n\t\t}\n\t\tthis.syncEntityToBody();\n\t}\n\tonEnable() {\n\t\tif (!this._body) {\n\t\t\tthis.createBody();\n\t\t}\n\t\tthis.enableSimulation();\n\t}\n\tonDisable() {\n\t\tthis.disableSimulation();\n\t}\n}\nRigidBodyComponent.EVENT_CONTACT = 'contact';\nRigidBodyComponent.EVENT_COLLISIONSTART = 'collisionstart';\nRigidBodyComponent.EVENT_COLLISIONEND = 'collisionend';\nRigidBodyComponent.EVENT_TRIGGERENTER = 'triggerenter';\nRigidBodyComponent.EVENT_TRIGGERLEAVE = 'triggerleave';\n\nexport { RigidBodyComponent };\n","const BODYTYPE_STATIC = 'static';\nconst BODYTYPE_DYNAMIC = 'dynamic';\nconst BODYTYPE_KINEMATIC = 'kinematic';\nconst BODYFLAG_STATIC_OBJECT = 1;\nconst BODYFLAG_KINEMATIC_OBJECT = 2;\nconst BODYFLAG_NORESPONSE_OBJECT = 4;\nconst BODYSTATE_ACTIVE_TAG = 1;\nconst BODYSTATE_ISLAND_SLEEPING = 2;\nconst BODYSTATE_WANTS_DEACTIVATION = 3;\nconst BODYSTATE_DISABLE_DEACTIVATION = 4;\nconst BODYSTATE_DISABLE_SIMULATION = 5;\nconst BODYGROUP_NONE = 0;\nconst BODYGROUP_DEFAULT = 1;\nconst BODYGROUP_DYNAMIC = 1;\nconst BODYGROUP_STATIC = 2;\nconst BODYGROUP_KINEMATIC = 4;\nconst BODYGROUP_ENGINE_1 = 8;\nconst BODYGROUP_TRIGGER = 16;\nconst BODYGROUP_ENGINE_2 = 32;\nconst BODYGROUP_ENGINE_3 = 64;\nconst BODYGROUP_USER_1 = 128;\nconst BODYGROUP_USER_2 = 256;\nconst BODYGROUP_USER_3 = 512;\nconst BODYGROUP_USER_4 = 1024;\nconst BODYGROUP_USER_5 = 2048;\nconst BODYGROUP_USER_6 = 4096;\nconst BODYGROUP_USER_7 = 8192;\nconst BODYGROUP_USER_8 = 16384;\nconst BODYMASK_NONE = 0;\nconst BODYMASK_ALL = 65535;\nconst BODYMASK_STATIC = 2;\nconst BODYMASK_NOT_STATIC = 65535 ^ 2;\nconst BODYMASK_NOT_STATIC_KINEMATIC = 65535 ^ (2 | 4);\n\nexport { BODYFLAG_KINEMATIC_OBJECT, BODYFLAG_NORESPONSE_OBJECT, BODYFLAG_STATIC_OBJECT, BODYGROUP_DEFAULT, BODYGROUP_DYNAMIC, BODYGROUP_ENGINE_1, BODYGROUP_ENGINE_2, BODYGROUP_ENGINE_3, BODYGROUP_KINEMATIC, BODYGROUP_NONE, BODYGROUP_STATIC, BODYGROUP_TRIGGER, BODYGROUP_USER_1, BODYGROUP_USER_2, BODYGROUP_USER_3, BODYGROUP_USER_4, BODYGROUP_USER_5, BODYGROUP_USER_6, BODYGROUP_USER_7, BODYGROUP_USER_8, BODYMASK_ALL, BODYMASK_NONE, BODYMASK_NOT_STATIC, BODYMASK_NOT_STATIC_KINEMATIC, BODYMASK_STATIC, BODYSTATE_ACTIVE_TAG, BODYSTATE_DISABLE_DEACTIVATION, BODYSTATE_DISABLE_SIMULATION, BODYSTATE_ISLAND_SLEEPING, BODYSTATE_WANTS_DEACTIVATION, BODYTYPE_DYNAMIC, BODYTYPE_KINEMATIC, BODYTYPE_STATIC };\n","class RigidBodyComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n}\n\nexport { RigidBodyComponentData };\n","import { ObjectPool } from '../../../core/object-pool.js';\nimport { Vec3 } from '../../../core/math/vec3.js';\nimport { Component } from '../component.js';\nimport { ComponentSystem } from '../system.js';\nimport { BODYFLAG_NORESPONSE_OBJECT } from './constants.js';\nimport { RigidBodyComponent } from './component.js';\nimport { RigidBodyComponentData } from './data.js';\n\nlet ammoRayStart, ammoRayEnd;\nclass RaycastResult {\n\tconstructor(entity, point, normal, hitFraction) {\n\t\tthis.entity = void 0;\n\t\tthis.point = void 0;\n\t\tthis.normal = void 0;\n\t\tthis.hitFraction = void 0;\n\t\tthis.entity = entity;\n\t\tthis.point = point;\n\t\tthis.normal = normal;\n\t\tthis.hitFraction = hitFraction;\n\t}\n}\nclass SingleContactResult {\n\tconstructor(a, b, contactPoint) {\n\t\tthis.a = void 0;\n\t\tthis.b = void 0;\n\t\tthis.impulse = void 0;\n\t\tthis.localPointA = void 0;\n\t\tthis.localPointB = void 0;\n\t\tthis.pointA = void 0;\n\t\tthis.pointB = void 0;\n\t\tthis.normal = void 0;\n\t\tif (arguments.length !== 0) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.impulse = contactPoint.impulse;\n\t\t\tthis.localPointA = contactPoint.localPoint;\n\t\t\tthis.localPointB = contactPoint.localPointOther;\n\t\t\tthis.pointA = contactPoint.point;\n\t\t\tthis.pointB = contactPoint.pointOther;\n\t\t\tthis.normal = contactPoint.normal;\n\t\t} else {\n\t\t\tthis.a = null;\n\t\t\tthis.b = null;\n\t\t\tthis.impulse = 0;\n\t\t\tthis.localPointA = new Vec3();\n\t\t\tthis.localPointB = new Vec3();\n\t\t\tthis.pointA = new Vec3();\n\t\t\tthis.pointB = new Vec3();\n\t\t\tthis.normal = new Vec3();\n\t\t}\n\t}\n}\nclass ContactPoint {\n\tconstructor(localPoint = new Vec3(), localPointOther = new Vec3(), point = new Vec3(), pointOther = new Vec3(), normal = new Vec3(), impulse = 0) {\n\t\tthis.localPoint = void 0;\n\t\tthis.localPointOther = void 0;\n\t\tthis.point = void 0;\n\t\tthis.pointOther = void 0;\n\t\tthis.normal = void 0;\n\t\tthis.impulse = void 0;\n\t\tthis.localPoint = localPoint;\n\t\tthis.localPointOther = localPointOther;\n\t\tthis.point = point;\n\t\tthis.pointOther = pointOther;\n\t\tthis.normal = normal;\n\t\tthis.impulse = impulse;\n\t}\n}\nclass ContactResult {\n\tconstructor(other, contacts) {\n\t\tthis.other = void 0;\n\t\tthis.contacts = void 0;\n\t\tthis.other = other;\n\t\tthis.contacts = contacts;\n\t}\n}\nconst _schema = ['enabled'];\nclass RigidBodyComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.maxSubSteps = 10;\n\t\tthis.fixedTimeStep = 1 / 60;\n\t\tthis.gravity = new Vec3(0, -9.81, 0);\n\t\tthis._gravityFloat32 = new Float32Array(3);\n\t\tthis._dynamic = [];\n\t\tthis._kinematic = [];\n\t\tthis._triggers = [];\n\t\tthis._compounds = [];\n\t\tthis.id = 'rigidbody';\n\t\tthis._stats = app.stats.frame;\n\t\tthis.ComponentType = RigidBodyComponent;\n\t\tthis.DataType = RigidBodyComponentData;\n\t\tthis.contactPointPool = null;\n\t\tthis.contactResultPool = null;\n\t\tthis.singleContactResultPool = null;\n\t\tthis.schema = _schema;\n\t\tthis.collisions = {};\n\t\tthis.frameCollisions = {};\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t}\n\tonLibraryLoaded() {\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\tthis.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();\n\t\t\tthis.dispatcher = new Ammo.btCollisionDispatcher(this.collisionConfiguration);\n\t\t\tthis.overlappingPairCache = new Ammo.btDbvtBroadphase();\n\t\t\tthis.solver = new Ammo.btSequentialImpulseConstraintSolver();\n\t\t\tthis.dynamicsWorld = new Ammo.btDiscreteDynamicsWorld(this.dispatcher, this.overlappingPairCache, this.solver, this.collisionConfiguration);\n\t\t\tif (this.dynamicsWorld.setInternalTickCallback) {\n\t\t\t\tconst checkForCollisionsPointer = Ammo.addFunction(this._checkForCollisions.bind(this), 'vif');\n\t\t\t\tthis.dynamicsWorld.setInternalTickCallback(checkForCollisionsPointer);\n\t\t\t}\n\t\t\tammoRayStart = new Ammo.btVector3();\n\t\t\tammoRayEnd = new Ammo.btVector3();\n\t\t\tRigidBodyComponent.onLibraryLoaded();\n\t\t\tthis.contactPointPool = new ObjectPool(ContactPoint, 1);\n\t\t\tthis.contactResultPool = new ObjectPool(ContactResult, 1);\n\t\t\tthis.singleContactResultPool = new ObjectPool(SingleContactResult, 1);\n\t\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t\t} else {\n\t\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t\t}\n\t}\n\tinitializeComponentData(component, data, properties) {\n\t\tconst props = ['mass', 'linearDamping', 'angularDamping', 'linearFactor', 'angularFactor', 'friction', 'rollingFriction', 'restitution', 'type', 'group', 'mask'];\n\t\tfor (const property of props) {\n\t\t\tif (data.hasOwnProperty(property)) {\n\t\t\t\tconst value = data[property];\n\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\tcomponent[property] = new Vec3(value[0], value[1], value[2]);\n\t\t\t\t} else {\n\t\t\t\t\tcomponent[property] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsuper.initializeComponentData(component, data, ['enabled']);\n\t}\n\tcloneComponent(entity, clone) {\n\t\tconst rigidbody = entity.rigidbody;\n\t\tconst data = {\n\t\t\tenabled: rigidbody.enabled,\n\t\t\tmass: rigidbody.mass,\n\t\t\tlinearDamping: rigidbody.linearDamping,\n\t\t\tangularDamping: rigidbody.angularDamping,\n\t\t\tlinearFactor: [rigidbody.linearFactor.x, rigidbody.linearFactor.y, rigidbody.linearFactor.z],\n\t\t\tangularFactor: [rigidbody.angularFactor.x, rigidbody.angularFactor.y, rigidbody.angularFactor.z],\n\t\t\tfriction: rigidbody.friction,\n\t\t\trollingFriction: rigidbody.rollingFriction,\n\t\t\trestitution: rigidbody.restitution,\n\t\t\ttype: rigidbody.type,\n\t\t\tgroup: rigidbody.group,\n\t\t\tmask: rigidbody.mask\n\t\t};\n\t\treturn this.addComponent(clone, data);\n\t}\n\tonBeforeRemove(entity, component) {\n\t\tif (component.enabled) {\n\t\t\tcomponent.enabled = false;\n\t\t}\n\t\tif (component.body) {\n\t\t\tthis.destroyBody(component.body);\n\t\t\tcomponent.body = null;\n\t\t}\n\t}\n\taddBody(body, group, mask) {\n\t\tif (group !== undefined && mask !== undefined) {\n\t\t\tthis.dynamicsWorld.addRigidBody(body, group, mask);\n\t\t} else {\n\t\t\tthis.dynamicsWorld.addRigidBody(body);\n\t\t}\n\t}\n\tremoveBody(body) {\n\t\tthis.dynamicsWorld.removeRigidBody(body);\n\t}\n\tcreateBody(mass, shape, transform) {\n\t\tconst localInertia = new Ammo.btVector3(0, 0, 0);\n\t\tif (mass !== 0) {\n\t\t\tshape.calculateLocalInertia(mass, localInertia);\n\t\t}\n\t\tconst motionState = new Ammo.btDefaultMotionState(transform);\n\t\tconst bodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);\n\t\tconst body = new Ammo.btRigidBody(bodyInfo);\n\t\tAmmo.destroy(bodyInfo);\n\t\tAmmo.destroy(localInertia);\n\t\treturn body;\n\t}\n\tdestroyBody(body) {\n\t\tconst motionState = body.getMotionState();\n\t\tif (motionState) {\n\t\t\tAmmo.destroy(motionState);\n\t\t}\n\t\tAmmo.destroy(body);\n\t}\n\traycastFirst(start, end, options = {}) {\n\t\tif (options.filterTags || options.filterCallback) {\n\t\t\toptions.sort = true;\n\t\t\treturn this.raycastAll(start, end, options)[0] || null;\n\t\t}\n\t\tlet result = null;\n\t\tammoRayStart.setValue(start.x, start.y, start.z);\n\t\tammoRayEnd.setValue(end.x, end.y, end.z);\n\t\tconst rayCallback = new Ammo.ClosestRayResultCallback(ammoRayStart, ammoRayEnd);\n\t\tif (typeof options.filterCollisionGroup === 'number') {\n\t\t\trayCallback.set_m_collisionFilterGroup(options.filterCollisionGroup);\n\t\t}\n\t\tif (typeof options.filterCollisionMask === 'number') {\n\t\t\trayCallback.set_m_collisionFilterMask(options.filterCollisionMask);\n\t\t}\n\t\tthis.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);\n\t\tif (rayCallback.hasHit()) {\n\t\t\tconst collisionObj = rayCallback.get_m_collisionObject();\n\t\t\tconst body = Ammo.castObject(collisionObj, Ammo.btRigidBody);\n\t\t\tif (body) {\n\t\t\t\tconst point = rayCallback.get_m_hitPointWorld();\n\t\t\t\tconst normal = rayCallback.get_m_hitNormalWorld();\n\t\t\t\tresult = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()), rayCallback.get_m_closestHitFraction());\n\t\t\t}\n\t\t}\n\t\tAmmo.destroy(rayCallback);\n\t\treturn result;\n\t}\n\traycastAll(start, end, options = {}) {\n\t\tconst results = [];\n\t\tammoRayStart.setValue(start.x, start.y, start.z);\n\t\tammoRayEnd.setValue(end.x, end.y, end.z);\n\t\tconst rayCallback = new Ammo.AllHitsRayResultCallback(ammoRayStart, ammoRayEnd);\n\t\tif (typeof options.filterCollisionGroup === 'number') {\n\t\t\trayCallback.set_m_collisionFilterGroup(options.filterCollisionGroup);\n\t\t}\n\t\tif (typeof options.filterCollisionMask === 'number') {\n\t\t\trayCallback.set_m_collisionFilterMask(options.filterCollisionMask);\n\t\t}\n\t\tthis.dynamicsWorld.rayTest(ammoRayStart, ammoRayEnd, rayCallback);\n\t\tif (rayCallback.hasHit()) {\n\t\t\tconst collisionObjs = rayCallback.get_m_collisionObjects();\n\t\t\tconst points = rayCallback.get_m_hitPointWorld();\n\t\t\tconst normals = rayCallback.get_m_hitNormalWorld();\n\t\t\tconst hitFractions = rayCallback.get_m_hitFractions();\n\t\t\tconst numHits = collisionObjs.size();\n\t\t\tfor (let i = 0; i < numHits; i++) {\n\t\t\t\tconst body = Ammo.castObject(collisionObjs.at(i), Ammo.btRigidBody);\n\t\t\t\tif (body && body.entity) {\n\t\t\t\t\tif (options.filterTags && !body.entity.tags.has(...options.filterTags) || options.filterCallback && !options.filterCallback(body.entity)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tconst point = points.at(i);\n\t\t\t\t\tconst normal = normals.at(i);\n\t\t\t\t\tconst result = new RaycastResult(body.entity, new Vec3(point.x(), point.y(), point.z()), new Vec3(normal.x(), normal.y(), normal.z()), hitFractions.at(i));\n\t\t\t\t\tresults.push(result);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.sort) {\n\t\t\t\tresults.sort((a, b) => a.hitFraction - b.hitFraction);\n\t\t\t}\n\t\t}\n\t\tAmmo.destroy(rayCallback);\n\t\treturn results;\n\t}\n\t_storeCollision(entity, other) {\n\t\tlet isNewCollision = false;\n\t\tconst guid = entity.getGuid();\n\t\tthis.collisions[guid] = this.collisions[guid] || {\n\t\t\tothers: [],\n\t\t\tentity: entity\n\t\t};\n\t\tif (this.collisions[guid].others.indexOf(other) < 0) {\n\t\t\tthis.collisions[guid].others.push(other);\n\t\t\tisNewCollision = true;\n\t\t}\n\t\tthis.frameCollisions[guid] = this.frameCollisions[guid] || {\n\t\t\tothers: [],\n\t\t\tentity: entity\n\t\t};\n\t\tthis.frameCollisions[guid].others.push(other);\n\t\treturn isNewCollision;\n\t}\n\t_createContactPointFromAmmo(contactPoint) {\n\t\tconst localPointA = contactPoint.get_m_localPointA();\n\t\tconst localPointB = contactPoint.get_m_localPointB();\n\t\tconst positionWorldOnA = contactPoint.getPositionWorldOnA();\n\t\tconst positionWorldOnB = contactPoint.getPositionWorldOnB();\n\t\tconst normalWorldOnB = contactPoint.get_m_normalWorldOnB();\n\t\tconst contact = this.contactPointPool.allocate();\n\t\tcontact.localPoint.set(localPointA.x(), localPointA.y(), localPointA.z());\n\t\tcontact.localPointOther.set(localPointB.x(), localPointB.y(), localPointB.z());\n\t\tcontact.point.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());\n\t\tcontact.pointOther.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());\n\t\tcontact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());\n\t\tcontact.impulse = contactPoint.getAppliedImpulse();\n\t\treturn contact;\n\t}\n\t_createReverseContactPointFromAmmo(contactPoint) {\n\t\tconst localPointA = contactPoint.get_m_localPointA();\n\t\tconst localPointB = contactPoint.get_m_localPointB();\n\t\tconst positionWorldOnA = contactPoint.getPositionWorldOnA();\n\t\tconst positionWorldOnB = contactPoint.getPositionWorldOnB();\n\t\tconst normalWorldOnB = contactPoint.get_m_normalWorldOnB();\n\t\tconst contact = this.contactPointPool.allocate();\n\t\tcontact.localPointOther.set(localPointA.x(), localPointA.y(), localPointA.z());\n\t\tcontact.localPoint.set(localPointB.x(), localPointB.y(), localPointB.z());\n\t\tcontact.pointOther.set(positionWorldOnA.x(), positionWorldOnA.y(), positionWorldOnA.z());\n\t\tcontact.point.set(positionWorldOnB.x(), positionWorldOnB.y(), positionWorldOnB.z());\n\t\tcontact.normal.set(normalWorldOnB.x(), normalWorldOnB.y(), normalWorldOnB.z());\n\t\tcontact.impulse = contactPoint.getAppliedImpulse();\n\t\treturn contact;\n\t}\n\t_createSingleContactResult(a, b, contactPoint) {\n\t\tconst result = this.singleContactResultPool.allocate();\n\t\tresult.a = a;\n\t\tresult.b = b;\n\t\tresult.localPointA = contactPoint.localPoint;\n\t\tresult.localPointB = contactPoint.localPointOther;\n\t\tresult.pointA = contactPoint.point;\n\t\tresult.pointB = contactPoint.pointOther;\n\t\tresult.normal = contactPoint.normal;\n\t\tresult.impulse = contactPoint.impulse;\n\t\treturn result;\n\t}\n\t_createContactResult(other, contacts) {\n\t\tconst result = this.contactResultPool.allocate();\n\t\tresult.other = other;\n\t\tresult.contacts = contacts;\n\t\treturn result;\n\t}\n\t_cleanOldCollisions() {\n\t\tfor (const guid in this.collisions) {\n\t\t\tif (this.collisions.hasOwnProperty(guid)) {\n\t\t\t\tconst frameCollision = this.frameCollisions[guid];\n\t\t\t\tconst collision = this.collisions[guid];\n\t\t\t\tconst entity = collision.entity;\n\t\t\t\tconst entityCollision = entity.collision;\n\t\t\t\tconst entityRigidbody = entity.rigidbody;\n\t\t\t\tconst others = collision.others;\n\t\t\t\tconst length = others.length;\n\t\t\t\tlet i = length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tconst other = others[i];\n\t\t\t\t\tif (!frameCollision || frameCollision.others.indexOf(other) < 0) {\n\t\t\t\t\t\tothers.splice(i, 1);\n\t\t\t\t\t\tif (entity.trigger) {\n\t\t\t\t\t\t\tif (entityCollision) {\n\t\t\t\t\t\t\t\tentityCollision.fire('triggerleave', other);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (other.rigidbody) {\n\t\t\t\t\t\t\t\tother.rigidbody.fire('triggerleave', entity);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (!other.trigger) {\n\t\t\t\t\t\t\tif (entityRigidbody) {\n\t\t\t\t\t\t\t\tentityRigidbody.fire('collisionend', other);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (entityCollision) {\n\t\t\t\t\t\t\t\tentityCollision.fire('collisionend', other);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (others.length === 0) {\n\t\t\t\t\tdelete this.collisions[guid];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t_hasContactEvent(entity) {\n\t\tconst c = entity.collision;\n\t\tif (c && (c.hasEvent('collisionstart') || c.hasEvent('collisionend') || c.hasEvent('contact'))) {\n\t\t\treturn true;\n\t\t}\n\t\tconst r = entity.rigidbody;\n\t\treturn r && (r.hasEvent('collisionstart') || r.hasEvent('collisionend') || r.hasEvent('contact'));\n\t}\n\t_checkForCollisions(world, timeStep) {\n\t\tconst dynamicsWorld = Ammo.wrapPointer(world, Ammo.btDynamicsWorld);\n\t\tconst dispatcher = dynamicsWorld.getDispatcher();\n\t\tconst numManifolds = dispatcher.getNumManifolds();\n\t\tthis.frameCollisions = {};\n\t\tfor (let i = 0; i < numManifolds; i++) {\n\t\t\tconst manifold = dispatcher.getManifoldByIndexInternal(i);\n\t\t\tconst body0 = manifold.getBody0();\n\t\t\tconst body1 = manifold.getBody1();\n\t\t\tconst wb0 = Ammo.castObject(body0, Ammo.btRigidBody);\n\t\t\tconst wb1 = Ammo.castObject(body1, Ammo.btRigidBody);\n\t\t\tconst e0 = wb0.entity;\n\t\t\tconst e1 = wb1.entity;\n\t\t\tif (!e0 || !e1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst flags0 = wb0.getCollisionFlags();\n\t\t\tconst flags1 = wb1.getCollisionFlags();\n\t\t\tconst numContacts = manifold.getNumContacts();\n\t\t\tconst forwardContacts = [];\n\t\t\tconst reverseContacts = [];\n\t\t\tlet newCollision;\n\t\t\tif (numContacts > 0) {\n\t\t\t\tif (flags0 & BODYFLAG_NORESPONSE_OBJECT || flags1 & BODYFLAG_NORESPONSE_OBJECT) {\n\t\t\t\t\tconst e0Events = e0.collision && (e0.collision.hasEvent('triggerenter') || e0.collision.hasEvent('triggerleave'));\n\t\t\t\t\tconst e1Events = e1.collision && (e1.collision.hasEvent('triggerenter') || e1.collision.hasEvent('triggerleave'));\n\t\t\t\t\tconst e0BodyEvents = e0.rigidbody && (e0.rigidbody.hasEvent('triggerenter') || e0.rigidbody.hasEvent('triggerleave'));\n\t\t\t\t\tconst e1BodyEvents = e1.rigidbody && (e1.rigidbody.hasEvent('triggerenter') || e1.rigidbody.hasEvent('triggerleave'));\n\t\t\t\t\tif (e0Events) {\n\t\t\t\t\t\tnewCollision = this._storeCollision(e0, e1);\n\t\t\t\t\t\tif (newCollision && !(flags1 & BODYFLAG_NORESPONSE_OBJECT)) {\n\t\t\t\t\t\t\te0.collision.fire('triggerenter', e1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (e1Events) {\n\t\t\t\t\t\tnewCollision = this._storeCollision(e1, e0);\n\t\t\t\t\t\tif (newCollision && !(flags0 & BODYFLAG_NORESPONSE_OBJECT)) {\n\t\t\t\t\t\t\te1.collision.fire('triggerenter', e0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (e0BodyEvents) {\n\t\t\t\t\t\tif (!newCollision) {\n\t\t\t\t\t\t\tnewCollision = this._storeCollision(e1, e0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (newCollision) {\n\t\t\t\t\t\t\te0.rigidbody.fire('triggerenter', e1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (e1BodyEvents) {\n\t\t\t\t\t\tif (!newCollision) {\n\t\t\t\t\t\t\tnewCollision = this._storeCollision(e0, e1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (newCollision) {\n\t\t\t\t\t\t\te1.rigidbody.fire('triggerenter', e0);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconst e0Events = this._hasContactEvent(e0);\n\t\t\t\t\tconst e1Events = this._hasContactEvent(e1);\n\t\t\t\t\tconst globalEvents = this.hasEvent('contact');\n\t\t\t\t\tif (globalEvents || e0Events || e1Events) {\n\t\t\t\t\t\tfor (let j = 0; j < numContacts; j++) {\n\t\t\t\t\t\t\tconst btContactPoint = manifold.getContactPoint(j);\n\t\t\t\t\t\t\tconst contactPoint = this._createContactPointFromAmmo(btContactPoint);\n\t\t\t\t\t\t\tif (e0Events || e1Events) {\n\t\t\t\t\t\t\t\tforwardContacts.push(contactPoint);\n\t\t\t\t\t\t\t\tconst reverseContactPoint = this._createReverseContactPointFromAmmo(btContactPoint);\n\t\t\t\t\t\t\t\treverseContacts.push(reverseContactPoint);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (globalEvents) {\n\t\t\t\t\t\t\t\tconst result = this._createSingleContactResult(e0, e1, contactPoint);\n\t\t\t\t\t\t\t\tthis.fire('contact', result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (e0Events) {\n\t\t\t\t\t\t\tconst forwardResult = this._createContactResult(e1, forwardContacts);\n\t\t\t\t\t\t\tnewCollision = this._storeCollision(e0, e1);\n\t\t\t\t\t\t\tif (e0.collision) {\n\t\t\t\t\t\t\t\te0.collision.fire('contact', forwardResult);\n\t\t\t\t\t\t\t\tif (newCollision) {\n\t\t\t\t\t\t\t\t\te0.collision.fire('collisionstart', forwardResult);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (e0.rigidbody) {\n\t\t\t\t\t\t\t\te0.rigidbody.fire('contact', forwardResult);\n\t\t\t\t\t\t\t\tif (newCollision) {\n\t\t\t\t\t\t\t\t\te0.rigidbody.fire('collisionstart', forwardResult);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (e1Events) {\n\t\t\t\t\t\t\tconst reverseResult = this._createContactResult(e0, reverseContacts);\n\t\t\t\t\t\t\tnewCollision = this._storeCollision(e1, e0);\n\t\t\t\t\t\t\tif (e1.collision) {\n\t\t\t\t\t\t\t\te1.collision.fire('contact', reverseResult);\n\t\t\t\t\t\t\t\tif (newCollision) {\n\t\t\t\t\t\t\t\t\te1.collision.fire('collisionstart', reverseResult);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (e1.rigidbody) {\n\t\t\t\t\t\t\t\te1.rigidbody.fire('contact', reverseResult);\n\t\t\t\t\t\t\t\tif (newCollision) {\n\t\t\t\t\t\t\t\t\te1.rigidbody.fire('collisionstart', reverseResult);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._cleanOldCollisions();\n\t\tthis.contactPointPool.freeAll();\n\t\tthis.contactResultPool.freeAll();\n\t\tthis.singleContactResultPool.freeAll();\n\t}\n\tonUpdate(dt) {\n\t\tlet i, len;\n\t\tthis._gravityFloat32[0] = this.gravity.x;\n\t\tthis._gravityFloat32[1] = this.gravity.y;\n\t\tthis._gravityFloat32[2] = this.gravity.z;\n\t\tconst gravity = this.dynamicsWorld.getGravity();\n\t\tif (gravity.x() !== this._gravityFloat32[0] || gravity.y() !== this._gravityFloat32[1] || gravity.z() !== this._gravityFloat32[2]) {\n\t\t\tgravity.setValue(this.gravity.x, this.gravity.y, this.gravity.z);\n\t\t\tthis.dynamicsWorld.setGravity(gravity);\n\t\t}\n\t\tconst triggers = this._triggers;\n\t\tfor (i = 0, len = triggers.length; i < len; i++) {\n\t\t\ttriggers[i].updateTransform();\n\t\t}\n\t\tconst compounds = this._compounds;\n\t\tfor (i = 0, len = compounds.length; i < len; i++) {\n\t\t\tcompounds[i]._updateCompound();\n\t\t}\n\t\tconst kinematic = this._kinematic;\n\t\tfor (i = 0, len = kinematic.length; i < len; i++) {\n\t\t\tkinematic[i]._updateKinematic();\n\t\t}\n\t\tthis.dynamicsWorld.stepSimulation(dt, this.maxSubSteps, this.fixedTimeStep);\n\t\tconst dynamic = this._dynamic;\n\t\tfor (i = 0, len = dynamic.length; i < len; i++) {\n\t\t\tdynamic[i]._updateDynamic();\n\t\t}\n\t\tif (!this.dynamicsWorld.setInternalTickCallback) {\n\t\t\tthis._checkForCollisions(Ammo.getPointer(this.dynamicsWorld), dt);\n\t\t}\n\t}\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t\tif (typeof Ammo !== 'undefined') {\n\t\t\tAmmo.destroy(this.dynamicsWorld);\n\t\t\tAmmo.destroy(this.solver);\n\t\t\tAmmo.destroy(this.overlappingPairCache);\n\t\t\tAmmo.destroy(this.dispatcher);\n\t\t\tAmmo.destroy(this.collisionConfiguration);\n\t\t\tAmmo.destroy(ammoRayStart);\n\t\t\tAmmo.destroy(ammoRayEnd);\n\t\t\tthis.dynamicsWorld = null;\n\t\t\tthis.solver = null;\n\t\t\tthis.overlappingPairCache = null;\n\t\t\tthis.dispatcher = null;\n\t\t\tthis.collisionConfiguration = null;\n\t\t\tammoRayStart = null;\n\t\t\tammoRayEnd = null;\n\t\t\tRigidBodyComponent.onAppDestroy();\n\t\t}\n\t}\n}\nRigidBodyComponentSystem.EVENT_CONTACT = 'contact';\nComponent._buildAccessors(RigidBodyComponent.prototype, _schema);\n\nexport { ContactPoint, ContactResult, RaycastResult, RigidBodyComponentSystem, SingleContactResult };\n","import { Mat4 } from '../../../core/math/mat4.js';\nimport { Vec2 } from '../../../core/math/vec2.js';\nimport { Entity } from '../../entity.js';\nimport { SCALEMODE_NONE, SCALEMODE_BLEND } from './constants.js';\nimport { Component } from '../component.js';\n\nconst _transform = new Mat4();\nclass ScreenComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._resolution = new Vec2(640, 320);\n\t\tthis._referenceResolution = new Vec2(640, 320);\n\t\tthis._scaleMode = SCALEMODE_NONE;\n\t\tthis.scale = 1;\n\t\tthis._scaleBlend = 0.5;\n\t\tthis._priority = 0;\n\t\tthis._screenSpace = false;\n\t\tthis.cull = this._screenSpace;\n\t\tthis._screenMatrix = new Mat4();\n\t\tthis._elements = new Set();\n\t\tsystem.app.graphicsDevice.on('resizecanvas', this._onResize, this);\n\t}\n\tsyncDrawOrder() {\n\t\tthis.system.queueDrawOrderSync(this.entity.getGuid(), this._processDrawOrderSync, this);\n\t}\n\t_recurseDrawOrderSync(e, i) {\n\t\tif (!(e instanceof Entity)) {\n\t\t\treturn i;\n\t\t}\n\t\tif (e.element) {\n\t\t\tconst prevDrawOrder = e.element.drawOrder;\n\t\t\te.element.drawOrder = i++;\n\t\t\tif (e.element._batchGroupId >= 0 && prevDrawOrder !== e.element.drawOrder) {\n\t\t\t\tvar _this$system$app$batc;\n\t\t\t\t(_this$system$app$batc = this.system.app.batcher) == null || _this$system$app$batc.markGroupDirty(e.element._batchGroupId);\n\t\t\t}\n\t\t}\n\t\tif (e.particlesystem) {\n\t\t\te.particlesystem.drawOrder = i++;\n\t\t}\n\t\tconst children = e.children;\n\t\tfor (let j = 0; j < children.length; j++) {\n\t\t\ti = this._recurseDrawOrderSync(children[j], i);\n\t\t}\n\t\treturn i;\n\t}\n\t_processDrawOrderSync() {\n\t\tconst i = 1;\n\t\tthis._recurseDrawOrderSync(this.entity, i);\n\t\tthis.fire('syncdraworder');\n\t}\n\t_calcProjectionMatrix() {\n\t\tconst w = this._resolution.x / this.scale;\n\t\tconst h = this._resolution.y / this.scale;\n\t\tconst left = 0;\n\t\tconst right = w;\n\t\tconst bottom = -h;\n\t\tconst top = 0;\n\t\tconst near = 1;\n\t\tconst far = -1;\n\t\tthis._screenMatrix.setOrtho(left, right, bottom, top, near, far);\n\t\tif (!this._screenSpace) {\n\t\t\t_transform.setScale(0.5 * w, 0.5 * h, 1);\n\t\t\tthis._screenMatrix.mul2(_transform, this._screenMatrix);\n\t\t}\n\t}\n\t_updateScale() {\n\t\tthis.scale = this._calcScale(this._resolution, this.referenceResolution);\n\t}\n\t_calcScale(resolution, referenceResolution) {\n\t\tconst lx = Math.log2((resolution.x || 1) / referenceResolution.x);\n\t\tconst ly = Math.log2((resolution.y || 1) / referenceResolution.y);\n\t\treturn Math.pow(2, lx * (1 - this._scaleBlend) + ly * this._scaleBlend);\n\t}\n\t_onResize(width, height) {\n\t\tif (this._screenSpace) {\n\t\t\tthis._resolution.set(width, height);\n\t\t\tthis.resolution = this._resolution;\n\t\t}\n\t}\n\t_bindElement(element) {\n\t\tthis._elements.add(element);\n\t}\n\t_unbindElement(element) {\n\t\tthis._elements.delete(element);\n\t}\n\tonRemove() {\n\t\tthis.system.app.graphicsDevice.off('resizecanvas', this._onResize, this);\n\t\tthis.fire('remove');\n\t\tthis._elements.forEach(element => element._onScreenRemove());\n\t\tthis._elements.clear();\n\t\tthis.off();\n\t}\n\tset resolution(value) {\n\t\tif (!this._screenSpace) {\n\t\t\tthis._resolution.set(value.x, value.y);\n\t\t} else {\n\t\t\tthis._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);\n\t\t}\n\t\tthis._updateScale();\n\t\tthis._calcProjectionMatrix();\n\t\tif (!this.entity._dirtyLocal) {\n\t\t\tthis.entity._dirtifyLocal();\n\t\t}\n\t\tthis.fire('set:resolution', this._resolution);\n\t\tthis._elements.forEach(element => element._onScreenResize(this._resolution));\n\t}\n\tget resolution() {\n\t\treturn this._resolution;\n\t}\n\tset referenceResolution(value) {\n\t\tthis._referenceResolution.set(value.x, value.y);\n\t\tthis._updateScale();\n\t\tthis._calcProjectionMatrix();\n\t\tif (!this.entity._dirtyLocal) {\n\t\t\tthis.entity._dirtifyLocal();\n\t\t}\n\t\tthis.fire('set:referenceresolution', this._resolution);\n\t\tthis._elements.forEach(element => element._onScreenResize(this._resolution));\n\t}\n\tget referenceResolution() {\n\t\tif (this._scaleMode === SCALEMODE_NONE) {\n\t\t\treturn this._resolution;\n\t\t}\n\t\treturn this._referenceResolution;\n\t}\n\tset screenSpace(value) {\n\t\tthis._screenSpace = value;\n\t\tif (this._screenSpace) {\n\t\t\tthis._resolution.set(this.system.app.graphicsDevice.width, this.system.app.graphicsDevice.height);\n\t\t}\n\t\tthis.resolution = this._resolution;\n\t\tif (!this.entity._dirtyLocal) {\n\t\t\tthis.entity._dirtifyLocal();\n\t\t}\n\t\tthis.fire('set:screenspace', this._screenSpace);\n\t\tthis._elements.forEach(element => element._onScreenSpaceChange());\n\t}\n\tget screenSpace() {\n\t\treturn this._screenSpace;\n\t}\n\tset scaleMode(value) {\n\t\tif (value !== SCALEMODE_NONE && value !== SCALEMODE_BLEND) {\n\t\t\tvalue = SCALEMODE_NONE;\n\t\t}\n\t\tif (!this._screenSpace && value !== SCALEMODE_NONE) {\n\t\t\tvalue = SCALEMODE_NONE;\n\t\t}\n\t\tthis._scaleMode = value;\n\t\tthis.resolution = this._resolution;\n\t\tthis.fire('set:scalemode', this._scaleMode);\n\t}\n\tget scaleMode() {\n\t\treturn this._scaleMode;\n\t}\n\tset scaleBlend(value) {\n\t\tthis._scaleBlend = value;\n\t\tthis._updateScale();\n\t\tthis._calcProjectionMatrix();\n\t\tif (!this.entity._dirtyLocal) {\n\t\t\tthis.entity._dirtifyLocal();\n\t\t}\n\t\tthis.fire('set:scaleblend', this._scaleBlend);\n\t\tthis._elements.forEach(element => element._onScreenResize(this._resolution));\n\t}\n\tget scaleBlend() {\n\t\treturn this._scaleBlend;\n\t}\n\tset priority(value) {\n\t\tif (value > 0xFF) {\n\t\t\tvalue = 0xFF;\n\t\t}\n\t\tif (this._priority === value) {\n\t\t\treturn;\n\t\t}\n\t\tthis._priority = value;\n\t\tthis.syncDrawOrder();\n\t}\n\tget priority() {\n\t\treturn this._priority;\n\t}\n}\n\nexport { ScreenComponent };\n","const SCALEMODE_NONE = 'none';\nconst SCALEMODE_BLEND = 'blend';\n\nexport { SCALEMODE_BLEND, SCALEMODE_NONE };\n","class ScreenComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n}\n\nexport { ScreenComponentData };\n","import { IndexedList } from '../../../core/indexed-list.js';\nimport { Vec2 } from '../../../core/math/vec2.js';\nimport { Component } from '../component.js';\nimport { ComponentSystem } from '../system.js';\nimport { ScreenComponent } from './component.js';\nimport { ScreenComponentData } from './data.js';\n\nconst _schema = ['enabled'];\nclass ScreenComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'screen';\n\t\tthis.ComponentType = ScreenComponent;\n\t\tthis.DataType = ScreenComponentData;\n\t\tthis.schema = _schema;\n\t\tthis.windowResolution = new Vec2();\n\t\tthis._drawOrderSyncQueue = new IndexedList();\n\t\tthis.app.graphicsDevice.on('resizecanvas', this._onResize, this);\n\t\tthis.app.systems.on('update', this._onUpdate, this);\n\t\tthis.on('beforeremove', this.onRemoveComponent, this);\n\t}\n\tinitializeComponentData(component, data, properties) {\n\t\tif (data.priority !== undefined) component.priority = data.priority;\n\t\tif (data.screenSpace !== undefined) component.screenSpace = data.screenSpace;\n\t\tcomponent.cull = component.screenSpace;\n\t\tif (data.scaleMode !== undefined) component.scaleMode = data.scaleMode;\n\t\tif (data.scaleBlend !== undefined) component.scaleBlend = data.scaleBlend;\n\t\tif (data.resolution !== undefined) {\n\t\t\tif (data.resolution instanceof Vec2) {\n\t\t\t\tcomponent._resolution.copy(data.resolution);\n\t\t\t} else {\n\t\t\t\tcomponent._resolution.set(data.resolution[0], data.resolution[1]);\n\t\t\t}\n\t\t\tcomponent.resolution = component._resolution;\n\t\t}\n\t\tif (data.referenceResolution !== undefined) {\n\t\t\tif (data.referenceResolution instanceof Vec2) {\n\t\t\t\tcomponent._referenceResolution.copy(data.referenceResolution);\n\t\t\t} else {\n\t\t\t\tcomponent._referenceResolution.set(data.referenceResolution[0], data.referenceResolution[1]);\n\t\t\t}\n\t\t\tcomponent.referenceResolution = component._referenceResolution;\n\t\t}\n\t\tcomponent.syncDrawOrder();\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.graphicsDevice.off('resizecanvas', this._onResize, this);\n\t\tthis.app.systems.off('update', this._onUpdate, this);\n\t}\n\t_onUpdate(dt) {\n\t\tconst components = this.store;\n\t\tfor (const id in components) {\n\t\t\tif (components[id].entity.screen.update) components[id].entity.screen.update(dt);\n\t\t}\n\t}\n\t_onResize(width, height) {\n\t\tthis.windowResolution.x = width;\n\t\tthis.windowResolution.y = height;\n\t}\n\tcloneComponent(entity, clone) {\n\t\tconst screen = entity.screen;\n\t\treturn this.addComponent(clone, {\n\t\t\tenabled: screen.enabled,\n\t\t\tscreenSpace: screen.screenSpace,\n\t\t\tscaleMode: screen.scaleMode,\n\t\t\tresolution: screen.resolution.clone(),\n\t\t\treferenceResolution: screen.referenceResolution.clone()\n\t\t});\n\t}\n\tonRemoveComponent(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\tprocessDrawOrderSyncQueue() {\n\t\tconst list = this._drawOrderSyncQueue.list();\n\t\tfor (let i = 0; i < list.length; i++) {\n\t\t\tconst item = list[i];\n\t\t\titem.callback.call(item.scope);\n\t\t}\n\t\tthis._drawOrderSyncQueue.clear();\n\t}\n\tqueueDrawOrderSync(id, fn, scope) {\n\t\tif (!this._drawOrderSyncQueue.list().length) {\n\t\t\tthis.app.once('prerender', this.processDrawOrderSyncQueue, this);\n\t\t}\n\t\tif (!this._drawOrderSyncQueue.has(id)) {\n\t\t\tthis._drawOrderSyncQueue.push(id, {\n\t\t\t\tcallback: fn,\n\t\t\t\tscope: scope\n\t\t\t});\n\t\t}\n\t}\n}\nComponent._buildAccessors(ScreenComponent.prototype, _schema);\n\nexport { ScreenComponentSystem };\n","import { path } from '../../../core/path.js';\nimport { Component } from '../component.js';\n\nclass ScriptLegacyComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis.on('set_scripts', this.onSetScripts, this);\n\t}\n\tsend(name, functionName) {\n\t\tconst args = Array.prototype.slice.call(arguments, 2);\n\t\tconst instances = this.entity.script.instances;\n\t\tlet fn;\n\t\tif (instances && instances[name]) {\n\t\t\tfn = instances[name].instance[functionName];\n\t\t\tif (fn) {\n\t\t\t\treturn fn.apply(instances[name].instance, args);\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\tonEnable() {\n\t\tif (this.data.areScriptsLoaded && !this.system.preloading) {\n\t\t\tif (!this.data.initialized) {\n\t\t\t\tthis.system._initializeScriptComponent(this);\n\t\t\t} else {\n\t\t\t\tthis.system._enableScriptComponent(this);\n\t\t\t}\n\t\t\tif (!this.data.postInitialized) {\n\t\t\t\tthis.system._postInitializeScriptComponent(this);\n\t\t\t}\n\t\t}\n\t}\n\tonDisable() {\n\t\tthis.system._disableScriptComponent(this);\n\t}\n\tonSetScripts(name, oldValue, newValue) {\n\t\tif (!this.system._inTools || this.runInTools) {\n\t\t\tif (this._updateScriptAttributes(oldValue, newValue)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.enabled) {\n\t\t\t\tthis.system._disableScriptComponent(this);\n\t\t\t}\n\t\t\tthis.system._destroyScriptComponent(this);\n\t\t\tthis.data.areScriptsLoaded = false;\n\t\t\tconst scripts = newValue;\n\t\t\tconst urls = scripts.map(s => {\n\t\t\t\treturn s.url;\n\t\t\t});\n\t\t\tif (this._loadFromCache(urls)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._loadScripts(urls);\n\t\t}\n\t}\n\t_updateScriptAttributes(oldValue, newValue) {\n\t\tlet onlyUpdateAttributes = true;\n\t\tif (oldValue.length !== newValue.length) {\n\t\t\tonlyUpdateAttributes = false;\n\t\t} else {\n\t\t\tfor (let i = 0, len = newValue.length; i < len; i++) {\n\t\t\t\tif (oldValue[i].url !== newValue[i].url) {\n\t\t\t\t\tonlyUpdateAttributes = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (onlyUpdateAttributes) {\n\t\t\tfor (const key in this.instances) {\n\t\t\t\tif (this.instances.hasOwnProperty(key)) {\n\t\t\t\t\tthis.system._updateAccessors(this.entity, this.instances[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn onlyUpdateAttributes;\n\t}\n\t_loadFromCache(urls) {\n\t\tconst cached = [];\n\t\tconst prefix = this.system.app._scriptPrefix || '';\n\t\tconst regex = /^https?:\\/\\//i;\n\t\tfor (let i = 0, len = urls.length; i < len; i++) {\n\t\t\tlet url = urls[i];\n\t\t\tif (!regex.test(url)) {\n\t\t\t\turl = path.join(prefix, url);\n\t\t\t}\n\t\t\tconst type = this.system.app.loader.getFromCache(url, 'script');\n\t\t\tif (!type) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcached.push(type);\n\t\t}\n\t\tfor (let i = 0, len = cached.length; i < len; i++) {\n\t\t\tconst ScriptType = cached[i];\n\t\t\tif (ScriptType === true) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ScriptType && this.entity.script) {\n\t\t\t\tif (!this.entity.script.instances[ScriptType._pcScriptName]) {\n\t\t\t\t\tconst instance = new ScriptType(this.entity);\n\t\t\t\t\tthis.system._preRegisterInstance(this.entity, urls[i], ScriptType._pcScriptName, instance);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.data) {\n\t\t\tthis.data.areScriptsLoaded = true;\n\t\t}\n\t\tif (!this.system.preloading) {\n\t\t\tthis.system.onInitialize(this.entity);\n\t\t\tthis.system.onPostInitialize(this.entity);\n\t\t}\n\t\treturn true;\n\t}\n\t_loadScripts(urls) {\n\t\tlet count = urls.length;\n\t\tconst prefix = this.system.app._scriptPrefix || '';\n\t\turls.forEach(url => {\n\t\t\tlet _url = null;\n\t\t\tlet _unprefixed = null;\n\t\t\tif (url.toLowerCase().startsWith('http://') || url.toLowerCase().startsWith('https://')) {\n\t\t\t\t_unprefixed = url;\n\t\t\t\t_url = url;\n\t\t\t} else {\n\t\t\t\t_unprefixed = url;\n\t\t\t\t_url = path.join(prefix, url);\n\t\t\t}\n\t\t\tthis.system.app.loader.load(_url, 'script', (err, ScriptType) => {\n\t\t\t\tcount--;\n\t\t\t\tif (!err) {\n\t\t\t\t\tif (ScriptType && this.entity.script) {\n\t\t\t\t\t\tif (!this.entity.script.instances[ScriptType._pcScriptName]) {\n\t\t\t\t\t\t\tconst instance = new ScriptType(this.entity);\n\t\t\t\t\t\t\tthis.system._preRegisterInstance(this.entity, _unprefixed, ScriptType._pcScriptName, instance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(err);\n\t\t\t\t}\n\t\t\t\tif (count === 0) {\n\t\t\t\t\tthis.data.areScriptsLoaded = true;\n\t\t\t\t\tif (!this.system.preloading) {\n\t\t\t\t\t\tthis.system.onInitialize(this.entity);\n\t\t\t\t\t\tthis.system.onPostInitialize(this.entity);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport { ScriptLegacyComponent };\n","class ScriptLegacyComponentData {\n\tconstructor() {\n\t\tthis.scripts = [];\n\t\tthis.enabled = true;\n\t\tthis.instances = {};\n\t\tthis._instances = {};\n\t\tthis.runInTools = false;\n\t\tthis.attributes = {};\n\t\tthis.initialized = false;\n\t\tthis.postInitialized = false;\n\t\tthis.areScriptsLoaded = false;\n\t}\n}\n\nexport { ScriptLegacyComponentData };\n","import { extend } from '../../../core/core.js';\nimport { events } from '../../../core/events.js';\nimport { Color } from '../../../core/math/color.js';\nimport { Curve } from '../../../core/math/curve.js';\nimport { CurveSet } from '../../../core/math/curve-set.js';\nimport { Vec2 } from '../../../core/math/vec2.js';\nimport { Vec3 } from '../../../core/math/vec3.js';\nimport { Vec4 } from '../../../core/math/vec4.js';\nimport { Entity } from '../../entity.js';\nimport { Component } from '../component.js';\nimport { ComponentSystem } from '../system.js';\nimport { ScriptLegacyComponent } from './component.js';\nimport { ScriptLegacyComponentData } from './data.js';\n\nconst _schema = ['enabled', 'scripts', 'instances', 'runInTools'];\nconst INITIALIZE = 'initialize';\nconst POST_INITIALIZE = 'postInitialize';\nconst UPDATE = 'update';\nconst POST_UPDATE = 'postUpdate';\nconst FIXED_UPDATE = 'fixedUpdate';\nconst TOOLS_UPDATE = 'toolsUpdate';\nconst ON_ENABLE = 'onEnable';\nconst ON_DISABLE = 'onDisable';\nclass ScriptLegacyComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'script';\n\t\tthis.ComponentType = ScriptLegacyComponent;\n\t\tthis.DataType = ScriptLegacyComponentData;\n\t\tthis.schema = _schema;\n\t\tthis.preloading = false;\n\t\tthis.instancesWithUpdate = [];\n\t\tthis.instancesWithFixedUpdate = [];\n\t\tthis.instancesWithPostUpdate = [];\n\t\tthis.instancesWithToolsUpdate = [];\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t\tthis.app.systems.on(INITIALIZE, this.onInitialize, this);\n\t\tthis.app.systems.on(POST_INITIALIZE, this.onPostInitialize, this);\n\t\tthis.app.systems.on(UPDATE, this.onUpdate, this);\n\t\tthis.app.systems.on(FIXED_UPDATE, this.onFixedUpdate, this);\n\t\tthis.app.systems.on(POST_UPDATE, this.onPostUpdate, this);\n\t\tthis.app.systems.on(TOOLS_UPDATE, this.onToolsUpdate, this);\n\t}\n\tinitializeComponentData(component, data, properties) {\n\t\tproperties = ['runInTools', 'enabled', 'scripts'];\n\t\tif (data.scripts && data.scripts.length) {\n\t\t\tdata.scripts.forEach(script => {\n\t\t\t\tif (script.attributes && Array.isArray(script.attributes)) {\n\t\t\t\t\tconst dict = {};\n\t\t\t\t\tfor (let i = 0; i < script.attributes.length; i++) {\n\t\t\t\t\t\tdict[script.attributes[i].name] = script.attributes[i];\n\t\t\t\t\t}\n\t\t\t\t\tscript.attributes = dict;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\tcloneComponent(entity, clone) {\n\t\tconst src = this.store[entity.getGuid()];\n\t\tconst data = {\n\t\t\trunInTools: src.data.runInTools,\n\t\t\tscripts: [],\n\t\t\tenabled: src.data.enabled\n\t\t};\n\t\tconst scripts = src.data.scripts;\n\t\tfor (let i = 0, len = scripts.length; i < len; i++) {\n\t\t\tconst attributes = scripts[i].attributes;\n\t\t\tif (attributes) {\n\t\t\t\tdelete scripts[i].attributes;\n\t\t\t}\n\t\t\tdata.scripts.push(extend({}, scripts[i]));\n\t\t\tif (attributes) {\n\t\t\t\tdata.scripts[i].attributes = this._cloneAttributes(attributes);\n\t\t\t\tscripts[i].attributes = attributes;\n\t\t\t}\n\t\t}\n\t\treturn this.addComponent(clone, data);\n\t}\n\tonBeforeRemove(entity, component) {\n\t\tif (component.enabled) {\n\t\t\tthis._disableScriptComponent(component);\n\t\t}\n\t\tthis._destroyScriptComponent(component);\n\t}\n\tonInitialize(root) {\n\t\tthis._registerInstances(root);\n\t\tif (root.enabled) {\n\t\t\tif (root.script && root.script.enabled) {\n\t\t\t\tthis._initializeScriptComponent(root.script);\n\t\t\t}\n\t\t\tconst children = root._children;\n\t\t\tfor (let i = 0, len = children.length; i < len; i++) {\n\t\t\t\tif (children[i] instanceof Entity) {\n\t\t\t\t\tthis.onInitialize(children[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tonPostInitialize(root) {\n\t\tif (root.enabled) {\n\t\t\tif (root.script && root.script.enabled) {\n\t\t\t\tthis._postInitializeScriptComponent(root.script);\n\t\t\t}\n\t\t\tconst children = root._children;\n\t\t\tfor (let i = 0, len = children.length; i < len; i++) {\n\t\t\t\tif (children[i] instanceof Entity) {\n\t\t\t\t\tthis.onPostInitialize(children[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t_callInstancesMethod(script, method) {\n\t\tconst instances = script.data.instances;\n\t\tfor (const name in instances) {\n\t\t\tif (instances.hasOwnProperty(name)) {\n\t\t\t\tconst instance = instances[name].instance;\n\t\t\t\tif (instance[method]) {\n\t\t\t\t\tinstance[method]();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t_initializeScriptComponent(script) {\n\t\tthis._callInstancesMethod(script, INITIALIZE);\n\t\tscript.data.initialized = true;\n\t\tif (script.enabled && script.entity.enabled) {\n\t\t\tthis._enableScriptComponent(script);\n\t\t}\n\t}\n\t_enableScriptComponent(script) {\n\t\tthis._callInstancesMethod(script, ON_ENABLE);\n\t}\n\t_disableScriptComponent(script) {\n\t\tthis._callInstancesMethod(script, ON_DISABLE);\n\t}\n\t_destroyScriptComponent(script) {\n\t\tconst instances = script.data.instances;\n\t\tfor (const name in instances) {\n\t\t\tif (instances.hasOwnProperty(name)) {\n\t\t\t\tconst instance = instances[name].instance;\n\t\t\t\tif (instance.destroy) {\n\t\t\t\t\tinstance.destroy();\n\t\t\t\t}\n\t\t\t\tif (instance.update) {\n\t\t\t\t\tconst index = this.instancesWithUpdate.indexOf(instance);\n\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\tthis.instancesWithUpdate.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (instance.fixedUpdate) {\n\t\t\t\t\tconst index = this.instancesWithFixedUpdate.indexOf(instance);\n\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\tthis.instancesWithFixedUpdate.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (instance.postUpdate) {\n\t\t\t\t\tconst index = this.instancesWithPostUpdate.indexOf(instance);\n\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\tthis.instancesWithPostUpdate.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (instance.toolsUpdate) {\n\t\t\t\t\tconst index = this.instancesWithToolsUpdate.indexOf(instance);\n\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\tthis.instancesWithToolsUpdate.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (script.instances[name].instance === script[name]) {\n\t\t\t\t\tdelete script[name];\n\t\t\t\t}\n\t\t\t\tdelete script.instances[name];\n\t\t\t}\n\t\t}\n\t}\n\t_postInitializeScriptComponent(script) {\n\t\tthis._callInstancesMethod(script, POST_INITIALIZE);\n\t\tscript.data.postInitialized = true;\n\t}\n\t_updateInstances(method, updateList, dt) {\n\t\tfor (let i = 0, len = updateList.length; i < len; i++) {\n\t\t\tconst item = updateList[i];\n\t\t\tif (item && item.entity && item.entity.enabled && item.entity.script.enabled) {\n\t\t\t\titem[method](dt);\n\t\t\t}\n\t\t}\n\t}\n\tonUpdate(dt) {\n\t\tthis._updateInstances(UPDATE, this.instancesWithUpdate, dt);\n\t}\n\tonFixedUpdate(dt) {\n\t\tthis._updateInstances(FIXED_UPDATE, this.instancesWithFixedUpdate, dt);\n\t}\n\tonPostUpdate(dt) {\n\t\tthis._updateInstances(POST_UPDATE, this.instancesWithPostUpdate, dt);\n\t}\n\tonToolsUpdate(dt) {\n\t\tthis._updateInstances(TOOLS_UPDATE, this.instancesWithToolsUpdate, dt);\n\t}\n\tbroadcast(name, functionName) {\n\t\tconst args = Array.prototype.slice.call(arguments, 2);\n\t\tconst dataStore = this.store;\n\t\tfor (const id in dataStore) {\n\t\t\tif (dataStore.hasOwnProperty(id)) {\n\t\t\t\tconst data = dataStore[id].data;\n\t\t\t\tif (data.instances[name]) {\n\t\t\t\t\tconst fn = data.instances[name].instance[functionName];\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\tfn.apply(data.instances[name].instance, args);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t_preRegisterInstance(entity, url, name, instance) {\n\t\tif (entity.script) {\n\t\t\tentity.script.data._instances = entity.script.data._instances || {};\n\t\t\tif (entity.script.data._instances[name]) {\n\t\t\t\tthrow Error(`Script name collision '${name}'. Scripts from '${url}' and '${entity.script.data._instances[name].url}' {${entity.getGuid()}}`);\n\t\t\t}\n\t\t\tentity.script.data._instances[name] = {\n\t\t\t\turl: url,\n\t\t\t\tname: name,\n\t\t\t\tinstance: instance\n\t\t\t};\n\t\t}\n\t}\n\t_registerInstances(entity) {\n\t\tif (entity.script) {\n\t\t\tif (entity.script.data._instances) {\n\t\t\t\tentity.script.instances = entity.script.data._instances;\n\t\t\t\tfor (const instanceName in entity.script.instances) {\n\t\t\t\t\tconst preRegistered = entity.script.instances[instanceName];\n\t\t\t\t\tconst instance = preRegistered.instance;\n\t\t\t\t\tevents.attach(instance);\n\t\t\t\t\tif (instance.update) {\n\t\t\t\t\t\tthis.instancesWithUpdate.push(instance);\n\t\t\t\t\t}\n\t\t\t\t\tif (instance.fixedUpdate) {\n\t\t\t\t\t\tthis.instancesWithFixedUpdate.push(instance);\n\t\t\t\t\t}\n\t\t\t\t\tif (instance.postUpdate) {\n\t\t\t\t\t\tthis.instancesWithPostUpdate.push(instance);\n\t\t\t\t\t}\n\t\t\t\t\tif (instance.toolsUpdate) {\n\t\t\t\t\t\tthis.instancesWithToolsUpdate.push(instance);\n\t\t\t\t\t}\n\t\t\t\t\tif (entity.script.scripts) {\n\t\t\t\t\t\tthis._createAccessors(entity, preRegistered);\n\t\t\t\t\t}\n\t\t\t\t\tif (entity.script[instanceName]) {\n\t\t\t\t\t\tthrow Error(`Script with name '${instanceName}' is already attached to Script Component`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tentity.script[instanceName] = instance;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdelete entity.script.data._instances;\n\t\t\t}\n\t\t}\n\t\tconst children = entity._children;\n\t\tfor (let i = 0, len = children.length; i < len; i++) {\n\t\t\tif (children[i] instanceof Entity) {\n\t\t\t\tthis._registerInstances(children[i]);\n\t\t\t}\n\t\t}\n\t}\n\t_cloneAttributes(attributes) {\n\t\tconst result = {};\n\t\tfor (const key in attributes) {\n\t\t\tif (!attributes.hasOwnProperty(key)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (attributes[key].type !== 'entity') {\n\t\t\t\tresult[key] = extend({}, attributes[key]);\n\t\t\t} else {\n\t\t\t\tconst val = attributes[key].value;\n\t\t\t\tdelete attributes[key].value;\n\t\t\t\tresult[key] = extend({}, attributes[key]);\n\t\t\t\tresult[key].value = val;\n\t\t\t\tattributes[key].value = val;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\t_createAccessors(entity, instance) {\n\t\tconst len = entity.script.scripts.length;\n\t\tconst url = instance.url;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst script = entity.script.scripts[i];\n\t\t\tif (script.url === url) {\n\t\t\t\tconst attributes = script.attributes;\n\t\t\t\tif (script.name && attributes) {\n\t\t\t\t\tfor (const key in attributes) {\n\t\t\t\t\t\tif (attributes.hasOwnProperty(key)) {\n\t\t\t\t\t\t\tthis._createAccessor(attributes[key], instance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tentity.script.data.attributes[script.name] = this._cloneAttributes(attributes);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t_createAccessor(attribute, instance) {\n\t\tconst self = this;\n\t\tattribute = {\n\t\t\tname: attribute.name,\n\t\t\tvalue: attribute.value,\n\t\t\ttype: attribute.type\n\t\t};\n\t\tthis._convertAttributeValue(attribute);\n\t\tObject.defineProperty(instance.instance, attribute.name, {\n\t\t\tget: function () {\n\t\t\t\treturn attribute.value;\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\tconst oldValue = attribute.value;\n\t\t\t\tattribute.value = value;\n\t\t\t\tself._convertAttributeValue(attribute);\n\t\t\t\tinstance.instance.fire('set', attribute.name, oldValue, attribute.value);\n\t\t\t},\n\t\t\tconfigurable: true\n\t\t});\n\t}\n\t_updateAccessors(entity, instance) {\n\t\tconst len = entity.script.scripts.length;\n\t\tconst url = instance.url;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst scriptComponent = entity.script;\n\t\t\tconst script = scriptComponent.scripts[i];\n\t\t\tif (script.url === url) {\n\t\t\t\tconst name = script.name;\n\t\t\t\tconst attributes = script.attributes;\n\t\t\t\tif (name) {\n\t\t\t\t\tif (attributes) {\n\t\t\t\t\t\tfor (const key in attributes) {\n\t\t\t\t\t\t\tif (attributes.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\tthis._createAccessor(attributes[key], instance);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst previousAttributes = scriptComponent.data.attributes[name];\n\t\t\t\t\tif (previousAttributes) {\n\t\t\t\t\t\tfor (const key in previousAttributes) {\n\t\t\t\t\t\t\tconst oldAttribute = previousAttributes[key];\n\t\t\t\t\t\t\tif (!(key in attributes)) {\n\t\t\t\t\t\t\t\tdelete instance.instance[oldAttribute.name];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (attributes[key].value !== oldAttribute.value) {\n\t\t\t\t\t\t\t\t\tif (instance.instance.onAttributeChanged) {\n\t\t\t\t\t\t\t\t\t\tinstance.instance.onAttributeChanged(oldAttribute.name, oldAttribute.value, attributes[key].value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (attributes) {\n\t\t\t\t\t\tscriptComponent.data.attributes[name] = this._cloneAttributes(attributes);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete scriptComponent.data.attributes[name];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t_convertAttributeValue(attribute) {\n\t\tif (attribute.type === 'rgb' || attribute.type === 'rgba') {\n\t\t\tif (Array.isArray(attribute.value)) {\n\t\t\t\tattribute.value = attribute.value.length === 3 ? new Color(attribute.value[0], attribute.value[1], attribute.value[2]) : new Color(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);\n\t\t\t}\n\t\t} else if (attribute.type === 'vec2') {\n\t\t\tif (Array.isArray(attribute.value)) {\n\t\t\t\tattribute.value = new Vec2(attribute.value[0], attribute.value[1]);\n\t\t\t}\n\t\t} else if (attribute.type === 'vec3' || attribute.type === 'vector') {\n\t\t\tif (Array.isArray(attribute.value)) {\n\t\t\t\tattribute.value = new Vec3(attribute.value[0], attribute.value[1], attribute.value[2]);\n\t\t\t}\n\t\t} else if (attribute.type === 'vec4') {\n\t\t\tif (Array.isArray(attribute.value)) {\n\t\t\t\tattribute.value = new Vec4(attribute.value[0], attribute.value[1], attribute.value[2], attribute.value[3]);\n\t\t\t}\n\t\t} else if (attribute.type === 'entity') {\n\t\t\tif (attribute.value !== null && typeof attribute.value === 'string') {\n\t\t\t\tattribute.value = this.app.root.findByGuid(attribute.value);\n\t\t\t}\n\t\t} else if (attribute.type === 'curve' || attribute.type === 'colorcurve') {\n\t\t\tconst curveType = attribute.value.keys[0] instanceof Array ? CurveSet : Curve;\n\t\t\tattribute.value = new curveType(attribute.value.keys);\n\t\t\tattribute.value.type = attribute.value.type;\n\t\t}\n\t}\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off(INITIALIZE, this.onInitialize, this);\n\t\tthis.app.systems.off(POST_INITIALIZE, this.onPostInitialize, this);\n\t\tthis.app.systems.off(UPDATE, this.onUpdate, this);\n\t\tthis.app.systems.off(FIXED_UPDATE, this.onFixedUpdate, this);\n\t\tthis.app.systems.off(POST_UPDATE, this.onPostUpdate, this);\n\t\tthis.app.systems.off(TOOLS_UPDATE, this.onToolsUpdate, this);\n\t}\n}\nComponent._buildAccessors(ScriptLegacyComponent.prototype, _schema);\n\nexport { ScriptLegacyComponentSystem };\n","import { SortedLoopArray } from '../../../core/sorted-loop-array.js';\nimport { ScriptAttributes, assignAttributesToScript } from '../../script/script-attributes.js';\nimport { SCRIPT_POST_INITIALIZE, SCRIPT_INITIALIZE, SCRIPT_UPDATE, SCRIPT_POST_UPDATE, SCRIPT_SWAP } from '../../script/constants.js';\nimport { Component } from '../component.js';\nimport { Entity } from '../../entity.js';\nimport { ScriptType } from '../../script/script-type.js';\nimport { getScriptName } from '../../script/script.js';\n\nconst toLowerCamelCase = str => str[0].toLowerCase() + str.substring(1);\nclass ScriptComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._attributeDataMap = new Map();\n\t\tthis._scripts = [];\n\t\tthis._updateList = new SortedLoopArray({\n\t\t\tsortBy: '__executionOrder'\n\t\t});\n\t\tthis._postUpdateList = new SortedLoopArray({\n\t\t\tsortBy: '__executionOrder'\n\t\t});\n\t\tthis._scriptsIndex = {};\n\t\tthis._destroyedScripts = [];\n\t\tthis._destroyed = false;\n\t\tthis._scriptsData = null;\n\t\tthis._oldState = true;\n\t\tthis._enabled = true;\n\t\tthis._beingEnabled = false;\n\t\tthis._isLoopingThroughScripts = false;\n\t\tthis._executionOrder = -1;\n\t\tthis.on('set_enabled', this._onSetEnabled, this);\n\t}\n\tset scripts(value) {\n\t\tthis._scriptsData = value;\n\t\tfor (const key in value) {\n\t\t\tif (!value.hasOwnProperty(key)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst script = this._scriptsIndex[key];\n\t\t\tif (script) {\n\t\t\t\tif (typeof value[key].enabled === 'boolean') {\n\t\t\t\t\tscript.once('preInitialize', () => {\n\t\t\t\t\t\tthis.initializeAttributes(script);\n\t\t\t\t\t});\n\t\t\t\t\tscript.enabled = !!value[key].enabled;\n\t\t\t\t}\n\t\t\t\tif (typeof value[key].attributes === 'object') {\n\t\t\t\t\tfor (const attr in value[key].attributes) {\n\t\t\t\t\t\tif (ScriptAttributes.reservedNames.has(attr)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!script.__attributes.hasOwnProperty(attr)) {\n\t\t\t\t\t\t\tconst scriptType = this.system.app.scripts.get(key);\n\t\t\t\t\t\t\tif (scriptType) {\n\t\t\t\t\t\t\t\tscriptType.attributes.add(attr, {});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tscript[attr] = value[key].attributes[attr];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.log(this.order);\n\t\t\t}\n\t\t}\n\t}\n\tget scripts() {\n\t\treturn this._scripts;\n\t}\n\tset enabled(value) {\n\t\tconst oldValue = this._enabled;\n\t\tthis._enabled = value;\n\t\tthis.fire('set', 'enabled', oldValue, value);\n\t}\n\tget enabled() {\n\t\treturn this._enabled;\n\t}\n\tonEnable() {\n\t\tthis._beingEnabled = true;\n\t\tthis._checkState();\n\t\tif (!this.entity._beingEnabled) {\n\t\t\tthis.onPostStateChange();\n\t\t}\n\t\tthis._beingEnabled = false;\n\t}\n\tonDisable() {\n\t\tthis._checkState();\n\t}\n\tonPostStateChange() {\n\t\tconst wasLooping = this._beginLooping();\n\t\tfor (let i = 0, len = this.scripts.length; i < len; i++) {\n\t\t\tconst script = this.scripts[i];\n\t\t\tif (script._initialized && !script._postInitialized && script.enabled) {\n\t\t\t\tscript._postInitialized = true;\n\t\t\t\tif (script.postInitialize) {\n\t\t\t\t\tthis._scriptMethod(script, SCRIPT_POST_INITIALIZE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._endLooping(wasLooping);\n\t}\n\t_beginLooping() {\n\t\tconst looping = this._isLoopingThroughScripts;\n\t\tthis._isLoopingThroughScripts = true;\n\t\treturn looping;\n\t}\n\t_endLooping(wasLoopingBefore) {\n\t\tthis._isLoopingThroughScripts = wasLoopingBefore;\n\t\tif (!this._isLoopingThroughScripts) {\n\t\t\tthis._removeDestroyedScripts();\n\t\t}\n\t}\n\t_onSetEnabled(prop, old, value) {\n\t\tthis._beingEnabled = true;\n\t\tthis._checkState();\n\t\tthis._beingEnabled = false;\n\t}\n\t_checkState() {\n\t\tconst state = this.enabled && this.entity.enabled;\n\t\tif (state === this._oldState) {\n\t\t\treturn;\n\t\t}\n\t\tthis._oldState = state;\n\t\tthis.fire(state ? 'enable' : 'disable');\n\t\tthis.fire('state', state);\n\t\tif (state) {\n\t\t\tthis.system._addComponentToEnabled(this);\n\t\t} else {\n\t\t\tthis.system._removeComponentFromEnabled(this);\n\t\t}\n\t\tconst wasLooping = this._beginLooping();\n\t\tfor (let i = 0, len = this.scripts.length; i < len; i++) {\n\t\t\tconst script = this.scripts[i];\n\t\t\tscript.once('preInitialize', () => {\n\t\t\t\tthis.initializeAttributes(script);\n\t\t\t});\n\t\t\tscript.enabled = script._enabled;\n\t\t}\n\t\tthis._endLooping(wasLooping);\n\t}\n\t_onBeforeRemove() {\n\t\tthis.fire('remove');\n\t\tconst wasLooping = this._beginLooping();\n\t\tfor (let i = 0; i < this.scripts.length; i++) {\n\t\t\tconst script = this.scripts[i];\n\t\t\tif (!script) continue;\n\t\t\tthis.destroy(script.__scriptType.__name);\n\t\t}\n\t\tthis._endLooping(wasLooping);\n\t}\n\t_removeDestroyedScripts() {\n\t\tconst len = this._destroyedScripts.length;\n\t\tif (!len) return;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst script = this._destroyedScripts[i];\n\t\t\tthis._removeScriptInstance(script);\n\t\t}\n\t\tthis._destroyedScripts.length = 0;\n\t\tthis._resetExecutionOrder(0, this._scripts.length);\n\t}\n\t_onInitializeAttributes() {\n\t\tfor (let i = 0, len = this.scripts.length; i < len; i++) {\n\t\t\tconst script = this.scripts[i];\n\t\t\tthis.initializeAttributes(script);\n\t\t}\n\t}\n\tinitializeAttributes(script) {\n\t\tif (script instanceof ScriptType) {\n\t\t\tscript.__initializeAttributes();\n\t\t} else {\n\t\t\tvar _this$system$app$scri;\n\t\t\tconst name = script.__scriptType.__name;\n\t\t\tconst data = this._attributeDataMap.get(name);\n\t\t\tif (!data) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst schema = (_this$system$app$scri = this.system.app.scripts) == null ? void 0 : _this$system$app$scri.getSchema(name);\n\t\t\tassignAttributesToScript(this.system.app, schema.attributes, data, script);\n\t\t}\n\t}\n\t_scriptMethod(script, method, arg) {\n\t\tscript[method](arg);\n\t}\n\t_onInitialize() {\n\t\tconst scripts = this._scripts;\n\t\tconst wasLooping = this._beginLooping();\n\t\tfor (let i = 0, len = scripts.length; i < len; i++) {\n\t\t\tconst script = scripts[i];\n\t\t\tif (!script._initialized && script.enabled) {\n\t\t\t\tscript._initialized = true;\n\t\t\t\tif (script.initialize) {\n\t\t\t\t\tthis._scriptMethod(script, SCRIPT_INITIALIZE);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._endLooping(wasLooping);\n\t}\n\t_onPostInitialize() {\n\t\tthis.onPostStateChange();\n\t}\n\t_onUpdate(dt) {\n\t\tconst list = this._updateList;\n\t\tif (!list.length) return;\n\t\tconst wasLooping = this._beginLooping();\n\t\tfor (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {\n\t\t\tconst script = list.items[list.loopIndex];\n\t\t\tif (script.enabled) {\n\t\t\t\tthis._scriptMethod(script, SCRIPT_UPDATE, dt);\n\t\t\t}\n\t\t}\n\t\tthis._endLooping(wasLooping);\n\t}\n\t_onPostUpdate(dt) {\n\t\tconst list = this._postUpdateList;\n\t\tif (!list.length) return;\n\t\tconst wasLooping = this._beginLooping();\n\t\tfor (list.loopIndex = 0; list.loopIndex < list.length; list.loopIndex++) {\n\t\t\tconst script = list.items[list.loopIndex];\n\t\t\tif (script.enabled) {\n\t\t\t\tthis._scriptMethod(script, SCRIPT_POST_UPDATE, dt);\n\t\t\t}\n\t\t}\n\t\tthis._endLooping(wasLooping);\n\t}\n\t_insertScriptInstance(scriptInstance, index, scriptsLength) {\n\t\tif (index === -1) {\n\t\t\tthis._scripts.push(scriptInstance);\n\t\t\tscriptInstance.__executionOrder = scriptsLength;\n\t\t\tif (scriptInstance.update) {\n\t\t\t\tthis._updateList.append(scriptInstance);\n\t\t\t}\n\t\t\tif (scriptInstance.postUpdate) {\n\t\t\t\tthis._postUpdateList.append(scriptInstance);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._scripts.splice(index, 0, scriptInstance);\n\t\t\tscriptInstance.__executionOrder = index;\n\t\t\tthis._resetExecutionOrder(index + 1, scriptsLength + 1);\n\t\t\tif (scriptInstance.update) {\n\t\t\t\tthis._updateList.insert(scriptInstance);\n\t\t\t}\n\t\t\tif (scriptInstance.postUpdate) {\n\t\t\t\tthis._postUpdateList.insert(scriptInstance);\n\t\t\t}\n\t\t}\n\t}\n\t_removeScriptInstance(scriptInstance) {\n\t\tconst idx = this._scripts.indexOf(scriptInstance);\n\t\tif (idx === -1) return idx;\n\t\tthis._scripts.splice(idx, 1);\n\t\tif (scriptInstance.update) {\n\t\t\tthis._updateList.remove(scriptInstance);\n\t\t}\n\t\tif (scriptInstance.postUpdate) {\n\t\t\tthis._postUpdateList.remove(scriptInstance);\n\t\t}\n\t\treturn idx;\n\t}\n\t_resetExecutionOrder(startIndex, scriptsLength) {\n\t\tfor (let i = startIndex; i < scriptsLength; i++) {\n\t\t\tthis._scripts[i].__executionOrder = i;\n\t\t}\n\t}\n\t_resolveEntityScriptAttribute(attribute, attributeName, oldValue, useGuid, newAttributes, duplicatedIdsMap) {\n\t\tif (attribute.array) {\n\t\t\tconst len = oldValue.length;\n\t\t\tif (!len) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst newGuidArray = oldValue.slice();\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tconst guid = newGuidArray[i] instanceof Entity ? newGuidArray[i].getGuid() : newGuidArray[i];\n\t\t\t\tif (duplicatedIdsMap[guid]) {\n\t\t\t\t\tnewGuidArray[i] = useGuid ? duplicatedIdsMap[guid].getGuid() : duplicatedIdsMap[guid];\n\t\t\t\t}\n\t\t\t}\n\t\t\tnewAttributes[attributeName] = newGuidArray;\n\t\t} else {\n\t\t\tif (oldValue instanceof Entity) {\n\t\t\t\toldValue = oldValue.getGuid();\n\t\t\t} else if (typeof oldValue !== 'string') {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (duplicatedIdsMap[oldValue]) {\n\t\t\t\tnewAttributes[attributeName] = duplicatedIdsMap[oldValue];\n\t\t\t}\n\t\t}\n\t}\n\thas(nameOrType) {\n\t\tif (typeof nameOrType === 'string') {\n\t\t\treturn !!this._scriptsIndex[nameOrType];\n\t\t}\n\t\tif (!nameOrType) return false;\n\t\tconst scriptType = nameOrType;\n\t\tconst scriptName = scriptType.__name;\n\t\tconst scriptData = this._scriptsIndex[scriptName];\n\t\tconst scriptInstance = scriptData && scriptData.instance;\n\t\treturn scriptInstance instanceof scriptType;\n\t}\n\tget(nameOrType) {\n\t\tif (typeof nameOrType === 'string') {\n\t\t\tconst data = this._scriptsIndex[nameOrType];\n\t\t\treturn data ? data.instance : null;\n\t\t}\n\t\tif (!nameOrType) return null;\n\t\tconst scriptType = nameOrType;\n\t\tconst scriptName = scriptType.__name;\n\t\tconst scriptData = this._scriptsIndex[scriptName];\n\t\tconst scriptInstance = scriptData && scriptData.instance;\n\t\treturn scriptInstance instanceof scriptType ? scriptInstance : null;\n\t}\n\tcreate(nameOrType, args = {}) {\n\t\tconst self = this;\n\t\tlet scriptType = nameOrType;\n\t\tlet scriptName = nameOrType;\n\t\tif (typeof scriptType === 'string') {\n\t\t\tscriptType = this.system.app.scripts.get(scriptType);\n\t\t} else if (scriptType) {\n\t\t\tvar _scriptType, _scriptType$__name;\n\t\t\tscriptName = (_scriptType$__name = (_scriptType = scriptType).__name) != null ? _scriptType$__name : _scriptType.__name = toLowerCamelCase(getScriptName(scriptType));\n\t\t}\n\t\tif (scriptType) {\n\t\t\tif (!this._scriptsIndex[scriptName] || !this._scriptsIndex[scriptName].instance) {\n\t\t\t\tconst scriptInstance = new scriptType({\n\t\t\t\t\tapp: this.system.app,\n\t\t\t\t\tentity: this.entity,\n\t\t\t\t\tenabled: args.hasOwnProperty('enabled') ? args.enabled : true,\n\t\t\t\t\tattributes: args.attributes\n\t\t\t\t});\n\t\t\t\tif (!(scriptInstance instanceof ScriptType)) {\n\t\t\t\t\tthis._attributeDataMap.set(scriptName, args.attributes);\n\t\t\t\t}\n\t\t\t\tconst len = this._scripts.length;\n\t\t\t\tlet ind = -1;\n\t\t\t\tif (typeof args.ind === 'number' && args.ind !== -1 && len > args.ind) {\n\t\t\t\t\tind = args.ind;\n\t\t\t\t}\n\t\t\t\tthis._insertScriptInstance(scriptInstance, ind, len);\n\t\t\t\tthis._scriptsIndex[scriptName] = {\n\t\t\t\t\tinstance: scriptInstance,\n\t\t\t\t\tonSwap: function () {\n\t\t\t\t\t\tself.swap(scriptName);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis[scriptName] = scriptInstance;\n\t\t\t\tif (!args.preloading) {\n\t\t\t\t\tthis.initializeAttributes(scriptInstance);\n\t\t\t\t}\n\t\t\t\tthis.fire('create', scriptName, scriptInstance);\n\t\t\t\tthis.fire(`create:${scriptName}`, scriptInstance);\n\t\t\t\tthis.system.app.scripts.on(`swap:${scriptName}`, this._scriptsIndex[scriptName].onSwap);\n\t\t\t\tif (!args.preloading) {\n\t\t\t\t\tif (scriptInstance.enabled && !scriptInstance._initialized) {\n\t\t\t\t\t\tscriptInstance._initialized = true;\n\t\t\t\t\t\tif (scriptInstance.initialize) {\n\t\t\t\t\t\t\tthis._scriptMethod(scriptInstance, SCRIPT_INITIALIZE);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (scriptInstance.enabled && !scriptInstance._postInitialized) {\n\t\t\t\t\t\tscriptInstance._postInitialized = true;\n\t\t\t\t\t\tif (scriptInstance.postInitialize) {\n\t\t\t\t\t\t\tthis._scriptMethod(scriptInstance, SCRIPT_POST_INITIALIZE);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn scriptInstance;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._scriptsIndex[scriptName] = {\n\t\t\t\tawaiting: true,\n\t\t\t\tind: this._scripts.length\n\t\t\t};\n\t\t}\n\t\treturn null;\n\t}\n\tdestroy(nameOrType) {\n\t\tlet scriptName = nameOrType;\n\t\tlet scriptType = nameOrType;\n\t\tif (typeof scriptType === 'string') {\n\t\t\tscriptType = this.system.app.scripts.get(scriptType);\n\t\t} else if (scriptType) {\n\t\t\tscriptName = scriptType.__name;\n\t\t}\n\t\tconst scriptData = this._scriptsIndex[scriptName];\n\t\tdelete this._scriptsIndex[scriptName];\n\t\tif (!scriptData) return false;\n\t\tthis._attributeDataMap.delete(scriptName);\n\t\tconst scriptInstance = scriptData.instance;\n\t\tif (scriptInstance && !scriptInstance._destroyed) {\n\t\t\tscriptInstance.enabled = false;\n\t\t\tscriptInstance._destroyed = true;\n\t\t\tif (!this._isLoopingThroughScripts) {\n\t\t\t\tconst ind = this._removeScriptInstance(scriptInstance);\n\t\t\t\tif (ind >= 0) {\n\t\t\t\t\tthis._resetExecutionOrder(ind, this._scripts.length);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._destroyedScripts.push(scriptInstance);\n\t\t\t}\n\t\t}\n\t\tthis.system.app.scripts.off(`swap:${scriptName}`, scriptData.onSwap);\n\t\tdelete this[scriptName];\n\t\tthis.fire('destroy', scriptName, scriptInstance || null);\n\t\tthis.fire(`destroy:${scriptName}`, scriptInstance || null);\n\t\tif (scriptInstance) {\n\t\t\tscriptInstance.fire('destroy');\n\t\t}\n\t\treturn true;\n\t}\n\tswap(nameOrType) {\n\t\tlet scriptName = nameOrType;\n\t\tlet scriptType = nameOrType;\n\t\tif (typeof scriptType === 'string') {\n\t\t\tscriptType = this.system.app.scripts.get(scriptType);\n\t\t} else if (scriptType) {\n\t\t\tscriptName = scriptType.__name;\n\t\t}\n\t\tconst old = this._scriptsIndex[scriptName];\n\t\tif (!old || !old.instance) return false;\n\t\tconst scriptInstanceOld = old.instance;\n\t\tconst ind = this._scripts.indexOf(scriptInstanceOld);\n\t\tconst scriptInstance = new scriptType({\n\t\t\tapp: this.system.app,\n\t\t\tentity: this.entity,\n\t\t\tenabled: scriptInstanceOld.enabled,\n\t\t\tattributes: scriptInstanceOld.__attributes\n\t\t});\n\t\tif (!scriptInstance.swap) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.initializeAttributes(scriptInstance);\n\t\tthis._scripts[ind] = scriptInstance;\n\t\tthis._scriptsIndex[scriptName].instance = scriptInstance;\n\t\tthis[scriptName] = scriptInstance;\n\t\tscriptInstance.__executionOrder = ind;\n\t\tif (scriptInstanceOld.update) {\n\t\t\tthis._updateList.remove(scriptInstanceOld);\n\t\t}\n\t\tif (scriptInstanceOld.postUpdate) {\n\t\t\tthis._postUpdateList.remove(scriptInstanceOld);\n\t\t}\n\t\tif (scriptInstance.update) {\n\t\t\tthis._updateList.insert(scriptInstance);\n\t\t}\n\t\tif (scriptInstance.postUpdate) {\n\t\t\tthis._postUpdateList.insert(scriptInstance);\n\t\t}\n\t\tthis._scriptMethod(scriptInstance, SCRIPT_SWAP, scriptInstanceOld);\n\t\tthis.fire('swap', scriptName, scriptInstance);\n\t\tthis.fire(`swap:${scriptName}`, scriptInstance);\n\t\treturn true;\n\t}\n\tresolveDuplicatedEntityReferenceProperties(oldScriptComponent, duplicatedIdsMap) {\n\t\tconst newScriptComponent = this.entity.script;\n\t\tfor (const scriptName in oldScriptComponent._scriptsIndex) {\n\t\t\tconst scriptType = this.system.app.scripts.get(scriptName);\n\t\t\tif (!scriptType) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst script = oldScriptComponent._scriptsIndex[scriptName];\n\t\t\tif (!script || !script.instance) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst newAttributesRaw = newScriptComponent[scriptName].__attributesRaw;\n\t\t\tconst newAttributes = newScriptComponent[scriptName].__attributes;\n\t\t\tif (!newAttributesRaw && !newAttributes) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst useGuid = !!newAttributesRaw;\n\t\t\tconst oldAttributes = script.instance.__attributes;\n\t\t\tfor (const attributeName in oldAttributes) {\n\t\t\t\tif (!oldAttributes[attributeName]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst attribute = scriptType.attributes.get(attributeName);\n\t\t\t\tif (!attribute) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (attribute.type === 'entity') {\n\t\t\t\t\tthis._resolveEntityScriptAttribute(attribute, attributeName, oldAttributes[attributeName], useGuid, newAttributesRaw || newAttributes, duplicatedIdsMap);\n\t\t\t\t} else if (attribute.type === 'json' && Array.isArray(attribute.schema)) {\n\t\t\t\t\tconst oldValue = oldAttributes[attributeName];\n\t\t\t\t\tconst newJsonValue = newAttributesRaw ? newAttributesRaw[attributeName] : newAttributes[attributeName];\n\t\t\t\t\tfor (let i = 0; i < attribute.schema.length; i++) {\n\t\t\t\t\t\tconst field = attribute.schema[i];\n\t\t\t\t\t\tif (field.type !== 'entity') {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (attribute.array) {\n\t\t\t\t\t\t\tfor (let j = 0; j < oldValue.length; j++) {\n\t\t\t\t\t\t\t\tthis._resolveEntityScriptAttribute(field, field.name, oldValue[j][field.name], useGuid, newJsonValue[j], duplicatedIdsMap);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._resolveEntityScriptAttribute(field, field.name, oldValue[field.name], useGuid, newJsonValue, duplicatedIdsMap);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmove(nameOrType, ind) {\n\t\tconst len = this._scripts.length;\n\t\tif (ind >= len || ind < 0) {\n\t\t\treturn false;\n\t\t}\n\t\tlet scriptType = nameOrType;\n\t\tlet scriptName = nameOrType;\n\t\tif (typeof scriptName !== 'string') {\n\t\t\tscriptName = nameOrType.__name;\n\t\t} else {\n\t\t\tscriptType = null;\n\t\t}\n\t\tconst scriptData = this._scriptsIndex[scriptName];\n\t\tif (!scriptData || !scriptData.instance) {\n\t\t\treturn false;\n\t\t}\n\t\tconst scriptInstance = scriptData.instance;\n\t\tif (scriptType && !(scriptInstance instanceof scriptType)) {\n\t\t\treturn false;\n\t\t}\n\t\tconst indOld = this._scripts.indexOf(scriptInstance);\n\t\tif (indOld === -1 || indOld === ind) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._scripts.splice(ind, 0, this._scripts.splice(indOld, 1)[0]);\n\t\tthis._resetExecutionOrder(0, len);\n\t\tthis._updateList.sort();\n\t\tthis._postUpdateList.sort();\n\t\tthis.fire('move', scriptName, scriptInstance, ind, indOld);\n\t\tthis.fire(`move:${scriptName}`, scriptInstance, ind, indOld);\n\t\treturn true;\n\t}\n}\nScriptComponent.EVENT_CREATE = 'create';\nScriptComponent.EVENT_DESTROY = 'destroy';\nScriptComponent.EVENT_ENABLE = 'enable';\nScriptComponent.EVENT_DISABLE = 'disable';\nScriptComponent.EVENT_REMOVE = 'remove';\nScriptComponent.EVENT_STATE = 'state';\nScriptComponent.EVENT_MOVE = 'move';\nScriptComponent.EVENT_ERROR = 'error';\n\nexport { ScriptComponent };\n","class ScriptComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n}\n\nexport { ScriptComponentData };\n","import { SortedLoopArray } from '../../../core/sorted-loop-array.js';\nimport { ComponentSystem } from '../system.js';\nimport { ScriptComponent } from './component.js';\nimport { ScriptComponentData } from './data.js';\n\nconst METHOD_INITIALIZE_ATTRIBUTES = '_onInitializeAttributes';\nconst METHOD_INITIALIZE = '_onInitialize';\nconst METHOD_POST_INITIALIZE = '_onPostInitialize';\nconst METHOD_UPDATE = '_onUpdate';\nconst METHOD_POST_UPDATE = '_onPostUpdate';\nlet executionOrderCounter = 0;\nclass ScriptComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'script';\n\t\tthis.ComponentType = ScriptComponent;\n\t\tthis.DataType = ScriptComponentData;\n\t\tthis._components = new SortedLoopArray({\n\t\t\tsortBy: '_executionOrder'\n\t\t});\n\t\tthis._enabledComponents = new SortedLoopArray({\n\t\t\tsortBy: '_executionOrder'\n\t\t});\n\t\tthis.preloading = true;\n\t\tthis.on('beforeremove', this._onBeforeRemove, this);\n\t\tthis.app.systems.on('initialize', this._onInitialize, this);\n\t\tthis.app.systems.on('postInitialize', this._onPostInitialize, this);\n\t\tthis.app.systems.on('update', this._onUpdate, this);\n\t\tthis.app.systems.on('postUpdate', this._onPostUpdate, this);\n\t}\n\tinitializeComponentData(component, data) {\n\t\tcomponent._executionOrder = executionOrderCounter++;\n\t\tthis._components.append(component);\n\t\tif (executionOrderCounter > Number.MAX_SAFE_INTEGER) {\n\t\t\tthis._resetExecutionOrder();\n\t\t}\n\t\tcomponent.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;\n\t\tif (component.enabled && component.entity.enabled) {\n\t\t\tthis._enabledComponents.append(component);\n\t\t}\n\t\tif (data.hasOwnProperty('order') && data.hasOwnProperty('scripts')) {\n\t\t\tcomponent._scriptsData = data.scripts;\n\t\t\tfor (let i = 0; i < data.order.length; i++) {\n\t\t\t\tcomponent.create(data.order[i], {\n\t\t\t\t\tenabled: data.scripts[data.order[i]].enabled,\n\t\t\t\t\tattributes: data.scripts[data.order[i]].attributes,\n\t\t\t\t\tpreloading: this.preloading\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\tcloneComponent(entity, clone) {\n\t\tconst order = [];\n\t\tconst scripts = {};\n\t\tfor (let i = 0; i < entity.script._scripts.length; i++) {\n\t\t\tvar _entity$script$_attri;\n\t\t\tconst scriptInstance = entity.script._scripts[i];\n\t\t\tconst scriptName = scriptInstance.__scriptType.__name;\n\t\t\torder.push(scriptName);\n\t\t\tconst attributes = ((_entity$script$_attri = entity.script._attributeDataMap) == null ? void 0 : _entity$script$_attri.get(scriptName)) || {};\n\t\t\tfor (const key in scriptInstance.__attributes) {\n\t\t\t\tattributes[key] = scriptInstance.__attributes[key];\n\t\t\t}\n\t\t\tscripts[scriptName] = {\n\t\t\t\tenabled: scriptInstance._enabled,\n\t\t\t\tattributes: attributes\n\t\t\t};\n\t\t}\n\t\tfor (const key in entity.script._scriptsIndex) {\n\t\t\tif (key.awaiting) {\n\t\t\t\torder.splice(key.ind, 0, key);\n\t\t\t}\n\t\t}\n\t\tconst data = {\n\t\t\tenabled: entity.script.enabled,\n\t\t\torder: order,\n\t\t\tscripts: scripts\n\t\t};\n\t\treturn this.addComponent(clone, data);\n\t}\n\t_resetExecutionOrder() {\n\t\texecutionOrderCounter = 0;\n\t\tfor (let i = 0, len = this._components.length; i < len; i++) {\n\t\t\tthis._components.items[i]._executionOrder = executionOrderCounter++;\n\t\t}\n\t}\n\t_callComponentMethod(components, name, dt) {\n\t\tfor (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {\n\t\t\tcomponents.items[components.loopIndex][name](dt);\n\t\t}\n\t}\n\t_onInitialize() {\n\t\tthis.preloading = false;\n\t\tthis._callComponentMethod(this._components, METHOD_INITIALIZE_ATTRIBUTES);\n\t\tthis._callComponentMethod(this._enabledComponents, METHOD_INITIALIZE);\n\t}\n\t_onPostInitialize() {\n\t\tthis._callComponentMethod(this._enabledComponents, METHOD_POST_INITIALIZE);\n\t}\n\t_onUpdate(dt) {\n\t\tthis._callComponentMethod(this._enabledComponents, METHOD_UPDATE, dt);\n\t}\n\t_onPostUpdate(dt) {\n\t\tthis._callComponentMethod(this._enabledComponents, METHOD_POST_UPDATE, dt);\n\t}\n\t_addComponentToEnabled(component) {\n\t\tthis._enabledComponents.insert(component);\n\t}\n\t_removeComponentFromEnabled(component) {\n\t\tthis._enabledComponents.remove(component);\n\t}\n\t_onBeforeRemove(entity, component) {\n\t\tconst ind = this._components.items.indexOf(component);\n\t\tif (ind >= 0) {\n\t\t\tcomponent._onBeforeRemove();\n\t\t}\n\t\tthis._removeComponentFromEnabled(component);\n\t\tthis._components.remove(component);\n\t}\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('initialize', this._onInitialize, this);\n\t\tthis.app.systems.off('postInitialize', this._onPostInitialize, this);\n\t\tthis.app.systems.off('update', this._onUpdate, this);\n\t\tthis.app.systems.off('postUpdate', this._onPostUpdate, this);\n\t}\n}\n\nexport { ScriptComponentSystem };\n","import { math } from '../../../core/math/math.js';\nimport { Vec2 } from '../../../core/math/vec2.js';\nimport { Vec3 } from '../../../core/math/vec3.js';\nimport { ORIENTATION_HORIZONTAL, ORIENTATION_VERTICAL } from '../../../scene/constants.js';\nimport { GraphNode } from '../../../scene/graph-node.js';\nimport { ElementDragHelper } from '../element/element-drag-helper.js';\nimport { SCROLL_MODE_INFINITE, SCROLL_MODE_BOUNCE, SCROLL_MODE_CLAMP, SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED, SCROLLBAR_VISIBILITY_SHOW_ALWAYS } from './constants.js';\nimport { Component } from '../component.js';\nimport { EVENT_MOUSEWHEEL } from '../../../platform/input/constants.js';\n\nconst _tempScrollValue = new Vec2();\nclass ScrollViewComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._viewportEntity = null;\n\t\tthis._contentEntity = null;\n\t\tthis._horizontalScrollbarEntity = null;\n\t\tthis._verticalScrollbarEntity = null;\n\t\tthis._evtElementRemove = null;\n\t\tthis._evtViewportElementRemove = null;\n\t\tthis._evtViewportResize = null;\n\t\tthis._evtContentEntityElementAdd = null;\n\t\tthis._evtContentElementRemove = null;\n\t\tthis._evtContentResize = null;\n\t\tthis._evtHorizontalScrollbarAdd = null;\n\t\tthis._evtHorizontalScrollbarRemove = null;\n\t\tthis._evtHorizontalScrollbarValue = null;\n\t\tthis._evtVerticalScrollbarAdd = null;\n\t\tthis._evtVerticalScrollbarRemove = null;\n\t\tthis._evtVerticalScrollbarValue = null;\n\t\tthis._scrollbarUpdateFlags = {};\n\t\tthis._scrollbarEntities = {};\n\t\tthis._prevContentSizes = {};\n\t\tthis._prevContentSizes[ORIENTATION_HORIZONTAL] = null;\n\t\tthis._prevContentSizes[ORIENTATION_VERTICAL] = null;\n\t\tthis._scroll = new Vec2();\n\t\tthis._velocity = new Vec3();\n\t\tthis._dragStartPosition = new Vec3();\n\t\tthis._disabledContentInput = false;\n\t\tthis._disabledContentInputEntities = [];\n\t\tthis._toggleLifecycleListeners('on');\n\t\tthis._toggleElementListeners('on');\n\t}\n\tget data() {\n\t\tconst record = this.system.store[this.entity.getGuid()];\n\t\treturn record ? record.data : null;\n\t}\n\tset enabled(arg) {\n\t\tthis._setValue('enabled', arg);\n\t}\n\tget enabled() {\n\t\treturn this.data.enabled;\n\t}\n\tset horizontal(arg) {\n\t\tthis._setValue('horizontal', arg);\n\t}\n\tget horizontal() {\n\t\treturn this.data.horizontal;\n\t}\n\tset vertical(arg) {\n\t\tthis._setValue('vertical', arg);\n\t}\n\tget vertical() {\n\t\treturn this.data.vertical;\n\t}\n\tset scrollMode(arg) {\n\t\tthis._setValue('scrollMode', arg);\n\t}\n\tget scrollMode() {\n\t\treturn this.data.scrollMode;\n\t}\n\tset bounceAmount(arg) {\n\t\tthis._setValue('bounceAmount', arg);\n\t}\n\tget bounceAmount() {\n\t\treturn this.data.bounceAmount;\n\t}\n\tset friction(arg) {\n\t\tthis._setValue('friction', arg);\n\t}\n\tget friction() {\n\t\treturn this.data.friction;\n\t}\n\tset dragThreshold(arg) {\n\t\tthis._setValue('dragThreshold', arg);\n\t}\n\tget dragThreshold() {\n\t\treturn this.data.dragThreshold;\n\t}\n\tset useMouseWheel(arg) {\n\t\tthis._setValue('useMouseWheel', arg);\n\t}\n\tget useMouseWheel() {\n\t\treturn this.data.useMouseWheel;\n\t}\n\tset mouseWheelSensitivity(arg) {\n\t\tthis._setValue('mouseWheelSensitivity', arg);\n\t}\n\tget mouseWheelSensitivity() {\n\t\treturn this.data.mouseWheelSensitivity;\n\t}\n\tset horizontalScrollbarVisibility(arg) {\n\t\tthis._setValue('horizontalScrollbarVisibility', arg);\n\t}\n\tget horizontalScrollbarVisibility() {\n\t\treturn this.data.horizontalScrollbarVisibility;\n\t}\n\tset verticalScrollbarVisibility(arg) {\n\t\tthis._setValue('verticalScrollbarVisibility', arg);\n\t}\n\tget verticalScrollbarVisibility() {\n\t\treturn this.data.verticalScrollbarVisibility;\n\t}\n\tset viewportEntity(arg) {\n\t\tif (this._viewportEntity === arg) {\n\t\t\treturn;\n\t\t}\n\t\tconst isString = typeof arg === 'string';\n\t\tif (this._viewportEntity && isString && this._viewportEntity.getGuid() === arg) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._viewportEntity) {\n\t\t\tthis._viewportEntityUnsubscribe();\n\t\t}\n\t\tif (arg instanceof GraphNode) {\n\t\t\tthis._viewportEntity = arg;\n\t\t} else if (isString) {\n\t\t\tthis._viewportEntity = this.system.app.getEntityFromIndex(arg) || null;\n\t\t} else {\n\t\t\tthis._viewportEntity = null;\n\t\t}\n\t\tif (this._viewportEntity) {\n\t\t\tthis._viewportEntitySubscribe();\n\t\t}\n\t\tif (this._viewportEntity) {\n\t\t\tthis.data.viewportEntity = this._viewportEntity.getGuid();\n\t\t} else if (isString && arg) {\n\t\t\tthis.data.viewportEntity = arg;\n\t\t}\n\t}\n\tget viewportEntity() {\n\t\treturn this._viewportEntity;\n\t}\n\tset contentEntity(arg) {\n\t\tif (this._contentEntity === arg) {\n\t\t\treturn;\n\t\t}\n\t\tconst isString = typeof arg === 'string';\n\t\tif (this._contentEntity && isString && this._contentEntity.getGuid() === arg) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._contentEntity) {\n\t\t\tthis._contentEntityUnsubscribe();\n\t\t}\n\t\tif (arg instanceof GraphNode) {\n\t\t\tthis._contentEntity = arg;\n\t\t} else if (isString) {\n\t\t\tthis._contentEntity = this.system.app.getEntityFromIndex(arg) || null;\n\t\t} else {\n\t\t\tthis._contentEntity = null;\n\t\t}\n\t\tif (this._contentEntity) {\n\t\t\tthis._contentEntitySubscribe();\n\t\t}\n\t\tif (this._contentEntity) {\n\t\t\tthis.data.contentEntity = this._contentEntity.getGuid();\n\t\t} else if (isString && arg) {\n\t\t\tthis.data.contentEntity = arg;\n\t\t}\n\t}\n\tget contentEntity() {\n\t\treturn this._contentEntity;\n\t}\n\tset horizontalScrollbarEntity(arg) {\n\t\tif (this._horizontalScrollbarEntity === arg) {\n\t\t\treturn;\n\t\t}\n\t\tconst isString = typeof arg === 'string';\n\t\tif (this._horizontalScrollbarEntity && isString && this._horizontalScrollbarEntity.getGuid() === arg) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._horizontalScrollbarEntity) {\n\t\t\tthis._horizontalScrollbarEntityUnsubscribe();\n\t\t}\n\t\tif (arg instanceof GraphNode) {\n\t\t\tthis._horizontalScrollbarEntity = arg;\n\t\t} else if (isString) {\n\t\t\tthis._horizontalScrollbarEntity = this.system.app.getEntityFromIndex(arg) || null;\n\t\t} else {\n\t\t\tthis._horizontalScrollbarEntity = null;\n\t\t}\n\t\tthis._scrollbarEntities[ORIENTATION_HORIZONTAL] = this._horizontalScrollbarEntity;\n\t\tif (this._horizontalScrollbarEntity) {\n\t\t\tthis._horizontalScrollbarEntitySubscribe();\n\t\t}\n\t\tif (this._horizontalScrollbarEntity) {\n\t\t\tthis.data.horizontalScrollbarEntity = this._horizontalScrollbarEntity.getGuid();\n\t\t} else if (isString && arg) {\n\t\t\tthis.data.horizontalScrollbarEntity = arg;\n\t\t}\n\t}\n\tget horizontalScrollbarEntity() {\n\t\treturn this._horizontalScrollbarEntity;\n\t}\n\tset verticalScrollbarEntity(arg) {\n\t\tif (this._verticalScrollbarEntity === arg) {\n\t\t\treturn;\n\t\t}\n\t\tconst isString = typeof arg === 'string';\n\t\tif (this._verticalScrollbarEntity && isString && this._verticalScrollbarEntity.getGuid() === arg) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._verticalScrollbarEntity) {\n\t\t\tthis._verticalScrollbarEntityUnsubscribe();\n\t\t}\n\t\tif (arg instanceof GraphNode) {\n\t\t\tthis._verticalScrollbarEntity = arg;\n\t\t} else if (isString) {\n\t\t\tthis._verticalScrollbarEntity = this.system.app.getEntityFromIndex(arg) || null;\n\t\t} else {\n\t\t\tthis._verticalScrollbarEntity = null;\n\t\t}\n\t\tthis._scrollbarEntities[ORIENTATION_VERTICAL] = this._verticalScrollbarEntity;\n\t\tif (this._verticalScrollbarEntity) {\n\t\t\tthis._verticalScrollbarEntitySubscribe();\n\t\t}\n\t\tif (this._verticalScrollbarEntity) {\n\t\t\tthis.data.verticalScrollbarEntity = this._verticalScrollbarEntity.getGuid();\n\t\t} else if (isString && arg) {\n\t\t\tthis.data.verticalScrollbarEntity = arg;\n\t\t}\n\t}\n\tget verticalScrollbarEntity() {\n\t\treturn this._verticalScrollbarEntity;\n\t}\n\tset scroll(value) {\n\t\tthis._onSetScroll(value.x, value.y);\n\t}\n\tget scroll() {\n\t\treturn this._scroll;\n\t}\n\t_setValue(name, value) {\n\t\tconst data = this.data;\n\t\tconst oldValue = data[name];\n\t\tdata[name] = value;\n\t\tthis.fire('set', name, oldValue, value);\n\t}\n\t_toggleLifecycleListeners(onOrOff) {\n\t\tthis[onOrOff]('set_horizontal', this._onSetHorizontalScrollingEnabled, this);\n\t\tthis[onOrOff]('set_vertical', this._onSetVerticalScrollingEnabled, this);\n\t\tthis.entity[onOrOff]('element:add', this._onElementComponentAdd, this);\n\t}\n\t_toggleElementListeners(onOrOff) {\n\t\tif (this.entity.element) {\n\t\t\tif (onOrOff === 'on' && this._hasElementListeners) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.entity.element[onOrOff]('resize', this._syncAll, this);\n\t\t\tthis.entity.element[onOrOff](EVENT_MOUSEWHEEL, this._onMouseWheel, this);\n\t\t\tthis._hasElementListeners = onOrOff === 'on';\n\t\t}\n\t}\n\t_onElementComponentAdd(entity) {\n\t\tthis._evtElementRemove = this.entity.element.once('beforeremove', this._onElementComponentRemove, this);\n\t\tthis._toggleElementListeners('on');\n\t}\n\t_onElementComponentRemove(entity) {\n\t\tvar _this$_evtElementRemo;\n\t\t(_this$_evtElementRemo = this._evtElementRemove) == null || _this$_evtElementRemo.off();\n\t\tthis._evtElementRemove = null;\n\t\tthis._toggleElementListeners('off');\n\t}\n\t_viewportEntitySubscribe() {\n\t\tthis._evtViewportEntityElementAdd = this._viewportEntity.on('element:add', this._onViewportElementGain, this);\n\t\tif (this._viewportEntity.element) {\n\t\t\tthis._onViewportElementGain();\n\t\t}\n\t}\n\t_viewportEntityUnsubscribe() {\n\t\tvar _this$_evtViewportEnt, _this$_viewportEntity;\n\t\t(_this$_evtViewportEnt = this._evtViewportEntityElementAdd) == null || _this$_evtViewportEnt.off();\n\t\tthis._evtViewportEntityElementAdd = null;\n\t\tif ((_this$_viewportEntity = this._viewportEntity) != null && _this$_viewportEntity.element) {\n\t\t\tthis._onViewportElementLose();\n\t\t}\n\t}\n\t_viewportEntityElementSubscribe() {\n\t\tconst element = this._viewportEntity.element;\n\t\tthis._evtViewportElementRemove = element.once('beforeremove', this._onViewportElementLose, this);\n\t\tthis._evtViewportResize = element.on('resize', this._syncAll, this);\n\t}\n\t_viewportEntityElementUnsubscribe() {\n\t\tvar _this$_evtViewportEle, _this$_evtViewportRes;\n\t\t(_this$_evtViewportEle = this._evtViewportElementRemove) == null || _this$_evtViewportEle.off();\n\t\tthis._evtViewportElementRemove = null;\n\t\t(_this$_evtViewportRes = this._evtViewportResize) == null || _this$_evtViewportRes.off();\n\t\tthis._evtViewportResize = null;\n\t}\n\t_onViewportElementGain() {\n\t\tthis._viewportEntityElementSubscribe();\n\t\tthis._syncAll();\n\t}\n\t_onViewportElementLose() {\n\t\tthis._viewportEntityElementUnsubscribe();\n\t}\n\t_contentEntitySubscribe() {\n\t\tthis._evtContentEntityElementAdd = this._contentEntity.on('element:add', this._onContentElementGain, this);\n\t\tif (this._contentEntity.element) {\n\t\t\tthis._onContentElementGain();\n\t\t}\n\t}\n\t_contentEntityUnsubscribe() {\n\t\tvar _this$_evtContentEnti, _this$_contentEntity;\n\t\t(_this$_evtContentEnti = this._evtContentEntityElementAdd) == null || _this$_evtContentEnti.off();\n\t\tthis._evtContentEntityElementAdd = null;\n\t\tif ((_this$_contentEntity = this._contentEntity) != null && _this$_contentEntity.element) {\n\t\t\tthis._onContentElementLose();\n\t\t}\n\t}\n\t_contentEntityElementSubscribe() {\n\t\tconst element = this._contentEntity.element;\n\t\tthis._evtContentElementRemove = element.once('beforeremove', this._onContentElementLose, this);\n\t\tthis._evtContentResize = element.on('resize', this._syncAll, this);\n\t}\n\t_contentEntityElementUnsubscribe() {\n\t\tvar _this$_evtContentElem, _this$_evtContentResi;\n\t\t(_this$_evtContentElem = this._evtContentElementRemove) == null || _this$_evtContentElem.off();\n\t\tthis._evtContentElementRemove = null;\n\t\t(_this$_evtContentResi = this._evtContentResize) == null || _this$_evtContentResi.off();\n\t\tthis._evtContentResize = null;\n\t}\n\t_onContentElementGain() {\n\t\tthis._contentEntityElementSubscribe();\n\t\tthis._destroyDragHelper();\n\t\tthis._contentDragHelper = new ElementDragHelper(this._contentEntity.element);\n\t\tthis._contentDragHelper.on('drag:start', this._onContentDragStart, this);\n\t\tthis._contentDragHelper.on('drag:end', this._onContentDragEnd, this);\n\t\tthis._contentDragHelper.on('drag:move', this._onContentDragMove, this);\n\t\tthis._prevContentSizes[ORIENTATION_HORIZONTAL] = null;\n\t\tthis._prevContentSizes[ORIENTATION_VERTICAL] = null;\n\t\tthis._syncAll();\n\t}\n\t_onContentElementLose() {\n\t\tthis._contentEntityElementUnsubscribe();\n\t\tthis._destroyDragHelper();\n\t}\n\t_onContentDragStart() {\n\t\tif (this._contentEntity && this.enabled && this.entity.enabled) {\n\t\t\tthis._dragStartPosition.copy(this._contentEntity.getLocalPosition());\n\t\t}\n\t}\n\t_onContentDragEnd() {\n\t\tthis._prevContentDragPosition = null;\n\t\tthis._enableContentInput();\n\t}\n\t_onContentDragMove(position) {\n\t\tif (this._contentEntity && this.enabled && this.entity.enabled) {\n\t\t\tthis._wasDragged = true;\n\t\t\tthis._setScrollFromContentPosition(position);\n\t\t\tthis._setVelocityFromContentPositionDelta(position);\n\t\t\tif (!this._disabledContentInput) {\n\t\t\t\tconst dx = position.x - this._dragStartPosition.x;\n\t\t\t\tconst dy = position.y - this._dragStartPosition.y;\n\t\t\t\tif (Math.abs(dx) > this.dragThreshold || Math.abs(dy) > this.dragThreshold) {\n\t\t\t\t\tthis._disableContentInput();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t_horizontalScrollbarEntitySubscribe() {\n\t\tthis._evtHorizontalScrollbarAdd = this._horizontalScrollbarEntity.on('scrollbar:add', this._onHorizontalScrollbarGain, this);\n\t\tif (this._horizontalScrollbarEntity.scrollbar) {\n\t\t\tthis._onHorizontalScrollbarGain();\n\t\t}\n\t}\n\t_verticalScrollbarEntitySubscribe() {\n\t\tthis._evtVerticalScrollbarAdd = this._verticalScrollbarEntity.on('scrollbar:add', this._onVerticalScrollbarGain, this);\n\t\tif (this._verticalScrollbarEntity.scrollbar) {\n\t\t\tthis._onVerticalScrollbarGain();\n\t\t}\n\t}\n\t_horizontalScrollbarEntityUnsubscribe() {\n\t\tvar _this$_evtHorizontalS;\n\t\t(_this$_evtHorizontalS = this._evtHorizontalScrollbarAdd) == null || _this$_evtHorizontalS.off();\n\t\tthis._evtHorizontalScrollbarAdd = null;\n\t\tif (this._horizontalScrollbarEntity.scrollbar) {\n\t\t\tthis._onHorizontalScrollbarLose();\n\t\t}\n\t}\n\t_verticalScrollbarEntityUnsubscribe() {\n\t\tvar _this$_evtVerticalScr;\n\t\t(_this$_evtVerticalScr = this._evtVerticalScrollbarAdd) == null || _this$_evtVerticalScr.off();\n\t\tthis._evtVerticalScrollbarAdd = null;\n\t\tif (this._verticalScrollbarEntity.scrollbar) {\n\t\t\tthis._onVerticalScrollbarLose();\n\t\t}\n\t}\n\t_onSetHorizontalScrollbarValue(scrollValueX) {\n\t\tif (!this._scrollbarUpdateFlags[ORIENTATION_HORIZONTAL] && this.enabled && this.entity.enabled) {\n\t\t\tthis._onSetScroll(scrollValueX, null);\n\t\t}\n\t}\n\t_onSetVerticalScrollbarValue(scrollValueY) {\n\t\tif (!this._scrollbarUpdateFlags[ORIENTATION_VERTICAL] && this.enabled && this.entity.enabled) {\n\t\t\tthis._onSetScroll(null, scrollValueY);\n\t\t}\n\t}\n\t_onHorizontalScrollbarGain() {\n\t\tvar _this$_horizontalScro;\n\t\tconst scrollbar = (_this$_horizontalScro = this._horizontalScrollbarEntity) == null ? void 0 : _this$_horizontalScro.scrollbar;\n\t\tthis._evtHorizontalScrollbarRemove = scrollbar.on('beforeremove', this._onHorizontalScrollbarLose, this);\n\t\tthis._evtHorizontalScrollbarValue = scrollbar.on('set:value', this._onSetHorizontalScrollbarValue, this);\n\t\tthis._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);\n\t\tthis._syncScrollbarPosition(ORIENTATION_HORIZONTAL);\n\t}\n\t_onVerticalScrollbarGain() {\n\t\tvar _this$_verticalScroll;\n\t\tconst scrollbar = (_this$_verticalScroll = this._verticalScrollbarEntity) == null ? void 0 : _this$_verticalScroll.scrollbar;\n\t\tthis._evtVerticalScrollbarRemove = scrollbar.on('beforeremove', this._onVerticalScrollbarLose, this);\n\t\tthis._evtVerticalScrollbarValue = scrollbar.on('set:value', this._onSetVerticalScrollbarValue, this);\n\t\tthis._syncScrollbarEnabledState(ORIENTATION_VERTICAL);\n\t\tthis._syncScrollbarPosition(ORIENTATION_VERTICAL);\n\t}\n\t_onHorizontalScrollbarLose() {\n\t\tvar _this$_evtHorizontalS2, _this$_evtHorizontalS3;\n\t\t(_this$_evtHorizontalS2 = this._evtHorizontalScrollbarRemove) == null || _this$_evtHorizontalS2.off();\n\t\tthis._evtHorizontalScrollbarRemove = null;\n\t\t(_this$_evtHorizontalS3 = this._evtHorizontalScrollbarValue) == null || _this$_evtHorizontalS3.off();\n\t\tthis._evtHorizontalScrollbarValue = null;\n\t}\n\t_onVerticalScrollbarLose() {\n\t\tvar _this$_evtVerticalScr2, _this$_evtVerticalScr3;\n\t\t(_this$_evtVerticalScr2 = this._evtVerticalScrollbarRemove) == null || _this$_evtVerticalScr2.off();\n\t\tthis._evtVerticalScrollbarRemove = null;\n\t\t(_this$_evtVerticalScr3 = this._evtVerticalScrollbarValue) == null || _this$_evtVerticalScr3.off();\n\t\tthis._evtVerticalScrollbarValue = null;\n\t}\n\t_onSetHorizontalScrollingEnabled() {\n\t\tthis._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);\n\t}\n\t_onSetVerticalScrollingEnabled() {\n\t\tthis._syncScrollbarEnabledState(ORIENTATION_VERTICAL);\n\t}\n\t_onSetScroll(x, y, resetVelocity) {\n\t\tif (resetVelocity !== false) {\n\t\t\tthis._velocity.set(0, 0, 0);\n\t\t}\n\t\tconst xChanged = this._updateAxis(x, 'x', ORIENTATION_HORIZONTAL);\n\t\tconst yChanged = this._updateAxis(y, 'y', ORIENTATION_VERTICAL);\n\t\tif (xChanged || yChanged) {\n\t\t\tthis.fire('set:scroll', this._scroll);\n\t\t}\n\t}\n\t_updateAxis(scrollValue, axis, orientation) {\n\t\tconst hasChanged = scrollValue !== null && Math.abs(scrollValue - this._scroll[axis]) > 1e-5;\n\t\tif (hasChanged || this._isDragging() || scrollValue === 0) {\n\t\t\tthis._scroll[axis] = this._determineNewScrollValue(scrollValue, axis, orientation);\n\t\t\tthis._syncContentPosition(orientation);\n\t\t\tthis._syncScrollbarPosition(orientation);\n\t\t}\n\t\treturn hasChanged;\n\t}\n\t_determineNewScrollValue(scrollValue, axis, orientation) {\n\t\tif (!this._getScrollingEnabled(orientation)) {\n\t\t\treturn this._scroll[axis];\n\t\t}\n\t\tswitch (this.scrollMode) {\n\t\t\tcase SCROLL_MODE_CLAMP:\n\t\t\t\treturn math.clamp(scrollValue, 0, this._getMaxScrollValue(orientation));\n\t\t\tcase SCROLL_MODE_BOUNCE:\n\t\t\t\tthis._setVelocityFromOvershoot(scrollValue, axis, orientation);\n\t\t\t\treturn scrollValue;\n\t\t\tcase SCROLL_MODE_INFINITE:\n\t\t\t\treturn scrollValue;\n\t\t\tdefault:\n\t\t\t\tconsole.warn(`Unhandled scroll mode:${this.scrollMode}`);\n\t\t\t\treturn scrollValue;\n\t\t}\n\t}\n\t_syncAll() {\n\t\tthis._syncContentPosition(ORIENTATION_HORIZONTAL);\n\t\tthis._syncContentPosition(ORIENTATION_VERTICAL);\n\t\tthis._syncScrollbarPosition(ORIENTATION_HORIZONTAL);\n\t\tthis._syncScrollbarPosition(ORIENTATION_VERTICAL);\n\t\tthis._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);\n\t\tthis._syncScrollbarEnabledState(ORIENTATION_VERTICAL);\n\t}\n\t_syncContentPosition(orientation) {\n\t\tif (!this._contentEntity) {\n\t\t\treturn;\n\t\t}\n\t\tconst axis = this._getAxis(orientation);\n\t\tconst sign = this._getSign(orientation);\n\t\tconst prevContentSize = this._prevContentSizes[orientation];\n\t\tconst currContentSize = this._getContentSize(orientation);\n\t\tif (prevContentSize !== null && Math.abs(prevContentSize - currContentSize) > 1e-4) {\n\t\t\tconst prevMaxOffset = this._getMaxOffset(orientation, prevContentSize);\n\t\t\tconst currMaxOffset = this._getMaxOffset(orientation, currContentSize);\n\t\t\tif (currMaxOffset === 0) {\n\t\t\t\tthis._scroll[axis] = 1;\n\t\t\t} else {\n\t\t\t\tthis._scroll[axis] = math.clamp(this._scroll[axis] * prevMaxOffset / currMaxOffset, 0, 1);\n\t\t\t}\n\t\t}\n\t\tconst offset = this._scroll[axis] * this._getMaxOffset(orientation);\n\t\tconst contentPosition = this._contentEntity.getLocalPosition();\n\t\tcontentPosition[axis] = offset * sign;\n\t\tthis._contentEntity.setLocalPosition(contentPosition);\n\t\tthis._prevContentSizes[orientation] = currContentSize;\n\t}\n\t_syncScrollbarPosition(orientation) {\n\t\tconst scrollbarEntity = this._scrollbarEntities[orientation];\n\t\tif (!(scrollbarEntity != null && scrollbarEntity.scrollbar)) {\n\t\t\treturn;\n\t\t}\n\t\tconst axis = this._getAxis(orientation);\n\t\tthis._scrollbarUpdateFlags[orientation] = true;\n\t\tscrollbarEntity.scrollbar.value = this._scroll[axis];\n\t\tscrollbarEntity.scrollbar.handleSize = this._getScrollbarHandleSize(axis, orientation);\n\t\tthis._scrollbarUpdateFlags[orientation] = false;\n\t}\n\t_syncScrollbarEnabledState(orientation) {\n\t\tconst entity = this._scrollbarEntities[orientation];\n\t\tif (!entity) {\n\t\t\treturn;\n\t\t}\n\t\tconst isScrollingEnabled = this._getScrollingEnabled(orientation);\n\t\tconst requestedVisibility = this._getScrollbarVisibility(orientation);\n\t\tswitch (requestedVisibility) {\n\t\t\tcase SCROLLBAR_VISIBILITY_SHOW_ALWAYS:\n\t\t\t\tentity.enabled = isScrollingEnabled;\n\t\t\t\treturn;\n\t\t\tcase SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED:\n\t\t\t\tentity.enabled = isScrollingEnabled && this._contentIsLargerThanViewport(orientation);\n\t\t\t\treturn;\n\t\t\tdefault:\n\t\t\t\tconsole.warn(`Unhandled scrollbar visibility:${requestedVisibility}`);\n\t\t\t\tentity.enabled = isScrollingEnabled;\n\t\t}\n\t}\n\t_contentIsLargerThanViewport(orientation) {\n\t\treturn this._getContentSize(orientation) > this._getViewportSize(orientation);\n\t}\n\t_contentPositionToScrollValue(contentPosition) {\n\t\tconst maxOffsetH = this._getMaxOffset(ORIENTATION_HORIZONTAL);\n\t\tconst maxOffsetV = this._getMaxOffset(ORIENTATION_VERTICAL);\n\t\tif (maxOffsetH === 0) {\n\t\t\t_tempScrollValue.x = 0;\n\t\t} else {\n\t\t\t_tempScrollValue.x = contentPosition.x / maxOffsetH;\n\t\t}\n\t\tif (maxOffsetV === 0) {\n\t\t\t_tempScrollValue.y = 0;\n\t\t} else {\n\t\t\t_tempScrollValue.y = contentPosition.y / -maxOffsetV;\n\t\t}\n\t\treturn _tempScrollValue;\n\t}\n\t_getMaxOffset(orientation, contentSize) {\n\t\tcontentSize = contentSize === undefined ? this._getContentSize(orientation) : contentSize;\n\t\tconst viewportSize = this._getViewportSize(orientation);\n\t\tif (contentSize < viewportSize) {\n\t\t\treturn -this._getViewportSize(orientation);\n\t\t}\n\t\treturn viewportSize - contentSize;\n\t}\n\t_getMaxScrollValue(orientation) {\n\t\treturn this._contentIsLargerThanViewport(orientation) ? 1 : 0;\n\t}\n\t_getScrollbarHandleSize(axis, orientation) {\n\t\tconst viewportSize = this._getViewportSize(orientation);\n\t\tconst contentSize = this._getContentSize(orientation);\n\t\tif (Math.abs(contentSize) < 0.001) {\n\t\t\treturn 1;\n\t\t}\n\t\tconst handleSize = Math.min(viewportSize / contentSize, 1);\n\t\tconst overshoot = this._toOvershoot(this._scroll[axis], orientation);\n\t\tif (overshoot === 0) {\n\t\t\treturn handleSize;\n\t\t}\n\t\treturn handleSize / (1 + Math.abs(overshoot));\n\t}\n\t_getViewportSize(orientation) {\n\t\treturn this._getSize(orientation, this._viewportEntity);\n\t}\n\t_getContentSize(orientation) {\n\t\treturn this._getSize(orientation, this._contentEntity);\n\t}\n\t_getSize(orientation, entity) {\n\t\tif (entity != null && entity.element) {\n\t\t\treturn entity.element[this._getCalculatedDimension(orientation)];\n\t\t}\n\t\treturn 0;\n\t}\n\t_getScrollingEnabled(orientation) {\n\t\tif (orientation === ORIENTATION_HORIZONTAL) {\n\t\t\treturn this.horizontal;\n\t\t} else if (orientation === ORIENTATION_VERTICAL) {\n\t\t\treturn this.vertical;\n\t\t}\n\t\treturn undefined;\n\t}\n\t_getScrollbarVisibility(orientation) {\n\t\tif (orientation === ORIENTATION_HORIZONTAL) {\n\t\t\treturn this.horizontalScrollbarVisibility;\n\t\t} else if (orientation === ORIENTATION_VERTICAL) {\n\t\t\treturn this.verticalScrollbarVisibility;\n\t\t}\n\t\treturn undefined;\n\t}\n\t_getSign(orientation) {\n\t\treturn orientation === ORIENTATION_HORIZONTAL ? 1 : -1;\n\t}\n\t_getAxis(orientation) {\n\t\treturn orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';\n\t}\n\t_getCalculatedDimension(orientation) {\n\t\treturn orientation === ORIENTATION_HORIZONTAL ? 'calculatedWidth' : 'calculatedHeight';\n\t}\n\t_destroyDragHelper() {\n\t\tif (this._contentDragHelper) {\n\t\t\tthis._contentDragHelper.destroy();\n\t\t}\n\t}\n\tonUpdate() {\n\t\tif (this._contentEntity) {\n\t\t\tthis._updateVelocity();\n\t\t\tthis._syncScrollbarEnabledState(ORIENTATION_HORIZONTAL);\n\t\t\tthis._syncScrollbarEnabledState(ORIENTATION_VERTICAL);\n\t\t}\n\t}\n\t_updateVelocity() {\n\t\tif (!this._isDragging()) {\n\t\t\tif (this.scrollMode === SCROLL_MODE_BOUNCE) {\n\t\t\t\tif (this._hasOvershoot('x', ORIENTATION_HORIZONTAL)) {\n\t\t\t\t\tthis._setVelocityFromOvershoot(this.scroll.x, 'x', ORIENTATION_HORIZONTAL);\n\t\t\t\t}\n\t\t\t\tif (this._hasOvershoot('y', ORIENTATION_VERTICAL)) {\n\t\t\t\t\tthis._setVelocityFromOvershoot(this.scroll.y, 'y', ORIENTATION_VERTICAL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (Math.abs(this._velocity.x) > 1e-4 || Math.abs(this._velocity.y) > 1e-4) {\n\t\t\t\tconst position = this._contentEntity.getLocalPosition();\n\t\t\t\tposition.x += this._velocity.x;\n\t\t\t\tposition.y += this._velocity.y;\n\t\t\t\tthis._contentEntity.setLocalPosition(position);\n\t\t\t\tthis._setScrollFromContentPosition(position);\n\t\t\t}\n\t\t\tthis._velocity.x *= 1 - this.friction;\n\t\t\tthis._velocity.y *= 1 - this.friction;\n\t\t}\n\t}\n\t_hasOvershoot(axis, orientation) {\n\t\treturn Math.abs(this._toOvershoot(this.scroll[axis], orientation)) > 0.001;\n\t}\n\t_toOvershoot(scrollValue, orientation) {\n\t\tconst maxScrollValue = this._getMaxScrollValue(orientation);\n\t\tif (scrollValue < 0) {\n\t\t\treturn scrollValue;\n\t\t} else if (scrollValue > maxScrollValue) {\n\t\t\treturn scrollValue - maxScrollValue;\n\t\t}\n\t\treturn 0;\n\t}\n\t_setVelocityFromOvershoot(scrollValue, axis, orientation) {\n\t\tconst overshootValue = this._toOvershoot(scrollValue, orientation);\n\t\tconst overshootPixels = overshootValue * this._getMaxOffset(orientation) * this._getSign(orientation);\n\t\tif (Math.abs(overshootPixels) > 0) {\n\t\t\tthis._velocity[axis] = -overshootPixels / (this.bounceAmount * 50 + 1);\n\t\t}\n\t}\n\t_setVelocityFromContentPositionDelta(position) {\n\t\tif (this._prevContentDragPosition) {\n\t\t\tthis._velocity.sub2(position, this._prevContentDragPosition);\n\t\t\tthis._prevContentDragPosition.copy(position);\n\t\t} else {\n\t\t\tthis._velocity.set(0, 0, 0);\n\t\t\tthis._prevContentDragPosition = position.clone();\n\t\t}\n\t}\n\t_setScrollFromContentPosition(position) {\n\t\tlet scrollValue = this._contentPositionToScrollValue(position);\n\t\tif (this._isDragging()) {\n\t\t\tscrollValue = this._applyScrollValueTension(scrollValue);\n\t\t}\n\t\tthis._onSetScroll(scrollValue.x, scrollValue.y, false);\n\t}\n\t_applyScrollValueTension(scrollValue) {\n\t\tconst factor = 1;\n\t\tlet max = this._getMaxScrollValue(ORIENTATION_HORIZONTAL);\n\t\tlet overshoot = this._toOvershoot(scrollValue.x, ORIENTATION_HORIZONTAL);\n\t\tif (overshoot > 0) {\n\t\t\tscrollValue.x = max + factor * Math.log10(1 + overshoot);\n\t\t} else if (overshoot < 0) {\n\t\t\tscrollValue.x = -factor * Math.log10(1 - overshoot);\n\t\t}\n\t\tmax = this._getMaxScrollValue(ORIENTATION_VERTICAL);\n\t\tovershoot = this._toOvershoot(scrollValue.y, ORIENTATION_VERTICAL);\n\t\tif (overshoot > 0) {\n\t\t\tscrollValue.y = max + factor * Math.log10(1 + overshoot);\n\t\t} else if (overshoot < 0) {\n\t\t\tscrollValue.y = -factor * Math.log10(1 - overshoot);\n\t\t}\n\t\treturn scrollValue;\n\t}\n\t_isDragging() {\n\t\treturn this._contentDragHelper && this._contentDragHelper.isDragging;\n\t}\n\t_setScrollbarComponentsEnabled(enabled) {\n\t\tvar _this$_horizontalScro2, _this$_verticalScroll2;\n\t\tif ((_this$_horizontalScro2 = this._horizontalScrollbarEntity) != null && _this$_horizontalScro2.scrollbar) {\n\t\t\tthis._horizontalScrollbarEntity.scrollbar.enabled = enabled;\n\t\t}\n\t\tif ((_this$_verticalScroll2 = this._verticalScrollbarEntity) != null && _this$_verticalScroll2.scrollbar) {\n\t\t\tthis._verticalScrollbarEntity.scrollbar.enabled = enabled;\n\t\t}\n\t}\n\t_setContentDraggingEnabled(enabled) {\n\t\tif (this._contentDragHelper) {\n\t\t\tthis._contentDragHelper.enabled = enabled;\n\t\t}\n\t}\n\t_onMouseWheel(event) {\n\t\tvar _this$_contentEntity2;\n\t\tif (!this.useMouseWheel || !((_this$_contentEntity2 = this._contentEntity) != null && _this$_contentEntity2.element)) {\n\t\t\treturn;\n\t\t}\n\t\tconst wheelEvent = event.event;\n\t\tconst normalizedDeltaX = wheelEvent.deltaX / this._contentEntity.element.calculatedWidth * this.mouseWheelSensitivity.x;\n\t\tconst normalizedDeltaY = wheelEvent.deltaY / this._contentEntity.element.calculatedHeight * this.mouseWheelSensitivity.y;\n\t\tconst scrollX = math.clamp(this._scroll.x + normalizedDeltaX, 0, this._getMaxScrollValue(ORIENTATION_HORIZONTAL));\n\t\tconst scrollY = math.clamp(this._scroll.y + normalizedDeltaY, 0, this._getMaxScrollValue(ORIENTATION_VERTICAL));\n\t\tthis.scroll = new Vec2(scrollX, scrollY);\n\t}\n\t_enableContentInput() {\n\t\twhile (this._disabledContentInputEntities.length) {\n\t\t\tconst e = this._disabledContentInputEntities.pop();\n\t\t\tif (e.element) {\n\t\t\t\te.element.useInput = true;\n\t\t\t}\n\t\t}\n\t\tthis._disabledContentInput = false;\n\t}\n\t_disableContentInput() {\n\t\tconst _disableInput = e => {\n\t\t\tif (e.element && e.element.useInput) {\n\t\t\t\tthis._disabledContentInputEntities.push(e);\n\t\t\t\te.element.useInput = false;\n\t\t\t}\n\t\t\tconst children = e.children;\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\t_disableInput(children[i]);\n\t\t\t}\n\t\t};\n\t\tif (this._contentEntity) {\n\t\t\tconst children = this._contentEntity.children;\n\t\t\tfor (let i = 0, l = children.length; i < l; i++) {\n\t\t\t\t_disableInput(children[i]);\n\t\t\t}\n\t\t}\n\t\tthis._disabledContentInput = true;\n\t}\n\tonEnable() {\n\t\tthis._setScrollbarComponentsEnabled(true);\n\t\tthis._setContentDraggingEnabled(true);\n\t\tthis._syncAll();\n\t}\n\tonDisable() {\n\t\tthis._setScrollbarComponentsEnabled(false);\n\t\tthis._setContentDraggingEnabled(false);\n\t}\n\tonRemove() {\n\t\tthis._toggleLifecycleListeners('off');\n\t\tthis._toggleElementListeners('off');\n\t\tthis._destroyDragHelper();\n\t}\n\tresolveDuplicatedEntityReferenceProperties(oldScrollView, duplicatedIdsMap) {\n\t\tif (oldScrollView.viewportEntity) {\n\t\t\tthis.viewportEntity = duplicatedIdsMap[oldScrollView.viewportEntity.getGuid()];\n\t\t}\n\t\tif (oldScrollView.contentEntity) {\n\t\t\tthis.contentEntity = duplicatedIdsMap[oldScrollView.contentEntity.getGuid()];\n\t\t}\n\t\tif (oldScrollView.horizontalScrollbarEntity) {\n\t\t\tthis.horizontalScrollbarEntity = duplicatedIdsMap[oldScrollView.horizontalScrollbarEntity.getGuid()];\n\t\t}\n\t\tif (oldScrollView.verticalScrollbarEntity) {\n\t\t\tthis.verticalScrollbarEntity = duplicatedIdsMap[oldScrollView.verticalScrollbarEntity.getGuid()];\n\t\t}\n\t}\n}\nScrollViewComponent.EVENT_SETSCROLL = 'set:scroll';\n\nexport { ScrollViewComponent };\n","const SCROLL_MODE_CLAMP = 0;\nconst SCROLL_MODE_BOUNCE = 1;\nconst SCROLL_MODE_INFINITE = 2;\nconst SCROLLBAR_VISIBILITY_SHOW_ALWAYS = 0;\nconst SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED = 1;\n\nexport { SCROLLBAR_VISIBILITY_SHOW_ALWAYS, SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED, SCROLL_MODE_BOUNCE, SCROLL_MODE_CLAMP, SCROLL_MODE_INFINITE };\n","import { Vec2 } from '../../../core/math/vec2.js';\n\nconst DEFAULT_DRAG_THRESHOLD = 10;\nclass ScrollViewComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t\tthis.horizontal = void 0;\n\t\tthis.vertical = void 0;\n\t\tthis.scrollMode = void 0;\n\t\tthis.bounceAmount = void 0;\n\t\tthis.friction = void 0;\n\t\tthis.dragThreshold = DEFAULT_DRAG_THRESHOLD;\n\t\tthis.useMouseWheel = true;\n\t\tthis.mouseWheelSensitivity = new Vec2(1, 1);\n\t\tthis.horizontalScrollbarVisibility = 0;\n\t\tthis.verticalScrollbarVisibility = 0;\n\t\tthis.viewportEntity = null;\n\t\tthis.contentEntity = null;\n\t\tthis.horizontalScrollbarEntity = null;\n\t\tthis.verticalScrollbarEntity = null;\n\t}\n}\n\nexport { ScrollViewComponentData };\n","import { ComponentSystem } from '../system.js';\nimport { ScrollViewComponent } from './component.js';\nimport { ScrollViewComponentData } from './data.js';\nimport { Vec2 } from '../../../core/math/vec2.js';\n\nconst _schema = [{\n\tname: 'enabled',\n\ttype: 'boolean'\n}, {\n\tname: 'horizontal',\n\ttype: 'boolean'\n}, {\n\tname: 'vertical',\n\ttype: 'boolean'\n}, {\n\tname: 'scrollMode',\n\ttype: 'number'\n}, {\n\tname: 'bounceAmount',\n\ttype: 'number'\n}, {\n\tname: 'friction',\n\ttype: 'number'\n}, {\n\tname: 'dragThreshold',\n\ttype: 'number'\n}, {\n\tname: 'useMouseWheel',\n\ttype: 'boolean'\n}, {\n\tname: 'mouseWheelSensitivity',\n\ttype: 'vec2'\n}, {\n\tname: 'horizontalScrollbarVisibility',\n\ttype: 'number'\n}, {\n\tname: 'verticalScrollbarVisibility',\n\ttype: 'number'\n}];\nconst DEFAULT_DRAG_THRESHOLD = 10;\nclass ScrollViewComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'scrollview';\n\t\tthis.ComponentType = ScrollViewComponent;\n\t\tthis.DataType = ScrollViewComponentData;\n\t\tthis.schema = _schema;\n\t\tthis.on('beforeremove', this._onRemoveComponent, this);\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t}\n\tinitializeComponentData(component, data, properties) {\n\t\tif (data.dragThreshold === undefined) {\n\t\t\tdata.dragThreshold = DEFAULT_DRAG_THRESHOLD;\n\t\t}\n\t\tif (data.useMouseWheel === undefined) {\n\t\t\tdata.useMouseWheel = true;\n\t\t}\n\t\tif (data.mouseWheelSensitivity === undefined) {\n\t\t\tdata.mouseWheelSensitivity = new Vec2(1, 1);\n\t\t}\n\t\tsuper.initializeComponentData(component, data, _schema);\n\t\tcomponent.viewportEntity = data.viewportEntity;\n\t\tcomponent.contentEntity = data.contentEntity;\n\t\tcomponent.horizontalScrollbarEntity = data.horizontalScrollbarEntity;\n\t\tcomponent.verticalScrollbarEntity = data.verticalScrollbarEntity;\n\t}\n\tonUpdate(dt) {\n\t\tconst components = this.store;\n\t\tfor (const id in components) {\n\t\t\tconst entity = components[id].entity;\n\t\t\tconst component = entity.scrollview;\n\t\t\tif (component.enabled && entity.enabled) {\n\t\t\t\tcomponent.onUpdate();\n\t\t\t}\n\t\t}\n\t}\n\t_onRemoveComponent(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n}\n\nexport { ScrollViewComponentSystem };\n","import { math } from '../../../core/math/math.js';\nimport { ORIENTATION_HORIZONTAL } from '../../../scene/constants.js';\nimport { GraphNode } from '../../../scene/graph-node.js';\nimport { Component } from '../component.js';\nimport { ElementDragHelper } from '../element/element-drag-helper.js';\n\nclass ScrollbarComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._handleEntity = null;\n\t\tthis._evtHandleEntityElementAdd = null;\n\t\tthis._evtHandleEntityChanges = [];\n\t\tthis._toggleLifecycleListeners('on');\n\t}\n\tget data() {\n\t\tconst record = this.system.store[this.entity.getGuid()];\n\t\treturn record ? record.data : null;\n\t}\n\tset enabled(arg) {\n\t\tthis._setValue('enabled', arg);\n\t}\n\tget enabled() {\n\t\treturn this.data.enabled;\n\t}\n\tset orientation(arg) {\n\t\tthis._setValue('orientation', arg);\n\t}\n\tget orientation() {\n\t\treturn this.data.orientation;\n\t}\n\tset value(arg) {\n\t\tthis._setValue('value', arg);\n\t}\n\tget value() {\n\t\treturn this.data.value;\n\t}\n\tset handleSize(arg) {\n\t\tthis._setValue('handleSize', arg);\n\t}\n\tget handleSize() {\n\t\treturn this.data.handleSize;\n\t}\n\tset handleEntity(arg) {\n\t\tif (this._handleEntity === arg) {\n\t\t\treturn;\n\t\t}\n\t\tconst isString = typeof arg === 'string';\n\t\tif (this._handleEntity && isString && this._handleEntity.getGuid() === arg) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._handleEntity) {\n\t\t\tthis._handleEntityUnsubscribe();\n\t\t}\n\t\tif (arg instanceof GraphNode) {\n\t\t\tthis._handleEntity = arg;\n\t\t} else if (isString) {\n\t\t\tthis._handleEntity = this.system.app.getEntityFromIndex(arg) || null;\n\t\t} else {\n\t\t\tthis._handleEntity = null;\n\t\t}\n\t\tif (this._handleEntity) {\n\t\t\tthis._handleEntitySubscribe();\n\t\t}\n\t\tif (this._handleEntity) {\n\t\t\tthis.data.handleEntity = this._handleEntity.getGuid();\n\t\t} else if (isString && arg) {\n\t\t\tthis.data.handleEntity = arg;\n\t\t}\n\t}\n\tget handleEntity() {\n\t\treturn this._handleEntity;\n\t}\n\t_setValue(name, value) {\n\t\tconst data = this.data;\n\t\tconst oldValue = data[name];\n\t\tdata[name] = value;\n\t\tthis.fire('set', name, oldValue, value);\n\t}\n\t_toggleLifecycleListeners(onOrOff) {\n\t\tthis[onOrOff]('set_value', this._onSetValue, this);\n\t\tthis[onOrOff]('set_handleSize', this._onSetHandleSize, this);\n\t\tthis[onOrOff]('set_orientation', this._onSetOrientation, this);\n\t}\n\t_handleEntitySubscribe() {\n\t\tthis._evtHandleEntityElementAdd = this._handleEntity.on('element:add', this._onHandleElementGain, this);\n\t\tif (this._handleEntity.element) {\n\t\t\tthis._onHandleElementGain();\n\t\t}\n\t}\n\t_handleEntityUnsubscribe() {\n\t\tvar _this$_evtHandleEntit, _this$_handleEntity;\n\t\t(_this$_evtHandleEntit = this._evtHandleEntityElementAdd) == null || _this$_evtHandleEntit.off();\n\t\tthis._evtHandleEntityElementAdd = null;\n\t\tif ((_this$_handleEntity = this._handleEntity) != null && _this$_handleEntity.element) {\n\t\t\tthis._onHandleElementLose();\n\t\t}\n\t}\n\t_handleEntityElementSubscribe() {\n\t\tconst element = this._handleEntity.element;\n\t\tconst handles = this._evtHandleEntityChanges;\n\t\thandles.push(element.once('beforeremove', this._onHandleElementLose, this));\n\t\thandles.push(element.on('set:anchor', this._onSetHandleAlignment, this));\n\t\thandles.push(element.on('set:margin', this._onSetHandleAlignment, this));\n\t\thandles.push(element.on('set:pivot', this._onSetHandleAlignment, this));\n\t}\n\t_handleEntityElementUnsubscribe() {\n\t\tfor (let i = 0; i < this._evtHandleEntityChanges.length; i++) {\n\t\t\tthis._evtHandleEntityChanges[i].off();\n\t\t}\n\t\tthis._evtHandleEntityChanges.length = 0;\n\t}\n\t_onHandleElementGain() {\n\t\tthis._handleEntityElementSubscribe();\n\t\tthis._destroyDragHelper();\n\t\tthis._handleDragHelper = new ElementDragHelper(this._handleEntity.element, this._getAxis());\n\t\tthis._handleDragHelper.on('drag:move', this._onHandleDrag, this);\n\t\tthis._updateHandlePositionAndSize();\n\t}\n\t_onHandleElementLose() {\n\t\tthis._handleEntityElementUnsubscribe();\n\t\tthis._destroyDragHelper();\n\t}\n\t_onHandleDrag(position) {\n\t\tif (this._handleEntity && this.enabled && this.entity.enabled) {\n\t\t\tthis.value = this._handlePositionToScrollValue(position[this._getAxis()]);\n\t\t}\n\t}\n\t_onSetValue(name, oldValue, newValue) {\n\t\tif (Math.abs(newValue - oldValue) > 1e-5) {\n\t\t\tthis.data.value = math.clamp(newValue, 0, 1);\n\t\t\tthis._updateHandlePositionAndSize();\n\t\t\tthis.fire('set:value', this.data.value);\n\t\t}\n\t}\n\t_onSetHandleSize(name, oldValue, newValue) {\n\t\tif (Math.abs(newValue - oldValue) > 1e-5) {\n\t\t\tthis.data.handleSize = math.clamp(newValue, 0, 1);\n\t\t\tthis._updateHandlePositionAndSize();\n\t\t}\n\t}\n\t_onSetHandleAlignment() {\n\t\tthis._updateHandlePositionAndSize();\n\t}\n\t_onSetOrientation(name, oldValue, newValue) {\n\t\tvar _this$_handleEntity2;\n\t\tif (newValue !== oldValue && (_this$_handleEntity2 = this._handleEntity) != null && _this$_handleEntity2.element) {\n\t\t\tthis._handleEntity.element[this._getOppositeDimension()] = 0;\n\t\t}\n\t}\n\t_updateHandlePositionAndSize() {\n\t\tconst handleEntity = this._handleEntity;\n\t\tconst handleElement = handleEntity == null ? void 0 : handleEntity.element;\n\t\tif (handleEntity) {\n\t\t\tconst position = handleEntity.getLocalPosition();\n\t\t\tposition[this._getAxis()] = this._getHandlePosition();\n\t\t\thandleEntity.setLocalPosition(position);\n\t\t}\n\t\tif (handleElement) {\n\t\t\thandleElement[this._getDimension()] = this._getHandleLength();\n\t\t}\n\t}\n\t_handlePositionToScrollValue(handlePosition) {\n\t\treturn handlePosition * this._getSign() / this._getUsableTrackLength();\n\t}\n\t_scrollValueToHandlePosition(value) {\n\t\treturn value * this._getSign() * this._getUsableTrackLength();\n\t}\n\t_getUsableTrackLength() {\n\t\treturn Math.max(this._getTrackLength() - this._getHandleLength(), 0.001);\n\t}\n\t_getTrackLength() {\n\t\tif (this.entity.element) {\n\t\t\treturn this.orientation === ORIENTATION_HORIZONTAL ? this.entity.element.calculatedWidth : this.entity.element.calculatedHeight;\n\t\t}\n\t\treturn 0;\n\t}\n\t_getHandleLength() {\n\t\treturn this._getTrackLength() * this.handleSize;\n\t}\n\t_getHandlePosition() {\n\t\treturn this._scrollValueToHandlePosition(this.value);\n\t}\n\t_getSign() {\n\t\treturn this.orientation === ORIENTATION_HORIZONTAL ? 1 : -1;\n\t}\n\t_getAxis() {\n\t\treturn this.orientation === ORIENTATION_HORIZONTAL ? 'x' : 'y';\n\t}\n\t_getDimension() {\n\t\treturn this.orientation === ORIENTATION_HORIZONTAL ? 'width' : 'height';\n\t}\n\t_getOppositeDimension() {\n\t\treturn this.orientation === ORIENTATION_HORIZONTAL ? 'height' : 'width';\n\t}\n\t_destroyDragHelper() {\n\t\tif (this._handleDragHelper) {\n\t\t\tthis._handleDragHelper.destroy();\n\t\t}\n\t}\n\t_setHandleDraggingEnabled(enabled) {\n\t\tif (this._handleDragHelper) {\n\t\t\tthis._handleDragHelper.enabled = enabled;\n\t\t}\n\t}\n\tonEnable() {\n\t\tthis._setHandleDraggingEnabled(true);\n\t}\n\tonDisable() {\n\t\tthis._setHandleDraggingEnabled(false);\n\t}\n\tonRemove() {\n\t\tthis._destroyDragHelper();\n\t\tthis._toggleLifecycleListeners('off');\n\t}\n\tresolveDuplicatedEntityReferenceProperties(oldScrollbar, duplicatedIdsMap) {\n\t\tif (oldScrollbar.handleEntity) {\n\t\t\tthis.handleEntity = duplicatedIdsMap[oldScrollbar.handleEntity.getGuid()];\n\t\t}\n\t}\n}\nScrollbarComponent.EVENT_SETVALUE = 'set:value';\n\nexport { ScrollbarComponent };\n","import { ORIENTATION_HORIZONTAL } from '../../../scene/constants.js';\n\nclass ScrollbarComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t\tthis.orientation = ORIENTATION_HORIZONTAL;\n\t\tthis.value = 0;\n\t\tthis.handleSize = 0;\n\t\tthis.handleEntity = null;\n\t}\n}\n\nexport { ScrollbarComponentData };\n","import { ComponentSystem } from '../system.js';\nimport { ScrollbarComponent } from './component.js';\nimport { ScrollbarComponentData } from './data.js';\n\nconst _schema = [{\n\tname: 'enabled',\n\ttype: 'boolean'\n}, {\n\tname: 'orientation',\n\ttype: 'number'\n}, {\n\tname: 'value',\n\ttype: 'number'\n}, {\n\tname: 'handleSize',\n\ttype: 'number'\n}];\nclass ScrollbarComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'scrollbar';\n\t\tthis.ComponentType = ScrollbarComponent;\n\t\tthis.DataType = ScrollbarComponentData;\n\t\tthis.schema = _schema;\n\t\tthis.on('add', this._onAddComponent, this);\n\t\tthis.on('beforeremove', this._onRemoveComponent, this);\n\t}\n\tinitializeComponentData(component, data, properties) {\n\t\tsuper.initializeComponentData(component, data, _schema);\n\t\tcomponent.handleEntity = data.handleEntity;\n\t}\n\t_onAddComponent(entity) {\n\t\tentity.fire('scrollbar:add');\n\t}\n\t_onRemoveComponent(entity, component) {\n\t\tcomponent.onRemove();\n\t}\n}\n\nexport { ScrollbarComponentSystem };\n","import { DISTANCE_LINEAR } from '../../../platform/audio/constants.js';\nimport { Component } from '../component.js';\nimport { SoundSlot } from './slot.js';\n\nclass SoundComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._volume = 1;\n\t\tthis._pitch = 1;\n\t\tthis._positional = true;\n\t\tthis._refDistance = 1;\n\t\tthis._maxDistance = 10000;\n\t\tthis._rollOffFactor = 1;\n\t\tthis._distanceModel = DISTANCE_LINEAR;\n\t\tthis._slots = {};\n\t\tthis._playingBeforeDisable = {};\n\t}\n\t_updateSoundInstances(property, value, isFactor) {\n\t\tconst slots = this._slots;\n\t\tfor (const key in slots) {\n\t\t\tconst slot = slots[key];\n\t\t\tif (!slot.overlap) {\n\t\t\t\tconst instances = slot.instances;\n\t\t\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\t\t\tinstances[i][property] = isFactor ? slot[property] * value : value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tset distanceModel(value) {\n\t\tthis._distanceModel = value;\n\t\tthis._updateSoundInstances('distanceModel', value, false);\n\t}\n\tget distanceModel() {\n\t\treturn this._distanceModel;\n\t}\n\tset maxDistance(value) {\n\t\tthis._maxDistance = value;\n\t\tthis._updateSoundInstances('maxDistance', value, false);\n\t}\n\tget maxDistance() {\n\t\treturn this._maxDistance;\n\t}\n\tset refDistance(value) {\n\t\tthis._refDistance = value;\n\t\tthis._updateSoundInstances('refDistance', value, false);\n\t}\n\tget refDistance() {\n\t\treturn this._refDistance;\n\t}\n\tset rollOffFactor(value) {\n\t\tthis._rollOffFactor = value;\n\t\tthis._updateSoundInstances('rollOffFactor', value, false);\n\t}\n\tget rollOffFactor() {\n\t\treturn this._rollOffFactor;\n\t}\n\tset pitch(value) {\n\t\tthis._pitch = value;\n\t\tthis._updateSoundInstances('pitch', value, true);\n\t}\n\tget pitch() {\n\t\treturn this._pitch;\n\t}\n\tset volume(value) {\n\t\tthis._volume = value;\n\t\tthis._updateSoundInstances('volume', value, true);\n\t}\n\tget volume() {\n\t\treturn this._volume;\n\t}\n\tset positional(newValue) {\n\t\tthis._positional = newValue;\n\t\tconst slots = this._slots;\n\t\tfor (const key in slots) {\n\t\t\tconst slot = slots[key];\n\t\t\tif (!slot.overlap) {\n\t\t\t\tconst instances = slot.instances;\n\t\t\t\tconst oldLength = instances.length;\n\t\t\t\tfor (let i = oldLength - 1; i >= 0; i--) {\n\t\t\t\t\tconst isPlaying = instances[i].isPlaying || instances[i].isSuspended;\n\t\t\t\t\tconst currentTime = instances[i].currentTime;\n\t\t\t\t\tif (isPlaying) {\n\t\t\t\t\t\tinstances[i].stop();\n\t\t\t\t\t}\n\t\t\t\t\tconst instance = slot._createInstance();\n\t\t\t\t\tif (isPlaying) {\n\t\t\t\t\t\tinstance.play();\n\t\t\t\t\t\tinstance.currentTime = currentTime;\n\t\t\t\t\t}\n\t\t\t\t\tinstances.push(instance);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tget positional() {\n\t\treturn this._positional;\n\t}\n\tset slots(newValue) {\n\t\tconst oldValue = this._slots;\n\t\tif (oldValue) {\n\t\t\tfor (const key in oldValue) {\n\t\t\t\toldValue[key].stop();\n\t\t\t}\n\t\t}\n\t\tconst slots = {};\n\t\tfor (const key in newValue) {\n\t\t\tif (!(newValue[key] instanceof SoundSlot)) {\n\t\t\t\tif (newValue[key].name) {\n\t\t\t\t\tslots[newValue[key].name] = new SoundSlot(this, newValue[key].name, newValue[key]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tslots[newValue[key].name] = newValue[key];\n\t\t\t}\n\t\t}\n\t\tthis._slots = slots;\n\t\tif (this.enabled && this.entity.enabled) {\n\t\t\tthis.onEnable();\n\t\t}\n\t}\n\tget slots() {\n\t\treturn this._slots;\n\t}\n\tonEnable() {\n\t\tif (this.system._inTools) {\n\t\t\treturn;\n\t\t}\n\t\tconst slots = this._slots;\n\t\tconst playingBeforeDisable = this._playingBeforeDisable;\n\t\tfor (const key in slots) {\n\t\t\tconst slot = slots[key];\n\t\t\tif (slot.autoPlay && slot.isStopped) {\n\t\t\t\tslot.play();\n\t\t\t} else if (playingBeforeDisable[key]) {\n\t\t\t\tslot.resume();\n\t\t\t} else if (!slot.isLoaded) {\n\t\t\t\tslot.load();\n\t\t\t}\n\t\t}\n\t}\n\tonDisable() {\n\t\tconst slots = this._slots;\n\t\tconst playingBeforeDisable = {};\n\t\tfor (const key in slots) {\n\t\t\tif (!slots[key].overlap) {\n\t\t\t\tif (slots[key].isPlaying) {\n\t\t\t\t\tslots[key].pause();\n\t\t\t\t\tplayingBeforeDisable[key] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._playingBeforeDisable = playingBeforeDisable;\n\t}\n\tonRemove() {\n\t\tthis.off();\n\t}\n\taddSlot(name, options) {\n\t\tconst slots = this._slots;\n\t\tif (slots[name]) {\n\t\t\treturn null;\n\t\t}\n\t\tconst slot = new SoundSlot(this, name, options);\n\t\tslots[name] = slot;\n\t\tif (slot.autoPlay && this.enabled && this.entity.enabled) {\n\t\t\tslot.play();\n\t\t}\n\t\treturn slot;\n\t}\n\tremoveSlot(name) {\n\t\tconst slots = this._slots;\n\t\tif (slots[name]) {\n\t\t\tslots[name].stop();\n\t\t\tdelete slots[name];\n\t\t}\n\t}\n\tslot(name) {\n\t\treturn this._slots[name];\n\t}\n\t_getSlotProperty(name, property) {\n\t\tif (!this.enabled || !this.entity.enabled) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst slot = this._slots[name];\n\t\tif (!slot) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn slot[property];\n\t}\n\tisPlaying(name) {\n\t\treturn this._getSlotProperty(name, 'isPlaying') || false;\n\t}\n\tisLoaded(name) {\n\t\treturn this._getSlotProperty(name, 'isLoaded') || false;\n\t}\n\tisPaused(name) {\n\t\treturn this._getSlotProperty(name, 'isPaused') || false;\n\t}\n\tisStopped(name) {\n\t\treturn this._getSlotProperty(name, 'isStopped') || false;\n\t}\n\tplay(name) {\n\t\tif (!this.enabled || !this.entity.enabled) {\n\t\t\treturn null;\n\t\t}\n\t\tconst slot = this._slots[name];\n\t\tif (!slot) {\n\t\t\treturn null;\n\t\t}\n\t\treturn slot.play();\n\t}\n\tpause(name) {\n\t\tconst slots = this._slots;\n\t\tif (name) {\n\t\t\tconst slot = slots[name];\n\t\t\tif (!slot) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tslot.pause();\n\t\t} else {\n\t\t\tfor (const key in slots) {\n\t\t\t\tslots[key].pause();\n\t\t\t}\n\t\t}\n\t}\n\tresume(name) {\n\t\tconst slots = this._slots;\n\t\tif (name) {\n\t\t\tconst slot = slots[name];\n\t\t\tif (!slot) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (slot.isPaused) {\n\t\t\t\tslot.resume();\n\t\t\t}\n\t\t} else {\n\t\t\tfor (const key in slots) {\n\t\t\t\tslots[key].resume();\n\t\t\t}\n\t\t}\n\t}\n\tstop(name) {\n\t\tconst slots = this._slots;\n\t\tif (name) {\n\t\t\tconst slot = slots[name];\n\t\t\tif (!slot) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tslot.stop();\n\t\t} else {\n\t\t\tfor (const key in slots) {\n\t\t\t\tslots[key].stop();\n\t\t\t}\n\t\t}\n\t}\n}\nSoundComponent.EVENT_PLAY = 'play';\nSoundComponent.EVENT_PAUSE = 'pause';\nSoundComponent.EVENT_RESUME = 'resume';\nSoundComponent.EVENT_STOP = 'stop';\nSoundComponent.EVENT_END = 'end';\n\nexport { SoundComponent };\n","class SoundComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n}\n\nexport { SoundComponentData };\n","import { EventHandler } from '../../../core/event-handler.js';\nimport { math } from '../../../core/math/math.js';\nimport { Vec3 } from '../../../core/math/vec3.js';\nimport { Asset } from '../../asset/asset.js';\nimport { SoundInstance } from '../../../platform/sound/instance.js';\nimport { SoundInstance3d } from '../../../platform/sound/instance3d.js';\n\nconst instanceOptions = {\n\tvolume: 0,\n\tpitch: 0,\n\tloop: false,\n\tstartTime: 0,\n\tduration: 0,\n\tposition: new Vec3(),\n\tmaxDistance: 0,\n\trefDistance: 0,\n\trollOffFactor: 0,\n\tdistanceModel: 0,\n\tonPlay: null,\n\tonPause: null,\n\tonResume: null,\n\tonStop: null,\n\tonEnd: null\n};\nclass SoundSlot extends EventHandler {\n\tconstructor(component, name = 'Untitled', options = {}) {\n\t\tsuper();\n\t\tthis.name = void 0;\n\t\tthis.instances = [];\n\t\tthis._component = component;\n\t\tthis._assets = component.system.app.assets;\n\t\tthis._manager = component.system.manager;\n\t\tthis.name = name;\n\t\tthis._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;\n\t\tthis._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;\n\t\tthis._loop = !!(options.loop !== undefined ? options.loop : false);\n\t\tthis._duration = options.duration > 0 ? options.duration : null;\n\t\tthis._startTime = Math.max(0, Number(options.startTime) || 0);\n\t\tthis._overlap = !!options.overlap;\n\t\tthis._autoPlay = !!options.autoPlay;\n\t\tthis._firstNode = null;\n\t\tthis._lastNode = null;\n\t\tthis._asset = options.asset;\n\t\tif (this._asset instanceof Asset) {\n\t\t\tthis._asset = this._asset.id;\n\t\t}\n\t\tthis._onInstancePlayHandler = this._onInstancePlay.bind(this);\n\t\tthis._onInstancePauseHandler = this._onInstancePause.bind(this);\n\t\tthis._onInstanceResumeHandler = this._onInstanceResume.bind(this);\n\t\tthis._onInstanceStopHandler = this._onInstanceStop.bind(this);\n\t\tthis._onInstanceEndHandler = this._onInstanceEnd.bind(this);\n\t}\n\tplay() {\n\t\tif (!this.overlap) {\n\t\t\tthis.stop();\n\t\t}\n\t\tif (!this.isLoaded && !this._hasAsset()) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst instance = this._createInstance();\n\t\tthis.instances.push(instance);\n\t\tif (!this.isLoaded) {\n\t\t\tconst onLoad = function onLoad(sound) {\n\t\t\t\tconst playWhenLoaded = instance._playWhenLoaded;\n\t\t\t\tinstance.sound = sound;\n\t\t\t\tif (playWhenLoaded) {\n\t\t\t\t\tinstance.play();\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.off('load', onLoad);\n\t\t\tthis.once('load', onLoad);\n\t\t\tthis.load();\n\t\t} else {\n\t\t\tinstance.play();\n\t\t}\n\t\treturn instance;\n\t}\n\tpause() {\n\t\tlet paused = false;\n\t\tconst instances = this.instances;\n\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\tif (instances[i].pause()) {\n\t\t\t\tpaused = true;\n\t\t\t}\n\t\t}\n\t\treturn paused;\n\t}\n\tresume() {\n\t\tlet resumed = false;\n\t\tconst instances = this.instances;\n\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\tif (instances[i].resume()) {\n\t\t\t\tresumed = true;\n\t\t\t}\n\t\t}\n\t\treturn resumed;\n\t}\n\tstop() {\n\t\tlet stopped = false;\n\t\tconst instances = this.instances;\n\t\tlet i = instances.length;\n\t\twhile (i--) {\n\t\t\tinstances[i].stop();\n\t\t\tstopped = true;\n\t\t}\n\t\tinstances.length = 0;\n\t\treturn stopped;\n\t}\n\tload() {\n\t\tif (!this._hasAsset()) {\n\t\t\treturn;\n\t\t}\n\t\tconst asset = this._assets.get(this._asset);\n\t\tif (!asset) {\n\t\t\tthis._assets.off(`add:${this._asset}`, this._onAssetAdd, this);\n\t\t\tthis._assets.once(`add:${this._asset}`, this._onAssetAdd, this);\n\t\t\treturn;\n\t\t}\n\t\tasset.off('remove', this._onAssetRemoved, this);\n\t\tasset.on('remove', this._onAssetRemoved, this);\n\t\tif (!asset.resource) {\n\t\t\tasset.off('load', this._onAssetLoad, this);\n\t\t\tasset.once('load', this._onAssetLoad, this);\n\t\t\tthis._assets.load(asset);\n\t\t\treturn;\n\t\t}\n\t\tthis.fire('load', asset.resource);\n\t}\n\tsetExternalNodes(firstNode, lastNode) {\n\t\tif (!firstNode) {\n\t\t\tconsole.error('The firstNode must have a valid AudioNode');\n\t\t\treturn;\n\t\t}\n\t\tif (!lastNode) {\n\t\t\tlastNode = firstNode;\n\t\t}\n\t\tthis._firstNode = firstNode;\n\t\tthis._lastNode = lastNode;\n\t\tif (!this._overlap) {\n\t\t\tconst instances = this.instances;\n\t\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\t\tinstances[i].setExternalNodes(firstNode, lastNode);\n\t\t\t}\n\t\t}\n\t}\n\tclearExternalNodes() {\n\t\tthis._firstNode = null;\n\t\tthis._lastNode = null;\n\t\tif (!this._overlap) {\n\t\t\tconst instances = this.instances;\n\t\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\t\tinstances[i].clearExternalNodes();\n\t\t\t}\n\t\t}\n\t}\n\tgetExternalNodes() {\n\t\treturn [this._firstNode, this._lastNode];\n\t}\n\t_hasAsset() {\n\t\treturn this._asset != null;\n\t}\n\t_createInstance() {\n\t\tlet instance = null;\n\t\tconst component = this._component;\n\t\tlet sound = null;\n\t\tif (this._hasAsset()) {\n\t\t\tconst asset = this._assets.get(this._asset);\n\t\t\tif (asset) {\n\t\t\t\tsound = asset.resource;\n\t\t\t}\n\t\t}\n\t\tconst data = instanceOptions;\n\t\tdata.volume = this._volume * component.volume;\n\t\tdata.pitch = this._pitch * component.pitch;\n\t\tdata.loop = this._loop;\n\t\tdata.startTime = this._startTime;\n\t\tdata.duration = this._duration;\n\t\tdata.onPlay = this._onInstancePlayHandler;\n\t\tdata.onPause = this._onInstancePauseHandler;\n\t\tdata.onResume = this._onInstanceResumeHandler;\n\t\tdata.onStop = this._onInstanceStopHandler;\n\t\tdata.onEnd = this._onInstanceEndHandler;\n\t\tif (component.positional) {\n\t\t\tdata.position.copy(component.entity.getPosition());\n\t\t\tdata.maxDistance = component.maxDistance;\n\t\t\tdata.refDistance = component.refDistance;\n\t\t\tdata.rollOffFactor = component.rollOffFactor;\n\t\t\tdata.distanceModel = component.distanceModel;\n\t\t\tinstance = new SoundInstance3d(this._manager, sound, data);\n\t\t} else {\n\t\t\tinstance = new SoundInstance(this._manager, sound, data);\n\t\t}\n\t\tif (this._firstNode) {\n\t\t\tinstance.setExternalNodes(this._firstNode, this._lastNode);\n\t\t}\n\t\treturn instance;\n\t}\n\t_onInstancePlay(instance) {\n\t\tthis.fire('play', instance);\n\t\tthis._component.fire('play', this, instance);\n\t}\n\t_onInstancePause(instance) {\n\t\tthis.fire('pause', instance);\n\t\tthis._component.fire('pause', this, instance);\n\t}\n\t_onInstanceResume(instance) {\n\t\tthis.fire('resume', instance);\n\t\tthis._component.fire('resume', this, instance);\n\t}\n\t_onInstanceStop(instance) {\n\t\tconst idx = this.instances.indexOf(instance);\n\t\tif (idx !== -1) {\n\t\t\tthis.instances.splice(idx, 1);\n\t\t}\n\t\tthis.fire('stop', instance);\n\t\tthis._component.fire('stop', this, instance);\n\t}\n\t_onInstanceEnd(instance) {\n\t\tconst idx = this.instances.indexOf(instance);\n\t\tif (idx !== -1) {\n\t\t\tthis.instances.splice(idx, 1);\n\t\t}\n\t\tthis.fire('end', instance);\n\t\tthis._component.fire('end', this, instance);\n\t}\n\t_onAssetAdd(asset) {\n\t\tthis.load();\n\t}\n\t_onAssetLoad(asset) {\n\t\tthis.load();\n\t}\n\t_onAssetRemoved(asset) {\n\t\tasset.off('remove', this._onAssetRemoved, this);\n\t\tthis._assets.off(`add:${asset.id}`, this._onAssetAdd, this);\n\t\tthis.stop();\n\t}\n\tupdatePosition(position) {\n\t\tconst instances = this.instances;\n\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\tinstances[i].position = position;\n\t\t}\n\t}\n\tset asset(value) {\n\t\tconst old = this._asset;\n\t\tif (old) {\n\t\t\tthis._assets.off(`add:${old}`, this._onAssetAdd, this);\n\t\t\tconst oldAsset = this._assets.get(old);\n\t\t\tif (oldAsset) {\n\t\t\t\toldAsset.off('remove', this._onAssetRemoved, this);\n\t\t\t}\n\t\t}\n\t\tthis._asset = value;\n\t\tif (this._asset instanceof Asset) {\n\t\t\tthis._asset = this._asset.id;\n\t\t}\n\t\tif (this._hasAsset() && this._component.enabled && this._component.entity.enabled) {\n\t\t\tthis.load();\n\t\t}\n\t}\n\tget asset() {\n\t\treturn this._asset;\n\t}\n\tset autoPlay(value) {\n\t\tthis._autoPlay = !!value;\n\t}\n\tget autoPlay() {\n\t\treturn this._autoPlay;\n\t}\n\tset duration(value) {\n\t\tthis._duration = Math.max(0, Number(value) || 0) || null;\n\t\tif (!this._overlap) {\n\t\t\tconst instances = this.instances;\n\t\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\t\tinstances[i].duration = this._duration;\n\t\t\t}\n\t\t}\n\t}\n\tget duration() {\n\t\tlet assetDuration = 0;\n\t\tif (this._hasAsset()) {\n\t\t\tconst asset = this._assets.get(this._asset);\n\t\t\tassetDuration = asset != null && asset.resource ? asset.resource.duration : 0;\n\t\t}\n\t\tif (this._duration != null) {\n\t\t\treturn this._duration % (assetDuration || 1);\n\t\t}\n\t\treturn assetDuration;\n\t}\n\tget isLoaded() {\n\t\tif (this._hasAsset()) {\n\t\t\tconst asset = this._assets.get(this._asset);\n\t\t\tif (asset) {\n\t\t\t\treturn !!asset.resource;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tget isPaused() {\n\t\tconst instances = this.instances;\n\t\tconst len = instances.length;\n\t\tif (len === 0) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tif (!instances[i].isPaused) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tget isPlaying() {\n\t\tconst instances = this.instances;\n\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\tif (instances[i].isPlaying) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tget isStopped() {\n\t\tconst instances = this.instances;\n\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\tif (!instances[i].isStopped) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tset loop(value) {\n\t\tthis._loop = !!value;\n\t\tconst instances = this.instances;\n\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\tinstances[i].loop = this._loop;\n\t\t}\n\t}\n\tget loop() {\n\t\treturn this._loop;\n\t}\n\tset overlap(value) {\n\t\tthis._overlap = !!value;\n\t}\n\tget overlap() {\n\t\treturn this._overlap;\n\t}\n\tset pitch(value) {\n\t\tthis._pitch = Math.max(Number(value) || 0, 0.01);\n\t\tif (!this._overlap) {\n\t\t\tconst instances = this.instances;\n\t\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\t\tinstances[i].pitch = this.pitch * this._component.pitch;\n\t\t\t}\n\t\t}\n\t}\n\tget pitch() {\n\t\treturn this._pitch;\n\t}\n\tset startTime(value) {\n\t\tthis._startTime = Math.max(0, Number(value) || 0);\n\t\tif (!this._overlap) {\n\t\t\tconst instances = this.instances;\n\t\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\t\tinstances[i].startTime = this._startTime;\n\t\t\t}\n\t\t}\n\t}\n\tget startTime() {\n\t\treturn this._startTime;\n\t}\n\tset volume(value) {\n\t\tthis._volume = math.clamp(Number(value) || 0, 0, 1);\n\t\tif (!this._overlap) {\n\t\t\tconst instances = this.instances;\n\t\t\tfor (let i = 0, len = instances.length; i < len; i++) {\n\t\t\t\tinstances[i].volume = this._volume * this._component.volume;\n\t\t\t}\n\t\t}\n\t}\n\tget volume() {\n\t\treturn this._volume;\n\t}\n}\nSoundSlot.EVENT_PLAY = 'play';\nSoundSlot.EVENT_PAUSE = 'pause';\nSoundSlot.EVENT_RESUME = 'resume';\nSoundSlot.EVENT_STOP = 'stop';\nSoundSlot.EVENT_LOAD = 'load';\n\nexport { SoundSlot };\n","import { hasAudioContext } from '../../../platform/audio/capabilities.js';\nimport { Component } from '../component.js';\nimport { ComponentSystem } from '../system.js';\nimport { SoundComponent } from './component.js';\nimport { SoundComponentData } from './data.js';\n\nconst _schema = ['enabled'];\nclass SoundComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'sound';\n\t\tthis.ComponentType = SoundComponent;\n\t\tthis.DataType = SoundComponentData;\n\t\tthis.schema = _schema;\n\t\tthis.manager = app.soundManager;\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t}\n\tset volume(volume) {\n\t\tthis.manager.volume = volume;\n\t}\n\tget volume() {\n\t\treturn this.manager.volume;\n\t}\n\tget context() {\n\t\tif (!hasAudioContext()) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.manager.context;\n\t}\n\tinitializeComponentData(component, data, properties) {\n\t\tproperties = ['volume', 'pitch', 'positional', 'refDistance', 'maxDistance', 'rollOffFactor', 'distanceModel', 'slots'];\n\t\tfor (let i = 0; i < properties.length; i++) {\n\t\t\tif (data.hasOwnProperty(properties[i])) {\n\t\t\t\tcomponent[properties[i]] = data[properties[i]];\n\t\t\t}\n\t\t}\n\t\tsuper.initializeComponentData(component, data, ['enabled']);\n\t}\n\tcloneComponent(entity, clone) {\n\t\tconst srcComponent = entity.sound;\n\t\tconst srcSlots = srcComponent.slots;\n\t\tconst slots = {};\n\t\tfor (const key in srcSlots) {\n\t\t\tconst srcSlot = srcSlots[key];\n\t\t\tslots[key] = {\n\t\t\t\tname: srcSlot.name,\n\t\t\t\tvolume: srcSlot.volume,\n\t\t\t\tpitch: srcSlot.pitch,\n\t\t\t\tloop: srcSlot.loop,\n\t\t\t\tduration: srcSlot.duration,\n\t\t\t\tstartTime: srcSlot.startTime,\n\t\t\t\toverlap: srcSlot.overlap,\n\t\t\t\tautoPlay: srcSlot.autoPlay,\n\t\t\t\tasset: srcSlot.asset\n\t\t\t};\n\t\t}\n\t\tconst cloneData = {\n\t\t\tdistanceModel: srcComponent.distanceModel,\n\t\t\tenabled: srcComponent.enabled,\n\t\t\tmaxDistance: srcComponent.maxDistance,\n\t\t\tpitch: srcComponent.pitch,\n\t\t\tpositional: srcComponent.positional,\n\t\t\trefDistance: srcComponent.refDistance,\n\t\t\trollOffFactor: srcComponent.rollOffFactor,\n\t\t\tslots: slots,\n\t\t\tvolume: srcComponent.volume\n\t\t};\n\t\treturn this.addComponent(clone, cloneData);\n\t}\n\tonUpdate(dt) {\n\t\tconst store = this.store;\n\t\tfor (const id in store) {\n\t\t\tif (store.hasOwnProperty(id)) {\n\t\t\t\tconst item = store[id];\n\t\t\t\tconst entity = item.entity;\n\t\t\t\tif (entity.enabled) {\n\t\t\t\t\tconst component = entity.sound;\n\t\t\t\t\tif (component.enabled && component.positional) {\n\t\t\t\t\t\tconst position = entity.getPosition();\n\t\t\t\t\t\tconst slots = component.slots;\n\t\t\t\t\t\tfor (const key in slots) {\n\t\t\t\t\t\t\tslots[key].updatePosition(position);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tonBeforeRemove(entity, component) {\n\t\tconst slots = component.slots;\n\t\tfor (const key in slots) {\n\t\t\tif (!slots[key].overlap) {\n\t\t\t\tslots[key].stop();\n\t\t\t}\n\t\t}\n\t\tcomponent.onRemove();\n\t}\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t}\n}\nComponent._buildAccessors(SoundComponent.prototype, _schema);\n\nexport { SoundComponentSystem };\n","import { math } from '../../../core/math/math.js';\nimport { Color } from '../../../core/math/color.js';\nimport { Vec2 } from '../../../core/math/vec2.js';\nimport { Vec4 } from '../../../core/math/vec4.js';\nimport { LAYERID_WORLD, SPRITE_RENDERMODE_TILED, SPRITE_RENDERMODE_SLICED } from '../../../scene/constants.js';\nimport { BatchGroup } from '../../../scene/batching/batch-group.js';\nimport { GraphNode } from '../../../scene/graph-node.js';\nimport { MeshInstance } from '../../../scene/mesh-instance.js';\nimport { Model } from '../../../scene/model.js';\nimport { Component } from '../component.js';\nimport { SPRITETYPE_SIMPLE, SPRITETYPE_ANIMATED } from './constants.js';\nimport { SpriteAnimationClip } from './sprite-animation-clip.js';\n\nconst PARAM_EMISSIVE_MAP = 'texture_emissiveMap';\nconst PARAM_OPACITY_MAP = 'texture_opacityMap';\nconst PARAM_EMISSIVE = 'material_emissive';\nconst PARAM_OPACITY = 'material_opacity';\nconst PARAM_INNER_OFFSET = 'innerOffset';\nconst PARAM_OUTER_SCALE = 'outerScale';\nconst PARAM_ATLAS_RECT = 'atlasRect';\nclass SpriteComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._evtLayersChanged = null;\n\t\tthis._evtLayerAdded = null;\n\t\tthis._evtLayerRemoved = null;\n\t\tthis._type = SPRITETYPE_SIMPLE;\n\t\tthis._material = system.defaultMaterial;\n\t\tthis._color = new Color(1, 1, 1, 1);\n\t\tthis._colorUniform = new Float32Array(3);\n\t\tthis._speed = 1;\n\t\tthis._flipX = false;\n\t\tthis._flipY = false;\n\t\tthis._width = 1;\n\t\tthis._height = 1;\n\t\tthis._drawOrder = 0;\n\t\tthis._layers = [LAYERID_WORLD];\n\t\tthis._outerScale = new Vec2(1, 1);\n\t\tthis._outerScaleUniform = new Float32Array(2);\n\t\tthis._innerOffset = new Vec4();\n\t\tthis._innerOffsetUniform = new Float32Array(4);\n\t\tthis._atlasRect = new Vec4();\n\t\tthis._atlasRectUniform = new Float32Array(4);\n\t\tthis._batchGroupId = -1;\n\t\tthis._batchGroup = null;\n\t\tthis._node = new GraphNode();\n\t\tthis._model = new Model();\n\t\tthis._model.graph = this._node;\n\t\tthis._meshInstance = null;\n\t\tentity.addChild(this._model.graph);\n\t\tthis._model._entity = entity;\n\t\tthis._updateAabbFunc = this._updateAabb.bind(this);\n\t\tthis._addedModel = false;\n\t\tthis._autoPlayClip = null;\n\t\tthis._clips = {};\n\t\tthis._defaultClip = new SpriteAnimationClip(this, {\n\t\t\tname: this.entity.name,\n\t\t\tfps: 0,\n\t\t\tloop: false,\n\t\t\tspriteAsset: null\n\t\t});\n\t\tthis._currentClip = this._defaultClip;\n\t}\n\tset type(value) {\n\t\tif (this._type === value) {\n\t\t\treturn;\n\t\t}\n\t\tthis._type = value;\n\t\tif (this._type === SPRITETYPE_SIMPLE) {\n\t\t\tthis.stop();\n\t\t\tthis._currentClip = this._defaultClip;\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis._currentClip.frame = this.frame;\n\t\t\t\tif (this._currentClip.sprite) {\n\t\t\t\t\tthis._showModel();\n\t\t\t\t} else {\n\t\t\t\t\tthis._hideModel();\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (this._type === SPRITETYPE_ANIMATED) {\n\t\t\tthis.stop();\n\t\t\tif (this._autoPlayClip) {\n\t\t\t\tthis._tryAutoPlay();\n\t\t\t}\n\t\t\tif (this._currentClip && this._currentClip.isPlaying && this.enabled && this.entity.enabled) {\n\t\t\t\tthis._showModel();\n\t\t\t} else {\n\t\t\t\tthis._hideModel();\n\t\t\t}\n\t\t}\n\t}\n\tget type() {\n\t\treturn this._type;\n\t}\n\tset frame(value) {\n\t\tthis._currentClip.frame = value;\n\t}\n\tget frame() {\n\t\treturn this._currentClip.frame;\n\t}\n\tset spriteAsset(value) {\n\t\tthis._defaultClip.spriteAsset = value;\n\t}\n\tget spriteAsset() {\n\t\treturn this._defaultClip._spriteAsset;\n\t}\n\tset sprite(value) {\n\t\tthis._currentClip.sprite = value;\n\t}\n\tget sprite() {\n\t\treturn this._currentClip.sprite;\n\t}\n\tset material(value) {\n\t\tthis._material = value;\n\t\tif (this._meshInstance) {\n\t\t\tthis._meshInstance.material = value;\n\t\t}\n\t}\n\tget material() {\n\t\treturn this._material;\n\t}\n\tset color(value) {\n\t\tthis._color.r = value.r;\n\t\tthis._color.g = value.g;\n\t\tthis._color.b = value.b;\n\t\tif (this._meshInstance) {\n\t\t\tthis._colorUniform[0] = this._color.r;\n\t\t\tthis._colorUniform[1] = this._color.g;\n\t\t\tthis._colorUniform[2] = this._color.b;\n\t\t\tthis._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);\n\t\t}\n\t}\n\tget color() {\n\t\treturn this._color;\n\t}\n\tset opacity(value) {\n\t\tthis._color.a = value;\n\t\tif (this._meshInstance) {\n\t\t\tthis._meshInstance.setParameter(PARAM_OPACITY, value);\n\t\t}\n\t}\n\tget opacity() {\n\t\treturn this._color.a;\n\t}\n\tset clips(value) {\n\t\tif (!value) {\n\t\t\tfor (const name in this._clips) {\n\t\t\t\tthis.removeClip(name);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tfor (const name in this._clips) {\n\t\t\tlet found = false;\n\t\t\tfor (const key in value) {\n\t\t\t\tif (value[key].name === name) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tthis._clips[name].fps = value[key].fps;\n\t\t\t\t\tthis._clips[name].loop = value[key].loop;\n\t\t\t\t\tif (value[key].hasOwnProperty('sprite')) {\n\t\t\t\t\t\tthis._clips[name].sprite = value[key].sprite;\n\t\t\t\t\t} else if (value[key].hasOwnProperty('spriteAsset')) {\n\t\t\t\t\t\tthis._clips[name].spriteAsset = value[key].spriteAsset;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!found) {\n\t\t\t\tthis.removeClip(name);\n\t\t\t}\n\t\t}\n\t\tfor (const key in value) {\n\t\t\tif (this._clips[value[key].name]) continue;\n\t\t\tthis.addClip(value[key]);\n\t\t}\n\t\tif (this._autoPlayClip) {\n\t\t\tthis._tryAutoPlay();\n\t\t}\n\t\tif (!this._currentClip || !this._currentClip.sprite) {\n\t\t\tthis._hideModel();\n\t\t}\n\t}\n\tget clips() {\n\t\treturn this._clips;\n\t}\n\tget currentClip() {\n\t\treturn this._currentClip;\n\t}\n\tset speed(value) {\n\t\tthis._speed = value;\n\t}\n\tget speed() {\n\t\treturn this._speed;\n\t}\n\tset flipX(value) {\n\t\tif (this._flipX === value) return;\n\t\tthis._flipX = value;\n\t\tthis._updateTransform();\n\t}\n\tget flipX() {\n\t\treturn this._flipX;\n\t}\n\tset flipY(value) {\n\t\tif (this._flipY === value) return;\n\t\tthis._flipY = value;\n\t\tthis._updateTransform();\n\t}\n\tget flipY() {\n\t\treturn this._flipY;\n\t}\n\tset width(value) {\n\t\tif (value === this._width) return;\n\t\tthis._width = value;\n\t\tthis._outerScale.x = this._width;\n\t\tif (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {\n\t\t\tthis._updateTransform();\n\t\t}\n\t}\n\tget width() {\n\t\treturn this._width;\n\t}\n\tset height(value) {\n\t\tif (value === this._height) return;\n\t\tthis._height = value;\n\t\tthis._outerScale.y = this.height;\n\t\tif (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_TILED || this.sprite.renderMode === SPRITE_RENDERMODE_SLICED)) {\n\t\t\tthis._updateTransform();\n\t\t}\n\t}\n\tget height() {\n\t\treturn this._height;\n\t}\n\tset batchGroupId(value) {\n\t\tif (this._batchGroupId === value) {\n\t\t\treturn;\n\t\t}\n\t\tconst prev = this._batchGroupId;\n\t\tthis._batchGroupId = value;\n\t\tif (this.entity.enabled && prev >= 0) {\n\t\t\tvar _this$system$app$batc;\n\t\t\t(_this$system$app$batc = this.system.app.batcher) == null || _this$system$app$batc.remove(BatchGroup.SPRITE, prev, this.entity);\n\t\t}\n\t\tif (this.entity.enabled && value >= 0) {\n\t\t\tvar _this$system$app$batc2;\n\t\t\t(_this$system$app$batc2 = this.system.app.batcher) == null || _this$system$app$batc2.insert(BatchGroup.SPRITE, value, this.entity);\n\t\t} else {\n\t\t\tif (prev >= 0) {\n\t\t\t\tif (this._currentClip && this._currentClip.sprite && this.enabled && this.entity.enabled) {\n\t\t\t\t\tthis._showModel();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tget batchGroupId() {\n\t\treturn this._batchGroupId;\n\t}\n\tset autoPlayClip(value) {\n\t\tthis._autoPlayClip = value instanceof SpriteAnimationClip ? value.name : value;\n\t\tthis._tryAutoPlay();\n\t}\n\tget autoPlayClip() {\n\t\treturn this._autoPlayClip;\n\t}\n\tset drawOrder(value) {\n\t\tthis._drawOrder = value;\n\t\tif (this._meshInstance) {\n\t\t\tthis._meshInstance.drawOrder = value;\n\t\t}\n\t}\n\tget drawOrder() {\n\t\treturn this._drawOrder;\n\t}\n\tset layers(value) {\n\t\tif (this._addedModel) {\n\t\t\tthis._hideModel();\n\t\t}\n\t\tthis._layers = value;\n\t\tif (!this._meshInstance) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.enabled && this.entity.enabled) {\n\t\t\tthis._showModel();\n\t\t}\n\t}\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\tget aabb() {\n\t\tif (this._meshInstance) {\n\t\t\treturn this._meshInstance.aabb;\n\t\t}\n\t\treturn null;\n\t}\n\tonEnable() {\n\t\tconst app = this.system.app;\n\t\tconst scene = app.scene;\n\t\tconst layers = scene.layers;\n\t\tthis._evtLayersChanged = scene.on('set:layers', this._onLayersChanged, this);\n\t\tif (layers) {\n\t\t\tthis._evtLayerAdded = layers.on('add', this._onLayerAdded, this);\n\t\t\tthis._evtLayerRemoved = layers.on('remove', this._onLayerRemoved, this);\n\t\t}\n\t\tthis._showModel();\n\t\tif (this._autoPlayClip) {\n\t\t\tthis._tryAutoPlay();\n\t\t}\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tvar _app$batcher;\n\t\t\t(_app$batcher = app.batcher) == null || _app$batcher.insert(BatchGroup.SPRITE, this._batchGroupId, this.entity);\n\t\t}\n\t}\n\tonDisable() {\n\t\tvar _this$_evtLayersChang;\n\t\tconst app = this.system.app;\n\t\tconst scene = app.scene;\n\t\tconst layers = scene.layers;\n\t\t(_this$_evtLayersChang = this._evtLayersChanged) == null || _this$_evtLayersChang.off();\n\t\tthis._evtLayersChanged = null;\n\t\tif (layers) {\n\t\t\tvar _this$_evtLayerAdded, _this$_evtLayerRemove;\n\t\t\t(_this$_evtLayerAdded = this._evtLayerAdded) == null || _this$_evtLayerAdded.off();\n\t\t\tthis._evtLayerAdded = null;\n\t\t\t(_this$_evtLayerRemove = this._evtLayerRemoved) == null || _this$_evtLayerRemove.off();\n\t\t\tthis._evtLayerRemoved = null;\n\t\t}\n\t\tthis.stop();\n\t\tthis._hideModel();\n\t\tif (this._batchGroupId >= 0) {\n\t\t\tvar _app$batcher2;\n\t\t\t(_app$batcher2 = app.batcher) == null || _app$batcher2.remove(BatchGroup.SPRITE, this._batchGroupId, this.entity);\n\t\t}\n\t}\n\tonDestroy() {\n\t\tvar _this$_node;\n\t\tthis._currentClip = null;\n\t\tif (this._defaultClip) {\n\t\t\tthis._defaultClip._destroy();\n\t\t\tthis._defaultClip = null;\n\t\t}\n\t\tfor (const key in this._clips) {\n\t\t\tthis._clips[key]._destroy();\n\t\t}\n\t\tthis._clips = null;\n\t\tthis._hideModel();\n\t\tthis._model = null;\n\t\t(_this$_node = this._node) == null || _this$_node.remove();\n\t\tthis._node = null;\n\t\tif (this._meshInstance) {\n\t\t\tthis._meshInstance.material = null;\n\t\t\tthis._meshInstance.mesh = null;\n\t\t\tthis._meshInstance = null;\n\t\t}\n\t}\n\t_showModel() {\n\t\tif (this._addedModel) return;\n\t\tif (!this._meshInstance) return;\n\t\tconst meshInstances = [this._meshInstance];\n\t\tfor (let i = 0, len = this._layers.length; i < len; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this._layers[i]);\n\t\t\tif (layer) {\n\t\t\t\tlayer.addMeshInstances(meshInstances);\n\t\t\t}\n\t\t}\n\t\tthis._addedModel = true;\n\t}\n\t_hideModel() {\n\t\tif (!this._addedModel || !this._meshInstance) return;\n\t\tconst meshInstances = [this._meshInstance];\n\t\tfor (let i = 0, len = this._layers.length; i < len; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this._layers[i]);\n\t\t\tif (layer) {\n\t\t\t\tlayer.removeMeshInstances(meshInstances);\n\t\t\t}\n\t\t}\n\t\tthis._addedModel = false;\n\t}\n\t_showFrame(frame) {\n\t\tif (!this.sprite) return;\n\t\tconst mesh = this.sprite.meshes[frame];\n\t\tif (!mesh) {\n\t\t\tif (this._meshInstance) {\n\t\t\t\tthis._meshInstance.mesh = null;\n\t\t\t\tthis._meshInstance.visible = false;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tlet material;\n\t\tif (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED) {\n\t\t\tmaterial = this.system.default9SlicedMaterialSlicedMode;\n\t\t} else if (this.sprite.renderMode === SPRITE_RENDERMODE_TILED) {\n\t\t\tmaterial = this.system.default9SlicedMaterialTiledMode;\n\t\t} else {\n\t\t\tmaterial = this.system.defaultMaterial;\n\t\t}\n\t\tif (!this._meshInstance) {\n\t\t\tthis._meshInstance = new MeshInstance(mesh, this._material, this._node);\n\t\t\tthis._meshInstance.castShadow = false;\n\t\t\tthis._meshInstance.receiveShadow = false;\n\t\t\tthis._meshInstance.drawOrder = this._drawOrder;\n\t\t\tthis._model.meshInstances.push(this._meshInstance);\n\t\t\tthis._colorUniform[0] = this._color.r;\n\t\t\tthis._colorUniform[1] = this._color.g;\n\t\t\tthis._colorUniform[2] = this._color.b;\n\t\t\tthis._meshInstance.setParameter(PARAM_EMISSIVE, this._colorUniform);\n\t\t\tthis._meshInstance.setParameter(PARAM_OPACITY, this._color.a);\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis._showModel();\n\t\t\t}\n\t\t}\n\t\tif (this._meshInstance.material !== material) {\n\t\t\tthis._meshInstance.material = material;\n\t\t}\n\t\tif (this._meshInstance.mesh !== mesh) {\n\t\t\tthis._meshInstance.mesh = mesh;\n\t\t\tthis._meshInstance.visible = true;\n\t\t\tthis._meshInstance._aabbVer = -1;\n\t\t}\n\t\tif (this.sprite.atlas && this.sprite.atlas.texture) {\n\t\t\tthis._meshInstance.setParameter(PARAM_EMISSIVE_MAP, this.sprite.atlas.texture);\n\t\t\tthis._meshInstance.setParameter(PARAM_OPACITY_MAP, this.sprite.atlas.texture);\n\t\t} else {\n\t\t\tthis._meshInstance.deleteParameter(PARAM_EMISSIVE_MAP);\n\t\t\tthis._meshInstance.deleteParameter(PARAM_OPACITY_MAP);\n\t\t}\n\t\tif (this.sprite.atlas && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {\n\t\t\tthis._meshInstance._updateAabbFunc = this._updateAabbFunc;\n\t\t\tconst frameData = this.sprite.atlas.frames[this.sprite.frameKeys[frame]];\n\t\t\tif (frameData) {\n\t\t\t\tconst borderWidthScale = 2 / frameData.rect.z;\n\t\t\t\tconst borderHeightScale = 2 / frameData.rect.w;\n\t\t\t\tthis._innerOffset.set(frameData.border.x * borderWidthScale, frameData.border.y * borderHeightScale, frameData.border.z * borderWidthScale, frameData.border.w * borderHeightScale);\n\t\t\t\tconst tex = this.sprite.atlas.texture;\n\t\t\t\tthis._atlasRect.set(frameData.rect.x / tex.width, frameData.rect.y / tex.height, frameData.rect.z / tex.width, frameData.rect.w / tex.height);\n\t\t\t} else {\n\t\t\t\tthis._innerOffset.set(0, 0, 0, 0);\n\t\t\t}\n\t\t\tthis._innerOffsetUniform[0] = this._innerOffset.x;\n\t\t\tthis._innerOffsetUniform[1] = this._innerOffset.y;\n\t\t\tthis._innerOffsetUniform[2] = this._innerOffset.z;\n\t\t\tthis._innerOffsetUniform[3] = this._innerOffset.w;\n\t\t\tthis._meshInstance.setParameter(PARAM_INNER_OFFSET, this._innerOffsetUniform);\n\t\t\tthis._atlasRectUniform[0] = this._atlasRect.x;\n\t\t\tthis._atlasRectUniform[1] = this._atlasRect.y;\n\t\t\tthis._atlasRectUniform[2] = this._atlasRect.z;\n\t\t\tthis._atlasRectUniform[3] = this._atlasRect.w;\n\t\t\tthis._meshInstance.setParameter(PARAM_ATLAS_RECT, this._atlasRectUniform);\n\t\t} else {\n\t\t\tthis._meshInstance._updateAabbFunc = null;\n\t\t}\n\t\tthis._updateTransform();\n\t}\n\t_updateTransform() {\n\t\tlet scaleX = this.flipX ? -1 : 1;\n\t\tlet scaleY = this.flipY ? -1 : 1;\n\t\tlet posX = 0;\n\t\tlet posY = 0;\n\t\tif (this.sprite && (this.sprite.renderMode === SPRITE_RENDERMODE_SLICED || this.sprite.renderMode === SPRITE_RENDERMODE_TILED)) {\n\t\t\tlet w = 1;\n\t\t\tlet h = 1;\n\t\t\tif (this.sprite.atlas) {\n\t\t\t\tconst frameData = this.sprite.atlas.frames[this.sprite.frameKeys[this.frame]];\n\t\t\t\tif (frameData) {\n\t\t\t\t\tw = frameData.rect.z;\n\t\t\t\t\th = frameData.rect.w;\n\t\t\t\t\tposX = (0.5 - frameData.pivot.x) * this._width;\n\t\t\t\t\tposY = (0.5 - frameData.pivot.y) * this._height;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst scaleMulX = w / this.sprite.pixelsPerUnit;\n\t\t\tconst scaleMulY = h / this.sprite.pixelsPerUnit;\n\t\t\tthis._outerScale.set(Math.max(this._width, this._innerOffset.x * scaleMulX), Math.max(this._height, this._innerOffset.y * scaleMulY));\n\t\t\tscaleX *= scaleMulX;\n\t\t\tscaleY *= scaleMulY;\n\t\t\tthis._outerScale.x /= scaleMulX;\n\t\t\tthis._outerScale.y /= scaleMulY;\n\t\t\tscaleX *= math.clamp(this._width / (this._innerOffset.x * scaleMulX), 0.0001, 1);\n\t\t\tscaleY *= math.clamp(this._height / (this._innerOffset.y * scaleMulY), 0.0001, 1);\n\t\t\tif (this._meshInstance) {\n\t\t\t\tthis._outerScaleUniform[0] = this._outerScale.x;\n\t\t\t\tthis._outerScaleUniform[1] = this._outerScale.y;\n\t\t\t\tthis._meshInstance.setParameter(PARAM_OUTER_SCALE, this._outerScaleUniform);\n\t\t\t}\n\t\t}\n\t\tthis._node.setLocalScale(scaleX, scaleY, 1);\n\t\tthis._node.setLocalPosition(posX, posY, 0);\n\t}\n\t_updateAabb(aabb) {\n\t\taabb.center.set(0, 0, 0);\n\t\taabb.halfExtents.set(this._outerScale.x * 0.5, this._outerScale.y * 0.5, 0.001);\n\t\taabb.setFromTransformedAabb(aabb, this._node.getWorldTransform());\n\t\treturn aabb;\n\t}\n\t_tryAutoPlay() {\n\t\tif (!this._autoPlayClip) return;\n\t\tif (this.type !== SPRITETYPE_ANIMATED) return;\n\t\tconst clip = this._clips[this._autoPlayClip];\n\t\tif (clip && !clip.isPlaying && (!this._currentClip || !this._currentClip.isPlaying)) {\n\t\t\tif (this.enabled && this.entity.enabled) {\n\t\t\t\tthis.play(clip.name);\n\t\t\t}\n\t\t}\n\t}\n\t_onLayersChanged(oldComp, newComp) {\n\t\toldComp.off('add', this.onLayerAdded, this);\n\t\toldComp.off('remove', this.onLayerRemoved, this);\n\t\tnewComp.on('add', this.onLayerAdded, this);\n\t\tnewComp.on('remove', this.onLayerRemoved, this);\n\t\tif (this.enabled && this.entity.enabled) {\n\t\t\tthis._showModel();\n\t\t}\n\t}\n\t_onLayerAdded(layer) {\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tif (this._addedModel && this.enabled && this.entity.enabled && this._meshInstance) {\n\t\t\tlayer.addMeshInstances([this._meshInstance]);\n\t\t}\n\t}\n\t_onLayerRemoved(layer) {\n\t\tif (!this._meshInstance) return;\n\t\tconst index = this.layers.indexOf(layer.id);\n\t\tif (index < 0) return;\n\t\tlayer.removeMeshInstances([this._meshInstance]);\n\t}\n\tremoveModelFromLayers() {\n\t\tfor (let i = 0; i < this.layers.length; i++) {\n\t\t\tconst layer = this.system.app.scene.layers.getLayerById(this.layers[i]);\n\t\t\tif (!layer) continue;\n\t\t\tlayer.removeMeshInstances([this._meshInstance]);\n\t\t}\n\t}\n\taddClip(data) {\n\t\tconst clip = new SpriteAnimationClip(this, {\n\t\t\tname: data.name,\n\t\t\tfps: data.fps,\n\t\t\tloop: data.loop,\n\t\t\tspriteAsset: data.spriteAsset\n\t\t});\n\t\tthis._clips[data.name] = clip;\n\t\tif (clip.name && clip.name === this._autoPlayClip) {\n\t\t\tthis._tryAutoPlay();\n\t\t}\n\t\treturn clip;\n\t}\n\tremoveClip(name) {\n\t\tdelete this._clips[name];\n\t}\n\tclip(name) {\n\t\treturn this._clips[name];\n\t}\n\tplay(name) {\n\t\tconst clip = this._clips[name];\n\t\tconst current = this._currentClip;\n\t\tif (current && current !== clip) {\n\t\t\tcurrent._playing = false;\n\t\t}\n\t\tthis._currentClip = clip;\n\t\tif (this._currentClip) {\n\t\t\tthis._currentClip = clip;\n\t\t\tthis._currentClip.play();\n\t\t}\n\t\treturn clip;\n\t}\n\tpause() {\n\t\tif (this._currentClip === this._defaultClip) return;\n\t\tif (this._currentClip.isPlaying) {\n\t\t\tthis._currentClip.pause();\n\t\t}\n\t}\n\tresume() {\n\t\tif (this._currentClip === this._defaultClip) return;\n\t\tif (this._currentClip.isPaused) {\n\t\t\tthis._currentClip.resume();\n\t\t}\n\t}\n\tstop() {\n\t\tif (this._currentClip === this._defaultClip) return;\n\t\tthis._currentClip.stop();\n\t}\n}\nSpriteComponent.EVENT_PLAY = 'play';\nSpriteComponent.EVENT_PAUSE = 'pause';\nSpriteComponent.EVENT_RESUME = 'resume';\nSpriteComponent.EVENT_STOP = 'stop';\nSpriteComponent.EVENT_END = 'end';\nSpriteComponent.EVENT_LOOP = 'loop';\n\nexport { SpriteComponent };\n","const SPRITETYPE_SIMPLE = 'simple';\nconst SPRITETYPE_ANIMATED = 'animated';\n\nexport { SPRITETYPE_ANIMATED, SPRITETYPE_SIMPLE };\n","class SpriteComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n}\n\nexport { SpriteComponentData };\n","import { EventHandler } from '../../../core/event-handler.js';\nimport { math } from '../../../core/math/math.js';\nimport { Asset } from '../../asset/asset.js';\nimport { SPRITE_RENDERMODE_SIMPLE } from '../../../scene/constants.js';\n\nclass SpriteAnimationClip extends EventHandler {\n\tconstructor(component, data) {\n\t\tsuper();\n\t\tthis._evtSetMeshes = null;\n\t\tthis._component = component;\n\t\tthis._frame = 0;\n\t\tthis._sprite = null;\n\t\tthis._spriteAsset = null;\n\t\tthis.spriteAsset = data.spriteAsset;\n\t\tthis.name = data.name;\n\t\tthis.fps = data.fps || 0;\n\t\tthis.loop = data.loop || false;\n\t\tthis._playing = false;\n\t\tthis._paused = false;\n\t\tthis._time = 0;\n\t}\n\tget duration() {\n\t\tif (this._sprite) {\n\t\t\tconst fps = this.fps || Number.MIN_VALUE;\n\t\t\treturn this._sprite.frameKeys.length / Math.abs(fps);\n\t\t}\n\t\treturn 0;\n\t}\n\tset frame(value) {\n\t\tthis._setFrame(value);\n\t\tconst fps = this.fps || Number.MIN_VALUE;\n\t\tthis._setTime(this._frame / fps);\n\t}\n\tget frame() {\n\t\treturn this._frame;\n\t}\n\tget isPaused() {\n\t\treturn this._paused;\n\t}\n\tget isPlaying() {\n\t\treturn this._playing;\n\t}\n\tset sprite(value) {\n\t\tif (this._sprite) {\n\t\t\tvar _this$_evtSetMeshes;\n\t\t\t(_this$_evtSetMeshes = this._evtSetMeshes) == null || _this$_evtSetMeshes.off();\n\t\t\tthis._evtSetMeshes = null;\n\t\t\tthis._sprite.off('set:pixelsPerUnit', this._onSpritePpuChanged, this);\n\t\t\tthis._sprite.off('set:atlas', this._onSpriteMeshesChange, this);\n\t\t\tif (this._sprite.atlas) {\n\t\t\t\tthis._sprite.atlas.off('set:texture', this._onSpriteMeshesChange, this);\n\t\t\t}\n\t\t}\n\t\tthis._sprite = value;\n\t\tif (this._sprite) {\n\t\t\tthis._evtSetMeshes = this._sprite.on('set:meshes', this._onSpriteMeshesChange, this);\n\t\t\tthis._sprite.on('set:pixelsPerUnit', this._onSpritePpuChanged, this);\n\t\t\tthis._sprite.on('set:atlas', this._onSpriteMeshesChange, this);\n\t\t\tif (this._sprite.atlas) {\n\t\t\t\tthis._sprite.atlas.on('set:texture', this._onSpriteMeshesChange, this);\n\t\t\t}\n\t\t}\n\t\tif (this._component.currentClip === this) {\n\t\t\tlet mi;\n\t\t\tif (!value || !value.atlas) {\n\t\t\t\tmi = this._component._meshInstance;\n\t\t\t\tif (mi) {\n\t\t\t\t\tmi.deleteParameter('texture_emissiveMap');\n\t\t\t\t\tmi.deleteParameter('texture_opacityMap');\n\t\t\t\t}\n\t\t\t\tthis._component._hideModel();\n\t\t\t} else {\n\t\t\t\tif (value.atlas.texture) {\n\t\t\t\t\tmi = this._component._meshInstance;\n\t\t\t\t\tif (mi) {\n\t\t\t\t\t\tmi.setParameter('texture_emissiveMap', value.atlas.texture);\n\t\t\t\t\t\tmi.setParameter('texture_opacityMap', value.atlas.texture);\n\t\t\t\t\t}\n\t\t\t\t\tif (this._component.enabled && this._component.entity.enabled) {\n\t\t\t\t\t\tthis._component._showModel();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (this.time && this.fps) {\n\t\t\t\t\tthis.time = this.time;\n\t\t\t\t} else {\n\t\t\t\t\tthis.frame = this.frame;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tget sprite() {\n\t\treturn this._sprite;\n\t}\n\tset spriteAsset(value) {\n\t\tconst assets = this._component.system.app.assets;\n\t\tlet id = value;\n\t\tif (value instanceof Asset) {\n\t\t\tid = value.id;\n\t\t}\n\t\tif (this._spriteAsset !== id) {\n\t\t\tif (this._spriteAsset) {\n\t\t\t\tconst prev = assets.get(this._spriteAsset);\n\t\t\t\tif (prev) {\n\t\t\t\t\tthis._unbindSpriteAsset(prev);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._spriteAsset = id;\n\t\t\tif (this._spriteAsset) {\n\t\t\t\tconst asset = assets.get(this._spriteAsset);\n\t\t\t\tif (!asset) {\n\t\t\t\t\tthis.sprite = null;\n\t\t\t\t\tassets.on(`add:${this._spriteAsset}`, this._onSpriteAssetAdded, this);\n\t\t\t\t} else {\n\t\t\t\t\tthis._bindSpriteAsset(asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.sprite = null;\n\t\t\t}\n\t\t}\n\t}\n\tget spriteAsset() {\n\t\treturn this._spriteAsset;\n\t}\n\tset time(value) {\n\t\tthis._setTime(value);\n\t\tif (this._sprite) {\n\t\t\tthis.frame = Math.min(this._sprite.frameKeys.length - 1, Math.floor(this._time * Math.abs(this.fps)));\n\t\t} else {\n\t\t\tthis.frame = 0;\n\t\t}\n\t}\n\tget time() {\n\t\treturn this._time;\n\t}\n\t_onSpriteAssetAdded(asset) {\n\t\tthis._component.system.app.assets.off(`add:${asset.id}`, this._onSpriteAssetAdded, this);\n\t\tif (this._spriteAsset === asset.id) {\n\t\t\tthis._bindSpriteAsset(asset);\n\t\t}\n\t}\n\t_bindSpriteAsset(asset) {\n\t\tasset.on('load', this._onSpriteAssetLoad, this);\n\t\tasset.on('remove', this._onSpriteAssetRemove, this);\n\t\tif (asset.resource) {\n\t\t\tthis._onSpriteAssetLoad(asset);\n\t\t} else {\n\t\t\tthis._component.system.app.assets.load(asset);\n\t\t}\n\t}\n\t_unbindSpriteAsset(asset) {\n\t\tif (!asset) {\n\t\t\treturn;\n\t\t}\n\t\tasset.off('load', this._onSpriteAssetLoad, this);\n\t\tasset.off('remove', this._onSpriteAssetRemove, this);\n\t\tif (asset.resource && !asset.resource.atlas) {\n\t\t\tthis._component.system.app.assets.off(`load:${asset.data.textureAtlasAsset}`, this._onTextureAtlasLoad, this);\n\t\t}\n\t}\n\t_onSpriteAssetLoad(asset) {\n\t\tif (!asset.resource) {\n\t\t\tthis.sprite = null;\n\t\t} else {\n\t\t\tif (!asset.resource.atlas) {\n\t\t\t\tconst atlasAssetId = asset.data.textureAtlasAsset;\n\t\t\t\tconst assets = this._component.system.app.assets;\n\t\t\t\tassets.off(`load:${atlasAssetId}`, this._onTextureAtlasLoad, this);\n\t\t\t\tassets.once(`load:${atlasAssetId}`, this._onTextureAtlasLoad, this);\n\t\t\t} else {\n\t\t\t\tthis.sprite = asset.resource;\n\t\t\t}\n\t\t}\n\t}\n\t_onTextureAtlasLoad(atlasAsset) {\n\t\tconst spriteAsset = this._spriteAsset;\n\t\tif (spriteAsset instanceof Asset) {\n\t\t\tthis._onSpriteAssetLoad(spriteAsset);\n\t\t} else {\n\t\t\tthis._onSpriteAssetLoad(this._component.system.app.assets.get(spriteAsset));\n\t\t}\n\t}\n\t_onSpriteAssetRemove(asset) {\n\t\tthis.sprite = null;\n\t}\n\t_onSpriteMeshesChange() {\n\t\tif (this._component.currentClip === this) {\n\t\t\tthis._component._showFrame(this.frame);\n\t\t}\n\t}\n\t_onSpritePpuChanged() {\n\t\tif (this._component.currentClip === this) {\n\t\t\tif (this.sprite.renderMode !== SPRITE_RENDERMODE_SIMPLE) {\n\t\t\t\tthis._component._showFrame(this.frame);\n\t\t\t}\n\t\t}\n\t}\n\t_update(dt) {\n\t\tif (this.fps === 0) return;\n\t\tif (!this._playing || this._paused || !this._sprite) return;\n\t\tconst dir = this.fps < 0 ? -1 : 1;\n\t\tconst time = this._time + dt * this._component.speed * dir;\n\t\tconst duration = this.duration;\n\t\tconst end = time > duration || time < 0;\n\t\tthis._setTime(time);\n\t\tlet frame = this.frame;\n\t\tif (this._sprite) {\n\t\t\tframe = Math.floor(this._sprite.frameKeys.length * this._time / duration);\n\t\t} else {\n\t\t\tframe = 0;\n\t\t}\n\t\tif (frame !== this._frame) {\n\t\t\tthis._setFrame(frame);\n\t\t}\n\t\tif (end) {\n\t\t\tif (this.loop) {\n\t\t\t\tthis.fire('loop');\n\t\t\t\tthis._component.fire('loop', this);\n\t\t\t} else {\n\t\t\t\tthis._playing = false;\n\t\t\t\tthis._paused = false;\n\t\t\t\tthis.fire('end');\n\t\t\t\tthis._component.fire('end', this);\n\t\t\t}\n\t\t}\n\t}\n\t_setTime(value) {\n\t\tthis._time = value;\n\t\tconst duration = this.duration;\n\t\tif (this._time < 0) {\n\t\t\tif (this.loop) {\n\t\t\t\tthis._time = this._time % duration + duration;\n\t\t\t} else {\n\t\t\t\tthis._time = 0;\n\t\t\t}\n\t\t} else if (this._time > duration) {\n\t\t\tif (this.loop) {\n\t\t\t\tthis._time %= duration;\n\t\t\t} else {\n\t\t\t\tthis._time = duration;\n\t\t\t}\n\t\t}\n\t}\n\t_setFrame(value) {\n\t\tif (this._sprite) {\n\t\t\tthis._frame = math.clamp(value, 0, this._sprite.frameKeys.length - 1);\n\t\t} else {\n\t\t\tthis._frame = value;\n\t\t}\n\t\tif (this._component.currentClip === this) {\n\t\t\tthis._component._showFrame(this._frame);\n\t\t}\n\t}\n\t_destroy() {\n\t\tif (this._spriteAsset) {\n\t\t\tconst assets = this._component.system.app.assets;\n\t\t\tthis._unbindSpriteAsset(assets.get(this._spriteAsset));\n\t\t}\n\t\tif (this._sprite) {\n\t\t\tthis.sprite = null;\n\t\t}\n\t\tif (this._spriteAsset) {\n\t\t\tthis.spriteAsset = null;\n\t\t}\n\t}\n\tplay() {\n\t\tif (this._playing) {\n\t\t\treturn;\n\t\t}\n\t\tthis._playing = true;\n\t\tthis._paused = false;\n\t\tthis.frame = 0;\n\t\tthis.fire('play');\n\t\tthis._component.fire('play', this);\n\t}\n\tpause() {\n\t\tif (!this._playing || this._paused) {\n\t\t\treturn;\n\t\t}\n\t\tthis._paused = true;\n\t\tthis.fire('pause');\n\t\tthis._component.fire('pause', this);\n\t}\n\tresume() {\n\t\tif (!this._paused) return;\n\t\tthis._paused = false;\n\t\tthis.fire('resume');\n\t\tthis._component.fire('resume', this);\n\t}\n\tstop() {\n\t\tif (!this._playing) return;\n\t\tthis._playing = false;\n\t\tthis._paused = false;\n\t\tthis._time = 0;\n\t\tthis.frame = 0;\n\t\tthis.fire('stop');\n\t\tthis._component.fire('stop', this);\n\t}\n}\nSpriteAnimationClip.EVENT_PLAY = 'play';\nSpriteAnimationClip.EVENT_PAUSE = 'pause';\nSpriteAnimationClip.EVENT_RESUME = 'resume';\nSpriteAnimationClip.EVENT_STOP = 'stop';\nSpriteAnimationClip.EVENT_END = 'end';\nSpriteAnimationClip.EVENT_LOOP = 'loop';\n\nexport { SpriteAnimationClip };\n","import { Color } from '../../../core/math/color.js';\nimport { PIXELFORMAT_RGBA8, CULLFACE_NONE } from '../../../platform/graphics/constants.js';\nimport { Texture } from '../../../platform/graphics/texture.js';\nimport { BLEND_PREMULTIPLIED, SPRITE_RENDERMODE_SLICED, SPRITE_RENDERMODE_TILED } from '../../../scene/constants.js';\nimport { StandardMaterial } from '../../../scene/materials/standard-material.js';\nimport { Component } from '../component.js';\nimport { ComponentSystem } from '../system.js';\nimport { SpriteComponent } from './component.js';\nimport { SpriteComponentData } from './data.js';\n\nconst _schema = ['enabled'];\nclass SpriteComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'sprite';\n\t\tthis.ComponentType = SpriteComponent;\n\t\tthis.DataType = SpriteComponentData;\n\t\tthis.schema = _schema;\n\t\tthis._defaultTexture = null;\n\t\tthis._defaultMaterial = null;\n\t\tthis._default9SlicedMaterialSlicedMode = null;\n\t\tthis._default9SlicedMaterialTiledMode = null;\n\t\tthis.app.systems.on('update', this.onUpdate, this);\n\t\tthis.on('beforeremove', this.onBeforeRemove, this);\n\t}\n\tset defaultMaterial(material) {\n\t\tthis._defaultMaterial = material;\n\t}\n\tget defaultMaterial() {\n\t\tif (!this._defaultMaterial) {\n\t\t\tconst texture = new Texture(this.app.graphicsDevice, {\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1,\n\t\t\t\tformat: PIXELFORMAT_RGBA8,\n\t\t\t\tname: 'sprite'\n\t\t\t});\n\t\t\tconst pixels = new Uint8Array(texture.lock());\n\t\t\tpixels[0] = pixels[1] = pixels[2] = pixels[3] = 255;\n\t\t\ttexture.unlock();\n\t\t\tconst material = new StandardMaterial();\n\t\t\tmaterial.diffuse.set(0, 0, 0);\n\t\t\tmaterial.emissive.set(0.5, 0.5, 0.5);\n\t\t\tmaterial.emissiveMap = texture;\n\t\t\tmaterial.emissiveTint = true;\n\t\t\tmaterial.opacityMap = texture;\n\t\t\tmaterial.opacityMapChannel = 'a';\n\t\t\tmaterial.opacityTint = true;\n\t\t\tmaterial.opacity = 0;\n\t\t\tmaterial.useLighting = false;\n\t\t\tmaterial.useGammaTonemap = false;\n\t\t\tmaterial.useFog = false;\n\t\t\tmaterial.useSkybox = false;\n\t\t\tmaterial.blendType = BLEND_PREMULTIPLIED;\n\t\t\tmaterial.depthWrite = false;\n\t\t\tmaterial.pixelSnap = false;\n\t\t\tmaterial.cull = CULLFACE_NONE;\n\t\t\tmaterial.update();\n\t\t\tthis._defaultTexture = texture;\n\t\t\tthis._defaultMaterial = material;\n\t\t}\n\t\treturn this._defaultMaterial;\n\t}\n\tset default9SlicedMaterialSlicedMode(material) {\n\t\tthis._default9SlicedMaterialSlicedMode = material;\n\t}\n\tget default9SlicedMaterialSlicedMode() {\n\t\tif (!this._default9SlicedMaterialSlicedMode) {\n\t\t\tconst material = this.defaultMaterial.clone();\n\t\t\tmaterial.nineSlicedMode = SPRITE_RENDERMODE_SLICED;\n\t\t\tmaterial.update();\n\t\t\tthis._default9SlicedMaterialSlicedMode = material;\n\t\t}\n\t\treturn this._default9SlicedMaterialSlicedMode;\n\t}\n\tset default9SlicedMaterialTiledMode(material) {\n\t\tthis._default9SlicedMaterialTiledMode = material;\n\t}\n\tget default9SlicedMaterialTiledMode() {\n\t\tif (!this._default9SlicedMaterialTiledMode) {\n\t\t\tconst material = this.defaultMaterial.clone();\n\t\t\tmaterial.nineSlicedMode = SPRITE_RENDERMODE_TILED;\n\t\t\tmaterial.update();\n\t\t\tthis._default9SlicedMaterialTiledMode = material;\n\t\t}\n\t\treturn this._default9SlicedMaterialTiledMode;\n\t}\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.app.systems.off('update', this.onUpdate, this);\n\t\tif (this._defaultTexture) {\n\t\t\tthis._defaultTexture.destroy();\n\t\t\tthis._defaultTexture = null;\n\t\t}\n\t}\n\tinitializeComponentData(component, data, properties) {\n\t\tif (data.enabled !== undefined) {\n\t\t\tcomponent.enabled = data.enabled;\n\t\t}\n\t\tcomponent.type = data.type;\n\t\tif (data.layers && Array.isArray(data.layers)) {\n\t\t\tcomponent.layers = data.layers.slice(0);\n\t\t}\n\t\tif (data.drawOrder !== undefined) {\n\t\t\tcomponent.drawOrder = data.drawOrder;\n\t\t}\n\t\tif (data.color !== undefined) {\n\t\t\tif (data.color instanceof Color) {\n\t\t\t\tvar _data$opacity;\n\t\t\t\tcomponent.color.set(data.color.r, data.color.g, data.color.b, (_data$opacity = data.opacity) != null ? _data$opacity : 1);\n\t\t\t} else {\n\t\t\t\tvar _data$opacity2;\n\t\t\t\tcomponent.color.set(data.color[0], data.color[1], data.color[2], (_data$opacity2 = data.opacity) != null ? _data$opacity2 : 1);\n\t\t\t}\n\t\t\tcomponent.color = component.color;\n\t\t}\n\t\tif (data.opacity !== undefined) {\n\t\t\tcomponent.opacity = data.opacity;\n\t\t}\n\t\tif (data.flipX !== undefined) {\n\t\t\tcomponent.flipX = data.flipX;\n\t\t}\n\t\tif (data.flipY !== undefined) {\n\t\t\tcomponent.flipY = data.flipY;\n\t\t}\n\t\tif (data.width !== undefined) {\n\t\t\tcomponent.width = data.width;\n\t\t}\n\t\tif (data.height !== undefined) {\n\t\t\tcomponent.height = data.height;\n\t\t}\n\t\tif (data.spriteAsset !== undefined) {\n\t\t\tcomponent.spriteAsset = data.spriteAsset;\n\t\t}\n\t\tif (data.sprite) {\n\t\t\tcomponent.sprite = data.sprite;\n\t\t}\n\t\tif (data.frame !== undefined) {\n\t\t\tcomponent.frame = data.frame;\n\t\t}\n\t\tif (data.clips) {\n\t\t\tfor (const name in data.clips) {\n\t\t\t\tcomponent.addClip(data.clips[name]);\n\t\t\t}\n\t\t}\n\t\tif (data.speed !== undefined) {\n\t\t\tcomponent.speed = data.speed;\n\t\t}\n\t\tif (data.autoPlayClip) {\n\t\t\tcomponent.autoPlayClip = data.autoPlayClip;\n\t\t}\n\t\tcomponent.batchGroupId = data.batchGroupId === undefined || data.batchGroupId === null ? -1 : data.batchGroupId;\n\t\tsuper.initializeComponentData(component, data, properties);\n\t}\n\tcloneComponent(entity, clone) {\n\t\tconst source = entity.sprite;\n\t\treturn this.addComponent(clone, {\n\t\t\tenabled: source.enabled,\n\t\t\ttype: source.type,\n\t\t\tspriteAsset: source.spriteAsset,\n\t\t\tsprite: source.sprite,\n\t\t\twidth: source.width,\n\t\t\theight: source.height,\n\t\t\tframe: source.frame,\n\t\t\tcolor: source.color.clone(),\n\t\t\topacity: source.opacity,\n\t\t\tflipX: source.flipX,\n\t\t\tflipY: source.flipY,\n\t\t\tspeed: source.speed,\n\t\t\tclips: source.clips,\n\t\t\tautoPlayClip: source.autoPlayClip,\n\t\t\tbatchGroupId: source.batchGroupId,\n\t\t\tdrawOrder: source.drawOrder,\n\t\t\tlayers: source.layers.slice(0)\n\t\t});\n\t}\n\tonUpdate(dt) {\n\t\tconst components = this.store;\n\t\tfor (const id in components) {\n\t\t\tif (components.hasOwnProperty(id)) {\n\t\t\t\tconst component = components[id];\n\t\t\t\tif (component.data.enabled && component.entity.enabled) {\n\t\t\t\t\tconst sprite = component.entity.sprite;\n\t\t\t\t\tif (sprite._currentClip) {\n\t\t\t\t\t\tsprite._currentClip._update(dt);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tonBeforeRemove(entity, component) {\n\t\tcomponent.onDestroy();\n\t}\n}\nComponent._buildAccessors(SpriteComponent.prototype, _schema);\n\nexport { SpriteComponentSystem };\n","import { EventHandler } from '../../core/event-handler.js';\nimport { Color } from '../../core/math/color.js';\nimport { Vec2 } from '../../core/math/vec2.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { Vec4 } from '../../core/math/vec4.js';\n\nclass ComponentSystem extends EventHandler {\n\tconstructor(app) {\n\t\tsuper();\n\t\tthis.app = app;\n\t\tthis.store = {};\n\t\tthis.schema = [];\n\t}\n\taddComponent(entity, data = {}) {\n\t\tconst component = new this.ComponentType(this, entity);\n\t\tconst componentData = new this.DataType();\n\t\tthis.store[entity.getGuid()] = {\n\t\t\tentity: entity,\n\t\t\tdata: componentData\n\t\t};\n\t\tentity[this.id] = component;\n\t\tentity.c[this.id] = component;\n\t\tthis.initializeComponentData(component, data, []);\n\t\tthis.fire('add', entity, component);\n\t\treturn component;\n\t}\n\tremoveComponent(entity) {\n\t\tconst record = this.store[entity.getGuid()];\n\t\tconst component = entity.c[this.id];\n\t\tcomponent.fire('beforeremove');\n\t\tthis.fire('beforeremove', entity, component);\n\t\tdelete this.store[entity.getGuid()];\n\t\tentity[this.id] = undefined;\n\t\tdelete entity.c[this.id];\n\t\tthis.fire('remove', entity, record.data);\n\t}\n\tcloneComponent(entity, clone) {\n\t\tconst src = this.store[entity.getGuid()];\n\t\treturn this.addComponent(clone, src.data);\n\t}\n\tinitializeComponentData(component, data = {}, properties) {\n\t\tfor (let i = 0, len = properties.length; i < len; i++) {\n\t\t\tconst descriptor = properties[i];\n\t\t\tlet name, type;\n\t\t\tif (typeof descriptor === 'object') {\n\t\t\t\tname = descriptor.name;\n\t\t\t\ttype = descriptor.type;\n\t\t\t} else {\n\t\t\t\tname = descriptor;\n\t\t\t\ttype = undefined;\n\t\t\t}\n\t\t\tlet value = data[name];\n\t\t\tif (value !== undefined) {\n\t\t\t\tif (type !== undefined) {\n\t\t\t\t\tvalue = convertValue(value, type);\n\t\t\t\t}\n\t\t\t\tcomponent[name] = value;\n\t\t\t} else {\n\t\t\t\tcomponent[name] = component.data[name];\n\t\t\t}\n\t\t}\n\t\tif (component.enabled && component.entity.enabled) {\n\t\t\tcomponent.onEnable();\n\t\t}\n\t}\n\tgetPropertiesOfType(type) {\n\t\tconst matchingProperties = [];\n\t\tconst schema = this.schema || [];\n\t\tschema.forEach(descriptor => {\n\t\t\tif (descriptor && typeof descriptor === 'object' && descriptor.type === type) {\n\t\t\t\tmatchingProperties.push(descriptor);\n\t\t\t}\n\t\t});\n\t\treturn matchingProperties;\n\t}\n\tdestroy() {\n\t\tthis.off();\n\t}\n}\nfunction convertValue(value, type) {\n\tif (!value) {\n\t\treturn value;\n\t}\n\tswitch (type) {\n\t\tcase 'rgb':\n\t\t\tif (value instanceof Color) {\n\t\t\t\treturn value.clone();\n\t\t\t}\n\t\t\treturn new Color(value[0], value[1], value[2]);\n\t\tcase 'rgba':\n\t\t\tif (value instanceof Color) {\n\t\t\t\treturn value.clone();\n\t\t\t}\n\t\t\treturn new Color(value[0], value[1], value[2], value[3]);\n\t\tcase 'vec2':\n\t\t\tif (value instanceof Vec2) {\n\t\t\t\treturn value.clone();\n\t\t\t}\n\t\t\treturn new Vec2(value[0], value[1]);\n\t\tcase 'vec3':\n\t\t\tif (value instanceof Vec3) {\n\t\t\t\treturn value.clone();\n\t\t\t}\n\t\t\treturn new Vec3(value[0], value[1], value[2]);\n\t\tcase 'vec4':\n\t\t\tif (value instanceof Vec4) {\n\t\t\t\treturn value.clone();\n\t\t\t}\n\t\t\treturn new Vec4(value[0], value[1], value[2], value[3]);\n\t\tcase 'boolean':\n\t\tcase 'number':\n\t\tcase 'string':\n\t\t\treturn value;\n\t\tcase 'entity':\n\t\t\treturn value;\n\t\tdefault:\n\t\t\tthrow new Error(`Could not convert unhandled type: ${type}`);\n\t}\n}\n\nexport { ComponentSystem };\n","import { Vec3 } from '../../../core/math/vec3.js';\nimport { Component } from '../component.js';\n\nclass ZoneComponent extends Component {\n\tconstructor(system, entity) {\n\t\tsuper(system, entity);\n\t\tthis._oldState = true;\n\t\tthis._size = new Vec3();\n\t\tthis.on('set_enabled', this._onSetEnabled, this);\n\t}\n\tset size(data) {\n\t\tif (data instanceof Vec3) {\n\t\t\tthis._size.copy(data);\n\t\t} else if (data instanceof Array && data.length >= 3) {\n\t\t\tthis.size.set(data[0], data[1], data[2]);\n\t\t}\n\t}\n\tget size() {\n\t\treturn this._size;\n\t}\n\tonEnable() {\n\t\tthis._checkState();\n\t}\n\tonDisable() {\n\t\tthis._checkState();\n\t}\n\t_onSetEnabled(prop, old, value) {\n\t\tthis._checkState();\n\t}\n\t_checkState() {\n\t\tconst state = this.enabled && this.entity.enabled;\n\t\tif (state === this._oldState) {\n\t\t\treturn;\n\t\t}\n\t\tthis._oldState = state;\n\t\tthis.fire('enable');\n\t\tthis.fire('state', this.enabled);\n\t}\n\t_onBeforeRemove() {\n\t\tthis.fire('remove');\n\t}\n}\nZoneComponent.EVENT_ENABLE = 'enable';\nZoneComponent.EVENT_DISABLE = 'disable';\nZoneComponent.EVENT_STATE = 'state';\nZoneComponent.EVENT_REMOVE = 'remove';\n\nexport { ZoneComponent };\n","class ZoneComponentData {\n\tconstructor() {\n\t\tthis.enabled = true;\n\t}\n}\n\nexport { ZoneComponentData };\n","import { Vec3 } from '../../../core/math/vec3.js';\nimport { Component } from '../component.js';\nimport { ComponentSystem } from '../system.js';\nimport { ZoneComponent } from './component.js';\nimport { ZoneComponentData } from './data.js';\n\nconst _schema = ['enabled'];\nclass ZoneComponentSystem extends ComponentSystem {\n\tconstructor(app) {\n\t\tsuper(app);\n\t\tthis.id = 'zone';\n\t\tthis.ComponentType = ZoneComponent;\n\t\tthis.DataType = ZoneComponentData;\n\t\tthis.schema = _schema;\n\t\tthis.on('beforeremove', this._onBeforeRemove, this);\n\t}\n\tinitializeComponentData(component, data, properties) {\n\t\tcomponent.enabled = data.hasOwnProperty('enabled') ? !!data.enabled : true;\n\t\tif (data.size) {\n\t\t\tif (data.size instanceof Vec3) {\n\t\t\t\tcomponent.size.copy(data.size);\n\t\t\t} else if (data.size instanceof Array && data.size.length >= 3) {\n\t\t\t\tcomponent.size.set(data.size[0], data.size[1], data.size[2]);\n\t\t\t}\n\t\t}\n\t}\n\tcloneComponent(entity, clone) {\n\t\tconst data = {\n\t\t\tsize: entity.zone.size\n\t\t};\n\t\treturn this.addComponent(clone, data);\n\t}\n\t_onBeforeRemove(entity, component) {\n\t\tcomponent._onBeforeRemove();\n\t}\n}\nComponent._buildAccessors(ZoneComponent.prototype, _schema);\n\nexport { ZoneComponentSystem };\n","const FILLMODE_NONE = 'NONE';\nconst FILLMODE_FILL_WINDOW = 'FILL_WINDOW';\nconst FILLMODE_KEEP_ASPECT = 'KEEP_ASPECT';\nconst RESOLUTION_AUTO = 'AUTO';\nconst RESOLUTION_FIXED = 'FIXED';\n\nexport { FILLMODE_FILL_WINDOW, FILLMODE_KEEP_ASPECT, FILLMODE_NONE, RESOLUTION_AUTO, RESOLUTION_FIXED };\n","import { guid } from '../core/guid.js';\nimport { GraphNode } from '../scene/graph-node.js';\nimport { getApplication } from './globals.js';\n\nconst _enableList = [];\nclass Entity extends GraphNode {\n\tconstructor(name, app = getApplication()) {\n\t\tsuper(name);\n\t\tthis.anim = void 0;\n\t\tthis.animation = void 0;\n\t\tthis.audiolistener = void 0;\n\t\tthis.button = void 0;\n\t\tthis.camera = void 0;\n\t\tthis.collision = void 0;\n\t\tthis.element = void 0;\n\t\tthis.gsplat = void 0;\n\t\tthis.layoutchild = void 0;\n\t\tthis.layoutgroup = void 0;\n\t\tthis.light = void 0;\n\t\tthis.model = void 0;\n\t\tthis.particlesystem = void 0;\n\t\tthis.render = void 0;\n\t\tthis.rigidbody = void 0;\n\t\tthis.screen = void 0;\n\t\tthis.script = void 0;\n\t\tthis.scrollbar = void 0;\n\t\tthis.scrollview = void 0;\n\t\tthis.sound = void 0;\n\t\tthis.sprite = void 0;\n\t\tthis.c = {};\n\t\tthis._app = void 0;\n\t\tthis._destroying = false;\n\t\tthis._guid = null;\n\t\tthis._template = false;\n\t\tthis._app = app;\n\t}\n\taddComponent(type, data) {\n\t\tconst system = this._app.systems[type];\n\t\tif (!system) {\n\t\t\treturn null;\n\t\t}\n\t\tif (this.c[type]) {\n\t\t\treturn null;\n\t\t}\n\t\treturn system.addComponent(this, data);\n\t}\n\tremoveComponent(type) {\n\t\tconst system = this._app.systems[type];\n\t\tif (!system) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this.c[type]) {\n\t\t\treturn;\n\t\t}\n\t\tsystem.removeComponent(this);\n\t}\n\tfindComponent(type) {\n\t\tconst entity = this.findOne(node => {\n\t\t\treturn node.c && node.c[type];\n\t\t});\n\t\treturn entity && entity.c[type];\n\t}\n\tfindComponents(type) {\n\t\tconst entities = this.find(node => {\n\t\t\treturn node.c && node.c[type];\n\t\t});\n\t\treturn entities.map(entity => {\n\t\t\treturn entity.c[type];\n\t\t});\n\t}\n\tfindScript(nameOrType) {\n\t\tconst entity = this.findOne(node => {\n\t\t\tvar _node$c;\n\t\t\treturn (_node$c = node.c) == null || (_node$c = _node$c.script) == null ? void 0 : _node$c.has(nameOrType);\n\t\t});\n\t\treturn entity == null ? void 0 : entity.c.script.get(nameOrType);\n\t}\n\tfindScripts(nameOrType) {\n\t\tconst entities = this.find(node => {\n\t\t\tvar _node$c2;\n\t\t\treturn (_node$c2 = node.c) == null || (_node$c2 = _node$c2.script) == null ? void 0 : _node$c2.has(nameOrType);\n\t\t});\n\t\treturn entities.map(entity => entity.c.script.get(nameOrType));\n\t}\n\tgetGuid() {\n\t\tif (!this._guid) {\n\t\t\tthis.setGuid(guid.create());\n\t\t}\n\t\treturn this._guid;\n\t}\n\tsetGuid(guid) {\n\t\tconst index = this._app._entityIndex;\n\t\tif (this._guid) {\n\t\t\tdelete index[this._guid];\n\t\t}\n\t\tthis._guid = guid;\n\t\tindex[this._guid] = this;\n\t}\n\t_notifyHierarchyStateChanged(node, enabled) {\n\t\tlet enableFirst = false;\n\t\tif (node === this && _enableList.length === 0) {\n\t\t\tenableFirst = true;\n\t\t}\n\t\tnode._beingEnabled = true;\n\t\tnode._onHierarchyStateChanged(enabled);\n\t\tif (node._onHierarchyStatePostChanged) {\n\t\t\t_enableList.push(node);\n\t\t}\n\t\tconst c = node._children;\n\t\tfor (let i = 0, len = c.length; i < len; i++) {\n\t\t\tif (c[i]._enabled) {\n\t\t\t\tthis._notifyHierarchyStateChanged(c[i], enabled);\n\t\t\t}\n\t\t}\n\t\tnode._beingEnabled = false;\n\t\tif (enableFirst) {\n\t\t\tfor (let i = 0; i < _enableList.length; i++) {\n\t\t\t\t_enableList[i]._onHierarchyStatePostChanged();\n\t\t\t}\n\t\t\t_enableList.length = 0;\n\t\t}\n\t}\n\t_onHierarchyStateChanged(enabled) {\n\t\tsuper._onHierarchyStateChanged(enabled);\n\t\tconst components = this.c;\n\t\tfor (const type in components) {\n\t\t\tif (components.hasOwnProperty(type)) {\n\t\t\t\tconst component = components[type];\n\t\t\t\tif (component.enabled) {\n\t\t\t\t\tif (enabled) {\n\t\t\t\t\t\tcomponent.onEnable();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomponent.onDisable();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t_onHierarchyStatePostChanged() {\n\t\tconst components = this.c;\n\t\tfor (const type in components) {\n\t\t\tif (components.hasOwnProperty(type)) {\n\t\t\t\tcomponents[type].onPostStateChange();\n\t\t\t}\n\t\t}\n\t}\n\tfindByGuid(guid) {\n\t\tif (this._guid === guid) return this;\n\t\tconst e = this._app._entityIndex[guid];\n\t\tif (e && (e === this || e.isDescendantOf(this))) {\n\t\t\treturn e;\n\t\t}\n\t\treturn null;\n\t}\n\tdestroy() {\n\t\tthis._destroying = true;\n\t\tfor (const name in this.c) {\n\t\t\tthis.c[name].enabled = false;\n\t\t}\n\t\tfor (const name in this.c) {\n\t\t\tthis.c[name].system.removeComponent(this);\n\t\t}\n\t\tsuper.destroy();\n\t\tif (this._guid) {\n\t\t\tdelete this._app._entityIndex[this._guid];\n\t\t}\n\t\tthis._destroying = false;\n\t}\n\tclone() {\n\t\tconst duplicatedIdsMap = {};\n\t\tconst clone = this._cloneRecursively(duplicatedIdsMap);\n\t\tduplicatedIdsMap[this.getGuid()] = clone;\n\t\tresolveDuplicatedEntityReferenceProperties(this, this, clone, duplicatedIdsMap);\n\t\treturn clone;\n\t}\n\t_cloneRecursively(duplicatedIdsMap) {\n\t\tconst clone = new this.constructor(undefined, this._app);\n\t\tsuper._cloneInternal(clone);\n\t\tfor (const type in this.c) {\n\t\t\tconst component = this.c[type];\n\t\t\tcomponent.system.cloneComponent(this, clone);\n\t\t}\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tconst oldChild = this._children[i];\n\t\t\tif (oldChild instanceof Entity) {\n\t\t\t\tconst newChild = oldChild._cloneRecursively(duplicatedIdsMap);\n\t\t\t\tclone.addChild(newChild);\n\t\t\t\tduplicatedIdsMap[oldChild.getGuid()] = newChild;\n\t\t\t}\n\t\t}\n\t\treturn clone;\n\t}\n}\nEntity.EVENT_DESTROY = 'destroy';\nfunction resolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, oldEntity, newEntity, duplicatedIdsMap) {\n\tif (oldEntity instanceof Entity) {\n\t\tconst components = oldEntity.c;\n\t\tfor (const componentName in components) {\n\t\t\tconst component = components[componentName];\n\t\t\tconst entityProperties = component.system.getPropertiesOfType('entity');\n\t\t\tfor (let i = 0, len = entityProperties.length; i < len; i++) {\n\t\t\t\tconst propertyDescriptor = entityProperties[i];\n\t\t\t\tconst propertyName = propertyDescriptor.name;\n\t\t\t\tconst oldEntityReferenceId = component[propertyName];\n\t\t\t\tconst entityIsWithinOldSubtree = !!oldSubtreeRoot.findByGuid(oldEntityReferenceId);\n\t\t\t\tif (entityIsWithinOldSubtree) {\n\t\t\t\t\tconst newEntityReferenceId = duplicatedIdsMap[oldEntityReferenceId].getGuid();\n\t\t\t\t\tif (newEntityReferenceId) {\n\t\t\t\t\t\tnewEntity.c[componentName][propertyName] = newEntityReferenceId;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (components.script && !newEntity._app.useLegacyScriptAttributeCloning) {\n\t\t\tnewEntity.script.resolveDuplicatedEntityReferenceProperties(components.script, duplicatedIdsMap);\n\t\t}\n\t\tif (components.render) {\n\t\t\tnewEntity.render.resolveDuplicatedEntityReferenceProperties(components.render, duplicatedIdsMap);\n\t\t}\n\t\tif (components.button) {\n\t\t\tnewEntity.button.resolveDuplicatedEntityReferenceProperties(components.button, duplicatedIdsMap);\n\t\t}\n\t\tif (components.scrollview) {\n\t\t\tnewEntity.scrollview.resolveDuplicatedEntityReferenceProperties(components.scrollview, duplicatedIdsMap);\n\t\t}\n\t\tif (components.scrollbar) {\n\t\t\tnewEntity.scrollbar.resolveDuplicatedEntityReferenceProperties(components.scrollbar, duplicatedIdsMap);\n\t\t}\n\t\tif (components.anim) {\n\t\t\tnewEntity.anim.resolveDuplicatedEntityReferenceProperties(components.anim, duplicatedIdsMap);\n\t\t}\n\t\tconst _old = oldEntity.children.filter(e => {\n\t\t\treturn e instanceof Entity;\n\t\t});\n\t\tconst _new = newEntity.children.filter(e => {\n\t\t\treturn e instanceof Entity;\n\t\t});\n\t\tfor (let i = 0, len = _old.length; i < len; i++) {\n\t\t\tresolveDuplicatedEntityReferenceProperties(oldSubtreeRoot, _old[i], _new[i], duplicatedIdsMap);\n\t\t}\n\t}\n}\n\nexport { Entity };\n","const FONT_MSDF = 'msdf';\nconst FONT_BITMAP = 'bitmap';\n\nexport { FONT_BITMAP, FONT_MSDF };\n","import { FONT_MSDF } from './constants.js';\n\nclass Font {\n\tconstructor(textures, data) {\n\t\tthis.type = data ? data.type || FONT_MSDF : FONT_MSDF;\n\t\tthis.em = 1;\n\t\tthis.textures = textures;\n\t\tthis.intensity = 0.0;\n\t\tthis._data = null;\n\t\tthis.data = data;\n\t}\n\tset data(value) {\n\t\tthis._data = value;\n\t\tif (!value) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._data.intensity !== undefined) {\n\t\t\tthis.intensity = this._data.intensity;\n\t\t}\n\t\tif (!this._data.info) {\n\t\t\tthis._data.info = {};\n\t\t}\n\t\tif (!this._data.version || this._data.version < 2) {\n\t\t\tthis._data.info.maps = [{\n\t\t\t\twidth: this._data.info.width,\n\t\t\t\theight: this._data.info.height\n\t\t\t}];\n\t\t\tif (this._data.chars) {\n\t\t\t\tfor (const key in this._data.chars) {\n\t\t\t\t\tthis._data.chars[key].map = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tget data() {\n\t\treturn this._data;\n\t}\n}\n\nexport { Font };\n","let currentApplication;\nfunction getApplication() {\n\treturn currentApplication;\n}\nfunction setApplication(app) {\n\tcurrentApplication = app;\n}\n\nexport { getApplication, setApplication };\n","import { Vec2 } from '../../core/math/vec2.js';\nimport { CapsuleGeometry } from '../../scene/geometry/capsule-geometry.js';\nimport { ConeGeometry } from '../../scene/geometry/cone-geometry.js';\nimport { CylinderGeometry } from '../../scene/geometry/cylinder-geometry.js';\nimport { TorusGeometry } from '../../scene/geometry/torus-geometry.js';\nimport { Mesh } from '../../scene/mesh.js';\nimport { BoxGeometry } from '../../scene/geometry/box-geometry.js';\nimport { SphereGeometry } from '../../scene/geometry/sphere-geometry.js';\nimport { PlaneGeometry } from '../../scene/geometry/plane-geometry.js';\n\nconst shapePrimitives = [];\nfunction getShapePrimitive(device, type) {\n\tlet primData = null;\n\tfor (let i = 0; i < shapePrimitives.length; i++) {\n\t\tif (shapePrimitives[i].type === type && shapePrimitives[i].device === device) {\n\t\t\tprimData = shapePrimitives[i].primData;\n\t\t}\n\t}\n\tif (!primData) {\n\t\tlet mesh, area;\n\t\tswitch (type) {\n\t\t\tcase 'box':\n\t\t\t\tmesh = Mesh.fromGeometry(device, new BoxGeometry());\n\t\t\t\tarea = {\n\t\t\t\t\tx: 2,\n\t\t\t\t\ty: 2,\n\t\t\t\t\tz: 2,\n\t\t\t\t\tuv: 2.0 / 3\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tcase 'capsule':\n\t\t\t\tmesh = Mesh.fromGeometry(device, new CapsuleGeometry({\n\t\t\t\t\tradius: 0.5,\n\t\t\t\t\theight: 2\n\t\t\t\t}));\n\t\t\t\tarea = {\n\t\t\t\t\tx: Math.PI * 2,\n\t\t\t\t\ty: Math.PI,\n\t\t\t\t\tz: Math.PI * 2,\n\t\t\t\t\tuv: 1.0 / 3 + 1.0 / 3 / 3 * 2\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tcase 'cone':\n\t\t\t\tmesh = Mesh.fromGeometry(device, new ConeGeometry({\n\t\t\t\t\tbaseRadius: 0.5,\n\t\t\t\t\tpeakRadius: 0,\n\t\t\t\t\theight: 1\n\t\t\t\t}));\n\t\t\t\tarea = {\n\t\t\t\t\tx: 2.54,\n\t\t\t\t\ty: 2.54,\n\t\t\t\t\tz: 2.54,\n\t\t\t\t\tuv: 1.0 / 3 + 1.0 / 3 / 3\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tcase 'cylinder':\n\t\t\t\tmesh = Mesh.fromGeometry(device, new CylinderGeometry({\n\t\t\t\t\tradius: 0.5,\n\t\t\t\t\theight: 1\n\t\t\t\t}));\n\t\t\t\tarea = {\n\t\t\t\t\tx: Math.PI,\n\t\t\t\t\ty: 0.79 * 2,\n\t\t\t\t\tz: Math.PI,\n\t\t\t\t\tuv: 1.0 / 3 + 1.0 / 3 / 3 * 2\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tcase 'plane':\n\t\t\t\tmesh = Mesh.fromGeometry(device, new PlaneGeometry({\n\t\t\t\t\thalfExtents: new Vec2(0.5, 0.5),\n\t\t\t\t\twidthSegments: 1,\n\t\t\t\t\tlengthSegments: 1\n\t\t\t\t}));\n\t\t\t\tarea = {\n\t\t\t\t\tx: 0,\n\t\t\t\t\ty: 1,\n\t\t\t\t\tz: 0,\n\t\t\t\t\tuv: 1\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tcase 'sphere':\n\t\t\t\tmesh = Mesh.fromGeometry(device, new SphereGeometry({\n\t\t\t\t\tradius: 0.5\n\t\t\t\t}));\n\t\t\t\tarea = {\n\t\t\t\t\tx: Math.PI,\n\t\t\t\t\ty: Math.PI,\n\t\t\t\t\tz: Math.PI,\n\t\t\t\t\tuv: 1\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tcase 'torus':\n\t\t\t\tmesh = Mesh.fromGeometry(device, new TorusGeometry({\n\t\t\t\t\ttubeRadius: 0.2,\n\t\t\t\t\tringRadius: 0.3\n\t\t\t\t}));\n\t\t\t\tarea = {\n\t\t\t\t\tx: Math.PI * 0.5 * 0.5 - Math.PI * 0.1 * 0.1,\n\t\t\t\t\ty: 0.4,\n\t\t\t\t\tz: 0.4,\n\t\t\t\t\tuv: 1\n\t\t\t\t};\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Invalid primitive type: ${type}`);\n\t\t}\n\t\tmesh.incRefCount();\n\t\tprimData = {\n\t\t\tmesh: mesh,\n\t\t\tarea: area\n\t\t};\n\t\tshapePrimitives.push({\n\t\t\ttype: type,\n\t\t\tdevice: device,\n\t\t\tprimData: primData\n\t\t});\n\t}\n\treturn primData;\n}\n\nexport { getShapePrimitive };\n","import { Http, http } from '../../platform/net/http.js';\nimport { AnimCurve } from '../anim/evaluator/anim-curve.js';\nimport { AnimData } from '../anim/evaluator/anim-data.js';\nimport { AnimTrack } from '../anim/evaluator/anim-track.js';\nimport { ResourceHandler } from './handler.js';\n\nclass AnimClipHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'animclip');\n\t}\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\t\tconst options = {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t};\n\t\tif (url.load.startsWith('blob:')) {\n\t\t\toptions.responseType = Http.ResponseType.JSON;\n\t\t}\n\t\thttp.get(url.load, options, (err, response) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(`Error loading animation clip resource: ${url.original} [${err}]`);\n\t\t\t} else {\n\t\t\t\tcallback(null, response);\n\t\t\t}\n\t\t});\n\t}\n\topen(url, data) {\n\t\tconst name = data.name;\n\t\tconst duration = data.duration;\n\t\tconst inputs = data.inputs.map(input => {\n\t\t\treturn new AnimData(1, input);\n\t\t});\n\t\tconst outputs = data.outputs.map(output => {\n\t\t\treturn new AnimData(output.components, output.data);\n\t\t});\n\t\tconst curves = data.curves.map(curve => {\n\t\t\treturn new AnimCurve([curve.path], curve.inputIndex, curve.outputIndex, curve.interpolation);\n\t\t});\n\t\treturn new AnimTrack(name, duration, inputs, outputs, curves);\n\t}\n}\n\nexport { AnimClipHandler };\n","import { Http, http } from '../../platform/net/http.js';\nimport { AnimStateGraph } from '../anim/state-graph/anim-state-graph.js';\nimport { ResourceHandler } from './handler.js';\n\nclass AnimStateGraphHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'animstategraph');\n\t}\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\t\tconst options = {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t};\n\t\tif (url.load.startsWith('blob:')) {\n\t\t\toptions.responseType = Http.ResponseType.JSON;\n\t\t}\n\t\thttp.get(url.load, options, (err, response) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(`Error loading animation state graph resource: ${url.original} [${err}]`);\n\t\t\t} else {\n\t\t\t\tcallback(null, response);\n\t\t\t}\n\t\t});\n\t}\n\topen(url, data) {\n\t\treturn new AnimStateGraph(data);\n\t}\n}\n\nexport { AnimStateGraphHandler };\n","import { path } from '../../core/path.js';\nimport { Quat } from '../../core/math/quat.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { Http, http } from '../../platform/net/http.js';\nimport { Animation, Node, Key } from '../../scene/animation/animation.js';\nimport { AnimEvents } from '../anim/evaluator/anim-events.js';\nimport { GlbParser } from '../parsers/glb-parser.js';\nimport { ResourceHandler } from './handler.js';\n\nclass AnimationHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'animation');\n\t\tthis.device = app.graphicsDevice;\n\t\tthis.assets = app.assets;\n\t}\n\tload(url, callback, asset) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\t\tconst options = {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t};\n\t\tif (url.load.startsWith('blob:') || url.load.startsWith('data:')) {\n\t\t\tif (path.getExtension(url.original).toLowerCase() === '.glb') {\n\t\t\t\toptions.responseType = Http.ResponseType.ARRAY_BUFFER;\n\t\t\t} else {\n\t\t\t\toptions.responseType = Http.ResponseType.JSON;\n\t\t\t}\n\t\t}\n\t\thttp.get(url.load, options, (err, response) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(`Error loading animation resource: ${url.original} [${err}]`);\n\t\t\t} else {\n\t\t\t\tif (path.getExtension(url.original).toLowerCase() === '.glb') {\n\t\t\t\t\tvar _asset$options;\n\t\t\t\t\tGlbParser.parse('filename.glb', '', response, this.device, this.assets, (_asset$options = asset == null ? void 0 : asset.options) != null ? _asset$options : {}, (err, parseResult) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tvar _asset$data;\n\t\t\t\t\t\t\tconst animations = parseResult.animations;\n\t\t\t\t\t\t\tif (asset != null && (_asset$data = asset.data) != null && _asset$data.events) {\n\t\t\t\t\t\t\t\tfor (let i = 0; i < animations.length; i++) {\n\t\t\t\t\t\t\t\t\tanimations[i].events = new AnimEvents(Object.values(asset.data.events));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tparseResult.destroy();\n\t\t\t\t\t\t\tcallback(null, animations);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcallback(null, this[`_parseAnimationV${response.animation.version}`](response));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\topen(url, data, asset) {\n\t\treturn data;\n\t}\n\t_parseAnimationV3(data) {\n\t\tconst animData = data.animation;\n\t\tconst anim = new Animation();\n\t\tanim.name = animData.name;\n\t\tanim.duration = animData.duration;\n\t\tfor (let i = 0; i < animData.nodes.length; i++) {\n\t\t\tconst node = new Node();\n\t\t\tconst n = animData.nodes[i];\n\t\t\tnode._name = n.name;\n\t\t\tfor (let j = 0; j < n.keys.length; j++) {\n\t\t\t\tconst k = n.keys[j];\n\t\t\t\tconst t = k.time;\n\t\t\t\tconst p = k.pos;\n\t\t\t\tconst r = k.rot;\n\t\t\t\tconst s = k.scale;\n\t\t\t\tconst pos = new Vec3(p[0], p[1], p[2]);\n\t\t\t\tconst rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);\n\t\t\t\tconst scl = new Vec3(s[0], s[1], s[2]);\n\t\t\t\tconst key = new Key(t, pos, rot, scl);\n\t\t\t\tnode._keys.push(key);\n\t\t\t}\n\t\t\tanim.addNode(node);\n\t\t}\n\t\treturn anim;\n\t}\n\t_parseAnimationV4(data) {\n\t\tconst animData = data.animation;\n\t\tconst anim = new Animation();\n\t\tanim.name = animData.name;\n\t\tanim.duration = animData.duration;\n\t\tfor (let i = 0; i < animData.nodes.length; i++) {\n\t\t\tconst node = new Node();\n\t\t\tconst n = animData.nodes[i];\n\t\t\tnode._name = n.name;\n\t\t\tconst defPos = n.defaults.p;\n\t\t\tconst defRot = n.defaults.r;\n\t\t\tconst defScl = n.defaults.s;\n\t\t\tfor (let j = 0; j < n.keys.length; j++) {\n\t\t\t\tconst k = n.keys[j];\n\t\t\t\tconst t = k.t;\n\t\t\t\tconst p = defPos ? defPos : k.p;\n\t\t\t\tconst r = defRot ? defRot : k.r;\n\t\t\t\tconst s = defScl ? defScl : k.s;\n\t\t\t\tconst pos = new Vec3(p[0], p[1], p[2]);\n\t\t\t\tconst rot = new Quat().setFromEulerAngles(r[0], r[1], r[2]);\n\t\t\t\tconst scl = new Vec3(s[0], s[1], s[2]);\n\t\t\t\tconst key = new Key(t, pos, rot, scl);\n\t\t\t\tnode._keys.push(key);\n\t\t\t}\n\t\t\tanim.addNode(node);\n\t\t}\n\t\treturn anim;\n\t}\n}\n\nexport { AnimationHandler };\n","import { path } from '../../core/path.js';\nimport { Http, http } from '../../platform/net/http.js';\nimport { hasAudioContext } from '../../platform/audio/capabilities.js';\nimport { Sound } from '../../platform/sound/sound.js';\nimport { ResourceHandler } from './handler.js';\n\nconst ie = function () {\n\tif (typeof window === 'undefined') {\n\t\treturn false;\n\t}\n\tconst ua = window.navigator.userAgent;\n\tconst msie = ua.indexOf('MSIE ');\n\tif (msie > 0) {\n\t\treturn parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n\t}\n\tconst trident = ua.indexOf('Trident/');\n\tif (trident > 0) {\n\t\tconst rv = ua.indexOf('rv:');\n\t\treturn parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n\t}\n\treturn false;\n}();\nconst supportedExtensions = ['.ogg', '.mp3', '.wav', '.mp4a', '.m4a', '.mp4', '.aac', '.opus'];\nclass AudioHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'audio');\n\t\tthis.manager = app.soundManager;\n\t}\n\t_isSupported(url) {\n\t\tconst ext = path.getExtension(url);\n\t\treturn supportedExtensions.indexOf(ext) > -1;\n\t}\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\t\tconst success = function success(resource) {\n\t\t\tcallback(null, new Sound(resource));\n\t\t};\n\t\tconst error = function error(err) {\n\t\t\tlet msg = `Error loading audio url: ${url.original}`;\n\t\t\tif (err) {\n\t\t\t\tmsg += `: ${err.message || err}`;\n\t\t\t}\n\t\t\tconsole.warn(msg);\n\t\t\tcallback(msg);\n\t\t};\n\t\tif (this._createSound) {\n\t\t\tif (!this._isSupported(url.original)) {\n\t\t\t\terror(`Audio format for ${url.original} not supported`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._createSound(url.load, success, error);\n\t\t} else {\n\t\t\terror(null);\n\t\t}\n\t}\n\t_createSound(url, success, error) {\n\t\tif (hasAudioContext()) {\n\t\t\tconst manager = this.manager;\n\t\t\tif (!manager.context) {\n\t\t\t\terror('Audio manager has no audio context');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst options = {\n\t\t\t\tretry: this.maxRetries > 0,\n\t\t\t\tmaxRetries: this.maxRetries\n\t\t\t};\n\t\t\tif (url.startsWith('blob:') || url.startsWith('data:')) {\n\t\t\t\toptions.responseType = Http.ResponseType.ARRAY_BUFFER;\n\t\t\t}\n\t\t\thttp.get(url, options, (err, response) => {\n\t\t\t\tif (err) {\n\t\t\t\t\terror(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmanager.context.decodeAudioData(response, success, error);\n\t\t\t});\n\t\t} else {\n\t\t\tlet audio = null;\n\t\t\ttry {\n\t\t\t\taudio = new Audio();\n\t\t\t} catch (e) {\n\t\t\t\terror('No support for Audio element');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (ie) {\n\t\t\t\tdocument.body.appendChild(audio);\n\t\t\t}\n\t\t\tconst onReady = function onReady() {\n\t\t\t\taudio.removeEventListener('canplaythrough', onReady);\n\t\t\t\tif (ie) {\n\t\t\t\t\tdocument.body.removeChild(audio);\n\t\t\t\t}\n\t\t\t\tsuccess(audio);\n\t\t\t};\n\t\t\taudio.onerror = function () {\n\t\t\t\taudio.onerror = null;\n\t\t\t\tif (ie) {\n\t\t\t\t\tdocument.body.removeChild(audio);\n\t\t\t\t}\n\t\t\t\terror();\n\t\t\t};\n\t\t\taudio.addEventListener('canplaythrough', onReady);\n\t\t\taudio.src = url;\n\t\t}\n\t}\n}\n\nexport { AudioHandler };\n","function BasisWorker() {\n\tconst BASIS_FORMAT = {\n\t\tcTFETC1: 0,\n\t\tcTFETC2: 1,\n\t\tcTFBC1: 2,\n\t\tcTFBC3: 3,\n\t\tcTFPVRTC1_4_RGB: 8,\n\t\tcTFPVRTC1_4_RGBA: 9,\n\t\tcTFASTC_4x4: 10,\n\t\tcTFATC_RGB: 11,\n\t\tcTFATC_RGBA_INTERPOLATED_ALPHA: 12,\n\t\tcTFRGBA32: 13,\n\t\tcTFRGB565: 14,\n\t\tcTFRGBA4444: 16\n\t};\n\tconst opaqueMapping = {\n\t\tastc: BASIS_FORMAT.cTFASTC_4x4,\n\t\tdxt: BASIS_FORMAT.cTFBC1,\n\t\tetc1: BASIS_FORMAT.cTFETC1,\n\t\tetc2: BASIS_FORMAT.cTFETC1,\n\t\tpvr: BASIS_FORMAT.cTFPVRTC1_4_RGB,\n\t\tatc: BASIS_FORMAT.cTFATC_RGB,\n\t\tnone: BASIS_FORMAT.cTFRGB565\n\t};\n\tconst alphaMapping = {\n\t\tastc: BASIS_FORMAT.cTFASTC_4x4,\n\t\tdxt: BASIS_FORMAT.cTFBC3,\n\t\tetc1: BASIS_FORMAT.cTFRGBA4444,\n\t\tetc2: BASIS_FORMAT.cTFETC2,\n\t\tpvr: BASIS_FORMAT.cTFPVRTC1_4_RGBA,\n\t\tatc: BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA,\n\t\tnone: BASIS_FORMAT.cTFRGBA4444\n\t};\n\tconst PIXEL_FORMAT = {\n\t\tETC1: 21,\n\t\tETC2_RGB: 22,\n\t\tETC2_RGBA: 23,\n\t\tDXT1: 8,\n\t\tDXT5: 10,\n\t\tPVRTC_4BPP_RGB_1: 26,\n\t\tPVRTC_4BPP_RGBA_1: 27,\n\t\tASTC_4x4: 28,\n\t\tATC_RGB: 29,\n\t\tATC_RGBA: 30,\n\t\tR8_G8_B8_A8: 7,\n\t\tR5_G6_B5: 3,\n\t\tR4_G4_B4_A4: 5\n\t};\n\tconst basisToEngineMapping = (basisFormat, deviceDetails) => {\n\t\tswitch (basisFormat) {\n\t\t\tcase BASIS_FORMAT.cTFETC1:\n\t\t\t\treturn deviceDetails.formats.etc1 ? PIXEL_FORMAT.ETC1 : PIXEL_FORMAT.ETC2_RGB;\n\t\t\tcase BASIS_FORMAT.cTFETC2:\n\t\t\t\treturn PIXEL_FORMAT.ETC2_RGBA;\n\t\t\tcase BASIS_FORMAT.cTFBC1:\n\t\t\t\treturn PIXEL_FORMAT.DXT1;\n\t\t\tcase BASIS_FORMAT.cTFBC3:\n\t\t\t\treturn PIXEL_FORMAT.DXT5;\n\t\t\tcase BASIS_FORMAT.cTFPVRTC1_4_RGB:\n\t\t\t\treturn PIXEL_FORMAT.PVRTC_4BPP_RGB_1;\n\t\t\tcase BASIS_FORMAT.cTFPVRTC1_4_RGBA:\n\t\t\t\treturn PIXEL_FORMAT.PVRTC_4BPP_RGBA_1;\n\t\t\tcase BASIS_FORMAT.cTFASTC_4x4:\n\t\t\t\treturn PIXEL_FORMAT.ASTC_4x4;\n\t\t\tcase BASIS_FORMAT.cTFATC_RGB:\n\t\t\t\treturn PIXEL_FORMAT.ATC_RGB;\n\t\t\tcase BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:\n\t\t\t\treturn PIXEL_FORMAT.ATC_RGBA;\n\t\t\tcase BASIS_FORMAT.cTFRGBA32:\n\t\t\t\treturn PIXEL_FORMAT.R8_G8_B8_A8;\n\t\t\tcase BASIS_FORMAT.cTFRGB565:\n\t\t\t\treturn PIXEL_FORMAT.R5_G6_B5;\n\t\t\tcase BASIS_FORMAT.cTFRGBA4444:\n\t\t\t\treturn PIXEL_FORMAT.R4_G4_B4_A4;\n\t\t}\n\t};\n\tconst unswizzleGGGR = data => {\n\t\tconst genB = function genB(R, G) {\n\t\t\tconst r = R * (2.0 / 255.0) - 1.0;\n\t\t\tconst g = G * (2.0 / 255.0) - 1.0;\n\t\t\tconst b = Math.sqrt(1.0 - Math.min(1.0, r * r + g * g));\n\t\t\treturn Math.max(0, Math.min(255, Math.floor((b + 1.0) * 0.5 * 255.0)));\n\t\t};\n\t\tfor (let offset = 0; offset < data.length; offset += 4) {\n\t\t\tconst R = data[offset + 3];\n\t\t\tconst G = data[offset + 1];\n\t\t\tdata[offset + 0] = R;\n\t\t\tdata[offset + 2] = genB(R, G);\n\t\t\tdata[offset + 3] = 255;\n\t\t}\n\t\treturn data;\n\t};\n\tconst pack565 = data => {\n\t\tconst result = new Uint16Array(data.length / 4);\n\t\tfor (let offset = 0; offset < data.length; offset += 4) {\n\t\t\tconst R = data[offset + 0];\n\t\t\tconst G = data[offset + 1];\n\t\t\tconst B = data[offset + 2];\n\t\t\tresult[offset / 4] = (R & 0xf8) << 8 | (G & 0xfc) << 3 | B >> 3;\n\t\t}\n\t\treturn result;\n\t};\n\tconst isPOT = (width, height) => {\n\t\treturn (width & width - 1) === 0 && (height & height - 1) === 0;\n\t};\n\tconst performanceNow = () => {\n\t\treturn typeof performance !== 'undefined' ? performance.now() : 0;\n\t};\n\tlet basis;\n\tlet rgbPriority;\n\tlet rgbaPriority;\n\tconst chooseTargetFormat = (deviceDetails, hasAlpha, isUASTC) => {\n\t\tif (isUASTC) {\n\t\t\tif (deviceDetails.formats.astc) {\n\t\t\t\treturn 'astc';\n\t\t\t}\n\t\t} else {\n\t\t\tif (hasAlpha) {\n\t\t\t\tif (deviceDetails.formats.etc2) {\n\t\t\t\t\treturn 'etc2';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (deviceDetails.formats.etc1 || deviceDetails.formats.etc2) {\n\t\t\t\t\treturn 'etc1';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst testInOrder = priority => {\n\t\t\tfor (let i = 0; i < priority.length; ++i) {\n\t\t\t\tconst format = priority[i];\n\t\t\t\tif (deviceDetails.formats[format]) {\n\t\t\t\t\treturn format;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn 'none';\n\t\t};\n\t\treturn testInOrder(hasAlpha ? rgbaPriority : rgbPriority);\n\t};\n\tconst dimensionsValid = (width, height, format, webgl2) => {\n\t\tswitch (format) {\n\t\t\tcase BASIS_FORMAT.cTFETC1:\n\t\t\tcase BASIS_FORMAT.cTFETC2:\n\t\t\t\treturn true;\n\t\t\tcase BASIS_FORMAT.cTFBC1:\n\t\t\tcase BASIS_FORMAT.cTFBC3:\n\t\t\t\treturn (width & 0x3) === 0 && (height & 0x3) === 0;\n\t\t\tcase BASIS_FORMAT.cTFPVRTC1_4_RGB:\n\t\t\tcase BASIS_FORMAT.cTFPVRTC1_4_RGBA:\n\t\t\t\treturn isPOT(width, height) && (width === height || webgl2);\n\t\t\tcase BASIS_FORMAT.cTFASTC_4x4:\n\t\t\t\treturn true;\n\t\t\tcase BASIS_FORMAT.cTFATC_RGB:\n\t\t\tcase BASIS_FORMAT.cTFATC_RGBA_INTERPOLATED_ALPHA:\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\tconst transcodeKTX2 = (url, data, options) => {\n\t\tif (!basis.KTX2File) {\n\t\t\tthrow new Error('Basis transcoder module does not include support for KTX2.');\n\t\t}\n\t\tconst funcStart = performanceNow();\n\t\tconst basisFile = new basis.KTX2File(new Uint8Array(data));\n\t\tconst width = basisFile.getWidth();\n\t\tconst height = basisFile.getHeight();\n\t\tconst levels = basisFile.getLevels();\n\t\tconst hasAlpha = !!basisFile.getHasAlpha();\n\t\tconst isUASTC = basisFile.isUASTC && basisFile.isUASTC();\n\t\tif (!width || !height || !levels) {\n\t\t\tbasisFile.close();\n\t\t\tbasisFile.delete();\n\t\t\tthrow new Error(`Invalid image dimensions url=${url} width=${width} height=${height} levels=${levels}`);\n\t\t}\n\t\tconst format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);\n\t\tconst unswizzle = !!options.isGGGR && format === 'pvr';\n\t\tlet basisFormat;\n\t\tif (unswizzle) {\n\t\t\tbasisFormat = BASIS_FORMAT.cTFRGBA32;\n\t\t} else {\n\t\t\tbasisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];\n\t\t\tif (!dimensionsValid(width, height, basisFormat, options.deviceDetails.webgl2)) {\n\t\t\t\tbasisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;\n\t\t\t}\n\t\t}\n\t\tif (!basisFile.startTranscoding()) {\n\t\t\tbasisFile.close();\n\t\t\tbasisFile.delete();\n\t\t\tthrow new Error(`Failed to start transcoding url=${url}`);\n\t\t}\n\t\tlet i;\n\t\tconst levelData = [];\n\t\tfor (let mip = 0; mip < levels; ++mip) {\n\t\t\tconst dstSize = basisFile.getImageTranscodedSizeInBytes(mip, 0, 0, basisFormat);\n\t\t\tconst dst = new Uint8Array(dstSize);\n\t\t\tif (!basisFile.transcodeImage(dst, mip, 0, 0, basisFormat, 0, -1, -1)) {\n\t\t\t\tbasisFile.close();\n\t\t\t\tbasisFile.delete();\n\t\t\t\tthrow new Error(`Failed to transcode image url=${url}`);\n\t\t\t}\n\t\t\tconst is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;\n\t\t\tlevelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);\n\t\t}\n\t\tbasisFile.close();\n\t\tbasisFile.delete();\n\t\tif (unswizzle) {\n\t\t\tbasisFormat = BASIS_FORMAT.cTFRGB565;\n\t\t\tfor (i = 0; i < levelData.length; ++i) {\n\t\t\t\tlevelData[i] = pack565(unswizzleGGGR(levelData[i]));\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tformat: basisToEngineMapping(basisFormat, options.deviceDetails),\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tlevels: levelData,\n\t\t\tcubemap: false,\n\t\t\ttranscodeTime: performanceNow() - funcStart,\n\t\t\turl: url,\n\t\t\tunswizzledGGGR: unswizzle\n\t\t};\n\t};\n\tconst transcodeBasis = (url, data, options) => {\n\t\tconst funcStart = performanceNow();\n\t\tconst basisFile = new basis.BasisFile(new Uint8Array(data));\n\t\tconst width = basisFile.getImageWidth(0, 0);\n\t\tconst height = basisFile.getImageHeight(0, 0);\n\t\tconst images = basisFile.getNumImages();\n\t\tconst levels = basisFile.getNumLevels(0);\n\t\tconst hasAlpha = !!basisFile.getHasAlpha();\n\t\tconst isUASTC = basisFile.isUASTC && basisFile.isUASTC();\n\t\tif (!width || !height || !images || !levels) {\n\t\t\tbasisFile.close();\n\t\t\tbasisFile.delete();\n\t\t\tthrow new Error(`Invalid image dimensions url=${url} width=${width} height=${height} images=${images} levels=${levels}`);\n\t\t}\n\t\tconst format = chooseTargetFormat(options.deviceDetails, hasAlpha, isUASTC);\n\t\tconst unswizzle = !!options.isGGGR && format === 'pvr';\n\t\tlet basisFormat;\n\t\tif (unswizzle) {\n\t\t\tbasisFormat = BASIS_FORMAT.cTFRGBA32;\n\t\t} else {\n\t\t\tbasisFormat = hasAlpha ? alphaMapping[format] : opaqueMapping[format];\n\t\t\tif (!dimensionsValid(width, height, basisFormat, options.deviceDetails.webgl2)) {\n\t\t\t\tbasisFormat = hasAlpha ? BASIS_FORMAT.cTFRGBA32 : BASIS_FORMAT.cTFRGB565;\n\t\t\t}\n\t\t}\n\t\tif (!basisFile.startTranscoding()) {\n\t\t\tbasisFile.close();\n\t\t\tbasisFile.delete();\n\t\t\tthrow new Error(`Failed to start transcoding url=${url}`);\n\t\t}\n\t\tlet i;\n\t\tconst levelData = [];\n\t\tfor (let mip = 0; mip < levels; ++mip) {\n\t\t\tconst dstSize = basisFile.getImageTranscodedSizeInBytes(0, mip, basisFormat);\n\t\t\tconst dst = new Uint8Array(dstSize);\n\t\t\tif (!basisFile.transcodeImage(dst, 0, mip, basisFormat, 0, 0)) {\n\t\t\t\tif (mip === levels - 1 && dstSize === levelData[mip - 1].buffer.byteLength) {\n\t\t\t\t\tdst.set(new Uint8Array(levelData[mip - 1].buffer));\n\t\t\t\t\tconsole.warn(`Failed to transcode last mipmap level, using previous level instead url=${url}`);\n\t\t\t\t} else {\n\t\t\t\t\tbasisFile.close();\n\t\t\t\t\tbasisFile.delete();\n\t\t\t\t\tthrow new Error(`Failed to transcode image url=${url}`);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst is16BitFormat = basisFormat === BASIS_FORMAT.cTFRGB565 || basisFormat === BASIS_FORMAT.cTFRGBA4444;\n\t\t\tlevelData.push(is16BitFormat ? new Uint16Array(dst.buffer) : dst);\n\t\t}\n\t\tbasisFile.close();\n\t\tbasisFile.delete();\n\t\tif (unswizzle) {\n\t\t\tbasisFormat = BASIS_FORMAT.cTFRGB565;\n\t\t\tfor (i = 0; i < levelData.length; ++i) {\n\t\t\t\tlevelData[i] = pack565(unswizzleGGGR(levelData[i]));\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tformat: basisToEngineMapping(basisFormat, options.deviceDetails),\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tlevels: levelData,\n\t\t\tcubemap: false,\n\t\t\ttranscodeTime: performanceNow() - funcStart,\n\t\t\turl: url,\n\t\t\tunswizzledGGGR: unswizzle\n\t\t};\n\t};\n\tconst transcode = (url, data, options) => {\n\t\treturn options.isKTX2 ? transcodeKTX2(url, data, options) : transcodeBasis(url, data, options);\n\t};\n\tconst workerTranscode = (url, data, options) => {\n\t\ttry {\n\t\t\tconst result = transcode(url, data, options);\n\t\t\tresult.levels = result.levels.map(v => v.buffer);\n\t\t\tself.postMessage({\n\t\t\t\turl: url,\n\t\t\t\tdata: result\n\t\t\t}, result.levels);\n\t\t} catch (err) {\n\t\t\tself.postMessage({\n\t\t\t\turl: url,\n\t\t\t\terr: err\n\t\t\t}, null);\n\t\t}\n\t};\n\tconst workerInit = (config, callback) => {\n\t\tconst instantiateWasmFunc = (imports, successCallback) => {\n\t\t\tWebAssembly.instantiate(config.module, imports).then(result => {\n\t\t\t\tsuccessCallback(result);\n\t\t\t}).catch(reason => {\n\t\t\t\tconsole.error(`instantiate failed + ${reason}`);\n\t\t\t});\n\t\t\treturn {};\n\t\t};\n\t\tself.BASIS(config.module ? {\n\t\t\tinstantiateWasm: instantiateWasmFunc\n\t\t} : null).then(instance => {\n\t\t\tinstance.initializeBasis();\n\t\t\tbasis = instance;\n\t\t\trgbPriority = config.rgbPriority;\n\t\t\trgbaPriority = config.rgbaPriority;\n\t\t\tcallback(null);\n\t\t});\n\t};\n\tconst queue = [];\n\tself.onmessage = message => {\n\t\tconst data = message.data;\n\t\tswitch (data.type) {\n\t\t\tcase 'init':\n\t\t\t\tworkerInit(data.config, () => {\n\t\t\t\t\tfor (let i = 0; i < queue.length; ++i) {\n\t\t\t\t\t\tworkerTranscode(queue[i].url, queue[i].data, queue[i].options);\n\t\t\t\t\t}\n\t\t\t\t\tqueue.length = 0;\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'transcode':\n\t\t\t\tif (basis) {\n\t\t\t\t\tworkerTranscode(data.url, data.data, data.options);\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push(data);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t};\n}\n\nexport { BasisWorker };\n","import { WasmModule } from '../../core/wasm-module.js';\nimport { PIXELFORMAT_RGB565, PIXELFORMAT_RGBA4 } from '../../platform/graphics/constants.js';\nimport { BasisWorker } from './basis-worker.js';\nimport { http } from '../../platform/net/http.js';\n\nconst getCompressionFormats = device => {\n\treturn {\n\t\tastc: !!device.extCompressedTextureASTC,\n\t\tatc: !!device.extCompressedTextureATC,\n\t\tdxt: !!device.extCompressedTextureS3TC,\n\t\tetc1: !!device.extCompressedTextureETC1,\n\t\tetc2: !!device.extCompressedTextureETC,\n\t\tpvr: !!device.extCompressedTexturePVRTC\n\t};\n};\nconst prepareWorkerModules = (config, callback) => {\n\tconst getWorkerBlob = basisCode => {\n\t\tconst code = ['/* basis */', basisCode, '', `(${BasisWorker.toString()})()\\n\\n`].join('\\n');\n\t\treturn new Blob([code], {\n\t\t\ttype: 'application/javascript'\n\t\t});\n\t};\n\tconst wasmSupported = () => {\n\t\ttry {\n\t\t\tif (typeof WebAssembly === 'object' && typeof WebAssembly.instantiate === 'function') {\n\t\t\t\tconst module = new WebAssembly.Module(Uint8Array.of(0x0, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00));\n\t\t\t\tif (module instanceof WebAssembly.Module) {\n\t\t\t\t\treturn new WebAssembly.Instance(module) instanceof WebAssembly.Instance;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {}\n\t\treturn false;\n\t};\n\tconst sendResponse = (basisCode, module) => {\n\t\tcallback(null, {\n\t\t\tworkerUrl: URL.createObjectURL(getWorkerBlob(basisCode)),\n\t\t\tmodule: module,\n\t\t\trgbPriority: config.rgbPriority,\n\t\t\trgbaPriority: config.rgbaPriority\n\t\t});\n\t};\n\tconst options = {\n\t\tcache: true,\n\t\tresponseType: 'text',\n\t\tretry: config.maxRetries > 0,\n\t\tmaxRetries: config.maxRetries\n\t};\n\tif (config.glueUrl && config.wasmUrl && wasmSupported()) {\n\t\tlet basisCode = null;\n\t\tlet module = null;\n\t\thttp.get(config.glueUrl, options, (err, response) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else {\n\t\t\t\tif (module) {\n\t\t\t\t\tsendResponse(response, module);\n\t\t\t\t} else {\n\t\t\t\t\tbasisCode = response;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tconst fetchPromise = fetch(config.wasmUrl);\n\t\tconst compileManual = () => {\n\t\t\tfetchPromise.then(result => result.arrayBuffer()).then(buffer => WebAssembly.compile(buffer)).then(module_ => {\n\t\t\t\tif (basisCode) {\n\t\t\t\t\tsendResponse(basisCode, module_);\n\t\t\t\t} else {\n\t\t\t\t\tmodule = module_;\n\t\t\t\t}\n\t\t\t}).catch(err => {\n\t\t\t\tcallback(err, null);\n\t\t\t});\n\t\t};\n\t\tif (WebAssembly.compileStreaming) {\n\t\t\tWebAssembly.compileStreaming(fetchPromise).then(module_ => {\n\t\t\t\tif (basisCode) {\n\t\t\t\t\tsendResponse(basisCode, module_);\n\t\t\t\t} else {\n\t\t\t\t\tmodule = module_;\n\t\t\t\t}\n\t\t\t}).catch(err => {\n\t\t\t\tcompileManual();\n\t\t\t});\n\t\t} else {\n\t\t\tcompileManual();\n\t\t}\n\t} else {\n\t\thttp.get(config.fallbackUrl, options, (err, response) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(err, null);\n\t\t\t} else {\n\t\t\t\tsendResponse(response, null);\n\t\t\t}\n\t\t});\n\t}\n};\nclass BasisQueue {\n\tconstructor() {\n\t\tthis.callbacks = {};\n\t\tthis.queue = [];\n\t\tthis.clients = [];\n\t}\n\tenqueueJob(url, data, callback, options) {\n\t\tif (this.callbacks.hasOwnProperty(url)) {\n\t\t\tthis.callbacks[url].push(callback);\n\t\t} else {\n\t\t\tthis.callbacks[url] = [callback];\n\t\t\tconst job = {\n\t\t\t\turl: url,\n\t\t\t\tdata: data,\n\t\t\t\toptions: options\n\t\t\t};\n\t\t\tif (this.clients.length > 0) {\n\t\t\t\tthis.clients.shift().run(job);\n\t\t\t} else {\n\t\t\t\tthis.queue.push(job);\n\t\t\t}\n\t\t}\n\t}\n\tenqueueClient(client) {\n\t\tif (this.queue.length > 0) {\n\t\t\tclient.run(this.queue.shift());\n\t\t} else {\n\t\t\tthis.clients.push(client);\n\t\t}\n\t}\n\thandleResponse(url, err, data) {\n\t\tconst callback = this.callbacks[url];\n\t\tif (err) {\n\t\t\tfor (let i = 0; i < callback.length; ++i) {\n\t\t\t\tcallback[i](err);\n\t\t\t}\n\t\t} else {\n\t\t\tif (data.format === PIXELFORMAT_RGB565 || data.format === PIXELFORMAT_RGBA4) {\n\t\t\t\tdata.levels = data.levels.map(v => {\n\t\t\t\t\treturn new Uint16Array(v);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tdata.levels = data.levels.map(v => {\n\t\t\t\t\treturn new Uint8Array(v);\n\t\t\t\t});\n\t\t\t}\n\t\t\tfor (let i = 0; i < callback.length; ++i) {\n\t\t\t\tcallback[i](null, data);\n\t\t\t}\n\t\t}\n\t\tdelete this.callbacks[url];\n\t}\n}\nclass BasisClient {\n\tconstructor(queue, config, eager) {\n\t\tthis.queue = queue;\n\t\tthis.worker = new Worker(config.workerUrl);\n\t\tthis.worker.addEventListener('message', message => {\n\t\t\tconst data = message.data;\n\t\t\tthis.queue.handleResponse(data.url, data.err, data.data);\n\t\t\tif (!this.eager) {\n\t\t\t\tthis.queue.enqueueClient(this);\n\t\t\t}\n\t\t});\n\t\tthis.worker.postMessage({\n\t\t\ttype: 'init',\n\t\t\tconfig: config\n\t\t});\n\t\tthis.eager = eager;\n\t}\n\trun(job) {\n\t\tconst transfer = [];\n\t\tif (job.data instanceof ArrayBuffer) {\n\t\t\ttransfer.push(job.data);\n\t\t}\n\t\tthis.worker.postMessage({\n\t\t\ttype: 'transcode',\n\t\t\turl: job.url,\n\t\t\tformat: job.format,\n\t\t\tdata: job.data,\n\t\t\toptions: job.options\n\t\t}, transfer);\n\t\tif (this.eager) {\n\t\t\tthis.queue.enqueueClient(this);\n\t\t}\n\t}\n}\nconst defaultNumWorkers = 1;\nconst defaultRgbPriority = ['etc1', 'etc2', 'astc', 'dxt', 'pvr', 'atc'];\nconst defaultRgbaPriority = ['astc', 'dxt', 'etc2', 'pvr', 'atc'];\nconst defaultMaxRetries = 5;\nconst queue = new BasisQueue();\nlet lazyConfig = null;\nlet initializing = false;\nfunction basisInitialize(config) {\n\tif (initializing) {\n\t\treturn;\n\t}\n\tif (!config) {\n\t\tconfig = lazyConfig || {};\n\t} else if (config.lazyInit) {\n\t\tlazyConfig = config;\n\t\treturn;\n\t}\n\tif (!config.glueUrl || !config.wasmUrl || !config.fallbackUrl) {\n\t\tconst moduleConfig = WasmModule.getConfig('BASIS');\n\t\tif (moduleConfig) {\n\t\t\tconfig = {\n\t\t\t\tglueUrl: moduleConfig.glueUrl,\n\t\t\t\twasmUrl: moduleConfig.wasmUrl,\n\t\t\t\tfallbackUrl: moduleConfig.fallbackUrl,\n\t\t\t\tnumWorkers: moduleConfig.numWorkers\n\t\t\t};\n\t\t}\n\t}\n\tif (config.glueUrl || config.wasmUrl || config.fallbackUrl) {\n\t\tinitializing = true;\n\t\tconst numWorkers = Math.max(1, Math.min(16, config.numWorkers || defaultNumWorkers));\n\t\tconst eagerWorkers = config.numWorkers === 1 || (config.hasOwnProperty('eagerWorkers') ? config.eagerWorkers : true);\n\t\tconfig.rgbPriority = config.rgbPriority || defaultRgbPriority;\n\t\tconfig.rgbaPriority = config.rgbaPriority || defaultRgbaPriority;\n\t\tconfig.maxRetries = config.hasOwnProperty('maxRetries') ? config.maxRetries : defaultMaxRetries;\n\t\tprepareWorkerModules(config, (err, clientConfig) => {\n\t\t\tif (err) {\n\t\t\t\tconsole.error(`failed to initialize basis worker: ${err}`);\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < numWorkers; ++i) {\n\t\t\t\t\tqueue.enqueueClient(new BasisClient(queue, clientConfig, eagerWorkers));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\nlet deviceDetails = null;\nfunction basisTranscode(device, url, data, callback, options) {\n\tbasisInitialize();\n\tif (!deviceDetails) {\n\t\tdeviceDetails = {\n\t\t\twebgl2: device.isWebGL2,\n\t\t\tformats: getCompressionFormats(device)\n\t\t};\n\t}\n\tqueue.enqueueJob(url, data, callback, {\n\t\tdeviceDetails: deviceDetails,\n\t\tisGGGR: !!(options != null && options.isGGGR),\n\t\tisKTX2: !!(options != null && options.isKTX2)\n\t});\n\treturn initializing;\n}\n\nexport { basisInitialize, basisTranscode };\n","import { http, Http } from '../../platform/net/http.js';\nimport { ResourceHandler } from './handler.js';\n\nclass BinaryHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'binary');\n\t}\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\t\thttp.get(url.load, {\n\t\t\tresponseType: Http.ResponseType.ARRAY_BUFFER,\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t}, (err, response) => {\n\t\t\tif (!err) {\n\t\t\t\tcallback(null, response);\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading binary resource: ${url.original} [${err}]`);\n\t\t\t}\n\t\t});\n\t}\n\topenBinary(data) {\n\t\treturn data.buffer;\n\t}\n}\n\nexport { BinaryHandler };\n","import { Bundle } from '../bundle/bundle.js';\nimport { Untar } from './untar.js';\nimport { ResourceHandler } from './handler.js';\n\nclass BundleHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'bundle');\n\t\tthis._assets = app.assets;\n\t}\n\t_fetchRetries(url, options, retries = 0) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst tryFetch = () => {\n\t\t\t\tfetch(url, options).then(resolve).catch(err => {\n\t\t\t\t\tretries++;\n\t\t\t\t\tif (retries < this.maxRetries) {\n\t\t\t\t\t\ttryFetch();\n\t\t\t\t\t} else {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t\ttryFetch();\n\t\t});\n\t}\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\t\tthis._fetchRetries(url.load, {\n\t\t\tmode: 'cors',\n\t\t\tcredentials: 'include'\n\t\t}, this.maxRetries).then(res => {\n\t\t\tconst bundle = new Bundle();\n\t\t\tcallback(null, bundle);\n\t\t\tconst untar = new Untar(res, this._assets.prefix);\n\t\t\tuntar.on('file', file => {\n\t\t\t\tbundle.addFile(file.name, file.data);\n\t\t\t});\n\t\t\tuntar.on('done', () => {\n\t\t\t\tbundle.loaded = true;\n\t\t\t});\n\t\t\tuntar.on('error', err => {\n\t\t\t\tcallback(err);\n\t\t\t});\n\t\t}).catch(err => {\n\t\t\tcallback(err);\n\t\t});\n\t}\n\topen(url, bundle) {\n\t\treturn bundle;\n\t}\n}\n\nexport { BundleHandler };\n","import { path } from '../../core/path.js';\nimport { GlbContainerParser } from '../parsers/glb-container-parser.js';\nimport { ResourceHandler } from './handler.js';\n\nclass ContainerResource {\n\tinstantiateModelEntity(options) {\n\t\treturn null;\n\t}\n\tinstantiateRenderEntity(options) {\n\t\treturn null;\n\t}\n\tgetMaterialVariants() {\n\t\treturn null;\n\t}\n\tapplyMaterialVariant(entity, name) {}\n\tapplyMaterialVariantInstances(instances, name) {}\n}\nclass ContainerHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'container');\n\t\tthis.glbContainerParser = new GlbContainerParser(app.graphicsDevice, app.assets, 0);\n\t\tthis.parsers = {};\n\t}\n\tset maxRetries(value) {\n\t\tthis.glbContainerParser.maxRetries = value;\n\t\tfor (const parser in this.parsers) {\n\t\t\tif (this.parsers.hasOwnProperty(parser)) {\n\t\t\t\tthis.parsers[parser].maxRetries = value;\n\t\t\t}\n\t\t}\n\t}\n\tget maxRetries() {\n\t\treturn this.glbContainerParser.maxRetries;\n\t}\n\t_getUrlWithoutParams(url) {\n\t\treturn url.indexOf('?') >= 0 ? url.split('?')[0] : url;\n\t}\n\t_getParser(url) {\n\t\tconst ext = url ? path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '') : null;\n\t\treturn this.parsers[ext] || this.glbContainerParser;\n\t}\n\tload(url, callback, asset) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\t\tthis._getParser(url.original).load(url, callback, asset);\n\t}\n\topen(url, data, asset) {\n\t\treturn this._getParser(url).open(url, data, asset);\n\t}\n}\n\nexport { ContainerHandler, ContainerResource };\n","import { http } from '../../platform/net/http.js';\nimport { ResourceHandler } from './handler.js';\n\nclass CssHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'css');\n\t\tthis.decoder = null;\n\t}\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\t\thttp.get(url.load, {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t}, (err, response) => {\n\t\t\tif (!err) {\n\t\t\t\tcallback(null, response);\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading css resource: ${url.original} [${err}]`);\n\t\t\t}\n\t\t});\n\t}\n\topenBinary(data) {\n\t\tvar _this$decoder;\n\t\t(_this$decoder = this.decoder) != null ? _this$decoder : this.decoder = new TextDecoder('utf-8');\n\t\treturn this.decoder.decode(data);\n\t}\n}\n\nexport { CssHandler };\n","import { ADDRESS_CLAMP_TO_EDGE, TEXTURETYPE_RGBP, PIXELFORMAT_RGB8, PIXELFORMAT_RGBA8, TEXTURETYPE_RGBM, TEXTURETYPE_DEFAULT } from '../../platform/graphics/constants.js';\nimport { Texture } from '../../platform/graphics/texture.js';\nimport { Asset } from '../asset/asset.js';\nimport { ResourceHandler } from './handler.js';\n\nclass CubemapHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'cubemap');\n\t\tthis._device = app.graphicsDevice;\n\t\tthis._registry = app.assets;\n\t\tthis._loader = app.loader;\n\t}\n\tload(url, callback, asset) {\n\t\tthis.loadAssets(asset, callback);\n\t}\n\topen(url, data, asset) {\n\t\treturn asset ? asset.resource : null;\n\t}\n\tpatch(asset, registry) {\n\t\tthis.loadAssets(asset, (err, result) => {\n\t\t\tif (err) {\n\t\t\t\tregistry.fire('error', asset);\n\t\t\t\tregistry.fire(`error:${asset.id}`, err, asset);\n\t\t\t\tasset.fire('error', asset);\n\t\t\t}\n\t\t});\n\t}\n\tgetAssetIds(cubemapAsset) {\n\t\tconst result = [];\n\t\tresult[0] = cubemapAsset.file;\n\t\tif ((cubemapAsset.loadFaces || !cubemapAsset.file) && cubemapAsset.data && cubemapAsset.data.textures) {\n\t\t\tfor (let i = 0; i < 6; ++i) {\n\t\t\t\tresult[i + 1] = cubemapAsset.data.textures[i];\n\t\t\t}\n\t\t} else {\n\t\t\tresult[1] = result[2] = result[3] = result[4] = result[5] = result[6] = null;\n\t\t}\n\t\treturn result;\n\t}\n\tcompareAssetIds(assetIdA, assetIdB) {\n\t\tif (assetIdA && assetIdB) {\n\t\t\tif (parseInt(assetIdA, 10) === assetIdA || typeof assetIdA === 'string') {\n\t\t\t\treturn assetIdA === assetIdB;\n\t\t\t}\n\t\t\treturn assetIdA.url === assetIdB.url;\n\t\t}\n\t\treturn assetIdA !== null === (assetIdB !== null);\n\t}\n\tupdate(cubemapAsset, assetIds, assets) {\n\t\tconst assetData = cubemapAsset.data || {};\n\t\tconst oldAssets = cubemapAsset._handlerState.assets;\n\t\tconst oldResources = cubemapAsset._resources;\n\t\tlet tex, mip, i;\n\t\tconst resources = [null, null, null, null, null, null, null];\n\t\tconst getType = function getType() {\n\t\t\tif (assetData.hasOwnProperty('type')) {\n\t\t\t\treturn assetData.type;\n\t\t\t}\n\t\t\tif (assetData.hasOwnProperty('rgbm')) {\n\t\t\t\treturn assetData.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;\n\t\t\t}\n\t\t\treturn null;\n\t\t};\n\t\tif (!cubemapAsset.loaded || assets[0] !== oldAssets[0]) {\n\t\t\tif (assets[0]) {\n\t\t\t\ttex = assets[0].resource;\n\t\t\t\tif (tex.cubemap) {\n\t\t\t\t\tfor (i = 0; i < 6; ++i) {\n\t\t\t\t\t\tresources[i + 1] = new Texture(this._device, {\n\t\t\t\t\t\t\tname: `${cubemapAsset.name}_prelitCubemap${tex.width >> i}`,\n\t\t\t\t\t\t\tcubemap: true,\n\t\t\t\t\t\t\ttype: getType() || tex.type,\n\t\t\t\t\t\t\twidth: tex.width >> i,\n\t\t\t\t\t\t\theight: tex.height >> i,\n\t\t\t\t\t\t\tformat: tex.format,\n\t\t\t\t\t\t\tlevels: [tex._levels[i]],\n\t\t\t\t\t\t\tfixCubemapSeams: true,\n\t\t\t\t\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\t\t\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\t\t\t\t\tmipmaps: i === 0\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttex.type = TEXTURETYPE_RGBP;\n\t\t\t\t\ttex.addressU = ADDRESS_CLAMP_TO_EDGE;\n\t\t\t\t\ttex.addressV = ADDRESS_CLAMP_TO_EDGE;\n\t\t\t\t\ttex.mipmaps = false;\n\t\t\t\t\tresources[1] = tex;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tresources[1] = oldResources[1] || null;\n\t\t\tresources[2] = oldResources[2] || null;\n\t\t\tresources[3] = oldResources[3] || null;\n\t\t\tresources[4] = oldResources[4] || null;\n\t\t\tresources[5] = oldResources[5] || null;\n\t\t\tresources[6] = oldResources[6] || null;\n\t\t}\n\t\tconst faceAssets = assets.slice(1);\n\t\tif (!cubemapAsset.loaded || !this.cmpArrays(faceAssets, oldAssets.slice(1))) {\n\t\t\tif (faceAssets.indexOf(null) === -1) {\n\t\t\t\tvar _assetData$mipmaps;\n\t\t\t\tconst faceTextures = faceAssets.map(asset => {\n\t\t\t\t\treturn asset.resource;\n\t\t\t\t});\n\t\t\t\tconst faceLevels = [];\n\t\t\t\tfor (mip = 0; mip < faceTextures[0]._levels.length; ++mip) {\n\t\t\t\t\tfaceLevels.push(faceTextures.map(faceTexture => {\n\t\t\t\t\t\treturn faceTexture._levels[mip];\n\t\t\t\t\t}));\n\t\t\t\t}\n\t\t\t\tconst format = faceTextures[0].format;\n\t\t\t\tconst faces = new Texture(this._device, {\n\t\t\t\t\tname: `${cubemapAsset.name}_faces`,\n\t\t\t\t\tcubemap: true,\n\t\t\t\t\ttype: getType() || faceTextures[0].type,\n\t\t\t\t\twidth: faceTextures[0].width,\n\t\t\t\t\theight: faceTextures[0].height,\n\t\t\t\t\tformat: format === PIXELFORMAT_RGB8 ? PIXELFORMAT_RGBA8 : format,\n\t\t\t\t\tmipmaps: (_assetData$mipmaps = assetData.mipmaps) != null ? _assetData$mipmaps : true,\n\t\t\t\t\tlevels: faceLevels,\n\t\t\t\t\tminFilter: assetData.hasOwnProperty('minFilter') ? assetData.minFilter : faceTextures[0].minFilter,\n\t\t\t\t\tmagFilter: assetData.hasOwnProperty('magFilter') ? assetData.magFilter : faceTextures[0].magFilter,\n\t\t\t\t\tanisotropy: assetData.hasOwnProperty('anisotropy') ? assetData.anisotropy : 1,\n\t\t\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\t\t\tfixCubemapSeams: !!assets[0]\n\t\t\t\t});\n\t\t\t\tresources[0] = faces;\n\t\t\t}\n\t\t} else {\n\t\t\tresources[0] = oldResources[0] || null;\n\t\t}\n\t\tif (!this.cmpArrays(resources, oldResources)) {\n\t\t\tcubemapAsset.resources = resources;\n\t\t\tcubemapAsset._handlerState.assetIds = assetIds;\n\t\t\tcubemapAsset._handlerState.assets = assets;\n\t\t\tfor (i = 0; i < oldResources.length; ++i) {\n\t\t\t\tif (oldResources[i] !== null && resources.indexOf(oldResources[i]) === -1) {\n\t\t\t\t\toldResources[i].destroy();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < oldAssets.length; ++i) {\n\t\t\tif (oldAssets[i] !== null && assets.indexOf(oldAssets[i]) === -1) {\n\t\t\t\toldAssets[i].unload();\n\t\t\t}\n\t\t}\n\t}\n\tcmpArrays(arr1, arr2) {\n\t\tif (arr1.length !== arr2.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < arr1.length; ++i) {\n\t\t\tif (arr1[i] !== arr2[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tresolveId(value) {\n\t\tconst valueInt = parseInt(value, 10);\n\t\treturn valueInt === value || valueInt.toString() === value ? valueInt : value;\n\t}\n\tloadAssets(cubemapAsset, callback) {\n\t\tif (!cubemapAsset.hasOwnProperty('_handlerState')) {\n\t\t\tcubemapAsset._handlerState = {\n\t\t\t\tassetIds: [null, null, null, null, null, null, null],\n\t\t\t\tassets: [null, null, null, null, null, null, null]\n\t\t\t};\n\t\t}\n\t\tconst self = this;\n\t\tconst assetIds = self.getAssetIds(cubemapAsset);\n\t\tconst assets = [null, null, null, null, null, null, null];\n\t\tconst loadedAssetIds = cubemapAsset._handlerState.assetIds;\n\t\tconst loadedAssets = cubemapAsset._handlerState.assets;\n\t\tconst registry = self._registry;\n\t\tlet awaiting = 7;\n\t\tconst onLoad = function onLoad(index, asset) {\n\t\t\tassets[index] = asset;\n\t\t\tawaiting--;\n\t\t\tif (awaiting === 0) {\n\t\t\t\tself.update(cubemapAsset, assetIds, assets);\n\t\t\t\tcallback(null, cubemapAsset.resources);\n\t\t\t}\n\t\t};\n\t\tconst onError = function onError(index, err, asset) {\n\t\t\tcallback(err);\n\t\t};\n\t\tconst processTexAsset = function processTexAsset(index, texAsset) {\n\t\t\tif (texAsset.loaded) {\n\t\t\t\tonLoad(index, texAsset);\n\t\t\t} else {\n\t\t\t\tregistry.once(`load:${texAsset.id}`, onLoad.bind(self, index));\n\t\t\t\tregistry.once(`error:${texAsset.id}`, onError.bind(self, index));\n\t\t\t\tif (!texAsset.loading) {\n\t\t\t\t\tregistry.load(texAsset);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tlet texAsset;\n\t\tfor (let i = 0; i < 7; ++i) {\n\t\t\tconst assetId = this.resolveId(assetIds[i]);\n\t\t\tif (!assetId) {\n\t\t\t\tonLoad(i, null);\n\t\t\t} else if (self.compareAssetIds(assetId, loadedAssetIds[i])) {\n\t\t\t\tprocessTexAsset(i, loadedAssets[i]);\n\t\t\t} else if (parseInt(assetId, 10) === assetId) {\n\t\t\t\ttexAsset = registry.get(assetId);\n\t\t\t\tif (texAsset) {\n\t\t\t\t\tprocessTexAsset(i, texAsset);\n\t\t\t\t} else {\n\t\t\t\t\tsetTimeout(((index, assetId_) => {\n\t\t\t\t\t\tconst texAsset = registry.get(assetId_);\n\t\t\t\t\t\tif (texAsset) {\n\t\t\t\t\t\t\tprocessTexAsset(index, texAsset);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tonError(index, `failed to find dependent cubemap asset=${assetId_}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}).bind(null, i, assetId));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst file = typeof assetId === 'string' ? {\n\t\t\t\t\turl: assetId,\n\t\t\t\t\tfilename: assetId\n\t\t\t\t} : assetId;\n\t\t\t\ttexAsset = new Asset(`${cubemapAsset.name}_part_${i}`, 'texture', file);\n\t\t\t\tregistry.add(texAsset);\n\t\t\t\tprocessTexAsset(i, texAsset);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { CubemapHandler };\n","import { ResourceHandler } from './handler.js';\n\nclass FolderHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'folder');\n\t}\n\tload(url, callback) {\n\t\tcallback(null, null);\n\t}\n}\n\nexport { FolderHandler };\n","import { path } from '../../core/path.js';\nimport { string } from '../../core/string.js';\nimport { http } from '../../platform/net/http.js';\nimport { Font } from '../font/font.js';\nimport { ResourceHandler } from './handler.js';\n\nfunction upgradeDataSchema(data) {\n\tif (data.version < 3) {\n\t\tif (data.version < 2) {\n\t\t\tdata.info.maps = data.info.maps || [{\n\t\t\t\twidth: data.info.width,\n\t\t\t\theight: data.info.height\n\t\t\t}];\n\t\t}\n\t\tdata.chars = Object.keys(data.chars || {}).reduce((newChars, key) => {\n\t\t\tconst existing = data.chars[key];\n\t\t\tconst newKey = existing.letter !== undefined ? existing.letter : string.fromCodePoint(key);\n\t\t\tif (data.version < 2) {\n\t\t\t\texisting.map = existing.map || 0;\n\t\t\t}\n\t\t\tnewChars[newKey] = existing;\n\t\t\treturn newChars;\n\t\t}, {});\n\t\tdata.version = 3;\n\t}\n\treturn data;\n}\nclass FontHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'font');\n\t\tthis._loader = app.loader;\n\t\tthis.maxRetries = 0;\n\t}\n\tload(url, callback, asset) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\t\tconst self = this;\n\t\tif (path.getExtension(url.original) === '.json') {\n\t\t\thttp.get(url.load, {\n\t\t\t\tretry: this.maxRetries > 0,\n\t\t\t\tmaxRetries: this.maxRetries\n\t\t\t}, (err, response) => {\n\t\t\t\tif (!err) {\n\t\t\t\t\tconst data = upgradeDataSchema(response);\n\t\t\t\t\tself._loadTextures(url.load.replace('.json', '.png'), data, (err, textures) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcallback(null, {\n\t\t\t\t\t\t\t\tdata: data,\n\t\t\t\t\t\t\t\ttextures: textures\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcallback(`Error loading font resource: ${url.original} [${err}]`);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tif (asset && asset.data) {\n\t\t\t\tasset.data = upgradeDataSchema(asset.data);\n\t\t\t}\n\t\t\tthis._loadTextures(url.load, asset && asset.data, callback);\n\t\t}\n\t}\n\t_loadTextures(url, data, callback) {\n\t\tconst numTextures = data.info.maps.length;\n\t\tlet numLoaded = 0;\n\t\tlet error = null;\n\t\tconst textures = new Array(numTextures);\n\t\tconst loader = this._loader;\n\t\tconst loadTexture = function loadTexture(index) {\n\t\t\tconst onLoaded = function onLoaded(err, texture) {\n\t\t\t\tif (error) return;\n\t\t\t\tif (err) {\n\t\t\t\t\terror = err;\n\t\t\t\t\tcallback(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\ttexture.upload();\n\t\t\t\ttextures[index] = texture;\n\t\t\t\tnumLoaded++;\n\t\t\t\tif (numLoaded === numTextures) {\n\t\t\t\t\tcallback(null, textures);\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (index === 0) {\n\t\t\t\tloader.load(url, 'texture', onLoaded);\n\t\t\t} else {\n\t\t\t\tloader.load(url.replace('.png', `${index}.png`), 'texture', onLoaded);\n\t\t\t}\n\t\t};\n\t\tfor (let i = 0; i < numTextures; i++) {\n\t\t\tloadTexture(i);\n\t\t}\n\t}\n\topen(url, data, asset) {\n\t\tlet font;\n\t\tif (data.textures) {\n\t\t\tfont = new Font(data.textures, data.data);\n\t\t} else {\n\t\t\tfont = new Font(data, null);\n\t\t}\n\t\treturn font;\n\t}\n\tpatch(asset, assets) {\n\t\tconst font = asset.resource;\n\t\tif (!font.data && asset.data) {\n\t\t\tfont.data = asset.data;\n\t\t} else if (!asset.data && font.data) {\n\t\t\tasset.data = font.data;\n\t\t}\n\t\tif (asset.data) {\n\t\t\tasset.data = upgradeDataSchema(asset.data);\n\t\t}\n\t}\n}\n\nexport { FontHandler };\n","import { PlyParser } from '../parsers/ply.js';\nimport { ResourceHandler } from './handler.js';\n\nclass GSplatHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'gsplat');\n\t\tthis.parser = new PlyParser(app.graphicsDevice, app.assets, 3);\n\t}\n\tload(url, callback, asset) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\t\tthis.parser.load(url, callback, asset);\n\t}\n\topen(url, data, asset) {\n\t\treturn this.parser.open(url, data, asset);\n\t}\n}\n\nexport { GSplatHandler };\n","class ResourceHandler {\n\tconstructor(app, handlerType) {\n\t\tthis.handlerType = '';\n\t\tthis._app = void 0;\n\t\tthis._maxRetries = 0;\n\t\tthis._app = app;\n\t\tthis.handlerType = handlerType;\n\t}\n\tset maxRetries(value) {\n\t\tthis._maxRetries = value;\n\t}\n\tget maxRetries() {\n\t\treturn this._maxRetries;\n\t}\n\tload(url, callback, asset) {}\n\topen(url, data, asset) {\n\t\treturn data;\n\t}\n\tpatch(asset, assets) {}\n}\n\nexport { ResourceHandler };\n","import { SceneParser } from '../parsers/scene.js';\nimport { SceneUtils } from './scene-utils.js';\nimport { ResourceHandler } from './handler.js';\n\nclass HierarchyHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'hierarchy');\n\t}\n\tload(url, callback) {\n\t\tSceneUtils.load(url, this.maxRetries, callback);\n\t}\n\topen(url, data) {\n\t\tthis._app.systems.script.preloading = true;\n\t\tconst parser = new SceneParser(this._app, false);\n\t\tconst parent = parser.parse(data);\n\t\tthis._app.systems.script.preloading = false;\n\t\treturn parent;\n\t}\n}\n\nexport { HierarchyHandler };\n","import { http } from '../../platform/net/http.js';\nimport { ResourceHandler } from './handler.js';\n\nclass HtmlHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'html');\n\t\tthis.decoder = null;\n\t}\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\t\thttp.get(url.load, {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t}, (err, response) => {\n\t\t\tif (!err) {\n\t\t\t\tcallback(null, response);\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading html resource: ${url.original} [${err}]`);\n\t\t\t}\n\t\t});\n\t}\n\topenBinary(data) {\n\t\tvar _this$decoder;\n\t\t(_this$decoder = this.decoder) != null ? _this$decoder : this.decoder = new TextDecoder('utf-8');\n\t\treturn this.decoder.decode(data);\n\t}\n}\n\nexport { HtmlHandler };\n","import { Http, http } from '../../platform/net/http.js';\nimport { ResourceHandler } from './handler.js';\n\nclass JsonHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'json');\n\t\tthis.decoder = null;\n\t}\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\t\tconst options = {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t};\n\t\tif (url.load.startsWith('blob:')) {\n\t\t\toptions.responseType = Http.ResponseType.JSON;\n\t\t}\n\t\thttp.get(url.load, options, (err, response) => {\n\t\t\tif (!err) {\n\t\t\t\tcallback(null, response);\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading JSON resource: ${url.original} [${err}]`);\n\t\t\t}\n\t\t});\n\t}\n\topenBinary(data) {\n\t\tvar _this$decoder;\n\t\t(_this$decoder = this.decoder) != null ? _this$decoder : this.decoder = new TextDecoder('utf-8');\n\t\treturn JSON.parse(this.decoder.decode(data));\n\t}\n}\n\nexport { JsonHandler };\n","class ResourceLoader {\n\tconstructor(app) {\n\t\tthis._handlers = {};\n\t\tthis._requests = {};\n\t\tthis._cache = {};\n\t\tthis._app = app;\n\t}\n\taddHandler(type, handler) {\n\t\tthis._handlers[type] = handler;\n\t\thandler._loader = this;\n\t}\n\tremoveHandler(type) {\n\t\tdelete this._handlers[type];\n\t}\n\tgetHandler(type) {\n\t\treturn this._handlers[type];\n\t}\n\tstatic makeKey(url, type) {\n\t\treturn `${url}-${type}`;\n\t}\n\tload(url, type, callback, asset, options) {\n\t\tconst handler = this._handlers[type];\n\t\tif (!handler) {\n\t\t\tconst err = `No resource handler for asset type: '${type}' when loading [${url}]`;\n\t\t\tcallback(err);\n\t\t\treturn;\n\t\t}\n\t\tif (!url) {\n\t\t\tthis._loadNull(handler, callback, asset);\n\t\t\treturn;\n\t\t}\n\t\tconst key = ResourceLoader.makeKey(url, type);\n\t\tif (this._cache[key] !== undefined) {\n\t\t\tcallback(null, this._cache[key]);\n\t\t} else if (this._requests[key]) {\n\t\t\tthis._requests[key].push(callback);\n\t\t} else {\n\t\t\tthis._requests[key] = [callback];\n\t\t\tconst self = this;\n\t\t\tconst handleLoad = function handleLoad(err, urlObj) {\n\t\t\t\tif (err) {\n\t\t\t\t\tself._onFailure(key, err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (urlObj.load instanceof DataView) {\n\t\t\t\t\tif (handler.openBinary) {\n\t\t\t\t\t\tif (!self._requests[key]) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst data = handler.openBinary(urlObj.load);\n\t\t\t\t\t\t\tself._onSuccess(key, data);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\tself._onFailure(key, err);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\turlObj.load = URL.createObjectURL(new Blob([urlObj.load]));\n\t\t\t\t\tif (asset) {\n\t\t\t\t\t\tif (asset.urlObject) {\n\t\t\t\t\t\t\tURL.revokeObjectURL(asset.urlObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tasset.urlObject = urlObj.load;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\thandler.load(urlObj, (err, data, extra) => {\n\t\t\t\t\tif (!self._requests[key]) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tself._onFailure(key, err);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\tself._onSuccess(key, handler.open(urlObj.original, data, asset), extra);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tself._onFailure(key, e);\n\t\t\t\t\t}\n\t\t\t\t}, asset);\n\t\t\t};\n\t\t\tconst normalizedUrl = url.split('?')[0];\n\t\t\tif (this._app.enableBundles && this._app.bundles.hasUrl(normalizedUrl) && !(options && options.bundlesIgnore)) {\n\t\t\t\tif (!this._app.bundles.urlIsLoadedOrLoading(normalizedUrl)) {\n\t\t\t\t\tvar _this$_app$assets;\n\t\t\t\t\tconst bundles = this._app.bundles.listBundlesForAsset(asset);\n\t\t\t\t\tlet bundle;\n\t\t\t\t\tif (options && options.bundlesFilter) {\n\t\t\t\t\t\tbundle = options.bundlesFilter(bundles);\n\t\t\t\t\t}\n\t\t\t\t\tif (!bundle) {\n\t\t\t\t\t\tbundles == null || bundles.sort((a, b) => {\n\t\t\t\t\t\t\treturn a.file.size - b.file.size;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tbundle = bundles == null ? void 0 : bundles[0];\n\t\t\t\t\t}\n\t\t\t\t\tif (bundle) (_this$_app$assets = this._app.assets) == null || _this$_app$assets.load(bundle);\n\t\t\t\t}\n\t\t\t\tthis._app.bundles.loadUrl(normalizedUrl, (err, fileUrlFromBundle) => {\n\t\t\t\t\thandleLoad(err, {\n\t\t\t\t\t\tload: fileUrlFromBundle,\n\t\t\t\t\t\toriginal: normalizedUrl\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\thandleLoad(null, {\n\t\t\t\t\tload: url,\n\t\t\t\t\toriginal: asset && asset.file.filename || url\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\t_loadNull(handler, callback, asset) {\n\t\tconst onLoad = function onLoad(err, data, extra) {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tcallback(null, handler.open(null, data, asset), extra);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tcallback(e);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\thandler.load(null, onLoad, asset);\n\t}\n\t_onSuccess(key, result, extra) {\n\t\tif (result !== null) {\n\t\t\tthis._cache[key] = result;\n\t\t} else {\n\t\t\tdelete this._cache[key];\n\t\t}\n\t\tfor (let i = 0; i < this._requests[key].length; i++) {\n\t\t\tthis._requests[key][i](null, result, extra);\n\t\t}\n\t\tdelete this._requests[key];\n\t}\n\t_onFailure(key, err) {\n\t\tconsole.error(err);\n\t\tif (this._requests[key]) {\n\t\t\tfor (let i = 0; i < this._requests[key].length; i++) {\n\t\t\t\tthis._requests[key][i](err);\n\t\t\t}\n\t\t\tdelete this._requests[key];\n\t\t}\n\t}\n\topen(type, data) {\n\t\tconst handler = this._handlers[type];\n\t\tif (!handler) {\n\t\t\tconsole.warn(`No resource handler found for: ${type}`);\n\t\t\treturn data;\n\t\t}\n\t\treturn handler.open(null, data);\n\t}\n\tpatch(asset, assets) {\n\t\tconst handler = this._handlers[asset.type];\n\t\tif (!handler) {\n\t\t\tconsole.warn(`No resource handler found for: ${asset.type}`);\n\t\t\treturn;\n\t\t}\n\t\tif (handler.patch) {\n\t\t\thandler.patch(asset, assets);\n\t\t}\n\t}\n\tclearCache(url, type) {\n\t\tconst key = ResourceLoader.makeKey(url, type);\n\t\tdelete this._cache[key];\n\t}\n\tgetFromCache(url, type) {\n\t\tconst key = ResourceLoader.makeKey(url, type);\n\t\tif (this._cache[key]) {\n\t\t\treturn this._cache[key];\n\t\t}\n\t\treturn undefined;\n\t}\n\tenableRetry(maxRetries = 5) {\n\t\tmaxRetries = Math.max(0, maxRetries) || 0;\n\t\tfor (const key in this._handlers) {\n\t\t\tthis._handlers[key].maxRetries = maxRetries;\n\t\t}\n\t}\n\tdisableRetry() {\n\t\tfor (const key in this._handlers) {\n\t\t\tthis._handlers[key].maxRetries = 0;\n\t\t}\n\t}\n\tdestroy() {\n\t\tthis._handlers = {};\n\t\tthis._requests = {};\n\t\tthis._cache = {};\n\t}\n}\n\nexport { ResourceLoader };\n","import { http } from '../../platform/net/http.js';\nimport { PIXELFORMAT_RGBA8 } from '../../platform/graphics/constants.js';\nimport { Texture } from '../../platform/graphics/texture.js';\nimport { SPECULAR_PHONG } from '../../scene/constants.js';\nimport { standardMaterialTextureParameters, standardMaterialCubemapParameters } from '../../scene/materials/standard-material-parameters.js';\nimport { AssetReference } from '../asset/asset-reference.js';\nimport { JsonStandardMaterialParser } from '../parsers/material/json-standard-material.js';\nimport { ResourceHandler } from './handler.js';\n\nconst PLACEHOLDER_MAP = {\n\taoMap: 'white',\n\tdiffuseMap: 'gray',\n\tspecularMap: 'gray',\n\tspecularityFactorMap: 'white',\n\tmetalnessMap: 'black',\n\tglossMap: 'gray',\n\tsheenMap: 'black',\n\tsheenGlossinessMap: 'gray',\n\tclearCoatMap: 'black',\n\tclearCoatGlossMap: 'gray',\n\tclearCoatNormalMap: 'normal',\n\trefractionMap: 'white',\n\temissiveMap: 'gray',\n\tnormalMap: 'normal',\n\theightMap: 'gray',\n\topacityMap: 'gray',\n\tsphereMap: 'gray',\n\tlightMap: 'white'\n};\nclass MaterialHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'material');\n\t\tthis._assets = app.assets;\n\t\tthis._device = app.graphicsDevice;\n\t\tthis._placeholderTextures = null;\n\t\tthis._parser = new JsonStandardMaterialParser();\n\t}\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\t\thttp.get(url.load, {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t}, (err, response) => {\n\t\t\tif (!err) {\n\t\t\t\tif (callback) {\n\t\t\t\t\tresponse._engine = true;\n\t\t\t\t\tcallback(null, response);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(`Error loading material: ${url.original} [${err}]`);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\topen(url, data) {\n\t\tconst material = this._parser.parse(data);\n\t\tif (data._engine) {\n\t\t\tmaterial._data = data;\n\t\t\tdelete data._engine;\n\t\t}\n\t\treturn material;\n\t}\n\t_createPlaceholders() {\n\t\tthis._placeholderTextures = {};\n\t\tconst textures = {\n\t\t\twhite: [255, 255, 255, 255],\n\t\t\tgray: [128, 128, 128, 255],\n\t\t\tblack: [0, 0, 0, 255],\n\t\t\tnormal: [128, 128, 255, 255]\n\t\t};\n\t\tfor (const key in textures) {\n\t\t\tif (!textures.hasOwnProperty(key)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._placeholderTextures[key] = new Texture(this._device, {\n\t\t\t\twidth: 2,\n\t\t\t\theight: 2,\n\t\t\t\tformat: PIXELFORMAT_RGBA8,\n\t\t\t\tname: 'material_placeholder'\n\t\t\t});\n\t\t\tconst pixels = this._placeholderTextures[key].lock();\n\t\t\tfor (let i = 0; i < 4; i++) {\n\t\t\t\tfor (let c = 0; c < 4; c++) {\n\t\t\t\t\tpixels[i * 4 + c] = textures[key][c];\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._placeholderTextures[key].unlock();\n\t\t}\n\t}\n\tpatch(asset, assets) {\n\t\tif (asset.resource._data) {\n\t\t\tasset._data = asset.resource._data;\n\t\t\tdelete asset.resource._data;\n\t\t}\n\t\tasset.data.name = asset.name;\n\t\tasset.resource.name = asset.name;\n\t\tthis._bindAndAssignAssets(asset, assets);\n\t\tasset.off('unload', this._onAssetUnload, this);\n\t\tasset.on('unload', this._onAssetUnload, this);\n\t}\n\t_onAssetUnload(asset) {\n\t\tdelete asset.data.parameters;\n\t\tdelete asset.data.chunks;\n\t\tdelete asset.data.name;\n\t}\n\t_assignTexture(parameterName, materialAsset, texture) {\n\t\tmaterialAsset.resource[parameterName] = texture;\n\t}\n\t_getPlaceholderTexture(parameterName) {\n\t\tif (!this._placeholderTextures) {\n\t\t\tthis._createPlaceholders();\n\t\t}\n\t\tconst placeholder = PLACEHOLDER_MAP[parameterName];\n\t\tconst texture = this._placeholderTextures[placeholder];\n\t\treturn texture;\n\t}\n\t_assignPlaceholderTexture(parameterName, materialAsset) {\n\t\tmaterialAsset.resource[parameterName] = this._getPlaceholderTexture(parameterName);\n\t}\n\t_onTextureLoad(parameterName, materialAsset, textureAsset) {\n\t\tthis._assignTexture(parameterName, materialAsset, textureAsset.resource);\n\t\tmaterialAsset.resource.update();\n\t}\n\t_onTextureAdd(parameterName, materialAsset, textureAsset) {\n\t\tthis._assets.load(textureAsset);\n\t}\n\t_onTextureRemoveOrUnload(parameterName, materialAsset, textureAsset) {\n\t\tconst material = materialAsset.resource;\n\t\tif (material) {\n\t\t\tif (materialAsset.resource[parameterName] === textureAsset.resource) {\n\t\t\t\tthis._assignPlaceholderTexture(parameterName, materialAsset);\n\t\t\t\tmaterial.update();\n\t\t\t}\n\t\t}\n\t}\n\t_assignCubemap(parameterName, materialAsset, textures) {\n\t\tmaterialAsset.resource[parameterName] = textures[0];\n\t\tif (parameterName === 'cubeMap') {\n\t\t\tconst prefiltered = textures.slice(1);\n\t\t\tif (prefiltered.every(t => t)) {\n\t\t\t\tmaterialAsset.resource.prefilteredCubemaps = prefiltered;\n\t\t\t} else if (prefiltered[0]) {\n\t\t\t\tmaterialAsset.resource.envAtlas = prefiltered[0];\n\t\t\t}\n\t\t}\n\t}\n\t_onCubemapLoad(parameterName, materialAsset, cubemapAsset) {\n\t\tthis._assignCubemap(parameterName, materialAsset, cubemapAsset.resources);\n\t\tthis._parser.initialize(materialAsset.resource, materialAsset.data);\n\t}\n\t_onCubemapAdd(parameterName, materialAsset, cubemapAsset) {\n\t\tif (materialAsset.data.shadingModel === SPECULAR_PHONG) {\n\t\t\tmaterialAsset.loadFaces = true;\n\t\t}\n\t\tthis._assets.load(cubemapAsset);\n\t}\n\t_onCubemapRemoveOrUnload(parameterName, materialAsset, cubemapAsset) {\n\t\tconst material = materialAsset.resource;\n\t\tif (materialAsset.data.prefilteredCubeMap128 === cubemapAsset.resources[1]) {\n\t\t\tthis._assignCubemap(parameterName, materialAsset, [null, null, null, null, null, null, null]);\n\t\t\tmaterial.update();\n\t\t}\n\t}\n\t_bindAndAssignAssets(materialAsset, assets) {\n\t\tconst data = this._parser.migrate(materialAsset.data);\n\t\tconst material = materialAsset.resource;\n\t\tconst pathMapping = data.mappingFormat === 'path';\n\t\tconst TEXTURES = standardMaterialTextureParameters;\n\t\tlet i, name, assetReference;\n\t\tfor (i = 0; i < TEXTURES.length; i++) {\n\t\t\tname = TEXTURES[i];\n\t\t\tassetReference = material._assetReferences[name];\n\t\t\tconst dataAssetId = data[name];\n\t\t\tconst materialTexture = material[name];\n\t\t\tconst isPlaceHolderTexture = materialTexture === this._getPlaceholderTexture(name);\n\t\t\tconst dataValidated = data.validated;\n\t\t\tif (dataAssetId && (!materialTexture || !dataValidated || isPlaceHolderTexture)) {\n\t\t\t\tif (!assetReference) {\n\t\t\t\t\tassetReference = new AssetReference(name, materialAsset, assets, {\n\t\t\t\t\t\tload: this._onTextureLoad,\n\t\t\t\t\t\tadd: this._onTextureAdd,\n\t\t\t\t\t\tremove: this._onTextureRemoveOrUnload,\n\t\t\t\t\t\tunload: this._onTextureRemoveOrUnload\n\t\t\t\t\t}, this);\n\t\t\t\t\tmaterial._assetReferences[name] = assetReference;\n\t\t\t\t}\n\t\t\t\tif (pathMapping) {\n\t\t\t\t\tassetReference.url = materialAsset.getAbsoluteUrl(dataAssetId);\n\t\t\t\t} else {\n\t\t\t\t\tassetReference.id = dataAssetId;\n\t\t\t\t}\n\t\t\t\tif (assetReference.asset) {\n\t\t\t\t\tif (assetReference.asset.resource) {\n\t\t\t\t\t\tthis._assignTexture(name, materialAsset, assetReference.asset.resource);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis._assignPlaceholderTexture(name, materialAsset);\n\t\t\t\t\t}\n\t\t\t\t\tassets.load(assetReference.asset);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (assetReference) {\n\t\t\t\t\tif (pathMapping) {\n\t\t\t\t\t\tassetReference.url = null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassetReference.id = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst CUBEMAPS = standardMaterialCubemapParameters;\n\t\tfor (i = 0; i < CUBEMAPS.length; i++) {\n\t\t\tname = CUBEMAPS[i];\n\t\t\tassetReference = material._assetReferences[name];\n\t\t\tif (data[name] && !materialAsset.data.prefilteredCubeMap128) {\n\t\t\t\tif (!assetReference) {\n\t\t\t\t\tassetReference = new AssetReference(name, materialAsset, assets, {\n\t\t\t\t\t\tload: this._onCubemapLoad,\n\t\t\t\t\t\tadd: this._onCubemapAdd,\n\t\t\t\t\t\tremove: this._onCubemapRemoveOrUnload,\n\t\t\t\t\t\tunload: this._onCubemapRemoveOrUnload\n\t\t\t\t\t}, this);\n\t\t\t\t\tmaterial._assetReferences[name] = assetReference;\n\t\t\t\t}\n\t\t\t\tif (pathMapping) {\n\t\t\t\t\tassetReference.url = data[name];\n\t\t\t\t} else {\n\t\t\t\t\tassetReference.id = data[name];\n\t\t\t\t}\n\t\t\t\tif (assetReference.asset) {\n\t\t\t\t\tif (assetReference.asset.loaded) {\n\t\t\t\t\t\tthis._assignCubemap(name, materialAsset, assetReference.asset.resources);\n\t\t\t\t\t}\n\t\t\t\t\tassets.load(assetReference.asset);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._parser.initialize(material, data);\n\t}\n}\n\nexport { MaterialHandler };\n","import { path } from '../../core/path.js';\nimport { Http, http } from '../../platform/net/http.js';\nimport { getDefaultMaterial } from '../../scene/materials/default-material.js';\nimport { GlbModelParser } from '../parsers/glb-model.js';\nimport { JsonModelParser } from '../parsers/json-model.js';\nimport { ResourceHandler } from './handler.js';\n\nclass ModelHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'model');\n\t\tthis._parsers = [];\n\t\tthis.device = app.graphicsDevice;\n\t\tthis.assets = app.assets;\n\t\tthis.defaultMaterial = getDefaultMaterial(this.device);\n\t\tthis.addParser(new JsonModelParser(this), (url, data) => {\n\t\t\treturn path.getExtension(url) === '.json';\n\t\t});\n\t\tthis.addParser(new GlbModelParser(this), (url, data) => {\n\t\t\treturn path.getExtension(url) === '.glb';\n\t\t});\n\t}\n\tload(url, callback, asset) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\t\tconst options = {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t};\n\t\tif (url.load.startsWith('blob:') || url.load.startsWith('data:')) {\n\t\t\tif (path.getExtension(url.original).toLowerCase() === '.glb') {\n\t\t\t\toptions.responseType = Http.ResponseType.ARRAY_BUFFER;\n\t\t\t} else {\n\t\t\t\toptions.responseType = Http.ResponseType.JSON;\n\t\t\t}\n\t\t}\n\t\thttp.get(url.load, options, (err, response) => {\n\t\t\tif (!callback) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!err) {\n\t\t\t\tfor (let i = 0; i < this._parsers.length; i++) {\n\t\t\t\t\tconst p = this._parsers[i];\n\t\t\t\t\tif (p.decider(url.original, response)) {\n\t\t\t\t\t\tp.parser.parse(response, (err, parseResult) => {\n\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tcallback(null, parseResult);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, asset);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcallback('No parsers found');\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading model: ${url.original} [${err}]`);\n\t\t\t}\n\t\t});\n\t}\n\topen(url, data) {\n\t\treturn data;\n\t}\n\tpatch(asset, assets) {\n\t\tif (!asset.resource) {\n\t\t\treturn;\n\t\t}\n\t\tconst data = asset.data;\n\t\tconst self = this;\n\t\tasset.resource.meshInstances.forEach((meshInstance, i) => {\n\t\t\tif (data.mapping) {\n\t\t\t\tconst handleMaterial = function handleMaterial(asset) {\n\t\t\t\t\tif (asset.resource) {\n\t\t\t\t\t\tmeshInstance.material = asset.resource;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tasset.once('load', handleMaterial);\n\t\t\t\t\t\tassets.load(asset);\n\t\t\t\t\t}\n\t\t\t\t\tasset.once('remove', asset => {\n\t\t\t\t\t\tif (meshInstance.material === asset.resource) {\n\t\t\t\t\t\t\tmeshInstance.material = self.defaultMaterial;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t};\n\t\t\t\tif (!data.mapping[i]) {\n\t\t\t\t\tmeshInstance.material = self.defaultMaterial;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst id = data.mapping[i].material;\n\t\t\t\tconst url = data.mapping[i].path;\n\t\t\t\tlet material;\n\t\t\t\tif (id !== undefined) {\n\t\t\t\t\tif (!id) {\n\t\t\t\t\t\tmeshInstance.material = self.defaultMaterial;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmaterial = assets.get(id);\n\t\t\t\t\t\tif (material) {\n\t\t\t\t\t\t\thandleMaterial(material);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tassets.once(`add:${id}`, handleMaterial);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (url) {\n\t\t\t\t\tconst path = asset.getAbsoluteUrl(data.mapping[i].path);\n\t\t\t\t\tmaterial = assets.getByUrl(path);\n\t\t\t\t\tif (material) {\n\t\t\t\t\t\thandleMaterial(material);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassets.once(`add:url:${path}`, handleMaterial);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\taddParser(parser, decider) {\n\t\tthis._parsers.push({\n\t\t\tparser: parser,\n\t\t\tdecider: decider\n\t\t});\n\t}\n}\n\nexport { ModelHandler };\n","import { Render } from '../../scene/render.js';\nimport { ResourceHandler } from './handler.js';\n\nfunction onContainerAssetLoaded(containerAsset) {\n\tconst renderAsset = this;\n\tif (!renderAsset.resource) return;\n\tconst containerResource = containerAsset.resource;\n\tconst render = containerResource.renders && containerResource.renders[renderAsset.data.renderIndex];\n\tif (render) {\n\t\trenderAsset.resource.meshes = render.resource.meshes;\n\t}\n}\nfunction onContainerAssetAdded(containerAsset) {\n\tconst renderAsset = this;\n\trenderAsset.registry.off(`load:${containerAsset.id}`, onContainerAssetLoaded, renderAsset);\n\trenderAsset.registry.on(`load:${containerAsset.id}`, onContainerAssetLoaded, renderAsset);\n\trenderAsset.registry.off(`remove:${containerAsset.id}`, onContainerAssetRemoved, renderAsset);\n\trenderAsset.registry.once(`remove:${containerAsset.id}`, onContainerAssetRemoved, renderAsset);\n\tif (!containerAsset.resource) {\n\t\trenderAsset.registry.load(containerAsset);\n\t} else {\n\t\tonContainerAssetLoaded.call(renderAsset, containerAsset);\n\t}\n}\nfunction onContainerAssetRemoved(containerAsset) {\n\tconst renderAsset = this;\n\trenderAsset.registry.off(`load:${containerAsset.id}`, onContainerAssetLoaded, renderAsset);\n\tif (renderAsset.resource) {\n\t\trenderAsset.resource.destroy();\n\t}\n}\nclass RenderHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'render');\n\t\tthis._registry = app.assets;\n\t}\n\topen(url, data) {\n\t\treturn new Render();\n\t}\n\tpatch(asset, registry) {\n\t\tif (!asset.data.containerAsset) {\n\t\t\treturn;\n\t\t}\n\t\tconst containerAsset = registry.get(asset.data.containerAsset);\n\t\tif (!containerAsset) {\n\t\t\tregistry.once(`add:${asset.data.containerAsset}`, onContainerAssetAdded, asset);\n\t\t\treturn;\n\t\t}\n\t\tonContainerAssetAdded.call(asset, containerAsset);\n\t}\n}\n\nexport { RenderHandler };\n","import { http } from '../../platform/net/http.js';\n\nclass SceneUtils {\n\tstatic load(url, maxRetries, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\t\thttp.get(url.load, {\n\t\t\tretry: maxRetries > 0,\n\t\t\tmaxRetries: maxRetries\n\t\t}, (err, response) => {\n\t\t\tif (!err) {\n\t\t\t\tcallback(err, response);\n\t\t\t} else {\n\t\t\t\tlet errMsg = `Error while loading scene JSON ${url.original}`;\n\t\t\t\tif (err.message) {\n\t\t\t\t\terrMsg += `: ${err.message}`;\n\t\t\t\t\tif (err.stack) {\n\t\t\t\t\t\terrMsg += `\\n${err.stack}`;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terrMsg += `: ${err}`;\n\t\t\t\t}\n\t\t\t\tcallback(errMsg);\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport { SceneUtils };\n","import { SceneUtils } from './scene-utils.js';\nimport { SceneParser } from '../parsers/scene.js';\nimport { ResourceHandler } from './handler.js';\n\nclass SceneHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'scene');\n\t}\n\tload(url, callback) {\n\t\tSceneUtils.load(url, this.maxRetries, callback);\n\t}\n\topen(url, data) {\n\t\tthis._app.systems.script.preloading = true;\n\t\tconst parser = new SceneParser(this._app, false);\n\t\tconst parent = parser.parse(data);\n\t\tconst scene = this._app.scene;\n\t\tscene.root = parent;\n\t\tthis._app.applySceneSettings(data.settings);\n\t\tthis._app.systems.script.preloading = false;\n\t\treturn scene;\n\t}\n}\n\nexport { SceneHandler };\n","import { platform } from '../../core/platform.js';\nimport { script } from '../script.js';\nimport { ScriptTypes } from '../script/script-types.js';\nimport { registerScript } from '../script/script-create.js';\nimport { ResourceLoader } from './loader.js';\nimport { ResourceHandler } from './handler.js';\nimport { Script } from '../script/script.js';\n\nconst toLowerCamelCase = str => str[0].toLowerCase() + str.substring(1);\nclass ScriptHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'script');\n\t\tthis._scripts = {};\n\t\tthis._cache = {};\n\t}\n\tclearCache() {\n\t\tfor (const key in this._cache) {\n\t\t\tconst element = this._cache[key];\n\t\t\tconst parent = element.parentNode;\n\t\t\tif (parent) {\n\t\t\t\tparent.removeChild(element);\n\t\t\t}\n\t\t}\n\t\tthis._cache = {};\n\t}\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\t\tconst self = this;\n\t\tscript.app = this._app;\n\t\tconst onScriptLoad = (url.load, (err, url, extra) => {\n\t\t\tif (!err) {\n\t\t\t\tif (script.legacy) {\n\t\t\t\t\tlet Type = null;\n\t\t\t\t\tif (ScriptTypes._types.length) {\n\t\t\t\t\t\tType = ScriptTypes._types.pop();\n\t\t\t\t\t}\n\t\t\t\t\tif (Type) {\n\t\t\t\t\t\tthis._scripts[url] = Type;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tType = null;\n\t\t\t\t\t}\n\t\t\t\t\tcallback(null, Type, extra);\n\t\t\t\t} else {\n\t\t\t\t\tconst obj = {};\n\t\t\t\t\tfor (let i = 0; i < ScriptTypes._types.length; i++) {\n\t\t\t\t\t\tobj[ScriptTypes._types[i].name] = ScriptTypes._types[i];\n\t\t\t\t\t}\n\t\t\t\t\tScriptTypes._types.length = 0;\n\t\t\t\t\tcallback(null, obj, extra);\n\t\t\t\t\tdelete self._loader._cache[ResourceLoader.makeKey(url, 'script')];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcallback(err);\n\t\t\t}\n\t\t});\n\t\tconst [basePath] = url.load.split('?');\n\t\tconst isEsmScript = basePath.endsWith('.mjs');\n\t\tif (isEsmScript) {\n\t\t\tthis._loadModule(basePath, onScriptLoad);\n\t\t} else {\n\t\t\tthis._loadScript(url.load, onScriptLoad);\n\t\t}\n\t}\n\topen(url, data) {\n\t\treturn data;\n\t}\n\tpatch(asset, assets) {}\n\t_loadScript(url, callback) {\n\t\tconst head = document.head;\n\t\tconst element = document.createElement('script');\n\t\tthis._cache[url] = element;\n\t\telement.async = false;\n\t\telement.addEventListener('error', e => {\n\t\t\tcallback(`Script: ${e.target.src} failed to load`);\n\t\t}, false);\n\t\tlet done = false;\n\t\telement.onload = element.onreadystatechange = function () {\n\t\t\tif (!done && (!this.readyState || this.readyState === 'loaded' || this.readyState === 'complete')) {\n\t\t\t\tdone = true;\n\t\t\t\tcallback(null, url, element);\n\t\t\t}\n\t\t};\n\t\telement.src = url;\n\t\thead.appendChild(element);\n\t}\n\t_loadModule(url, callback) {\n\t\tconst baseUrl = platform.browser ? window.location.origin + window.location.pathname : import.meta.url;\n\t\tconst importUrl = new URL(url, baseUrl);\n\t\timport(/* @vite-ignore */ /* webpackIgnore: true */ importUrl.toString()).then(module => {\n\t\t\tconst filename = importUrl.pathname.split('/').pop();\n\t\t\tconst scriptSchema = this._app.assets.find(filename, 'script').data.scripts;\n\t\t\tfor (const key in module) {\n\t\t\t\tconst scriptClass = module[key];\n\t\t\t\tconst extendsScriptType = scriptClass.prototype instanceof Script;\n\t\t\t\tif (extendsScriptType) {\n\t\t\t\t\tconst scriptName = toLowerCamelCase(scriptClass.name);\n\t\t\t\t\tregisterScript(scriptClass, scriptName);\n\t\t\t\t\tthis._app.scripts.addSchema(scriptName, scriptSchema[scriptName]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcallback(null, url, null);\n\t\t}).catch(err => {\n\t\t\tcallback(err);\n\t\t});\n\t}\n}\n\nexport { ScriptHandler };\n","import { http } from '../../platform/net/http.js';\nimport { ResourceHandler } from './handler.js';\n\nclass ShaderHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'shader');\n\t\tthis.decoder = null;\n\t}\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\t\thttp.get(url.load, {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t}, (err, response) => {\n\t\t\tif (!err) {\n\t\t\t\tcallback(null, response);\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading shader resource: ${url.original} [${err}]`);\n\t\t\t}\n\t\t});\n\t}\n\topenBinary(data) {\n\t\tvar _this$decoder;\n\t\t(_this$decoder = this.decoder) != null ? _this$decoder : this.decoder = new TextDecoder('utf-8');\n\t\treturn this.decoder.decode(data);\n\t}\n}\n\nexport { ShaderHandler };\n","import { path } from '../../core/path.js';\nimport { http } from '../../platform/net/http.js';\nimport { Sprite } from '../../scene/sprite.js';\nimport { ResourceHandler } from './handler.js';\n\nfunction onTextureAtlasLoaded(atlasAsset) {\n\tconst spriteAsset = this;\n\tif (spriteAsset.resource) {\n\t\tspriteAsset.resource.atlas = atlasAsset.resource;\n\t}\n}\nfunction onTextureAtlasAdded(atlasAsset) {\n\tconst spriteAsset = this;\n\tspriteAsset.registry.load(atlasAsset);\n}\nclass SpriteHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'sprite');\n\t\tthis._assets = app.assets;\n\t\tthis._device = app.graphicsDevice;\n\t}\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\t\tif (path.getExtension(url.original) === '.json') {\n\t\t\thttp.get(url.load, {\n\t\t\t\tretry: this.maxRetries > 0,\n\t\t\t\tmaxRetries: this.maxRetries\n\t\t\t}, (err, response) => {\n\t\t\t\tif (!err) {\n\t\t\t\t\tcallback(null, response);\n\t\t\t\t} else {\n\t\t\t\t\tcallback(err);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\topen(url, data) {\n\t\tconst sprite = new Sprite(this._device);\n\t\tif (url) {\n\t\t\tsprite.__data = data;\n\t\t}\n\t\treturn sprite;\n\t}\n\tpatch(asset, assets) {\n\t\tconst sprite = asset.resource;\n\t\tif (sprite.__data) {\n\t\t\tasset.data.pixelsPerUnit = sprite.__data.pixelsPerUnit;\n\t\t\tasset.data.renderMode = sprite.__data.renderMode;\n\t\t\tasset.data.frameKeys = sprite.__data.frameKeys;\n\t\t\tif (sprite.__data.textureAtlasAsset) {\n\t\t\t\tconst atlas = assets.getByUrl(sprite.__data.textureAtlasAsset);\n\t\t\t\tif (atlas) {\n\t\t\t\t\tasset.data.textureAtlasAsset = atlas.id;\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(`Could not find textureatlas with url: ${sprite.__data.textureAtlasAsset}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsprite.startUpdate();\n\t\tsprite.renderMode = asset.data.renderMode;\n\t\tsprite.pixelsPerUnit = asset.data.pixelsPerUnit;\n\t\tsprite.frameKeys = asset.data.frameKeys;\n\t\tthis._updateAtlas(asset);\n\t\tsprite.endUpdate();\n\t\tasset.off('change', this._onAssetChange, this);\n\t\tasset.on('change', this._onAssetChange, this);\n\t}\n\t_updateAtlas(asset) {\n\t\tconst sprite = asset.resource;\n\t\tif (!asset.data.textureAtlasAsset) {\n\t\t\tsprite.atlas = null;\n\t\t\treturn;\n\t\t}\n\t\tthis._assets.off(`load:${asset.data.textureAtlasAsset}`, onTextureAtlasLoaded, asset);\n\t\tthis._assets.on(`load:${asset.data.textureAtlasAsset}`, onTextureAtlasLoaded, asset);\n\t\tconst atlasAsset = this._assets.get(asset.data.textureAtlasAsset);\n\t\tif (atlasAsset && atlasAsset.resource) {\n\t\t\tsprite.atlas = atlasAsset.resource;\n\t\t} else {\n\t\t\tif (!atlasAsset) {\n\t\t\t\tthis._assets.off(`add:${asset.data.textureAtlasAsset}`, onTextureAtlasAdded, asset);\n\t\t\t\tthis._assets.on(`add:${asset.data.textureAtlasAsset}`, onTextureAtlasAdded, asset);\n\t\t\t} else {\n\t\t\t\tthis._assets.load(atlasAsset);\n\t\t\t}\n\t\t}\n\t}\n\t_onAssetChange(asset, attribute, value, oldValue) {\n\t\tif (attribute === 'data') {\n\t\t\tif (value && value.textureAtlasAsset && oldValue && value.textureAtlasAsset !== oldValue.textureAtlasAsset) {\n\t\t\t\tthis._assets.off(`load:${oldValue.textureAtlasAsset}`, onTextureAtlasLoaded, asset);\n\t\t\t\tthis._assets.off(`add:${oldValue.textureAtlasAsset}`, onTextureAtlasAdded, asset);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { SpriteHandler };\n","import { http } from '../../platform/net/http.js';\nimport { Template } from '../template.js';\nimport { ResourceHandler } from './handler.js';\n\nclass TemplateHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'template');\n\t\tthis.decoder = null;\n\t}\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\t\tconst options = {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t};\n\t\thttp.get(url.load, options, (err, response) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(`Error requesting template: ${url.original}`);\n\t\t\t} else {\n\t\t\t\tcallback(err, response);\n\t\t\t}\n\t\t});\n\t}\n\topen(url, data) {\n\t\treturn new Template(this._app, data);\n\t}\n\topenBinary(data) {\n\t\tvar _this$decoder;\n\t\t(_this$decoder = this.decoder) != null ? _this$decoder : this.decoder = new TextDecoder('utf-8');\n\t\treturn new Template(this._app, JSON.parse(this.decoder.decode(data)));\n\t}\n}\n\nexport { TemplateHandler };\n","import { http } from '../../platform/net/http.js';\nimport { ResourceHandler } from './handler.js';\n\nclass TextHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'text');\n\t\tthis.decoder = null;\n\t}\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\t\thttp.get(url.load, {\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t}, (err, response) => {\n\t\t\tif (!err) {\n\t\t\t\tcallback(null, response);\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading text resource: ${url.original} [${err}]`);\n\t\t\t}\n\t\t});\n\t}\n\topenBinary(data) {\n\t\tvar _this$decoder;\n\t\t(_this$decoder = this.decoder) != null ? _this$decoder : this.decoder = new TextDecoder('utf-8');\n\t\treturn this.decoder.decode(data);\n\t}\n}\n\nexport { TextHandler };\n","import { path } from '../../core/path.js';\nimport { Vec2 } from '../../core/math/vec2.js';\nimport { Vec4 } from '../../core/math/vec4.js';\nimport { TEXTURETYPE_RGBM, TEXTURETYPE_DEFAULT, ADDRESS_REPEAT, ADDRESS_CLAMP_TO_EDGE, ADDRESS_MIRRORED_REPEAT, FILTER_NEAREST, FILTER_LINEAR, FILTER_NEAREST_MIPMAP_NEAREST, FILTER_LINEAR_MIPMAP_NEAREST, FILTER_NEAREST_MIPMAP_LINEAR, FILTER_LINEAR_MIPMAP_LINEAR } from '../../platform/graphics/constants.js';\nimport { http } from '../../platform/net/http.js';\nimport { TextureAtlas } from '../../scene/texture-atlas.js';\nimport { ResourceHandler } from './handler.js';\n\nconst JSON_ADDRESS_MODE = {\n\t'repeat': ADDRESS_REPEAT,\n\t'clamp': ADDRESS_CLAMP_TO_EDGE,\n\t'mirror': ADDRESS_MIRRORED_REPEAT\n};\nconst JSON_FILTER_MODE = {\n\t'nearest': FILTER_NEAREST,\n\t'linear': FILTER_LINEAR,\n\t'nearest_mip_nearest': FILTER_NEAREST_MIPMAP_NEAREST,\n\t'linear_mip_nearest': FILTER_LINEAR_MIPMAP_NEAREST,\n\t'nearest_mip_linear': FILTER_NEAREST_MIPMAP_LINEAR,\n\t'linear_mip_linear': FILTER_LINEAR_MIPMAP_LINEAR\n};\nconst regexFrame = /^data\\.frames\\.(\\d+)$/;\nclass TextureAtlasHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'textureatlas');\n\t\tthis._loader = app.loader;\n\t}\n\tload(url, callback) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\t\tconst self = this;\n\t\tconst handler = this._loader.getHandler('texture');\n\t\tif (path.getExtension(url.original) === '.json') {\n\t\t\thttp.get(url.load, {\n\t\t\t\tretry: this.maxRetries > 0,\n\t\t\t\tmaxRetries: this.maxRetries\n\t\t\t}, (err, response) => {\n\t\t\t\tif (!err) {\n\t\t\t\t\tconst textureUrl = url.original.replace('.json', '.png');\n\t\t\t\t\tself._loader.load(textureUrl, 'texture', (err, texture) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcallback(null, {\n\t\t\t\t\t\t\t\tdata: response,\n\t\t\t\t\t\t\t\ttexture: texture\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tcallback(err);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\thandler.load(url, callback);\n\t\t}\n\t}\n\topen(url, data) {\n\t\tconst resource = new TextureAtlas();\n\t\tif (data.texture && data.data) {\n\t\t\tresource.texture = data.texture;\n\t\t\tresource.__data = data.data;\n\t\t} else {\n\t\t\tconst handler = this._loader.getHandler('texture');\n\t\t\tconst texture = handler.open(url, data);\n\t\t\tif (!texture) return null;\n\t\t\tresource.texture = texture;\n\t\t}\n\t\treturn resource;\n\t}\n\tpatch(asset, assets) {\n\t\tif (!asset.resource) {\n\t\t\treturn;\n\t\t}\n\t\tif (asset.resource.__data) {\n\t\t\tif (asset.resource.__data.minfilter !== undefined) asset.data.minfilter = asset.resource.__data.minfilter;\n\t\t\tif (asset.resource.__data.magfilter !== undefined) asset.data.magfilter = asset.resource.__data.magfilter;\n\t\t\tif (asset.resource.__data.addressu !== undefined) asset.data.addressu = asset.resource.__data.addressu;\n\t\t\tif (asset.resource.__data.addressv !== undefined) asset.data.addressv = asset.resource.__data.addressv;\n\t\t\tif (asset.resource.__data.mipmaps !== undefined) asset.data.mipmaps = asset.resource.__data.mipmaps;\n\t\t\tif (asset.resource.__data.anisotropy !== undefined) asset.data.anisotropy = asset.resource.__data.anisotropy;\n\t\t\tif (asset.resource.__data.rgbm !== undefined) asset.data.rgbm = !!asset.resource.__data.rgbm;\n\t\t\tasset.data.frames = asset.resource.__data.frames;\n\t\t\tdelete asset.resource.__data;\n\t\t}\n\t\tconst texture = asset.resource.texture;\n\t\tif (texture) {\n\t\t\ttexture.name = asset.name;\n\t\t\tif (asset.data.hasOwnProperty('minfilter') && texture.minFilter !== JSON_FILTER_MODE[asset.data.minfilter]) {\n\t\t\t\ttexture.minFilter = JSON_FILTER_MODE[asset.data.minfilter];\n\t\t\t}\n\t\t\tif (asset.data.hasOwnProperty('magfilter') && texture.magFilter !== JSON_FILTER_MODE[asset.data.magfilter]) {\n\t\t\t\ttexture.magFilter = JSON_FILTER_MODE[asset.data.magfilter];\n\t\t\t}\n\t\t\tif (asset.data.hasOwnProperty('addressu') && texture.addressU !== JSON_ADDRESS_MODE[asset.data.addressu]) {\n\t\t\t\ttexture.addressU = JSON_ADDRESS_MODE[asset.data.addressu];\n\t\t\t}\n\t\t\tif (asset.data.hasOwnProperty('addressv') && texture.addressV !== JSON_ADDRESS_MODE[asset.data.addressv]) {\n\t\t\t\ttexture.addressV = JSON_ADDRESS_MODE[asset.data.addressv];\n\t\t\t}\n\t\t\tif (asset.data.hasOwnProperty('mipmaps') && texture.mipmaps !== asset.data.mipmaps) {\n\t\t\t\ttexture.mipmaps = asset.data.mipmaps;\n\t\t\t}\n\t\t\tif (asset.data.hasOwnProperty('anisotropy') && texture.anisotropy !== asset.data.anisotropy) {\n\t\t\t\ttexture.anisotropy = asset.data.anisotropy;\n\t\t\t}\n\t\t\tif (asset.data.hasOwnProperty('rgbm')) {\n\t\t\t\tconst type = asset.data.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;\n\t\t\t\tif (texture.type !== type) {\n\t\t\t\t\ttexture.type = type;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tasset.resource.texture = texture;\n\t\tconst frames = {};\n\t\tfor (const key in asset.data.frames) {\n\t\t\tconst frame = asset.data.frames[key];\n\t\t\tframes[key] = {\n\t\t\t\trect: new Vec4(frame.rect),\n\t\t\t\tpivot: new Vec2(frame.pivot),\n\t\t\t\tborder: new Vec4(frame.border)\n\t\t\t};\n\t\t}\n\t\tasset.resource.frames = frames;\n\t\tasset.off('change', this._onAssetChange, this);\n\t\tasset.on('change', this._onAssetChange, this);\n\t}\n\t_onAssetChange(asset, attribute, value) {\n\t\tlet frame;\n\t\tif (attribute === 'data' || attribute === 'data.frames') {\n\t\t\tconst frames = {};\n\t\t\tfor (const key in value.frames) {\n\t\t\t\tframe = value.frames[key];\n\t\t\t\tframes[key] = {\n\t\t\t\t\trect: new Vec4(frame.rect),\n\t\t\t\t\tpivot: new Vec2(frame.pivot),\n\t\t\t\t\tborder: new Vec4(frame.border)\n\t\t\t\t};\n\t\t\t}\n\t\t\tasset.resource.frames = frames;\n\t\t} else {\n\t\t\tconst match = attribute.match(regexFrame);\n\t\t\tif (match) {\n\t\t\t\tconst frameKey = match[1];\n\t\t\t\tif (value) {\n\t\t\t\t\tif (!asset.resource.frames[frameKey]) {\n\t\t\t\t\t\tasset.resource.frames[frameKey] = {\n\t\t\t\t\t\t\trect: new Vec4(value.rect),\n\t\t\t\t\t\t\tpivot: new Vec2(value.pivot),\n\t\t\t\t\t\t\tborder: new Vec4(value.border)\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tframe = asset.resource.frames[frameKey];\n\t\t\t\t\t\tframe.rect.set(value.rect[0], value.rect[1], value.rect[2], value.rect[3]);\n\t\t\t\t\t\tframe.pivot.set(value.pivot[0], value.pivot[1]);\n\t\t\t\t\t\tframe.border.set(value.border[0], value.border[1], value.border[2], value.border[3]);\n\t\t\t\t\t}\n\t\t\t\t\tasset.resource.fire('set:frame', frameKey, asset.resource.frames[frameKey]);\n\t\t\t\t} else {\n\t\t\t\t\tif (asset.resource.frames[frameKey]) {\n\t\t\t\t\t\tdelete asset.resource.frames[frameKey];\n\t\t\t\t\t\tasset.resource.fire('remove:frame', frameKey);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { TextureAtlasHandler };\n","import { path } from '../../core/path.js';\nimport { TEXTURETYPE_RGBM, TEXTURETYPE_SWIZZLEGGGR, PIXELFORMAT_RGB8, ADDRESS_REPEAT, ADDRESS_CLAMP_TO_EDGE, ADDRESS_MIRRORED_REPEAT, FILTER_NEAREST, FILTER_LINEAR, FILTER_NEAREST_MIPMAP_NEAREST, FILTER_LINEAR_MIPMAP_NEAREST, FILTER_NEAREST_MIPMAP_LINEAR, FILTER_LINEAR_MIPMAP_LINEAR, TEXTURETYPE_DEFAULT, TEXTURETYPE_RGBE, TEXTURETYPE_RGBP, PIXELFORMAT_RGBA8, PIXELFORMAT_RGBA32F } from '../../platform/graphics/constants.js';\nimport { Texture } from '../../platform/graphics/texture.js';\nimport { TextureUtils } from '../../platform/graphics/texture-utils.js';\nimport { BasisParser } from '../parsers/texture/basis.js';\nimport { ImgParser } from '../parsers/texture/img.js';\nimport { KtxParser } from '../parsers/texture/ktx.js';\nimport { Ktx2Parser } from '../parsers/texture/ktx2.js';\nimport { DdsParser } from '../parsers/texture/dds.js';\nimport { HdrParser } from '../parsers/texture/hdr.js';\nimport { ResourceHandler } from './handler.js';\n\nconst JSON_ADDRESS_MODE = {\n\t'repeat': ADDRESS_REPEAT,\n\t'clamp': ADDRESS_CLAMP_TO_EDGE,\n\t'mirror': ADDRESS_MIRRORED_REPEAT\n};\nconst JSON_FILTER_MODE = {\n\t'nearest': FILTER_NEAREST,\n\t'linear': FILTER_LINEAR,\n\t'nearest_mip_nearest': FILTER_NEAREST_MIPMAP_NEAREST,\n\t'linear_mip_nearest': FILTER_LINEAR_MIPMAP_NEAREST,\n\t'nearest_mip_linear': FILTER_NEAREST_MIPMAP_LINEAR,\n\t'linear_mip_linear': FILTER_LINEAR_MIPMAP_LINEAR\n};\nconst JSON_TEXTURE_TYPE = {\n\t'default': TEXTURETYPE_DEFAULT,\n\t'rgbm': TEXTURETYPE_RGBM,\n\t'rgbe': TEXTURETYPE_RGBE,\n\t'rgbp': TEXTURETYPE_RGBP,\n\t'swizzleGGGR': TEXTURETYPE_SWIZZLEGGGR\n};\nconst _completePartialMipmapChain = function _completePartialMipmapChain(texture) {\n\tconst requiredMipLevels = TextureUtils.calcMipLevelsCount(texture._width, texture._height);\n\tconst isHtmlElement = function isHtmlElement(object) {\n\t\treturn object instanceof HTMLCanvasElement || object instanceof HTMLImageElement || object instanceof HTMLVideoElement;\n\t};\n\tif (!(texture._format === PIXELFORMAT_RGBA8 || texture._format === PIXELFORMAT_RGBA32F) || texture._volume || texture._compressed || texture._levels.length === 1 || texture._levels.length === requiredMipLevels || isHtmlElement(texture._cubemap ? texture._levels[0][0] : texture._levels[0])) {\n\t\treturn;\n\t}\n\tconst downsample = function downsample(width, height, data) {\n\t\tconst sampledWidth = Math.max(1, width >> 1);\n\t\tconst sampledHeight = Math.max(1, height >> 1);\n\t\tconst sampledData = new data.constructor(sampledWidth * sampledHeight * 4);\n\t\tconst xs = Math.floor(width / sampledWidth);\n\t\tconst ys = Math.floor(height / sampledHeight);\n\t\tconst xsys = xs * ys;\n\t\tfor (let y = 0; y < sampledHeight; ++y) {\n\t\t\tfor (let x = 0; x < sampledWidth; ++x) {\n\t\t\t\tfor (let e = 0; e < 4; ++e) {\n\t\t\t\t\tlet sum = 0;\n\t\t\t\t\tfor (let sy = 0; sy < ys; ++sy) {\n\t\t\t\t\t\tfor (let sx = 0; sx < xs; ++sx) {\n\t\t\t\t\t\t\tsum += data[(x * xs + sx + (y * ys + sy) * width) * 4 + e];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tsampledData[(x + y * sampledWidth) * 4 + e] = sum / xsys;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn sampledData;\n\t};\n\tfor (let level = texture._levels.length; level < requiredMipLevels; ++level) {\n\t\tconst width = Math.max(1, texture._width >> level - 1);\n\t\tconst height = Math.max(1, texture._height >> level - 1);\n\t\tif (texture._cubemap) {\n\t\t\tconst mips = [];\n\t\t\tfor (let face = 0; face < 6; ++face) {\n\t\t\t\tmips.push(downsample(width, height, texture._levels[level - 1][face]));\n\t\t\t}\n\t\t\ttexture._levels.push(mips);\n\t\t} else {\n\t\t\ttexture._levels.push(downsample(width, height, texture._levels[level - 1]));\n\t\t}\n\t}\n\ttexture._levelsUpdated = texture._cubemap ? [[true, true, true, true, true, true]] : [true];\n};\nclass TextureHandler extends ResourceHandler {\n\tconstructor(app) {\n\t\tsuper(app, 'texture');\n\t\tconst assets = app.assets;\n\t\tconst device = app.graphicsDevice;\n\t\tthis._device = device;\n\t\tthis._assets = assets;\n\t\tthis.imgParser = new ImgParser(assets, device);\n\t\tthis.parsers = {\n\t\t\tdds: new DdsParser(assets),\n\t\t\tktx: new KtxParser(assets),\n\t\t\tktx2: new Ktx2Parser(assets, device),\n\t\t\tbasis: new BasisParser(assets, device),\n\t\t\thdr: new HdrParser(assets)\n\t\t};\n\t}\n\tset crossOrigin(value) {\n\t\tthis.imgParser.crossOrigin = value;\n\t}\n\tget crossOrigin() {\n\t\treturn this.imgParser.crossOrigin;\n\t}\n\tset maxRetries(value) {\n\t\tthis.imgParser.maxRetries = value;\n\t\tfor (const parser in this.parsers) {\n\t\t\tif (this.parsers.hasOwnProperty(parser)) {\n\t\t\t\tthis.parsers[parser].maxRetries = value;\n\t\t\t}\n\t\t}\n\t}\n\tget maxRetries() {\n\t\treturn this.imgParser.maxRetries;\n\t}\n\t_getUrlWithoutParams(url) {\n\t\treturn url.indexOf('?') >= 0 ? url.split('?')[0] : url;\n\t}\n\t_getParser(url) {\n\t\tconst ext = path.getExtension(this._getUrlWithoutParams(url)).toLowerCase().replace('.', '');\n\t\treturn this.parsers[ext] || this.imgParser;\n\t}\n\t_getTextureOptions(asset) {\n\t\tconst options = {};\n\t\tif (asset) {\n\t\t\tvar _asset$name;\n\t\t\tif (((_asset$name = asset.name) == null ? void 0 : _asset$name.length) > 0) {\n\t\t\t\toptions.name = asset.name;\n\t\t\t}\n\t\t\tconst assetData = asset.data;\n\t\t\tif (assetData.hasOwnProperty('minfilter')) {\n\t\t\t\toptions.minFilter = JSON_FILTER_MODE[assetData.minfilter];\n\t\t\t}\n\t\t\tif (assetData.hasOwnProperty('magfilter')) {\n\t\t\t\toptions.magFilter = JSON_FILTER_MODE[assetData.magfilter];\n\t\t\t}\n\t\t\tif (assetData.hasOwnProperty('addressu')) {\n\t\t\t\toptions.addressU = JSON_ADDRESS_MODE[assetData.addressu];\n\t\t\t}\n\t\t\tif (assetData.hasOwnProperty('addressv')) {\n\t\t\t\toptions.addressV = JSON_ADDRESS_MODE[assetData.addressv];\n\t\t\t}\n\t\t\tif (assetData.hasOwnProperty('mipmaps')) {\n\t\t\t\toptions.mipmaps = assetData.mipmaps;\n\t\t\t}\n\t\t\tif (assetData.hasOwnProperty('anisotropy')) {\n\t\t\t\toptions.anisotropy = assetData.anisotropy;\n\t\t\t}\n\t\t\tif (assetData.hasOwnProperty('flipY')) {\n\t\t\t\toptions.flipY = !!assetData.flipY;\n\t\t\t}\n\t\t\tif (assetData.hasOwnProperty('type')) {\n\t\t\t\toptions.type = JSON_TEXTURE_TYPE[assetData.type];\n\t\t\t} else if (assetData.hasOwnProperty('rgbm') && assetData.rgbm) {\n\t\t\t\toptions.type = TEXTURETYPE_RGBM;\n\t\t\t} else if (asset.file && (asset.file.opt & 8) !== 0) {\n\t\t\t\toptions.type = TEXTURETYPE_SWIZZLEGGGR;\n\t\t\t}\n\t\t}\n\t\treturn options;\n\t}\n\tload(url, callback, asset) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = {\n\t\t\t\tload: url,\n\t\t\t\toriginal: url\n\t\t\t};\n\t\t}\n\t\tthis._getParser(url.original).load(url, callback, asset);\n\t}\n\topen(url, data, asset) {\n\t\tif (!url) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst textureOptions = this._getTextureOptions(asset);\n\t\tlet texture = this._getParser(url).open(url, data, this._device, textureOptions);\n\t\tif (texture === null) {\n\t\t\ttexture = new Texture(this._device, {\n\t\t\t\twidth: 4,\n\t\t\t\theight: 4,\n\t\t\t\tformat: PIXELFORMAT_RGB8\n\t\t\t});\n\t\t} else {\n\t\t\t_completePartialMipmapChain(texture);\n\t\t\tif (data.unswizzledGGGR) {\n\t\t\t\tasset.file.variants.basis.opt &= ~8;\n\t\t\t}\n\t\t}\n\t\treturn texture;\n\t}\n\tpatch(asset, assets) {\n\t\tconst texture = asset.resource;\n\t\tif (!texture) {\n\t\t\treturn;\n\t\t}\n\t\tconst options = this._getTextureOptions(asset);\n\t\tfor (const key of Object.keys(options)) {\n\t\t\ttexture[key] = options[key];\n\t\t}\n\t}\n}\n\nexport { TextureHandler };\n","import { EventHandler } from '../../core/event-handler.js';\n\nclass Untar extends EventHandler {\n\tconstructor(fetchPromise, assetsPrefix = '') {\n\t\tsuper();\n\t\tthis.headerSize = 512;\n\t\tthis.paddingSize = 512;\n\t\tthis.bytesRead = 0;\n\t\tthis.bytesReceived = 0;\n\t\tthis.headerRead = false;\n\t\tthis.reader = null;\n\t\tthis.data = new Uint8Array(0);\n\t\tthis.decoder = null;\n\t\tthis.prefix = '';\n\t\tthis.fileName = '';\n\t\tthis.fileSize = 0;\n\t\tthis.fileType = '';\n\t\tthis.ustarFormat = '';\n\t\tthis.prefix = assetsPrefix || '';\n\t\tthis.reader = fetchPromise.body.getReader();\n\t\tthis.reader.read().then(res => {\n\t\t\tthis.pump(res.done, res.value);\n\t\t}).catch(err => {\n\t\t\tthis.fire('error', err);\n\t\t});\n\t}\n\tpump(done, value) {\n\t\tif (done) {\n\t\t\tthis.fire('done');\n\t\t\treturn null;\n\t\t}\n\t\tthis.bytesReceived += value.byteLength;\n\t\tconst data = new Uint8Array(this.data.length + value.length);\n\t\tdata.set(this.data);\n\t\tdata.set(value, this.data.length);\n\t\tthis.data = data;\n\t\twhile (this.readFile());\n\t\treturn this.reader.read().then(res => {\n\t\t\tthis.pump(res.done, res.value);\n\t\t}).catch(err => {\n\t\t\tthis.fire('error', err);\n\t\t});\n\t}\n\treadFile() {\n\t\tif (!this.headerRead && this.bytesReceived > this.bytesRead + this.headerSize) {\n\t\t\tvar _this$decoder;\n\t\t\tthis.headerRead = true;\n\t\t\tconst view = new DataView(this.data.buffer, this.bytesRead, this.headerSize);\n\t\t\t(_this$decoder = this.decoder) != null ? _this$decoder : this.decoder = new TextDecoder('windows-1252');\n\t\t\tconst headers = this.decoder.decode(view);\n\t\t\tthis.fileName = headers.substring(0, 100).replace(/\\0/g, '');\n\t\t\tthis.fileSize = parseInt(headers.substring(124, 136), 8);\n\t\t\tthis.fileType = headers.substring(156, 157);\n\t\t\tthis.ustarFormat = headers.substring(257, 263);\n\t\t\tif (this.ustarFormat.indexOf('ustar') !== -1) {\n\t\t\t\tconst prefix = headers.substring(345, 500).replace(/\\0/g, '');\n\t\t\t\tif (prefix.length > 0) {\n\t\t\t\t\tthis.fileName = prefix.trim() + this.fileName.trim();\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.bytesRead += 512;\n\t\t}\n\t\tif (this.headerRead) {\n\t\t\tif (this.bytesReceived < this.bytesRead + this.fileSize) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.fileType === '' || this.fileType === '0') {\n\t\t\t\tconst dataView = new DataView(this.data.buffer, this.bytesRead, this.fileSize);\n\t\t\t\tconst file = {\n\t\t\t\t\tname: this.prefix + this.fileName,\n\t\t\t\t\tsize: this.fileSize,\n\t\t\t\t\tdata: dataView\n\t\t\t\t};\n\t\t\t\tthis.fire('file', file);\n\t\t\t}\n\t\t\tthis.bytesRead += this.fileSize;\n\t\t\tthis.headerRead = false;\n\t\t\tconst bytesRemained = this.bytesRead % this.paddingSize;\n\t\t\tif (bytesRemained !== 0) {\n\t\t\t\tthis.bytesRead += this.paddingSize - bytesRemained;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nexport { Untar };\n","const DEFAULT_LOCALE = 'en-US';\nconst DEFAULT_LOCALE_FALLBACKS = {\n\t'en': 'en-US',\n\t'es': 'en-ES',\n\t'zh': 'zh-CN',\n\t'zh-HK': 'zh-TW',\n\t'zh-TW': 'zh-HK',\n\t'zh-MO': 'zh-HK',\n\t'fr': 'fr-FR',\n\t'de': 'de-DE',\n\t'it': 'it-IT',\n\t'ru': 'ru-RU',\n\t'ja': 'ja-JP'\n};\n\nexport { DEFAULT_LOCALE, DEFAULT_LOCALE_FALLBACKS };\n","class I18nParser {\n\t_validate(data) {\n\t\tif (!data.header) {\n\t\t\tthrow new Error('pc.I18n#addData: Missing \"header\" field');\n\t\t}\n\t\tif (!data.header.version) {\n\t\t\tthrow new Error('pc.I18n#addData: Missing \"header.version\" field');\n\t\t}\n\t\tif (data.header.version !== 1) {\n\t\t\tthrow new Error('pc.I18n#addData: Invalid \"header.version\" field');\n\t\t}\n\t\tif (!data.data) {\n\t\t\tthrow new Error('pc.I18n#addData: Missing \"data\" field');\n\t\t} else if (!Array.isArray(data.data)) {\n\t\t\tthrow new Error('pc.I18n#addData: \"data\" field must be an array');\n\t\t}\n\t\tfor (let i = 0, len = data.data.length; i < len; i++) {\n\t\t\tconst entry = data.data[i];\n\t\t\tif (!entry.info) {\n\t\t\t\tthrow new Error(`pc.I18n#addData: missing \"data[${i}].info\" field`);\n\t\t\t}\n\t\t\tif (!entry.info.locale) {\n\t\t\t\tthrow new Error(`pc.I18n#addData: missing \"data[${i}].info.locale\" field`);\n\t\t\t}\n\t\t\tif (typeof entry.info.locale !== 'string') {\n\t\t\t\tthrow new Error(`pc.I18n#addData: \"data[${i}].info.locale\" must be a string`);\n\t\t\t}\n\t\t\tif (!entry.messages) {\n\t\t\t\tthrow new Error(`pc.I18n#addData: missing \"data[${i}].messages\" field`);\n\t\t\t}\n\t\t}\n\t}\n\tparse(data) {\n\t\treturn data.data;\n\t}\n}\n\nexport { I18nParser };\n","import { EventHandler } from '../../core/event-handler.js';\nimport { Asset } from '../asset/asset.js';\nimport { I18nParser } from './i18n-parser.js';\nimport { DEFAULT_LOCALE, DEFAULT_LOCALE_FALLBACKS } from './constants.js';\nimport { getLang, replaceLang, getPluralFn, findAvailableLocale } from './utils.js';\n\nclass I18n extends EventHandler {\n\tconstructor(app) {\n\t\tsuper();\n\t\tthis.locale = DEFAULT_LOCALE;\n\t\tthis._translations = {};\n\t\tthis._availableLangs = {};\n\t\tthis._app = app;\n\t\tthis._assets = [];\n\t\tthis._parser = new I18nParser();\n\t}\n\tset assets(value) {\n\t\tconst index = {};\n\t\tfor (let _i = 0, len = value.length; _i < len; _i++) {\n\t\t\tconst id = value[_i] instanceof Asset ? value[_i].id : value[_i];\n\t\t\tindex[id] = true;\n\t\t}\n\t\tlet i = this._assets.length;\n\t\twhile (i--) {\n\t\t\tconst id = this._assets[i];\n\t\t\tif (!index[id]) {\n\t\t\t\tthis._app.assets.off(`add:${id}`, this._onAssetAdd, this);\n\t\t\t\tconst asset = this._app.assets.get(id);\n\t\t\t\tif (asset) {\n\t\t\t\t\tthis._onAssetRemove(asset);\n\t\t\t\t}\n\t\t\t\tthis._assets.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\tfor (const id in index) {\n\t\t\tconst idNum = parseInt(id, 10);\n\t\t\tif (this._assets.indexOf(idNum) !== -1) continue;\n\t\t\tthis._assets.push(idNum);\n\t\t\tconst asset = this._app.assets.get(idNum);\n\t\t\tif (!asset) {\n\t\t\t\tthis._app.assets.once(`add:${idNum}`, this._onAssetAdd, this);\n\t\t\t} else {\n\t\t\t\tthis._onAssetAdd(asset);\n\t\t\t}\n\t\t}\n\t}\n\tget assets() {\n\t\treturn this._assets;\n\t}\n\tset locale(value) {\n\t\tif (this._locale === value) {\n\t\t\treturn;\n\t\t}\n\t\tlet lang = getLang(value);\n\t\tif (lang === 'in') {\n\t\t\tlang = 'id';\n\t\t\tvalue = replaceLang(value, lang);\n\t\t\tif (this._locale === value) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tconst old = this._locale;\n\t\tthis._locale = value;\n\t\tthis._lang = lang;\n\t\tthis._pluralFn = getPluralFn(this._lang);\n\t\tthis.fire('set:locale', value, old);\n\t}\n\tget locale() {\n\t\treturn this._locale;\n\t}\n\tstatic findAvailableLocale(desiredLocale, availableLocales) {\n\t\treturn findAvailableLocale(desiredLocale, availableLocales);\n\t}\n\tfindAvailableLocale(desiredLocale) {\n\t\tif (this._translations[desiredLocale]) {\n\t\t\treturn desiredLocale;\n\t\t}\n\t\tconst lang = getLang(desiredLocale);\n\t\treturn this._findFallbackLocale(desiredLocale, lang);\n\t}\n\tgetText(key, locale) {\n\t\tlet result = key;\n\t\tlet lang;\n\t\tif (!locale) {\n\t\t\tlocale = this._locale;\n\t\t\tlang = this._lang;\n\t\t}\n\t\tlet translations = this._translations[locale];\n\t\tif (!translations) {\n\t\t\tif (!lang) {\n\t\t\t\tlang = getLang(locale);\n\t\t\t}\n\t\t\tlocale = this._findFallbackLocale(locale, lang);\n\t\t\ttranslations = this._translations[locale];\n\t\t}\n\t\tif (translations && translations.hasOwnProperty(key)) {\n\t\t\tresult = translations[key];\n\t\t\tif (Array.isArray(result)) {\n\t\t\t\tresult = result[0];\n\t\t\t}\n\t\t\tif (result === null || result === undefined) {\n\t\t\t\tresult = key;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tgetPluralText(key, n, locale) {\n\t\tlet result = key;\n\t\tlet lang;\n\t\tlet pluralFn;\n\t\tif (!locale) {\n\t\t\tlocale = this._locale;\n\t\t\tlang = this._lang;\n\t\t\tpluralFn = this._pluralFn;\n\t\t} else {\n\t\t\tlang = getLang(locale);\n\t\t\tpluralFn = getPluralFn(lang);\n\t\t}\n\t\tlet translations = this._translations[locale];\n\t\tif (!translations) {\n\t\t\tlocale = this._findFallbackLocale(locale, lang);\n\t\t\tlang = getLang(locale);\n\t\t\tpluralFn = getPluralFn(lang);\n\t\t\ttranslations = this._translations[locale];\n\t\t}\n\t\tif (translations && translations[key] && pluralFn) {\n\t\t\tconst index = pluralFn(n);\n\t\t\tresult = translations[key][index];\n\t\t\tif (result === null || result === undefined) {\n\t\t\t\tresult = key;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\taddData(data) {\n\t\tlet parsed;\n\t\ttry {\n\t\t\tparsed = this._parser.parse(data);\n\t\t} catch (err) {\n\t\t\tconsole.error(err);\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0, len = parsed.length; i < len; i++) {\n\t\t\tconst entry = parsed[i];\n\t\t\tconst locale = entry.info.locale;\n\t\t\tconst messages = entry.messages;\n\t\t\tif (!this._translations[locale]) {\n\t\t\t\tthis._translations[locale] = {};\n\t\t\t\tconst lang = getLang(locale);\n\t\t\t\tif (!this._availableLangs[lang]) {\n\t\t\t\t\tthis._availableLangs[lang] = locale;\n\t\t\t\t}\n\t\t\t}\n\t\t\tObject.assign(this._translations[locale], messages);\n\t\t\tthis.fire('data:add', locale, messages);\n\t\t}\n\t}\n\tremoveData(data) {\n\t\tlet parsed;\n\t\ttry {\n\t\t\tparsed = this._parser.parse(data);\n\t\t} catch (err) {\n\t\t\tconsole.error(err);\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0, len = parsed.length; i < len; i++) {\n\t\t\tconst entry = parsed[i];\n\t\t\tconst locale = entry.info.locale;\n\t\t\tconst translations = this._translations[locale];\n\t\t\tif (!translations) continue;\n\t\t\tconst messages = entry.messages;\n\t\t\tfor (const key in messages) {\n\t\t\t\tdelete translations[key];\n\t\t\t}\n\t\t\tif (Object.keys(translations).length === 0) {\n\t\t\t\tdelete this._translations[locale];\n\t\t\t\tdelete this._availableLangs[getLang(locale)];\n\t\t\t}\n\t\t\tthis.fire('data:remove', locale, messages);\n\t\t}\n\t}\n\tdestroy() {\n\t\tthis._translations = null;\n\t\tthis._availableLangs = null;\n\t\tthis._assets = null;\n\t\tthis._parser = null;\n\t\tthis.off();\n\t}\n\t_findFallbackLocale(locale, lang) {\n\t\tlet result = DEFAULT_LOCALE_FALLBACKS[locale];\n\t\tif (result && this._translations[result]) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = DEFAULT_LOCALE_FALLBACKS[lang];\n\t\tif (result && this._translations[result]) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = this._availableLangs[lang];\n\t\tif (result && this._translations[result]) {\n\t\t\treturn result;\n\t\t}\n\t\treturn DEFAULT_LOCALE;\n\t}\n\t_onAssetAdd(asset) {\n\t\tasset.on('load', this._onAssetLoad, this);\n\t\tasset.on('change', this._onAssetChange, this);\n\t\tasset.on('remove', this._onAssetRemove, this);\n\t\tasset.on('unload', this._onAssetUnload, this);\n\t\tif (asset.resource) {\n\t\t\tthis._onAssetLoad(asset);\n\t\t}\n\t}\n\t_onAssetLoad(asset) {\n\t\tthis.addData(asset.resource);\n\t}\n\t_onAssetChange(asset) {\n\t\tif (asset.resource) {\n\t\t\tthis.addData(asset.resource);\n\t\t}\n\t}\n\t_onAssetRemove(asset) {\n\t\tasset.off('load', this._onAssetLoad, this);\n\t\tasset.off('change', this._onAssetChange, this);\n\t\tasset.off('remove', this._onAssetRemove, this);\n\t\tasset.off('unload', this._onAssetUnload, this);\n\t\tif (asset.resource) {\n\t\t\tthis.removeData(asset.resource);\n\t\t}\n\t\tthis._app.assets.once(`add:${asset.id}`, this._onAssetAdd, this);\n\t}\n\t_onAssetUnload(asset) {\n\t\tif (asset.resource) {\n\t\t\tthis.removeData(asset.resource);\n\t\t}\n\t}\n}\n\nexport { I18n };\n","import { DEFAULT_LOCALE_FALLBACKS, DEFAULT_LOCALE } from './constants.js';\n\nconst PLURALS = {};\nfunction definePluralFn(locales, fn) {\n\tfor (let i = 0, len = locales.length; i < len; i++) {\n\t\tPLURALS[locales[i]] = fn;\n\t}\n}\nfunction getLang(locale) {\n\tconst idx = locale.indexOf('-');\n\tif (idx !== -1) {\n\t\treturn locale.substring(0, idx);\n\t}\n\treturn locale;\n}\nfunction replaceLang(locale, desiredLang) {\n\tconst idx = locale.indexOf('-');\n\tif (idx !== -1) {\n\t\treturn desiredLang + locale.substring(idx);\n\t}\n\treturn desiredLang;\n}\nfunction findAvailableLocale(desiredLocale, availableLocales) {\n\tif (availableLocales[desiredLocale]) {\n\t\treturn desiredLocale;\n\t}\n\tlet fallback = DEFAULT_LOCALE_FALLBACKS[desiredLocale];\n\tif (fallback && availableLocales[fallback]) {\n\t\treturn fallback;\n\t}\n\tconst lang = getLang(desiredLocale);\n\tfallback = DEFAULT_LOCALE_FALLBACKS[lang];\n\tif (availableLocales[fallback]) {\n\t\treturn fallback;\n\t}\n\tif (availableLocales[lang]) {\n\t\treturn lang;\n\t}\n\treturn DEFAULT_LOCALE;\n}\ndefinePluralFn(['ja', 'ko', 'th', 'vi', 'zh', 'id'], n => {\n\treturn 0;\n});\ndefinePluralFn(['fa', 'hi'], n => {\n\tif (n >= 0 && n <= 1) {\n\t\treturn 0;\n\t}\n\treturn 1;\n});\ndefinePluralFn(['fr', 'pt'], n => {\n\tif (n >= 0 && n < 2) {\n\t\treturn 0;\n\t}\n\treturn 1;\n});\ndefinePluralFn(['da'], n => {\n\tif (n === 1 || !Number.isInteger(n) && n >= 0 && n <= 1) {\n\t\treturn 0;\n\t}\n\treturn 1;\n});\ndefinePluralFn(['de', 'en', 'it', 'el', 'es', 'tr', 'fi', 'sv', 'nb', 'no', 'ur'], n => {\n\tif (n === 1) {\n\t\treturn 0;\n\t}\n\treturn 1;\n});\ndefinePluralFn(['ru', 'uk'], n => {\n\tif (Number.isInteger(n)) {\n\t\tconst mod10 = n % 10;\n\t\tconst mod100 = n % 100;\n\t\tif (mod10 === 1 && mod100 !== 11) {\n\t\t\treturn 0;\n\t\t} else if (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {\n\t\t\treturn 1;\n\t\t} else if (mod10 === 0 || mod10 >= 5 && mod10 <= 9 || mod100 >= 11 && mod100 <= 14) {\n\t\t\treturn 2;\n\t\t}\n\t}\n\treturn 3;\n});\ndefinePluralFn(['pl'], n => {\n\tif (Number.isInteger(n)) {\n\t\tif (n === 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst mod10 = n % 10;\n\t\tconst mod100 = n % 100;\n\t\tif (mod10 >= 2 && mod10 <= 4 && (mod100 < 12 || mod100 > 14)) {\n\t\t\treturn 1;\n\t\t} else if (mod10 >= 0 && mod10 <= 1 || mod10 >= 5 && mod10 <= 9 || mod100 >= 12 && mod100 <= 14) {\n\t\t\treturn 2;\n\t\t}\n\t}\n\treturn 3;\n});\ndefinePluralFn(['ar'], n => {\n\tif (n === 0) {\n\t\treturn 0;\n\t} else if (n === 1) {\n\t\treturn 1;\n\t} else if (n === 2) {\n\t\treturn 2;\n\t}\n\tif (Number.isInteger(n)) {\n\t\tconst mod100 = n % 100;\n\t\tif (mod100 >= 3 && mod100 <= 10) {\n\t\t\treturn 3;\n\t\t} else if (mod100 >= 11 && mod100 <= 99) {\n\t\t\treturn 4;\n\t\t}\n\t}\n\treturn 5;\n});\nconst DEFAULT_PLURAL_FN = PLURALS[getLang(DEFAULT_LOCALE)];\nfunction getPluralFn(lang) {\n\treturn PLURALS[lang] || DEFAULT_PLURAL_FN;\n}\n\nexport { findAvailableLocale, getLang, getPluralFn, replaceLang };\n","import { Vec3 } from '../../core/math/vec3.js';\nimport { random } from '../../core/math/random.js';\nimport { Color } from '../../core/math/color.js';\nimport { Entity } from '../entity.js';\nimport { SHADOW_PCF3 } from '../../scene/constants.js';\nimport { BakeLight } from './bake-light.js';\n\nconst _tempPoint = new Vec3();\nclass BakeLightAmbient extends BakeLight {\n\tconstructor(lightmapper) {\n\t\tconst scene = lightmapper.scene;\n\t\tconst lightEntity = new Entity('AmbientLight');\n\t\tlightEntity.addComponent('light', {\n\t\t\ttype: 'directional',\n\t\t\taffectDynamic: true,\n\t\t\taffectLightmapped: false,\n\t\t\tbake: true,\n\t\t\tbakeNumSamples: scene.ambientBakeNumSamples,\n\t\t\tcastShadows: true,\n\t\t\tnormalOffsetBias: 0.05,\n\t\t\tshadowBias: 0.2,\n\t\t\tshadowDistance: 1,\n\t\t\tshadowResolution: 2048,\n\t\t\tshadowType: SHADOW_PCF3,\n\t\t\tcolor: Color.WHITE,\n\t\t\tintensity: 1,\n\t\t\tbakeDir: false\n\t\t});\n\t\tsuper(scene, lightEntity.light.light, lightmapper.lightingParams);\n\t}\n\tget numVirtualLights() {\n\t\treturn this.light.bakeNumSamples;\n\t}\n\tprepareVirtualLight(index, numVirtualLights) {\n\t\trandom.spherePointDeterministic(_tempPoint, index, numVirtualLights, 0, this.scene.ambientBakeSpherePart);\n\t\tthis.light._node.lookAt(_tempPoint.mulScalar(-1));\n\t\tthis.light._node.rotateLocal(90, 0, 0);\n\t\tconst gamma = this.scene.gammaCorrection ? 2.2 : 1;\n\t\tconst fullIntensity = 2 * Math.PI * this.scene.ambientBakeSpherePart;\n\t\tconst linearIntensity = Math.pow(fullIntensity, gamma);\n\t\tthis.light.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);\n\t}\n}\n\nexport { BakeLightAmbient };\n","import { Vec2 } from '../../core/math/vec2.js';\nimport { random } from '../../core/math/random.js';\nimport { LIGHTTYPE_DIRECTIONAL } from '../../scene/constants.js';\nimport { BakeLight } from './bake-light.js';\n\nconst _tempPoint = new Vec2();\nclass BakeLightSimple extends BakeLight {\n\tconstructor(lightmapper, light) {\n\t\tsuper(lightmapper.scene, light, lightmapper.lightingParams);\n\t}\n\tget numVirtualLights() {\n\t\tif (this.light.type === LIGHTTYPE_DIRECTIONAL) {\n\t\t\treturn this.light.bakeNumSamples;\n\t\t}\n\t\treturn 1;\n\t}\n\tprepareVirtualLight(index, numVirtualLights) {\n\t\tconst light = this.light;\n\t\tlight._node.setLocalRotation(this.rotation);\n\t\tif (index > 0) {\n\t\t\tconst directionalSpreadAngle = light.bakeArea;\n\t\t\trandom.circlePointDeterministic(_tempPoint, index, numVirtualLights);\n\t\t\t_tempPoint.mulScalar(directionalSpreadAngle * 0.5);\n\t\t\tlight._node.rotateLocal(_tempPoint.x, 0, _tempPoint.y);\n\t\t}\n\t\tlight._node.getWorldTransform();\n\t\tconst gamma = this.scene.gammaCorrection ? 2.2 : 1;\n\t\tconst linearIntensity = Math.pow(this.intensity, gamma);\n\t\tlight.intensity = Math.pow(linearIntensity / numVirtualLights, 1 / gamma);\n\t}\n}\n\nexport { BakeLightSimple };\n","import { BoundingBox } from '../../core/shape/bounding-box.js';\nimport { BoundingSphere } from '../../core/shape/bounding-sphere.js';\nimport { LIGHTTYPE_DIRECTIONAL } from '../../scene/constants.js';\n\nconst tempSphere = new BoundingSphere();\nclass BakeLight {\n\tconstructor(scene, light, lightingParams) {\n\t\tthis.scene = scene;\n\t\tthis.light = light;\n\t\tthis.store();\n\t\tlight.numCascades = 1;\n\t\tif (this.scene.clusteredLightingEnabled) {\n\t\t\tlight.castShadows = light.bakeShadows && lightingParams.shadowsEnabled;\n\t\t}\n\t\tif (light.type !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\tlight._node.getWorldTransform();\n\t\t\tlight.getBoundingSphere(tempSphere);\n\t\t\tthis.lightBounds = new BoundingBox();\n\t\t\tthis.lightBounds.center.copy(tempSphere.center);\n\t\t\tthis.lightBounds.halfExtents.set(tempSphere.radius, tempSphere.radius, tempSphere.radius);\n\t\t}\n\t}\n\tstore() {\n\t\tthis.mask = this.light.mask;\n\t\tthis.shadowUpdateMode = this.light.shadowUpdateMode;\n\t\tthis.enabled = this.light.enabled;\n\t\tthis.intensity = this.light.intensity;\n\t\tthis.rotation = this.light._node.getLocalRotation().clone();\n\t\tthis.numCascades = this.light.numCascades;\n\t\tthis.castShadows = this.light._castShadows;\n\t}\n\trestore() {\n\t\tconst light = this.light;\n\t\tlight.mask = this.mask;\n\t\tlight.shadowUpdateMode = this.shadowUpdateMode;\n\t\tlight.enabled = this.enabled;\n\t\tlight.intensity = this.intensity;\n\t\tlight._node.setLocalRotation(this.rotation);\n\t\tlight.numCascades = this.numCascades;\n\t\tlight._castShadows = this.castShadows;\n\t}\n\tstartBake() {\n\t\tthis.light.enabled = true;\n\t\tthis.light._destroyShadowMap();\n\t\tthis.light.beginFrame();\n\t}\n\tendBake(shadowMapCache) {\n\t\tconst light = this.light;\n\t\tlight.enabled = false;\n\t\tif (light.shadowMap) {\n\t\t\tif (light.shadowMap.cached) {\n\t\t\t\tshadowMapCache.add(light, light.shadowMap);\n\t\t\t}\n\t\t\tlight.shadowMap = null;\n\t\t}\n\t}\n}\n\nexport { BakeLight };\n","class BakeMeshNode {\n\tconstructor(node, meshInstances = null) {\n\t\tthis.node = node;\n\t\tthis.component = node.render || node.model;\n\t\tmeshInstances = meshInstances || this.component.meshInstances;\n\t\tthis.store();\n\t\tthis.meshInstances = meshInstances;\n\t\tthis.bounds = null;\n\t\tthis.renderTargets = [];\n\t}\n\tstore() {\n\t\tthis.castShadows = this.component.castShadows;\n\t}\n\trestore() {\n\t\tthis.component.castShadows = this.castShadows;\n\t}\n}\n\nexport { BakeMeshNode };\n","import { createShaderFromCode } from '../../scene/shader-lib/utils.js';\nimport { shaderChunks } from '../../scene/shader-lib/chunks/chunks.js';\nimport { shaderChunksLightmapper } from '../../scene/shader-lib/chunks/chunks-lightmapper.js';\n\nconst DENOISE_FILTER_SIZE = 15;\nclass LightmapFilters {\n\tconstructor(device) {\n\t\tthis.device = device;\n\t\tthis.shaderDilate = createShaderFromCode(device, shaderChunks.fullscreenQuadVS, shaderChunksLightmapper.dilatePS, 'lmDilate');\n\t\tthis.constantTexSource = device.scope.resolve('source');\n\t\tthis.constantPixelOffset = device.scope.resolve('pixelOffset');\n\t\tthis.pixelOffset = new Float32Array(2);\n\t\tthis.shaderDenoise = null;\n\t\tthis.sigmas = null;\n\t\tthis.constantSigmas = null;\n\t\tthis.kernel = null;\n\t}\n\tsetSourceTexture(texture) {\n\t\tthis.constantTexSource.setValue(texture);\n\t}\n\tprepare(textureWidth, textureHeight) {\n\t\tthis.pixelOffset[0] = 1 / textureWidth;\n\t\tthis.pixelOffset[1] = 1 / textureHeight;\n\t\tthis.constantPixelOffset.setValue(this.pixelOffset);\n\t}\n\tprepareDenoise(filterRange, filterSmoothness) {\n\t\tif (!this.shaderDenoise) {\n\t\t\tthis.shaderDenoise = createShaderFromCode(this.device, shaderChunks.fullscreenQuadVS, shaderChunksLightmapper.bilateralDeNoisePS, 'lmBilateralDeNoise');\n\t\t\tthis.sigmas = new Float32Array(2);\n\t\t\tthis.constantSigmas = this.device.scope.resolve('sigmas');\n\t\t\tthis.constantKernel = this.device.scope.resolve('kernel[0]');\n\t\t\tthis.bZnorm = this.device.scope.resolve('bZnorm');\n\t\t}\n\t\tthis.sigmas[0] = filterRange;\n\t\tthis.sigmas[1] = filterSmoothness;\n\t\tthis.constantSigmas.setValue(this.sigmas);\n\t\tthis.evaluateDenoiseUniforms(filterRange, filterSmoothness);\n\t}\n\tevaluateDenoiseUniforms(filterRange, filterSmoothness) {\n\t\tfunction normpdf(x, sigma) {\n\t\t\treturn 0.39894 * Math.exp(-0.5 * x * x / (sigma * sigma)) / sigma;\n\t\t}\n\t\tthis.kernel = this.kernel || new Float32Array(DENOISE_FILTER_SIZE);\n\t\tconst kernel = this.kernel;\n\t\tconst kSize = Math.floor((DENOISE_FILTER_SIZE - 1) / 2);\n\t\tfor (let j = 0; j <= kSize; ++j) {\n\t\t\tconst value = normpdf(j, filterRange);\n\t\t\tkernel[kSize + j] = value;\n\t\t\tkernel[kSize - j] = value;\n\t\t}\n\t\tthis.constantKernel.setValue(this.kernel);\n\t\tconst bZnorm = 1 / normpdf(0.0, filterSmoothness);\n\t\tthis.bZnorm.setValue(bZnorm);\n\t}\n}\n\nexport { LightmapFilters };\n","import { now } from '../../core/time.js';\nimport { Color } from '../../core/math/color.js';\nimport { math } from '../../core/math/math.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { BoundingBox } from '../../core/shape/bounding-box.js';\nimport { PIXELFORMAT_RGBA8, TEXTURETYPE_RGBM, CHUNKAPI_1_65, CULLFACE_NONE, TEXTURETYPE_DEFAULT, FILTER_NEAREST, ADDRESS_CLAMP_TO_EDGE, FILTER_LINEAR } from '../../platform/graphics/constants.js';\nimport { RenderTarget } from '../../platform/graphics/render-target.js';\nimport { drawQuadWithShader } from '../../scene/graphics/quad-render-utils.js';\nimport { Texture } from '../../platform/graphics/texture.js';\nimport { MeshInstance } from '../../scene/mesh-instance.js';\nimport { LightingParams } from '../../scene/lighting/lighting-params.js';\nimport { WorldClusters } from '../../scene/lighting/world-clusters.js';\nimport { shaderChunks } from '../../scene/shader-lib/chunks/chunks.js';\nimport { shaderChunksLightmapper } from '../../scene/shader-lib/chunks/chunks-lightmapper.js';\nimport { PROJECTION_ORTHOGRAPHIC, MASK_AFFECT_LIGHTMAPPED, BAKE_COLORDIR, MASK_BAKE, MASK_AFFECT_DYNAMIC, LIGHTTYPE_DIRECTIONAL, SHADOWUPDATE_REALTIME, SHADOWUPDATE_THISFRAME, FOG_NONE, LIGHTTYPE_SPOT, PROJECTION_PERSPECTIVE, LIGHTTYPE_OMNI, SHADER_FORWARDHDR, SHADERDEF_LM, SHADERDEF_DIRLM, SHADERDEF_LMAMBIENT } from '../../scene/constants.js';\nimport { Camera } from '../../scene/camera.js';\nimport { GraphNode } from '../../scene/graph-node.js';\nimport { StandardMaterial } from '../../scene/materials/standard-material.js';\nimport { BakeLightSimple } from './bake-light-simple.js';\nimport { BakeLightAmbient } from './bake-light-ambient.js';\nimport { BakeMeshNode } from './bake-mesh-node.js';\nimport { LightmapCache } from '../../scene/graphics/lightmap-cache.js';\nimport { LightmapFilters } from './lightmap-filters.js';\nimport { BlendState } from '../../platform/graphics/blend-state.js';\nimport { DepthState } from '../../platform/graphics/depth-state.js';\nimport { RenderPassLightmapper } from './render-pass-lightmapper.js';\n\nconst MAX_LIGHTMAP_SIZE = 2048;\nconst PASS_COLOR = 0;\nconst PASS_DIR = 1;\nconst tempVec = new Vec3();\nclass Lightmapper {\n\tconstructor(device, root, scene, renderer, assets) {\n\t\tthis.device = device;\n\t\tthis.root = root;\n\t\tthis.scene = scene;\n\t\tthis.renderer = renderer;\n\t\tthis.assets = assets;\n\t\tthis.shadowMapCache = renderer.shadowMapCache;\n\t\tthis._tempSet = new Set();\n\t\tthis._initCalled = false;\n\t\tthis.passMaterials = [];\n\t\tthis.ambientAOMaterial = null;\n\t\tthis.fog = '';\n\t\tthis.ambientLight = new Color();\n\t\tthis.renderTargets = new Map();\n\t\tthis.stats = {\n\t\t\trenderPasses: 0,\n\t\t\tlightmapCount: 0,\n\t\t\ttotalRenderTime: 0,\n\t\t\tforwardTime: 0,\n\t\t\tfboTime: 0,\n\t\t\tshadowMapTime: 0,\n\t\t\tcompileTime: 0,\n\t\t\tshadersLinked: 0\n\t\t};\n\t}\n\tdestroy() {\n\t\tvar _this$camera;\n\t\tLightmapCache.decRef(this.blackTex);\n\t\tthis.blackTex = null;\n\t\tLightmapCache.destroy();\n\t\tthis.device = null;\n\t\tthis.root = null;\n\t\tthis.scene = null;\n\t\tthis.renderer = null;\n\t\tthis.assets = null;\n\t\t(_this$camera = this.camera) == null || _this$camera.destroy();\n\t\tthis.camera = null;\n\t}\n\tinitBake(device) {\n\t\tif (!this._initCalled) {\n\t\t\tthis._initCalled = true;\n\t\t\tthis.lightmapFilters = new LightmapFilters(device);\n\t\t\tthis.constantBakeDir = device.scope.resolve('bakeDir');\n\t\t\tthis.materials = [];\n\t\t\tthis.blackTex = new Texture(this.device, {\n\t\t\t\twidth: 4,\n\t\t\t\theight: 4,\n\t\t\t\tformat: PIXELFORMAT_RGBA8,\n\t\t\t\ttype: TEXTURETYPE_RGBM,\n\t\t\t\tname: 'lightmapBlack'\n\t\t\t});\n\t\t\tLightmapCache.incRef(this.blackTex);\n\t\t\tconst camera = new Camera();\n\t\t\tcamera.clearColor.set(0, 0, 0, 0);\n\t\t\tcamera.clearColorBuffer = true;\n\t\t\tcamera.clearDepthBuffer = false;\n\t\t\tcamera.clearStencilBuffer = false;\n\t\t\tcamera.frustumCulling = false;\n\t\t\tcamera.projection = PROJECTION_ORTHOGRAPHIC;\n\t\t\tcamera.aspectRatio = 1;\n\t\t\tcamera.node = new GraphNode();\n\t\t\tthis.camera = camera;\n\t\t}\n\t\tif (this.scene.clusteredLightingEnabled) {\n\t\t\tconst lightingParams = new LightingParams(device.supportsAreaLights, device.maxTextureSize, () => {});\n\t\t\tthis.lightingParams = lightingParams;\n\t\t\tconst srcParams = this.scene.lighting;\n\t\t\tlightingParams.shadowsEnabled = srcParams.shadowsEnabled;\n\t\t\tlightingParams.shadowAtlasResolution = srcParams.shadowAtlasResolution;\n\t\t\tlightingParams.cookiesEnabled = srcParams.cookiesEnabled;\n\t\t\tlightingParams.cookieAtlasResolution = srcParams.cookieAtlasResolution;\n\t\t\tlightingParams.areaLightsEnabled = srcParams.areaLightsEnabled;\n\t\t\tlightingParams.cells = new Vec3(3, 3, 3);\n\t\t\tlightingParams.maxLightsPerCell = 4;\n\t\t\tthis.worldClusters = new WorldClusters(device);\n\t\t\tthis.worldClusters.name = 'ClusterLightmapper';\n\t\t}\n\t}\n\tfinishBake(bakeNodes) {\n\t\tthis.materials = [];\n\t\tfunction destroyRT(rt) {\n\t\t\tLightmapCache.decRef(rt.colorBuffer);\n\t\t\trt.destroy();\n\t\t}\n\t\tthis.renderTargets.forEach(rt => {\n\t\t\tdestroyRT(rt);\n\t\t});\n\t\tthis.renderTargets.clear();\n\t\tbakeNodes.forEach(node => {\n\t\t\tnode.renderTargets.forEach(rt => {\n\t\t\t\tdestroyRT(rt);\n\t\t\t});\n\t\t\tnode.renderTargets.length = 0;\n\t\t});\n\t\tthis.ambientAOMaterial = null;\n\t\tif (this.worldClusters) {\n\t\t\tthis.worldClusters.destroy();\n\t\t\tthis.worldClusters = null;\n\t\t}\n\t}\n\tcreateMaterialForPass(device, scene, pass, addAmbient) {\n\t\tconst material = new StandardMaterial();\n\t\tmaterial.name = `lmMaterial-pass:${pass}-ambient:${addAmbient}`;\n\t\tmaterial.chunks.APIVersion = CHUNKAPI_1_65;\n\t\tconst transformDefines = '#define UV1LAYOUT\\n';\n\t\tmaterial.chunks.transformVS = transformDefines + shaderChunks.transformVS;\n\t\tif (pass === PASS_COLOR) {\n\t\t\tlet bakeLmEndChunk = shaderChunksLightmapper.bakeLmEndPS;\n\t\t\tif (addAmbient) {\n\t\t\t\tbakeLmEndChunk = `\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight = ((dDiffuseLight - 0.5) * max(${scene.ambientBakeOcclusionContrast.toFixed(1)} + 1.0, 0.0)) + 0.5;\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight += vec3(${scene.ambientBakeOcclusionBrightness.toFixed(1)});\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight = saturate(dDiffuseLight);\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight *= dAmbientLight;\n\t\t\t\t\t\t\t\t${bakeLmEndChunk}`;\n\t\t\t} else {\n\t\t\t\tmaterial.ambient = new Color(0, 0, 0);\n\t\t\t\tmaterial.ambientTint = true;\n\t\t\t}\n\t\t\tmaterial.chunks.basePS = shaderChunks.basePS + (scene.lightmapPixelFormat === PIXELFORMAT_RGBA8 ? '\\n#define LIGHTMAP_RGBM\\n' : '');\n\t\t\tmaterial.chunks.endPS = bakeLmEndChunk;\n\t\t\tmaterial.lightMap = this.blackTex;\n\t\t} else {\n\t\t\tmaterial.chunks.basePS = `${shaderChunks.basePS}\\nuniform sampler2D texture_dirLightMap;\\nuniform float bakeDir;\\n`;\n\t\t\tmaterial.chunks.endPS = shaderChunksLightmapper.bakeDirLmEndPS;\n\t\t}\n\t\tmaterial.chunks.outputAlphaPS = '\\n';\n\t\tmaterial.chunks.outputAlphaOpaquePS = '\\n';\n\t\tmaterial.chunks.outputAlphaPremulPS = '\\n';\n\t\tmaterial.cull = CULLFACE_NONE;\n\t\tmaterial.forceUv1 = true;\n\t\tmaterial.update();\n\t\treturn material;\n\t}\n\tcreateMaterials(device, scene, passCount) {\n\t\tfor (let pass = 0; pass < passCount; pass++) {\n\t\t\tif (!this.passMaterials[pass]) {\n\t\t\t\tthis.passMaterials[pass] = this.createMaterialForPass(device, scene, pass, false);\n\t\t\t}\n\t\t}\n\t\tif (!this.ambientAOMaterial) {\n\t\t\tthis.ambientAOMaterial = this.createMaterialForPass(device, scene, 0, true);\n\t\t\tthis.ambientAOMaterial.onUpdateShader = function (options) {\n\t\t\t\toptions.litOptions.lightMapWithoutAmbient = true;\n\t\t\t\toptions.litOptions.separateAmbient = true;\n\t\t\t\treturn options;\n\t\t\t};\n\t\t}\n\t}\n\tcreateTexture(size, name) {\n\t\treturn new Texture(this.device, {\n\t\t\twidth: size,\n\t\t\theight: size,\n\t\t\tformat: this.scene.lightmapPixelFormat,\n\t\t\tmipmaps: false,\n\t\t\ttype: this.scene.lightmapPixelFormat === PIXELFORMAT_RGBA8 ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\tname: name\n\t\t});\n\t}\n\tcollectModels(node, bakeNodes, allNodes) {\n\t\tvar _node$model, _node$model2, _node$render;\n\t\tif (!node.enabled) return;\n\t\tlet meshInstances;\n\t\tif ((_node$model = node.model) != null && _node$model.model && (_node$model2 = node.model) != null && _node$model2.enabled) {\n\t\t\tif (allNodes) allNodes.push(new BakeMeshNode(node));\n\t\t\tif (node.model.lightmapped) {\n\t\t\t\tif (bakeNodes) {\n\t\t\t\t\tmeshInstances = node.model.model.meshInstances;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ((_node$render = node.render) != null && _node$render.enabled) {\n\t\t\tif (allNodes) allNodes.push(new BakeMeshNode(node));\n\t\t\tif (node.render.lightmapped) {\n\t\t\t\tif (bakeNodes) {\n\t\t\t\t\tmeshInstances = node.render.meshInstances;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (meshInstances) {\n\t\t\tlet hasUv1 = true;\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tif (!meshInstances[i].mesh.vertexBuffer.format.hasUv1) {\n\t\t\t\t\thasUv1 = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasUv1) {\n\t\t\t\tconst notInstancedMeshInstances = [];\n\t\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\t\tconst mesh = meshInstances[i].mesh;\n\t\t\t\t\tif (this._tempSet.has(mesh)) {\n\t\t\t\t\t\tbakeNodes.push(new BakeMeshNode(node, [meshInstances[i]]));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnotInstancedMeshInstances.push(meshInstances[i]);\n\t\t\t\t\t}\n\t\t\t\t\tthis._tempSet.add(mesh);\n\t\t\t\t}\n\t\t\t\tthis._tempSet.clear();\n\t\t\t\tif (notInstancedMeshInstances.length > 0) {\n\t\t\t\t\tbakeNodes.push(new BakeMeshNode(node, notInstancedMeshInstances));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < node._children.length; i++) {\n\t\t\tthis.collectModels(node._children[i], bakeNodes, allNodes);\n\t\t}\n\t}\n\tprepareShadowCasters(nodes) {\n\t\tconst casters = [];\n\t\tfor (let n = 0; n < nodes.length; n++) {\n\t\t\tconst component = nodes[n].component;\n\t\t\tcomponent.castShadows = component.castShadowsLightmap;\n\t\t\tif (component.castShadowsLightmap) {\n\t\t\t\tconst meshes = nodes[n].meshInstances;\n\t\t\t\tfor (let i = 0; i < meshes.length; i++) {\n\t\t\t\t\tmeshes[i].visibleThisFrame = true;\n\t\t\t\t\tcasters.push(meshes[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn casters;\n\t}\n\tupdateTransforms(nodes) {\n\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\tconst meshInstances = nodes[i].meshInstances;\n\t\t\tfor (let j = 0; j < meshInstances.length; j++) {\n\t\t\t\tmeshInstances[j].node.getWorldTransform();\n\t\t\t}\n\t\t}\n\t}\n\tcalculateLightmapSize(node) {\n\t\tlet data;\n\t\tconst sizeMult = this.scene.lightmapSizeMultiplier || 16;\n\t\tconst scale = tempVec;\n\t\tlet srcArea, lightmapSizeMultiplier;\n\t\tif (node.model) {\n\t\t\tlightmapSizeMultiplier = node.model.lightmapSizeMultiplier;\n\t\t\tif (node.model.asset) {\n\t\t\t\tdata = this.assets.get(node.model.asset).data;\n\t\t\t\tif (data.area) {\n\t\t\t\t\tsrcArea = data.area;\n\t\t\t\t}\n\t\t\t} else if (node.model._area) {\n\t\t\t\tdata = node.model;\n\t\t\t\tif (data._area) {\n\t\t\t\t\tsrcArea = data._area;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (node.render) {\n\t\t\tlightmapSizeMultiplier = node.render.lightmapSizeMultiplier;\n\t\t\tif (node.render.type !== 'asset') {\n\t\t\t\tif (node.render._area) {\n\t\t\t\t\tdata = node.render;\n\t\t\t\t\tif (data._area) {\n\t\t\t\t\t\tsrcArea = data._area;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst area = {\n\t\t\tx: 1,\n\t\t\ty: 1,\n\t\t\tz: 1,\n\t\t\tuv: 1\n\t\t};\n\t\tif (srcArea) {\n\t\t\tarea.x = srcArea.x;\n\t\t\tarea.y = srcArea.y;\n\t\t\tarea.z = srcArea.z;\n\t\t\tarea.uv = srcArea.uv;\n\t\t}\n\t\tconst areaMult = lightmapSizeMultiplier || 1;\n\t\tarea.x *= areaMult;\n\t\tarea.y *= areaMult;\n\t\tarea.z *= areaMult;\n\t\tconst component = node.render || node.model;\n\t\tconst bounds = this.computeNodeBounds(component.meshInstances);\n\t\tscale.copy(bounds.halfExtents);\n\t\tlet totalArea = area.x * scale.y * scale.z + area.y * scale.x * scale.z + area.z * scale.x * scale.y;\n\t\ttotalArea /= area.uv;\n\t\ttotalArea = Math.sqrt(totalArea);\n\t\tconst lightmapSize = Math.min(math.nextPowerOfTwo(totalArea * sizeMult), this.scene.lightmapMaxResolution || MAX_LIGHTMAP_SIZE);\n\t\treturn lightmapSize;\n\t}\n\tsetLightmapping(nodes, value, passCount, shaderDefs) {\n\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\tconst node = nodes[i];\n\t\t\tconst meshInstances = node.meshInstances;\n\t\t\tfor (let j = 0; j < meshInstances.length; j++) {\n\t\t\t\tconst meshInstance = meshInstances[j];\n\t\t\t\tmeshInstance.setLightmapped(value);\n\t\t\t\tif (value) {\n\t\t\t\t\tif (shaderDefs) {\n\t\t\t\t\t\tmeshInstance._shaderDefs |= shaderDefs;\n\t\t\t\t\t}\n\t\t\t\t\tmeshInstance.mask = MASK_AFFECT_LIGHTMAPPED;\n\t\t\t\t\tfor (let pass = 0; pass < passCount; pass++) {\n\t\t\t\t\t\tconst tex = node.renderTargets[pass].colorBuffer;\n\t\t\t\t\t\ttex.minFilter = FILTER_LINEAR;\n\t\t\t\t\t\ttex.magFilter = FILTER_LINEAR;\n\t\t\t\t\t\tmeshInstance.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbake(nodes, mode = BAKE_COLORDIR) {\n\t\tconst device = this.device;\n\t\tconst startTime = now();\n\t\tthis.scene._updateSkyMesh();\n\t\tthis.stats.renderPasses = 0;\n\t\tthis.stats.shadowMapTime = 0;\n\t\tthis.stats.forwardTime = 0;\n\t\tconst startShaders = device._shaderStats.linked;\n\t\tconst startFboTime = device._renderTargetCreationTime;\n\t\tconst startCompileTime = device._shaderStats.compileTime;\n\t\tconst bakeNodes = [];\n\t\tconst allNodes = [];\n\t\tif (nodes) {\n\t\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\t\tthis.collectModels(nodes[i], bakeNodes, null);\n\t\t\t}\n\t\t\tthis.collectModels(this.root, null, allNodes);\n\t\t} else {\n\t\t\tthis.collectModels(this.root, bakeNodes, allNodes);\n\t\t}\n\t\tif (bakeNodes.length > 0) {\n\t\t\tthis.renderer.shadowRenderer.frameUpdate();\n\t\t\tconst passCount = mode === BAKE_COLORDIR ? 2 : 1;\n\t\t\tthis.setLightmapping(bakeNodes, false, passCount);\n\t\t\tthis.initBake(device);\n\t\t\tthis.bakeInternal(passCount, bakeNodes, allNodes);\n\t\t\tlet shaderDefs = SHADERDEF_LM;\n\t\t\tif (mode === BAKE_COLORDIR) {\n\t\t\t\tshaderDefs |= SHADERDEF_DIRLM;\n\t\t\t}\n\t\t\tif (this.scene.ambientBake) {\n\t\t\t\tshaderDefs |= SHADERDEF_LMAMBIENT;\n\t\t\t}\n\t\t\tthis.setLightmapping(bakeNodes, true, passCount, shaderDefs);\n\t\t\tthis.finishBake(bakeNodes);\n\t\t}\n\t\tconst nowTime = now();\n\t\tthis.stats.totalRenderTime = nowTime - startTime;\n\t\tthis.stats.shadersLinked = device._shaderStats.linked - startShaders;\n\t\tthis.stats.compileTime = device._shaderStats.compileTime - startCompileTime;\n\t\tthis.stats.fboTime = device._renderTargetCreationTime - startFboTime;\n\t\tthis.stats.lightmapCount = bakeNodes.length;\n\t}\n\tallocateTextures(bakeNodes, passCount) {\n\t\tfor (let i = 0; i < bakeNodes.length; i++) {\n\t\t\tconst bakeNode = bakeNodes[i];\n\t\t\tconst size = this.calculateLightmapSize(bakeNode.node);\n\t\t\tfor (let pass = 0; pass < passCount; pass++) {\n\t\t\t\tconst tex = this.createTexture(size, `lightmapper_lightmap_${i}`);\n\t\t\t\tLightmapCache.incRef(tex);\n\t\t\t\tbakeNode.renderTargets[pass] = new RenderTarget({\n\t\t\t\t\tcolorBuffer: tex,\n\t\t\t\t\tdepth: false\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (!this.renderTargets.has(size)) {\n\t\t\t\tconst tex = this.createTexture(size, `lightmapper_temp_lightmap_${size}`);\n\t\t\t\tLightmapCache.incRef(tex);\n\t\t\t\tthis.renderTargets.set(size, new RenderTarget({\n\t\t\t\t\tcolorBuffer: tex,\n\t\t\t\t\tdepth: false\n\t\t\t\t}));\n\t\t\t}\n\t\t}\n\t}\n\tprepareLightsToBake(allLights, bakeLights) {\n\t\tif (this.scene.ambientBake) {\n\t\t\tconst ambientLight = new BakeLightAmbient(this);\n\t\t\tbakeLights.push(ambientLight);\n\t\t}\n\t\tconst sceneLights = this.renderer.lights;\n\t\tfor (let i = 0; i < sceneLights.length; i++) {\n\t\t\tconst light = sceneLights[i];\n\t\t\tconst bakeLight = new BakeLightSimple(this, light);\n\t\t\tallLights.push(bakeLight);\n\t\t\tif (light.enabled && (light.mask & MASK_BAKE) !== 0) {\n\t\t\t\tlight.mask = MASK_BAKE | MASK_AFFECT_LIGHTMAPPED | MASK_AFFECT_DYNAMIC;\n\t\t\t\tlight.shadowUpdateMode = light.type === LIGHTTYPE_DIRECTIONAL ? SHADOWUPDATE_REALTIME : SHADOWUPDATE_THISFRAME;\n\t\t\t\tbakeLights.push(bakeLight);\n\t\t\t}\n\t\t}\n\t\tbakeLights.sort();\n\t}\n\trestoreLights(allLights) {\n\t\tfor (let i = 0; i < allLights.length; i++) {\n\t\t\tallLights[i].restore();\n\t\t}\n\t}\n\tsetupScene() {\n\t\tthis.fog = this.scene.fog;\n\t\tthis.ambientLight.copy(this.scene.ambientLight);\n\t\tthis.scene.fog = FOG_NONE;\n\t\tif (!this.scene.ambientBake) {\n\t\t\tthis.scene.ambientLight.set(0, 0, 0);\n\t\t}\n\t\tthis.renderer.setSceneConstants();\n\t}\n\trestoreScene() {\n\t\tthis.scene.fog = this.fog;\n\t\tthis.scene.ambientLight.copy(this.ambientLight);\n\t}\n\tcomputeNodeBounds(meshInstances) {\n\t\tconst bounds = new BoundingBox();\n\t\tif (meshInstances.length > 0) {\n\t\t\tbounds.copy(meshInstances[0].aabb);\n\t\t\tfor (let m = 1; m < meshInstances.length; m++) {\n\t\t\t\tbounds.add(meshInstances[m].aabb);\n\t\t\t}\n\t\t}\n\t\treturn bounds;\n\t}\n\tcomputeNodesBounds(nodes) {\n\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\tconst meshInstances = nodes[i].meshInstances;\n\t\t\tnodes[i].bounds = this.computeNodeBounds(meshInstances);\n\t\t}\n\t}\n\tcomputeBounds(meshInstances) {\n\t\tconst bounds = new BoundingBox();\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tbounds.copy(meshInstances[0].aabb);\n\t\t\tfor (let m = 1; m < meshInstances.length; m++) {\n\t\t\t\tbounds.add(meshInstances[m].aabb);\n\t\t\t}\n\t\t}\n\t\treturn bounds;\n\t}\n\tbackupMaterials(meshInstances) {\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tthis.materials[i] = meshInstances[i].material;\n\t\t}\n\t}\n\trestoreMaterials(meshInstances) {\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tmeshInstances[i].material = this.materials[i];\n\t\t}\n\t}\n\tlightCameraPrepare(device, bakeLight) {\n\t\tconst light = bakeLight.light;\n\t\tlet shadowCam;\n\t\tif (light.type === LIGHTTYPE_SPOT) {\n\t\t\tconst lightRenderData = light.getRenderData(null, 0);\n\t\t\tshadowCam = lightRenderData.shadowCamera;\n\t\t\tshadowCam._node.setPosition(light._node.getPosition());\n\t\t\tshadowCam._node.setRotation(light._node.getRotation());\n\t\t\tshadowCam._node.rotateLocal(-90, 0, 0);\n\t\t\tshadowCam.projection = PROJECTION_PERSPECTIVE;\n\t\t\tshadowCam.nearClip = light.attenuationEnd / 1000;\n\t\t\tshadowCam.farClip = light.attenuationEnd;\n\t\t\tshadowCam.aspectRatio = 1;\n\t\t\tshadowCam.fov = light._outerConeAngle * 2;\n\t\t\tthis.renderer.updateCameraFrustum(shadowCam);\n\t\t}\n\t\treturn shadowCam;\n\t}\n\tlightCameraPrepareAndCull(bakeLight, bakeNode, shadowCam, casterBounds) {\n\t\tconst light = bakeLight.light;\n\t\tlet lightAffectsNode = true;\n\t\tif (light.type === LIGHTTYPE_DIRECTIONAL) {\n\t\t\ttempVec.copy(casterBounds.center);\n\t\t\ttempVec.y += casterBounds.halfExtents.y;\n\t\t\tthis.camera.node.setPosition(tempVec);\n\t\t\tthis.camera.node.setEulerAngles(-90, 0, 0);\n\t\t\tthis.camera.nearClip = 0;\n\t\t\tthis.camera.farClip = casterBounds.halfExtents.y * 2;\n\t\t\tconst frustumSize = Math.max(casterBounds.halfExtents.x, casterBounds.halfExtents.z);\n\t\t\tthis.camera.orthoHeight = frustumSize;\n\t\t} else {\n\t\t\tif (!bakeLight.lightBounds.intersects(bakeNode.bounds)) {\n\t\t\t\tlightAffectsNode = false;\n\t\t\t}\n\t\t}\n\t\tif (light.type === LIGHTTYPE_SPOT) {\n\t\t\tlet nodeVisible = false;\n\t\t\tconst meshInstances = bakeNode.meshInstances;\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tif (meshInstances[i]._isVisible(shadowCam)) {\n\t\t\t\t\tnodeVisible = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!nodeVisible) {\n\t\t\t\tlightAffectsNode = false;\n\t\t\t}\n\t\t}\n\t\treturn lightAffectsNode;\n\t}\n\tsetupLightArray(lightArray, light) {\n\t\tlightArray[LIGHTTYPE_DIRECTIONAL].length = 0;\n\t\tlightArray[LIGHTTYPE_OMNI].length = 0;\n\t\tlightArray[LIGHTTYPE_SPOT].length = 0;\n\t\tlightArray[light.type][0] = light;\n\t\tlight.visibleThisFrame = true;\n\t}\n\trenderShadowMap(comp, shadowMapRendered, casters, bakeLight) {\n\t\tconst light = bakeLight.light;\n\t\tconst isClustered = this.scene.clusteredLightingEnabled;\n\t\tconst castShadow = light.castShadows && (!isClustered || this.scene.lighting.shadowsEnabled);\n\t\tif (!shadowMapRendered && castShadow) {\n\t\t\tif (!light.shadowMap && !isClustered) {\n\t\t\t\tlight.shadowMap = this.shadowMapCache.get(this.device, light);\n\t\t\t}\n\t\t\tif (light.type === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\tthis.renderer._shadowRendererDirectional.cull(light, comp, this.camera, casters);\n\t\t\t\tconst shadowPass = this.renderer._shadowRendererDirectional.getLightRenderPass(light, this.camera);\n\t\t\t\tshadowPass == null || shadowPass.render();\n\t\t\t} else {\n\t\t\t\tif (this.device.isWebGPU) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tthis.renderer._shadowRendererLocal.cull(light, comp, casters);\n\t\t\t\tconst insideRenderPass = false;\n\t\t\t\tthis.renderer.shadowRenderer.render(light, this.camera, insideRenderPass);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tpostprocessTextures(device, bakeNodes, passCount) {\n\t\tconst numDilates2x = 1;\n\t\tconst dilateShader = this.lightmapFilters.shaderDilate;\n\t\tconst filterLightmap = this.scene.lightmapFilterEnabled;\n\t\tif (filterLightmap) {\n\t\t\tthis.lightmapFilters.prepareDenoise(this.scene.lightmapFilterRange, this.scene.lightmapFilterSmoothness);\n\t\t}\n\t\tdevice.setBlendState(BlendState.NOBLEND);\n\t\tdevice.setDepthState(DepthState.NODEPTH);\n\t\tdevice.setStencilState(null, null);\n\t\tfor (let node = 0; node < bakeNodes.length; node++) {\n\t\t\tconst bakeNode = bakeNodes[node];\n\t\t\tfor (let pass = 0; pass < passCount; pass++) {\n\t\t\t\tconst nodeRT = bakeNode.renderTargets[pass];\n\t\t\t\tconst lightmap = nodeRT.colorBuffer;\n\t\t\t\tconst tempRT = this.renderTargets.get(lightmap.width);\n\t\t\t\tconst tempTex = tempRT.colorBuffer;\n\t\t\t\tthis.lightmapFilters.prepare(lightmap.width, lightmap.height);\n\t\t\t\tfor (let i = 0; i < numDilates2x; i++) {\n\t\t\t\t\tthis.lightmapFilters.setSourceTexture(lightmap);\n\t\t\t\t\tconst bilateralFilterEnabled = filterLightmap && pass === 0 && i === 0;\n\t\t\t\t\tdrawQuadWithShader(device, tempRT, bilateralFilterEnabled ? this.lightmapFilters.shaderDenoise : dilateShader);\n\t\t\t\t\tthis.lightmapFilters.setSourceTexture(tempTex);\n\t\t\t\t\tdrawQuadWithShader(device, nodeRT, dilateShader);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbakeInternal(passCount, bakeNodes, allNodes) {\n\t\tconst scene = this.scene;\n\t\tconst comp = scene.layers;\n\t\tconst device = this.device;\n\t\tconst clusteredLightingEnabled = scene.clusteredLightingEnabled;\n\t\tthis.createMaterials(device, scene, passCount);\n\t\tthis.setupScene();\n\t\tcomp._update();\n\t\tthis.computeNodesBounds(bakeNodes);\n\t\tthis.allocateTextures(bakeNodes, passCount);\n\t\tthis.renderer.collectLights(comp);\n\t\tconst allLights = [],\n\t\t\tbakeLights = [];\n\t\tthis.prepareLightsToBake(allLights, bakeLights);\n\t\tthis.updateTransforms(allNodes);\n\t\tconst casters = this.prepareShadowCasters(allNodes);\n\t\tthis.renderer.updateCpuSkinMatrices(casters);\n\t\tthis.renderer.gpuUpdate(casters);\n\t\tconst casterBounds = this.computeBounds(casters);\n\t\tlet i, j, rcv, m;\n\t\tfor (i = 0; i < bakeNodes.length; i++) {\n\t\t\tconst bakeNode = bakeNodes[i];\n\t\t\trcv = bakeNode.meshInstances;\n\t\t\tfor (j = 0; j < rcv.length; j++) {\n\t\t\t\tm = rcv[j];\n\t\t\t\tm.setLightmapped(false);\n\t\t\t\tm.mask = MASK_BAKE;\n\t\t\t\tm.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], this.blackTex);\n\t\t\t\tm.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], this.blackTex);\n\t\t\t}\n\t\t}\n\t\tfor (j = 0; j < bakeLights.length; j++) {\n\t\t\tbakeLights[j].light.enabled = false;\n\t\t}\n\t\tconst lightArray = [[], [], []];\n\t\tlet pass, node;\n\t\tlet shadersUpdatedOn1stPass = false;\n\t\tfor (i = 0; i < bakeLights.length; i++) {\n\t\t\tconst bakeLight = bakeLights[i];\n\t\t\tconst isAmbientLight = bakeLight instanceof BakeLightAmbient;\n\t\t\tconst isDirectional = bakeLight.light.type === LIGHTTYPE_DIRECTIONAL;\n\t\t\tlet numVirtualLights = bakeLight.numVirtualLights;\n\t\t\tif (passCount > 1 && numVirtualLights > 1 && bakeLight.light.bakeDir) {\n\t\t\t\tnumVirtualLights = 1;\n\t\t\t}\n\t\t\tfor (let virtualLightIndex = 0; virtualLightIndex < numVirtualLights; virtualLightIndex++) {\n\t\t\t\tif (numVirtualLights > 1) {\n\t\t\t\t\tbakeLight.prepareVirtualLight(virtualLightIndex, numVirtualLights);\n\t\t\t\t}\n\t\t\t\tbakeLight.startBake();\n\t\t\t\tlet shadowMapRendered = false;\n\t\t\t\tconst shadowCam = this.lightCameraPrepare(device, bakeLight);\n\t\t\t\tfor (node = 0; node < bakeNodes.length; node++) {\n\t\t\t\t\tconst bakeNode = bakeNodes[node];\n\t\t\t\t\trcv = bakeNode.meshInstances;\n\t\t\t\t\tconst lightAffectsNode = this.lightCameraPrepareAndCull(bakeLight, bakeNode, shadowCam, casterBounds);\n\t\t\t\t\tif (!lightAffectsNode) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tthis.setupLightArray(lightArray, bakeLight.light);\n\t\t\t\t\tconst clusterLights = isDirectional ? [] : [bakeLight.light];\n\t\t\t\t\tif (clusteredLightingEnabled) {\n\t\t\t\t\t\tthis.renderer.lightTextureAtlas.update(clusterLights, this.lightingParams);\n\t\t\t\t\t}\n\t\t\t\t\tshadowMapRendered = this.renderShadowMap(comp, shadowMapRendered, casters, bakeLight);\n\t\t\t\t\tif (clusteredLightingEnabled) {\n\t\t\t\t\t\tthis.worldClusters.update(clusterLights, this.scene.gammaCorrection, this.lightingParams);\n\t\t\t\t\t}\n\t\t\t\t\tthis.backupMaterials(rcv);\n\t\t\t\t\tfor (pass = 0; pass < passCount; pass++) {\n\t\t\t\t\t\tif (pass > 0 && virtualLightIndex > 0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (isAmbientLight && pass > 0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst nodeRT = bakeNode.renderTargets[pass];\n\t\t\t\t\t\tconst lightmapSize = bakeNode.renderTargets[pass].colorBuffer.width;\n\t\t\t\t\t\tconst tempRT = this.renderTargets.get(lightmapSize);\n\t\t\t\t\t\tconst tempTex = tempRT.colorBuffer;\n\t\t\t\t\t\tif (pass === 0) {\n\t\t\t\t\t\t\tshadersUpdatedOn1stPass = scene.updateShaders;\n\t\t\t\t\t\t} else if (shadersUpdatedOn1stPass) {\n\t\t\t\t\t\t\tscene.updateShaders = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet passMaterial = this.passMaterials[pass];\n\t\t\t\t\t\tif (isAmbientLight) {\n\t\t\t\t\t\t\tconst lastVirtualLightForPass = virtualLightIndex + 1 === numVirtualLights;\n\t\t\t\t\t\t\tif (lastVirtualLightForPass && pass === 0) {\n\t\t\t\t\t\t\t\tpassMaterial = this.ambientAOMaterial;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (j = 0; j < rcv.length; j++) {\n\t\t\t\t\t\t\trcv[j].material = passMaterial;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis.renderer.updateShaders(rcv);\n\t\t\t\t\t\tif (pass === PASS_DIR) {\n\t\t\t\t\t\t\tthis.constantBakeDir.setValue(bakeLight.light.bakeDir ? 1 : 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (device.isWebGPU) {\n\t\t\t\t\t\t\tconst renderPass = new RenderPassLightmapper(device, this.renderer, this.camera, clusteredLightingEnabled ? this.worldClusters : null, rcv, lightArray);\n\t\t\t\t\t\t\trenderPass.init(tempRT);\n\t\t\t\t\t\t\trenderPass.render();\n\t\t\t\t\t\t\trenderPass.destroy();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.renderer.setCamera(this.camera, tempRT, true);\n\t\t\t\t\t\t\tif (clusteredLightingEnabled) {\n\t\t\t\t\t\t\t\tthis.worldClusters.activate();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.renderer._forwardTime = 0;\n\t\t\t\t\t\t\tthis.renderer._shadowMapTime = 0;\n\t\t\t\t\t\t\tthis.renderer.renderForward(this.camera, rcv, lightArray, SHADER_FORWARDHDR);\n\t\t\t\t\t\t\tdevice.updateEnd();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbakeNode.renderTargets[pass] = tempRT;\n\t\t\t\t\t\tthis.renderTargets.set(lightmapSize, nodeRT);\n\t\t\t\t\t\tfor (j = 0; j < rcv.length; j++) {\n\t\t\t\t\t\t\tm = rcv[j];\n\t\t\t\t\t\t\tm.setRealtimeLightmap(MeshInstance.lightmapParamNames[pass], tempTex);\n\t\t\t\t\t\t\tm._shaderDefs |= SHADERDEF_LM;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.restoreMaterials(rcv);\n\t\t\t\t}\n\t\t\t\tbakeLight.endBake(this.shadowMapCache);\n\t\t\t}\n\t\t}\n\t\tthis.postprocessTextures(device, bakeNodes, passCount);\n\t\tfor (node = 0; node < allNodes.length; node++) {\n\t\t\tallNodes[node].restore();\n\t\t}\n\t\tthis.restoreLights(allLights);\n\t\tthis.restoreScene();\n\t\tif (!clusteredLightingEnabled) {\n\t\t\tthis.shadowMapCache.clear();\n\t\t}\n\t}\n}\n\nexport { Lightmapper };\n","import { RenderPass } from '../../platform/graphics/render-pass.js';\nimport { SHADER_FORWARDHDR } from '../../scene/constants.js';\n\nclass RenderPassLightmapper extends RenderPass {\n\tconstructor(device, renderer, camera, worldClusters, receivers, lightArray) {\n\t\tsuper(device);\n\t\tthis.viewBindGroups = [];\n\t\tthis.renderer = renderer;\n\t\tthis.camera = camera;\n\t\tthis.worldClusters = worldClusters;\n\t\tthis.receivers = receivers;\n\t\tthis.lightArray = lightArray;\n\t}\n\tdestroy() {\n\t\tthis.viewBindGroups.forEach(bg => {\n\t\t\tbg.defaultUniformBuffer.destroy();\n\t\t\tbg.destroy();\n\t\t});\n\t\tthis.viewBindGroups.length = 0;\n\t}\n\texecute() {\n\t\tthis.device;\n\t\tconst {\n\t\t\trenderer,\n\t\t\tcamera,\n\t\t\treceivers,\n\t\t\trenderTarget,\n\t\t\tworldClusters,\n\t\t\tlightArray\n\t\t} = this;\n\t\trenderer.renderForwardLayer(camera, renderTarget, null, undefined, SHADER_FORWARDHDR, this.viewBindGroups, {\n\t\t\tmeshInstances: receivers,\n\t\t\tsplitLights: lightArray,\n\t\t\tlightClusters: worldClusters\n\t\t});\n\t}\n}\n\nexport { RenderPassLightmapper };\n","import { WasmModule } from '../../core/wasm-module.js';\nimport { DracoWorker } from './draco-worker.js';\nimport { http } from '../../platform/net/http.js';\n\nconst downloadMaxRetries = 3;\nclass JobQueue {\n\tconstructor() {\n\t\tthis.workers = [[], [], []];\n\t\tthis.jobId = 0;\n\t\tthis.jobQueue = [];\n\t\tthis.jobCallbacks = new Map();\n\t\tthis.run = (worker, job) => {\n\t\t\tworker.postMessage({\n\t\t\t\ttype: 'decodeMesh',\n\t\t\t\tjobId: job.jobId,\n\t\t\t\tbuffer: job.buffer\n\t\t\t}, [job.buffer]);\n\t\t};\n\t}\n\tinit(workers) {\n\t\tworkers.forEach(worker => {\n\t\t\tworker.addEventListener('message', message => {\n\t\t\t\tconst data = message.data;\n\t\t\t\tconst callback = this.jobCallbacks.get(data.jobId);\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(data.error, {\n\t\t\t\t\t\tindices: data.indices,\n\t\t\t\t\t\tvertices: data.vertices,\n\t\t\t\t\t\tattributes: data.attributes\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tthis.jobCallbacks.delete(data.jobId);\n\t\t\t\tif (this.jobQueue.length > 0) {\n\t\t\t\t\tconst job = this.jobQueue.shift();\n\t\t\t\t\tthis.run(worker, job);\n\t\t\t\t} else {\n\t\t\t\t\tconst index2 = this.workers[2].indexOf(worker);\n\t\t\t\t\tif (index2 !== -1) {\n\t\t\t\t\t\tthis.workers[2].splice(index2, 1);\n\t\t\t\t\t\tthis.workers[1].push(worker);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst index1 = this.workers[1].indexOf(worker);\n\t\t\t\t\t\tif (index1 !== -1) {\n\t\t\t\t\t\t\tthis.workers[1].splice(index1, 1);\n\t\t\t\t\t\t\tthis.workers[0].push(worker);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tthis.workers[0] = workers;\n\t\twhile (this.jobQueue.length && (this.workers[0].length || this.workers[1].length)) {\n\t\t\tconst job = this.jobQueue.shift();\n\t\t\tif (this.workers[0].length > 0) {\n\t\t\t\tconst worker = this.workers[0].shift();\n\t\t\t\tthis.workers[1].push(worker);\n\t\t\t\tthis.run(worker, job);\n\t\t\t} else {\n\t\t\t\tconst worker = this.workers[1].shift();\n\t\t\t\tthis.workers[2].push(worker);\n\t\t\t\tthis.run(worker, job);\n\t\t\t}\n\t\t}\n\t}\n\tenqueueJob(buffer, callback) {\n\t\tconst job = {\n\t\t\tjobId: this.jobId++,\n\t\t\tbuffer: buffer\n\t\t};\n\t\tthis.jobCallbacks.set(job.jobId, callback);\n\t\tif (this.workers[0].length > 0) {\n\t\t\tconst worker = this.workers[0].shift();\n\t\t\tthis.workers[1].push(worker);\n\t\t\tthis.run(worker, job);\n\t\t} else if (this.workers[1].length > 0) {\n\t\t\tconst worker = this.workers[1].shift();\n\t\t\tthis.workers[2].push(worker);\n\t\t\tthis.run(worker, job);\n\t\t} else {\n\t\t\tthis.jobQueue.push(job);\n\t\t}\n\t}\n}\nconst downloadScript = url => {\n\treturn new Promise((resolve, reject) => {\n\t\tconst options = {\n\t\t\tcache: true,\n\t\t\tresponseType: 'text',\n\t\t\tretry: downloadMaxRetries > 0,\n\t\t\tmaxRetries: downloadMaxRetries\n\t\t};\n\t\thttp.get(url, options, (err, response) => {\n\t\t\tif (err) {\n\t\t\t\treject(err);\n\t\t\t} else {\n\t\t\t\tresolve(response);\n\t\t\t}\n\t\t});\n\t});\n};\nconst compileModule = url => {\n\tconst compileManual = () => {\n\t\treturn fetch(url).then(result => result.arrayBuffer()).then(buffer => WebAssembly.compile(buffer));\n\t};\n\tconst compileStreaming = () => {\n\t\treturn WebAssembly.compileStreaming(fetch(url)).catch(err => {\n\t\t\treturn compileManual();\n\t\t});\n\t};\n\treturn WebAssembly.compileStreaming ? compileStreaming() : compileManual();\n};\nconst defaultNumWorkers = 1;\nlet jobQueue;\nlet lazyConfig;\nconst initializeWorkers = config => {\n\tif (jobQueue) {\n\t\treturn true;\n\t}\n\tif (!config) {\n\t\tif (lazyConfig) {\n\t\t\tconfig = lazyConfig;\n\t\t} else {\n\t\t\tconst moduleConfig = WasmModule.getConfig('DracoDecoderModule');\n\t\t\tif (moduleConfig) {\n\t\t\t\tconfig = {\n\t\t\t\t\tjsUrl: moduleConfig.glueUrl,\n\t\t\t\t\twasmUrl: moduleConfig.wasmUrl,\n\t\t\t\t\tnumWorkers: moduleConfig.numWorkers\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tconfig = {\n\t\t\t\t\tjsUrl: 'draco.wasm.js',\n\t\t\t\t\twasmUrl: 'draco.wasm.wasm',\n\t\t\t\t\tnumWorkers: defaultNumWorkers\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n\tif (!config.jsUrl || !config.wasmUrl) {\n\t\treturn false;\n\t}\n\tjobQueue = new JobQueue();\n\tPromise.all([downloadScript(config.jsUrl), compileModule(config.wasmUrl)]).then(([dracoSource, dracoModule]) => {\n\t\tconst code = ['/* draco */', dracoSource, '/* worker */', `(\\n${DracoWorker.toString()}\\n)()\\n\\n`].join('\\n');\n\t\tconst blob = new Blob([code], {\n\t\t\ttype: 'application/javascript'\n\t\t});\n\t\tconst workerUrl = URL.createObjectURL(blob);\n\t\tconst numWorkers = Math.max(1, Math.min(16, config.numWorkers || defaultNumWorkers));\n\t\tconst workers = [];\n\t\tfor (let i = 0; i < numWorkers; ++i) {\n\t\t\tconst worker = new Worker(workerUrl);\n\t\t\tworker.postMessage({\n\t\t\t\ttype: 'init',\n\t\t\t\tmodule: dracoModule\n\t\t\t});\n\t\t\tworkers.push(worker);\n\t\t}\n\t\tjobQueue.init(workers);\n\t});\n\treturn true;\n};\nconst dracoInitialize = config => {\n\tif (config != null && config.lazyInit) {\n\t\tlazyConfig = config;\n\t} else {\n\t\tinitializeWorkers(config);\n\t}\n};\nconst dracoDecode = (buffer, callback) => {\n\tif (!initializeWorkers()) {\n\t\treturn false;\n\t}\n\tjobQueue.enqueueJob(buffer, callback);\n\treturn true;\n};\n\nexport { dracoDecode, dracoInitialize };\n","function DracoWorker(jsUrl, wasmUrl) {\n\tlet draco;\n\tconst POSITION_ATTRIBUTE = 0;\n\tconst NORMAL_ATTRIBUTE = 1;\n\tconst wrap = (typedArray, dataType) => {\n\t\tswitch (dataType) {\n\t\t\tcase draco.DT_INT8:\n\t\t\t\treturn new Int8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n\t\t\tcase draco.DT_INT16:\n\t\t\t\treturn new Int16Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 2);\n\t\t\tcase draco.DT_INT32:\n\t\t\t\treturn new Int32Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 4);\n\t\t\tcase draco.DT_UINT8:\n\t\t\t\treturn new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n\t\t\tcase draco.DT_UINT16:\n\t\t\t\treturn new Uint16Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 2);\n\t\t\tcase draco.DT_UINT32:\n\t\t\t\treturn new Uint32Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 4);\n\t\t\tcase draco.DT_FLOAT32:\n\t\t\t\treturn new Float32Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength / 4);\n\t\t}\n\t\treturn null;\n\t};\n\tconst componentSizeInBytes = dataType => {\n\t\tswitch (dataType) {\n\t\t\tcase draco.DT_INT8:\n\t\t\t\treturn 1;\n\t\t\tcase draco.DT_INT16:\n\t\t\t\treturn 2;\n\t\t\tcase draco.DT_INT32:\n\t\t\t\treturn 4;\n\t\t\tcase draco.DT_UINT8:\n\t\t\t\treturn 1;\n\t\t\tcase draco.DT_UINT16:\n\t\t\t\treturn 2;\n\t\t\tcase draco.DT_UINT32:\n\t\t\t\treturn 4;\n\t\t\tcase draco.DT_FLOAT32:\n\t\t\t\treturn 4;\n\t\t}\n\t\treturn 1;\n\t};\n\tconst attributeSizeInBytes = attribute => {\n\t\treturn attribute.num_components() * componentSizeInBytes(attribute.data_type());\n\t};\n\tconst attributeOrder = {\n\t\t0: 0,\n\t\t1: 1,\n\t\t5: 2,\n\t\t2: 3,\n\t\t7: 4,\n\t\t8: 5,\n\t\t4: 6,\n\t\t3: 7\n\t};\n\tconst generateNormals = (vertices, indices) => {\n\t\tconst subtract = (dst, a, b) => {\n\t\t\tdst[0] = a[0] - b[0];\n\t\t\tdst[1] = a[1] - b[1];\n\t\t\tdst[2] = a[2] - b[2];\n\t\t};\n\t\tconst cross = (dst, a, b) => {\n\t\t\tdst[0] = a[1] * b[2] - b[1] * a[2];\n\t\t\tdst[1] = a[2] * b[0] - b[2] * a[0];\n\t\t\tdst[2] = a[0] * b[1] - b[0] * a[1];\n\t\t};\n\t\tconst normalize = (dst, offset) => {\n\t\t\tconst a = dst[offset + 0];\n\t\t\tconst b = dst[offset + 1];\n\t\t\tconst c = dst[offset + 2];\n\t\t\tconst l = 1.0 / Math.sqrt(a * a + b * b + c * c);\n\t\t\tdst[offset + 0] *= l;\n\t\t\tdst[offset + 1] *= l;\n\t\t\tdst[offset + 2] *= l;\n\t\t};\n\t\tconst copy = (dst, src, srcOffset) => {\n\t\t\tfor (let i = 0; i < 3; ++i) {\n\t\t\t\tdst[i] = src[srcOffset + i];\n\t\t\t}\n\t\t};\n\t\tconst numTriangles = indices.length / 3;\n\t\tconst numVertices = vertices.length / 3;\n\t\tconst result = new Float32Array(vertices.length);\n\t\tconst a = [0, 0, 0],\n\t\t\tb = [0, 0, 0],\n\t\t\tc = [0, 0, 0],\n\t\t\tt1 = [0, 0, 0],\n\t\t\tt2 = [0, 0, 0],\n\t\t\tn = [0, 0, 0];\n\t\tfor (let i = 0; i < numTriangles; ++i) {\n\t\t\tconst v0 = indices[i * 3 + 0] * 3;\n\t\t\tconst v1 = indices[i * 3 + 1] * 3;\n\t\t\tconst v2 = indices[i * 3 + 2] * 3;\n\t\t\tcopy(a, vertices, v0);\n\t\t\tcopy(b, vertices, v1);\n\t\t\tcopy(c, vertices, v2);\n\t\t\tsubtract(t1, b, a);\n\t\t\tsubtract(t2, c, a);\n\t\t\tcross(n, t1, t2);\n\t\t\tnormalize(n, 0);\n\t\t\tfor (let j = 0; j < 3; ++j) {\n\t\t\t\tresult[v0 + j] += n[j];\n\t\t\t\tresult[v1 + j] += n[j];\n\t\t\t\tresult[v2 + j] += n[j];\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < numVertices; ++i) {\n\t\t\tnormalize(result, i * 3);\n\t\t}\n\t\treturn new Uint8Array(result.buffer);\n\t};\n\tconst decodeMesh = inputBuffer => {\n\t\tconst result = {};\n\t\tconst buffer = new draco.DecoderBuffer();\n\t\tbuffer.Init(inputBuffer, inputBuffer.length);\n\t\tconst decoder = new draco.Decoder();\n\t\tif (decoder.GetEncodedGeometryType(buffer) !== draco.TRIANGULAR_MESH) {\n\t\t\tresult.error = 'Failed to decode draco mesh: not a mesh';\n\t\t\treturn result;\n\t\t}\n\t\tconst mesh = new draco.Mesh();\n\t\tconst status = decoder.DecodeBufferToMesh(buffer, mesh);\n\t\tif (!status || !status.ok() || mesh.ptr === 0) {\n\t\t\tresult.error = 'Failed to decode draco asset';\n\t\t\treturn result;\n\t\t}\n\t\tconst numIndices = mesh.num_faces() * 3;\n\t\tconst shortIndices = mesh.num_points() <= 65535;\n\t\tconst indicesSize = numIndices * (shortIndices ? 2 : 4);\n\t\tconst indicesPtr = draco._malloc(indicesSize);\n\t\tif (shortIndices) {\n\t\t\tdecoder.GetTrianglesUInt16Array(mesh, indicesSize, indicesPtr);\n\t\t\tresult.indices = new Uint16Array(draco.HEAPU16.buffer, indicesPtr, numIndices).slice().buffer;\n\t\t} else {\n\t\t\tdecoder.GetTrianglesUInt32Array(mesh, indicesSize, indicesPtr);\n\t\t\tresult.indices = new Uint32Array(draco.HEAPU32.buffer, indicesPtr, numIndices).slice().buffer;\n\t\t}\n\t\tdraco._free(indicesPtr);\n\t\tconst attributes = [];\n\t\tfor (let i = 0; i < mesh.num_attributes(); ++i) {\n\t\t\tattributes.push(decoder.GetAttribute(mesh, i));\n\t\t}\n\t\tattributes.sort((a, b) => {\n\t\t\tvar _attributeOrder$a$att, _attributeOrder$b$att;\n\t\t\treturn ((_attributeOrder$a$att = attributeOrder[a.attribute_type()]) != null ? _attributeOrder$a$att : attributeOrder.length) - ((_attributeOrder$b$att = attributeOrder[b.attribute_type()]) != null ? _attributeOrder$b$att : attributeOrder.length);\n\t\t});\n\t\tresult.attributes = attributes.map(a => a.unique_id());\n\t\tlet totalVertexSize = 0;\n\t\tconst offsets = attributes.map(a => {\n\t\t\tconst offset = totalVertexSize;\n\t\t\ttotalVertexSize += Math.ceil(attributeSizeInBytes(a) / 4) * 4;\n\t\t\treturn offset;\n\t\t});\n\t\tconst hasNormals = attributes.some(a => a.attribute_type() === NORMAL_ATTRIBUTE);\n\t\tconst normalOffset = offsets[1];\n\t\tif (!hasNormals) {\n\t\t\tfor (let i = 1; i < offsets.length; ++i) {\n\t\t\t\toffsets[i] += 12;\n\t\t\t}\n\t\t\ttotalVertexSize += 12;\n\t\t}\n\t\tresult.vertices = new ArrayBuffer(mesh.num_points() * totalVertexSize);\n\t\tconst dst = new Uint8Array(result.vertices);\n\t\tfor (let i = 0; i < mesh.num_attributes(); ++i) {\n\t\t\tconst attribute = attributes[i];\n\t\t\tconst sizeInBytes = attributeSizeInBytes(attribute);\n\t\t\tconst ptrSize = mesh.num_points() * sizeInBytes;\n\t\t\tconst ptr = draco._malloc(ptrSize);\n\t\t\tdecoder.GetAttributeDataArrayForAllPoints(mesh, attribute, attribute.data_type(), ptrSize, ptr);\n\t\t\tconst src = new Uint8Array(draco.HEAPU8.buffer, ptr, ptrSize);\n\t\t\tfor (let j = 0; j < mesh.num_points(); ++j) {\n\t\t\t\tfor (let c = 0; c < sizeInBytes; ++c) {\n\t\t\t\t\tdst[j * totalVertexSize + offsets[i] + c] = src[j * sizeInBytes + c];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!hasNormals && attribute.attribute_type() === POSITION_ATTRIBUTE) {\n\t\t\t\tconst normals = generateNormals(wrap(src, attribute.data_type()), shortIndices ? new Uint16Array(result.indices) : new Uint32Array(result.indices));\n\t\t\t\tfor (let j = 0; j < mesh.num_points(); ++j) {\n\t\t\t\t\tfor (let c = 0; c < 12; ++c) {\n\t\t\t\t\t\tdst[j * totalVertexSize + normalOffset + c] = normals[j * 12 + c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdraco._free(ptr);\n\t\t}\n\t\tdraco.destroy(mesh);\n\t\tdraco.destroy(decoder);\n\t\tdraco.destroy(buffer);\n\t\treturn result;\n\t};\n\tconst decode = data => {\n\t\tconst result = decodeMesh(new Uint8Array(data.buffer));\n\t\tself.postMessage({\n\t\t\tjobId: data.jobId,\n\t\t\terror: result.error,\n\t\t\tindices: result.indices,\n\t\t\tvertices: result.vertices,\n\t\t\tattributes: result.attributes\n\t\t}, [result.indices, result.vertices].filter(t => t != null));\n\t};\n\tconst workQueue = [];\n\tself.onmessage = message => {\n\t\tconst data = message.data;\n\t\tswitch (data.type) {\n\t\t\tcase 'init':\n\t\t\t\tself.DracoDecoderModule({\n\t\t\t\t\tinstantiateWasm: (imports, successCallback) => {\n\t\t\t\t\t\tWebAssembly.instantiate(data.module, imports).then(result => successCallback(result)).catch(reason => console.error(`instantiate failed + ${reason}`));\n\t\t\t\t\t\treturn {};\n\t\t\t\t\t}\n\t\t\t\t}).then(instance => {\n\t\t\t\t\tdraco = instance;\n\t\t\t\t\tworkQueue.forEach(data => decode(data));\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'decodeMesh':\n\t\t\t\tif (draco) {\n\t\t\t\t\tdecode(data);\n\t\t\t\t} else {\n\t\t\t\t\tworkQueue.push(data);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t};\n}\n\nexport { DracoWorker };\n","import { path } from '../../core/path.js';\nimport { Asset } from '../asset/asset.js';\nimport { GlbParser } from './glb-parser.js';\nimport { GlbContainerResource } from './glb-container-resource.js';\n\nclass GlbContainerParser {\n\tconstructor(device, assets, maxRetries) {\n\t\tthis._device = device;\n\t\tthis._assets = assets;\n\t\tthis._defaultMaterial = GlbParser.createDefaultMaterial();\n\t\tthis.maxRetries = maxRetries;\n\t}\n\t_getUrlWithoutParams(url) {\n\t\treturn url.indexOf('?') >= 0 ? url.split('?')[0] : url;\n\t}\n\tload(url, callback, asset) {\n\t\tAsset.fetchArrayBuffer(url.load, (err, result) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else {\n\t\t\t\tGlbParser.parse(this._getUrlWithoutParams(url.original), path.extractPath(url.load), result, this._device, asset.registry, asset.options, (err, result) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tcallback(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcallback(null, new GlbContainerResource(result, asset, this._assets, this._defaultMaterial));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}, asset, this.maxRetries);\n\t}\n\topen(url, data, asset) {\n\t\treturn data;\n\t}\n\tpatch(asset, assets) {}\n}\n\nexport { GlbContainerParser };\n","import { GraphNode } from '../../scene/graph-node.js';\nimport { MeshInstance } from '../../scene/mesh-instance.js';\nimport { Model } from '../../scene/model.js';\nimport { MorphInstance } from '../../scene/morph-instance.js';\nimport { SkinInstance } from '../../scene/skin-instance.js';\nimport { SkinInstanceCache } from '../../scene/skin-instance-cache.js';\nimport { Entity } from '../entity.js';\nimport { Asset } from '../asset/asset.js';\n\nclass GlbContainerResource {\n\tconstructor(data, asset, assets, defaultMaterial) {\n\t\tconst createAsset = function createAsset(type, resource, index) {\n\t\t\tconst subAsset = GlbContainerResource.createAsset(asset.name, type, resource, index);\n\t\t\tassets.add(subAsset);\n\t\t\treturn subAsset;\n\t\t};\n\t\tconst renders = [];\n\t\tfor (let i = 0; i < data.renders.length; ++i) {\n\t\t\trenders.push(createAsset('render', data.renders[i], i));\n\t\t}\n\t\tconst materials = [];\n\t\tfor (let i = 0; i < data.materials.length; ++i) {\n\t\t\tmaterials.push(createAsset('material', data.materials[i], i));\n\t\t}\n\t\tconst animations = [];\n\t\tfor (let i = 0; i < data.animations.length; ++i) {\n\t\t\tanimations.push(createAsset('animation', data.animations[i], i));\n\t\t}\n\t\tthis.data = data;\n\t\tthis._model = null;\n\t\tthis._assetName = asset.name;\n\t\tthis._assets = assets;\n\t\tthis._defaultMaterial = defaultMaterial;\n\t\tthis.renders = renders;\n\t\tthis.materials = materials;\n\t\tthis.textures = data.textures;\n\t\tthis.animations = animations;\n\t}\n\tget model() {\n\t\tif (!this._model) {\n\t\t\tconst model = GlbContainerResource.createModel(this.data, this._defaultMaterial);\n\t\t\tconst modelAsset = GlbContainerResource.createAsset(this._assetName, 'model', model, 0);\n\t\t\tthis._assets.add(modelAsset);\n\t\t\tthis._model = modelAsset;\n\t\t}\n\t\treturn this._model;\n\t}\n\tstatic createAsset(assetName, type, resource, index) {\n\t\tconst subAsset = new Asset(`${assetName}/${type}/${index}`, type, {\n\t\t\turl: ''\n\t\t});\n\t\tsubAsset.resource = resource;\n\t\tsubAsset.loaded = true;\n\t\treturn subAsset;\n\t}\n\tinstantiateModelEntity(options) {\n\t\tconst entity = new Entity();\n\t\tentity.addComponent('model', Object.assign({\n\t\t\ttype: 'asset',\n\t\t\tasset: this.model\n\t\t}, options));\n\t\treturn entity;\n\t}\n\tinstantiateRenderEntity(options) {\n\t\tconst defaultMaterial = this._defaultMaterial;\n\t\tconst skinnedMeshInstances = [];\n\t\tconst createMeshInstance = function createMeshInstance(root, entity, mesh, materials, meshDefaultMaterials, skins, gltfNode) {\n\t\t\tconst materialIndex = meshDefaultMaterials[mesh.id];\n\t\t\tconst material = materialIndex === undefined ? defaultMaterial : materials[materialIndex];\n\t\t\tconst meshInstance = new MeshInstance(mesh, material);\n\t\t\tif (mesh.morph) {\n\t\t\t\tmeshInstance.morphInstance = new MorphInstance(mesh.morph);\n\t\t\t}\n\t\t\tif (gltfNode.hasOwnProperty('skin')) {\n\t\t\t\tskinnedMeshInstances.push({\n\t\t\t\t\tmeshInstance: meshInstance,\n\t\t\t\t\trootBone: root,\n\t\t\t\t\tentity: entity\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn meshInstance;\n\t\t};\n\t\tconst cloneHierarchy = (root, node, glb) => {\n\t\t\tconst entity = new Entity();\n\t\t\tnode._cloneInternal(entity);\n\t\t\tif (!root) root = entity;\n\t\t\tlet attachedMi = null;\n\t\t\tlet renderAsset = null;\n\t\t\tfor (let i = 0; i < glb.nodes.length; i++) {\n\t\t\t\tconst glbNode = glb.nodes[i];\n\t\t\t\tif (glbNode === node) {\n\t\t\t\t\tconst gltfNode = glb.gltf.nodes[i];\n\t\t\t\t\tif (gltfNode.hasOwnProperty('mesh')) {\n\t\t\t\t\t\tconst meshGroup = glb.renders[gltfNode.mesh].meshes;\n\t\t\t\t\t\trenderAsset = this.renders[gltfNode.mesh];\n\t\t\t\t\t\tfor (let mi = 0; mi < meshGroup.length; mi++) {\n\t\t\t\t\t\t\tconst mesh = meshGroup[mi];\n\t\t\t\t\t\t\tif (mesh) {\n\t\t\t\t\t\t\t\tconst cloneMi = createMeshInstance(root, entity, mesh, glb.materials, glb.meshDefaultMaterials, glb.skins, gltfNode);\n\t\t\t\t\t\t\t\tif (!attachedMi) {\n\t\t\t\t\t\t\t\t\tattachedMi = [];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tattachedMi.push(cloneMi);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (glb.lights) {\n\t\t\t\t\t\tconst lightEntity = glb.lights.get(gltfNode);\n\t\t\t\t\t\tif (lightEntity) {\n\t\t\t\t\t\t\tentity.addChild(lightEntity.clone());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (glb.cameras) {\n\t\t\t\t\t\tconst cameraEntity = glb.cameras.get(gltfNode);\n\t\t\t\t\t\tif (cameraEntity) {\n\t\t\t\t\t\t\tcameraEntity.camera.system.cloneComponent(cameraEntity, entity);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (attachedMi) {\n\t\t\t\tentity.addComponent('render', Object.assign({\n\t\t\t\t\ttype: 'asset',\n\t\t\t\t\tmeshInstances: attachedMi\n\t\t\t\t}, options));\n\t\t\t\tentity.render.assignAsset(renderAsset);\n\t\t\t}\n\t\t\tconst children = node.children;\n\t\t\tfor (let i = 0; i < children.length; i++) {\n\t\t\t\tconst childClone = cloneHierarchy(root, children[i], glb);\n\t\t\t\tentity.addChild(childClone);\n\t\t\t}\n\t\t\treturn entity;\n\t\t};\n\t\tconst sceneClones = [];\n\t\tfor (const scene of this.data.scenes) {\n\t\t\tsceneClones.push(cloneHierarchy(null, scene, this.data));\n\t\t}\n\t\tskinnedMeshInstances.forEach(data => {\n\t\t\tdata.meshInstance.skinInstance = SkinInstanceCache.createCachedSkinInstance(data.meshInstance.mesh.skin, data.rootBone, data.entity);\n\t\t\tdata.meshInstance.node.render.rootBone = data.rootBone;\n\t\t});\n\t\treturn GlbContainerResource.createSceneHierarchy(sceneClones, Entity);\n\t}\n\tgetMaterialVariants() {\n\t\treturn this.data.variants ? Object.keys(this.data.variants) : [];\n\t}\n\tapplyMaterialVariant(entity, name) {\n\t\tconst variant = name ? this.data.variants[name] : null;\n\t\tif (variant === undefined) {\n\t\t\treturn;\n\t\t}\n\t\tconst renders = entity.findComponents('render');\n\t\tfor (let i = 0; i < renders.length; i++) {\n\t\t\tconst renderComponent = renders[i];\n\t\t\tthis._applyMaterialVariant(variant, renderComponent.meshInstances);\n\t\t}\n\t}\n\tapplyMaterialVariantInstances(instances, name) {\n\t\tconst variant = name ? this.data.variants[name] : null;\n\t\tif (variant === undefined) {\n\t\t\treturn;\n\t\t}\n\t\tthis._applyMaterialVariant(variant, instances);\n\t}\n\t_applyMaterialVariant(variant, instances) {\n\t\tinstances.forEach(instance => {\n\t\t\tif (variant === null) {\n\t\t\t\tinstance.material = this._defaultMaterial;\n\t\t\t} else {\n\t\t\t\tconst meshVariants = this.data.meshVariants[instance.mesh.id];\n\t\t\t\tif (meshVariants) {\n\t\t\t\t\tinstance.material = this.data.materials[meshVariants[variant]];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\tstatic createSceneHierarchy(sceneNodes, nodeType) {\n\t\tlet root = null;\n\t\tif (sceneNodes.length === 1) {\n\t\t\troot = sceneNodes[0];\n\t\t} else {\n\t\t\troot = new nodeType('SceneGroup');\n\t\t\tfor (const scene of sceneNodes) {\n\t\t\t\troot.addChild(scene);\n\t\t\t}\n\t\t}\n\t\treturn root;\n\t}\n\tstatic createModel(glb, defaultMaterial) {\n\t\tconst createMeshInstance = function createMeshInstance(model, mesh, skins, skinInstances, materials, node, gltfNode) {\n\t\t\tconst materialIndex = glb.meshDefaultMaterials[mesh.id];\n\t\t\tconst material = materialIndex === undefined ? defaultMaterial : materials[materialIndex];\n\t\t\tconst meshInstance = new MeshInstance(mesh, material, node);\n\t\t\tif (mesh.morph) {\n\t\t\t\tconst morphInstance = new MorphInstance(mesh.morph);\n\t\t\t\tmeshInstance.morphInstance = morphInstance;\n\t\t\t\tmodel.morphInstances.push(morphInstance);\n\t\t\t}\n\t\t\tif (gltfNode.hasOwnProperty('skin')) {\n\t\t\t\tconst skinIndex = gltfNode.skin;\n\t\t\t\tconst skin = skins[skinIndex];\n\t\t\t\tmesh.skin = skin;\n\t\t\t\tconst skinInstance = skinInstances[skinIndex];\n\t\t\t\tmeshInstance.skinInstance = skinInstance;\n\t\t\t\tmodel.skinInstances.push(skinInstance);\n\t\t\t}\n\t\t\tmodel.meshInstances.push(meshInstance);\n\t\t};\n\t\tconst model = new Model();\n\t\tconst skinInstances = [];\n\t\tfor (const skin of glb.skins) {\n\t\t\tconst skinInstance = new SkinInstance(skin);\n\t\t\tskinInstance.bones = skin.bones;\n\t\t\tskinInstances.push(skinInstance);\n\t\t}\n\t\tmodel.graph = GlbContainerResource.createSceneHierarchy(glb.scenes, GraphNode);\n\t\tfor (let i = 0; i < glb.nodes.length; i++) {\n\t\t\tconst node = glb.nodes[i];\n\t\t\tif (node.root === model.graph) {\n\t\t\t\tconst gltfNode = glb.gltf.nodes[i];\n\t\t\t\tif (gltfNode.hasOwnProperty('mesh')) {\n\t\t\t\t\tconst meshGroup = glb.renders[gltfNode.mesh].meshes;\n\t\t\t\t\tfor (let mi = 0; mi < meshGroup.length; mi++) {\n\t\t\t\t\t\tconst mesh = meshGroup[mi];\n\t\t\t\t\t\tif (mesh) {\n\t\t\t\t\t\t\tcreateMeshInstance(model, mesh, glb.skins, skinInstances, glb.materials, node, gltfNode);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn model;\n\t}\n\tdestroy() {\n\t\tconst registry = this._assets;\n\t\tconst destroyAsset = function destroyAsset(asset) {\n\t\t\tregistry.remove(asset);\n\t\t\tasset.unload();\n\t\t};\n\t\tconst destroyAssets = function destroyAssets(assets) {\n\t\t\tassets.forEach(asset => {\n\t\t\t\tdestroyAsset(asset);\n\t\t\t});\n\t\t};\n\t\tif (this.animations) {\n\t\t\tdestroyAssets(this.animations);\n\t\t\tthis.animations = null;\n\t\t}\n\t\tif (this.textures) {\n\t\t\tdestroyAssets(this.textures);\n\t\t\tthis.textures = null;\n\t\t}\n\t\tif (this.materials) {\n\t\t\tdestroyAssets(this.materials);\n\t\t\tthis.materials = null;\n\t\t}\n\t\tif (this.renders) {\n\t\t\tdestroyAssets(this.renders);\n\t\t\tthis.renders = null;\n\t\t}\n\t\tif (this._model) {\n\t\t\tdestroyAsset(this._model);\n\t\t\tthis._model = null;\n\t\t}\n\t\tthis.data = null;\n\t\tthis.assets = null;\n\t}\n}\n\nexport { GlbContainerResource };\n","import { GlbContainerResource } from './glb-container-resource.js';\nimport { GlbParser } from './glb-parser.js';\n\nclass GlbModelParser {\n\tconstructor(modelHandler) {\n\t\tthis._device = modelHandler.device;\n\t\tthis._defaultMaterial = modelHandler.defaultMaterial;\n\t\tthis._assets = modelHandler.assets;\n\t}\n\tparse(data, callback, asset) {\n\t\tvar _asset$options;\n\t\tGlbParser.parse('filename.glb', '', data, this._device, this._assets, (_asset$options = asset == null ? void 0 : asset.options) != null ? _asset$options : {}, (err, result) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else {\n\t\t\t\tconst model = GlbContainerResource.createModel(result, this._defaultMaterial);\n\t\t\t\tresult.destroy();\n\t\t\t\tcallback(null, model);\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport { GlbModelParser };\n","import { path } from '../../core/path.js';\nimport { Color } from '../../core/math/color.js';\nimport { Mat4 } from '../../core/math/mat4.js';\nimport { math } from '../../core/math/math.js';\nimport { Vec2 } from '../../core/math/vec2.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { BoundingBox } from '../../core/shape/bounding-box.js';\nimport { CULLFACE_NONE, CULLFACE_BACK, INDEXFORMAT_UINT32, INDEXFORMAT_UINT16, INDEXFORMAT_UINT8, BUFFER_STATIC, FILTER_LINEAR_MIPMAP_LINEAR, FILTER_NEAREST_MIPMAP_LINEAR, FILTER_LINEAR_MIPMAP_NEAREST, FILTER_NEAREST_MIPMAP_NEAREST, FILTER_LINEAR, FILTER_NEAREST, ADDRESS_REPEAT, ADDRESS_MIRRORED_REPEAT, ADDRESS_CLAMP_TO_EDGE, PRIMITIVE_TRIANGLES, PRIMITIVE_TRIFAN, PRIMITIVE_TRISTRIP, PRIMITIVE_LINESTRIP, PRIMITIVE_LINELOOP, PRIMITIVE_LINES, PRIMITIVE_POINTS, SEMANTIC_NORMAL, SEMANTIC_COLOR, TYPE_UINT8, TYPE_UINT16, TYPE_FLOAT32, TYPE_UINT32, TYPE_INT32, TYPE_INT16, TYPE_INT8, SEMANTIC_POSITION, SEMANTIC_TANGENT, SEMANTIC_BLENDINDICES, SEMANTIC_BLENDWEIGHT, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1, SEMANTIC_TEXCOORD2, SEMANTIC_TEXCOORD3, SEMANTIC_TEXCOORD4, SEMANTIC_TEXCOORD5, SEMANTIC_TEXCOORD6, SEMANTIC_TEXCOORD7, typedArrayTypesByteSize, typedArrayTypes } from '../../platform/graphics/constants.js';\nimport { IndexBuffer } from '../../platform/graphics/index-buffer.js';\nimport { Texture } from '../../platform/graphics/texture.js';\nimport { VertexBuffer } from '../../platform/graphics/vertex-buffer.js';\nimport { VertexFormat } from '../../platform/graphics/vertex-format.js';\nimport { http } from '../../platform/net/http.js';\nimport { SPECOCC_AO, BLEND_NONE, BLEND_NORMAL, PROJECTION_ORTHOGRAPHIC, PROJECTION_PERSPECTIVE, ASPECT_AUTO, LIGHTFALLOFF_INVERSESQUARED, ASPECT_MANUAL } from '../../scene/constants.js';\nimport { GraphNode } from '../../scene/graph-node.js';\nimport { Light, lightTypes } from '../../scene/light.js';\nimport { Mesh } from '../../scene/mesh.js';\nimport { Morph } from '../../scene/morph.js';\nimport { MorphTarget } from '../../scene/morph-target.js';\nimport { calculateNormals } from '../../scene/geometry/geometry-utils.js';\nimport { Render } from '../../scene/render.js';\nimport { Skin } from '../../scene/skin.js';\nimport { StandardMaterial } from '../../scene/materials/standard-material.js';\nimport { Entity } from '../entity.js';\nimport { INTERPOLATION_LINEAR, INTERPOLATION_CUBIC, INTERPOLATION_STEP } from '../anim/constants.js';\nimport { AnimCurve } from '../anim/evaluator/anim-curve.js';\nimport { AnimData } from '../anim/evaluator/anim-data.js';\nimport { AnimTrack } from '../anim/evaluator/anim-track.js';\nimport { Asset } from '../asset/asset.js';\nimport { ABSOLUTE_URL } from '../asset/constants.js';\nimport { dracoDecode } from './draco-decoder.js';\n\nclass GlbResources {\n\tconstructor() {\n\t\tthis.gltf = void 0;\n\t\tthis.nodes = void 0;\n\t\tthis.scenes = void 0;\n\t\tthis.animations = void 0;\n\t\tthis.textures = void 0;\n\t\tthis.materials = void 0;\n\t\tthis.variants = void 0;\n\t\tthis.meshVariants = void 0;\n\t\tthis.meshDefaultMaterials = void 0;\n\t\tthis.renders = void 0;\n\t\tthis.skins = void 0;\n\t\tthis.lights = void 0;\n\t\tthis.cameras = void 0;\n\t}\n\tdestroy() {\n\t\tif (this.renders) {\n\t\t\tthis.renders.forEach(render => {\n\t\t\t\trender.meshes = null;\n\t\t\t});\n\t\t}\n\t}\n}\nconst isDataURI = uri => {\n\treturn /^data:[^\\n\\r,\\u2028\\u2029]*,.*$/i.test(uri);\n};\nconst getDataURIMimeType = uri => {\n\treturn uri.substring(uri.indexOf(':') + 1, uri.indexOf(';'));\n};\nconst getNumComponents = accessorType => {\n\tswitch (accessorType) {\n\t\tcase 'SCALAR':\n\t\t\treturn 1;\n\t\tcase 'VEC2':\n\t\t\treturn 2;\n\t\tcase 'VEC3':\n\t\t\treturn 3;\n\t\tcase 'VEC4':\n\t\t\treturn 4;\n\t\tcase 'MAT2':\n\t\t\treturn 4;\n\t\tcase 'MAT3':\n\t\t\treturn 9;\n\t\tcase 'MAT4':\n\t\t\treturn 16;\n\t\tdefault:\n\t\t\treturn 3;\n\t}\n};\nconst getComponentType = componentType => {\n\tswitch (componentType) {\n\t\tcase 5120:\n\t\t\treturn TYPE_INT8;\n\t\tcase 5121:\n\t\t\treturn TYPE_UINT8;\n\t\tcase 5122:\n\t\t\treturn TYPE_INT16;\n\t\tcase 5123:\n\t\t\treturn TYPE_UINT16;\n\t\tcase 5124:\n\t\t\treturn TYPE_INT32;\n\t\tcase 5125:\n\t\t\treturn TYPE_UINT32;\n\t\tcase 5126:\n\t\t\treturn TYPE_FLOAT32;\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n};\nconst getComponentSizeInBytes = componentType => {\n\tswitch (componentType) {\n\t\tcase 5120:\n\t\t\treturn 1;\n\t\tcase 5121:\n\t\t\treturn 1;\n\t\tcase 5122:\n\t\t\treturn 2;\n\t\tcase 5123:\n\t\t\treturn 2;\n\t\tcase 5124:\n\t\t\treturn 4;\n\t\tcase 5125:\n\t\t\treturn 4;\n\t\tcase 5126:\n\t\t\treturn 4;\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n};\nconst getComponentDataType = componentType => {\n\tswitch (componentType) {\n\t\tcase 5120:\n\t\t\treturn Int8Array;\n\t\tcase 5121:\n\t\t\treturn Uint8Array;\n\t\tcase 5122:\n\t\t\treturn Int16Array;\n\t\tcase 5123:\n\t\t\treturn Uint16Array;\n\t\tcase 5124:\n\t\t\treturn Int32Array;\n\t\tcase 5125:\n\t\t\treturn Uint32Array;\n\t\tcase 5126:\n\t\t\treturn Float32Array;\n\t\tdefault:\n\t\t\treturn null;\n\t}\n};\nconst gltfToEngineSemanticMap = {\n\t'POSITION': SEMANTIC_POSITION,\n\t'NORMAL': SEMANTIC_NORMAL,\n\t'TANGENT': SEMANTIC_TANGENT,\n\t'COLOR_0': SEMANTIC_COLOR,\n\t'JOINTS_0': SEMANTIC_BLENDINDICES,\n\t'WEIGHTS_0': SEMANTIC_BLENDWEIGHT,\n\t'TEXCOORD_0': SEMANTIC_TEXCOORD0,\n\t'TEXCOORD_1': SEMANTIC_TEXCOORD1,\n\t'TEXCOORD_2': SEMANTIC_TEXCOORD2,\n\t'TEXCOORD_3': SEMANTIC_TEXCOORD3,\n\t'TEXCOORD_4': SEMANTIC_TEXCOORD4,\n\t'TEXCOORD_5': SEMANTIC_TEXCOORD5,\n\t'TEXCOORD_6': SEMANTIC_TEXCOORD6,\n\t'TEXCOORD_7': SEMANTIC_TEXCOORD7\n};\nconst attributeOrder = {\n\t[SEMANTIC_POSITION]: 0,\n\t[SEMANTIC_NORMAL]: 1,\n\t[SEMANTIC_TANGENT]: 2,\n\t[SEMANTIC_COLOR]: 3,\n\t[SEMANTIC_BLENDINDICES]: 4,\n\t[SEMANTIC_BLENDWEIGHT]: 5,\n\t[SEMANTIC_TEXCOORD0]: 6,\n\t[SEMANTIC_TEXCOORD1]: 7,\n\t[SEMANTIC_TEXCOORD2]: 8,\n\t[SEMANTIC_TEXCOORD3]: 9,\n\t[SEMANTIC_TEXCOORD4]: 10,\n\t[SEMANTIC_TEXCOORD5]: 11,\n\t[SEMANTIC_TEXCOORD6]: 12,\n\t[SEMANTIC_TEXCOORD7]: 13\n};\nconst getDequantizeFunc = srcType => {\n\tswitch (srcType) {\n\t\tcase TYPE_INT8:\n\t\t\treturn x => Math.max(x / 127.0, -1.0);\n\t\tcase TYPE_UINT8:\n\t\t\treturn x => x / 255.0;\n\t\tcase TYPE_INT16:\n\t\t\treturn x => Math.max(x / 32767.0, -1.0);\n\t\tcase TYPE_UINT16:\n\t\t\treturn x => x / 65535.0;\n\t\tdefault:\n\t\t\treturn x => x;\n\t}\n};\nconst dequantizeArray = (dstArray, srcArray, srcType) => {\n\tconst convFunc = getDequantizeFunc(srcType);\n\tconst len = srcArray.length;\n\tfor (let i = 0; i < len; ++i) {\n\t\tdstArray[i] = convFunc(srcArray[i]);\n\t}\n\treturn dstArray;\n};\nconst getAccessorData = (gltfAccessor, bufferViews, flatten = false) => {\n\tconst numComponents = getNumComponents(gltfAccessor.type);\n\tconst dataType = getComponentDataType(gltfAccessor.componentType);\n\tif (!dataType) {\n\t\treturn null;\n\t}\n\tlet result;\n\tif (gltfAccessor.sparse) {\n\t\tconst sparse = gltfAccessor.sparse;\n\t\tconst indicesAccessor = {\n\t\t\tcount: sparse.count,\n\t\t\ttype: 'SCALAR'\n\t\t};\n\t\tconst indices = getAccessorData(Object.assign(indicesAccessor, sparse.indices), bufferViews, true);\n\t\tconst valuesAccessor = {\n\t\t\tcount: sparse.count,\n\t\t\ttype: gltfAccessor.type,\n\t\t\tcomponentType: gltfAccessor.componentType\n\t\t};\n\t\tconst values = getAccessorData(Object.assign(valuesAccessor, sparse.values), bufferViews, true);\n\t\tif (gltfAccessor.hasOwnProperty('bufferView')) {\n\t\t\tconst baseAccessor = {\n\t\t\t\tbufferView: gltfAccessor.bufferView,\n\t\t\t\tbyteOffset: gltfAccessor.byteOffset,\n\t\t\t\tcomponentType: gltfAccessor.componentType,\n\t\t\t\tcount: gltfAccessor.count,\n\t\t\t\ttype: gltfAccessor.type\n\t\t\t};\n\t\t\tresult = getAccessorData(baseAccessor, bufferViews, true).slice();\n\t\t} else {\n\t\t\tresult = new dataType(gltfAccessor.count * numComponents);\n\t\t}\n\t\tfor (let i = 0; i < sparse.count; ++i) {\n\t\t\tconst targetIndex = indices[i];\n\t\t\tfor (let j = 0; j < numComponents; ++j) {\n\t\t\t\tresult[targetIndex * numComponents + j] = values[i * numComponents + j];\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif (gltfAccessor.hasOwnProperty('bufferView')) {\n\t\t\tconst bufferView = bufferViews[gltfAccessor.bufferView];\n\t\t\tif (flatten && bufferView.hasOwnProperty('byteStride')) {\n\t\t\t\tconst bytesPerElement = numComponents * dataType.BYTES_PER_ELEMENT;\n\t\t\t\tconst storage = new ArrayBuffer(gltfAccessor.count * bytesPerElement);\n\t\t\t\tconst tmpArray = new Uint8Array(storage);\n\t\t\t\tlet dstOffset = 0;\n\t\t\t\tfor (let i = 0; i < gltfAccessor.count; ++i) {\n\t\t\t\t\tlet srcOffset = (gltfAccessor.byteOffset || 0) + i * bufferView.byteStride;\n\t\t\t\t\tfor (let b = 0; b < bytesPerElement; ++b) {\n\t\t\t\t\t\ttmpArray[dstOffset++] = bufferView[srcOffset++];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult = new dataType(storage);\n\t\t\t} else {\n\t\t\t\tresult = new dataType(bufferView.buffer, bufferView.byteOffset + (gltfAccessor.byteOffset || 0), gltfAccessor.count * numComponents);\n\t\t\t}\n\t\t} else {\n\t\t\tresult = new dataType(gltfAccessor.count * numComponents);\n\t\t}\n\t}\n\treturn result;\n};\nconst getAccessorDataFloat32 = (gltfAccessor, bufferViews) => {\n\tconst data = getAccessorData(gltfAccessor, bufferViews, true);\n\tif (data instanceof Float32Array || !gltfAccessor.normalized) {\n\t\treturn data;\n\t}\n\tconst float32Data = new Float32Array(data.length);\n\tdequantizeArray(float32Data, data, getComponentType(gltfAccessor.componentType));\n\treturn float32Data;\n};\nconst getAccessorBoundingBox = gltfAccessor => {\n\tlet min = gltfAccessor.min;\n\tlet max = gltfAccessor.max;\n\tif (!min || !max) {\n\t\treturn null;\n\t}\n\tif (gltfAccessor.normalized) {\n\t\tconst ctype = getComponentType(gltfAccessor.componentType);\n\t\tmin = dequantizeArray([], min, ctype);\n\t\tmax = dequantizeArray([], max, ctype);\n\t}\n\treturn new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));\n};\nconst getPrimitiveType = primitive => {\n\tif (!primitive.hasOwnProperty('mode')) {\n\t\treturn PRIMITIVE_TRIANGLES;\n\t}\n\tswitch (primitive.mode) {\n\t\tcase 0:\n\t\t\treturn PRIMITIVE_POINTS;\n\t\tcase 1:\n\t\t\treturn PRIMITIVE_LINES;\n\t\tcase 2:\n\t\t\treturn PRIMITIVE_LINELOOP;\n\t\tcase 3:\n\t\t\treturn PRIMITIVE_LINESTRIP;\n\t\tcase 4:\n\t\t\treturn PRIMITIVE_TRIANGLES;\n\t\tcase 5:\n\t\t\treturn PRIMITIVE_TRISTRIP;\n\t\tcase 6:\n\t\t\treturn PRIMITIVE_TRIFAN;\n\t\tdefault:\n\t\t\treturn PRIMITIVE_TRIANGLES;\n\t}\n};\nconst generateIndices = numVertices => {\n\tconst dummyIndices = new Uint16Array(numVertices);\n\tfor (let i = 0; i < numVertices; i++) {\n\t\tdummyIndices[i] = i;\n\t}\n\treturn dummyIndices;\n};\nconst generateNormals = (sourceDesc, indices) => {\n\tconst p = sourceDesc[SEMANTIC_POSITION];\n\tif (!p || p.components !== 3) {\n\t\treturn;\n\t}\n\tlet positions;\n\tif (p.size !== p.stride) {\n\t\tconst srcStride = p.stride / typedArrayTypesByteSize[p.type];\n\t\tconst src = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * srcStride);\n\t\tpositions = new typedArrayTypes[p.type](p.count * 3);\n\t\tfor (let i = 0; i < p.count; ++i) {\n\t\t\tpositions[i * 3 + 0] = src[i * srcStride + 0];\n\t\t\tpositions[i * 3 + 1] = src[i * srcStride + 1];\n\t\t\tpositions[i * 3 + 2] = src[i * srcStride + 2];\n\t\t}\n\t} else {\n\t\tpositions = new typedArrayTypes[p.type](p.buffer, p.offset, p.count * 3);\n\t}\n\tconst numVertices = p.count;\n\tif (!indices) {\n\t\tindices = generateIndices(numVertices);\n\t}\n\tconst normalsTemp = calculateNormals(positions, indices);\n\tconst normals = new Float32Array(normalsTemp.length);\n\tnormals.set(normalsTemp);\n\tsourceDesc[SEMANTIC_NORMAL] = {\n\t\tbuffer: normals.buffer,\n\t\tsize: 12,\n\t\toffset: 0,\n\t\tstride: 12,\n\t\tcount: numVertices,\n\t\tcomponents: 3,\n\t\ttype: TYPE_FLOAT32\n\t};\n};\nconst flipTexCoordVs = vertexBuffer => {\n\tlet i, j;\n\tconst floatOffsets = [];\n\tconst shortOffsets = [];\n\tconst byteOffsets = [];\n\tfor (i = 0; i < vertexBuffer.format.elements.length; ++i) {\n\t\tconst element = vertexBuffer.format.elements[i];\n\t\tif (element.name === SEMANTIC_TEXCOORD0 || element.name === SEMANTIC_TEXCOORD1) {\n\t\t\tswitch (element.dataType) {\n\t\t\t\tcase TYPE_FLOAT32:\n\t\t\t\t\tfloatOffsets.push({\n\t\t\t\t\t\toffset: element.offset / 4 + 1,\n\t\t\t\t\t\tstride: element.stride / 4\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE_UINT16:\n\t\t\t\t\tshortOffsets.push({\n\t\t\t\t\t\toffset: element.offset / 2 + 1,\n\t\t\t\t\t\tstride: element.stride / 2\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase TYPE_UINT8:\n\t\t\t\t\tbyteOffsets.push({\n\t\t\t\t\t\toffset: element.offset + 1,\n\t\t\t\t\t\tstride: element.stride\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tconst flip = (offsets, type, one) => {\n\t\tconst typedArray = new type(vertexBuffer.storage);\n\t\tfor (i = 0; i < offsets.length; ++i) {\n\t\t\tlet index = offsets[i].offset;\n\t\t\tconst stride = offsets[i].stride;\n\t\t\tfor (j = 0; j < vertexBuffer.numVertices; ++j) {\n\t\t\t\ttypedArray[index] = one - typedArray[index];\n\t\t\t\tindex += stride;\n\t\t\t}\n\t\t}\n\t};\n\tif (floatOffsets.length > 0) {\n\t\tflip(floatOffsets, Float32Array, 1.0);\n\t}\n\tif (shortOffsets.length > 0) {\n\t\tflip(shortOffsets, Uint16Array, 65535);\n\t}\n\tif (byteOffsets.length > 0) {\n\t\tflip(byteOffsets, Uint8Array, 255);\n\t}\n};\nconst cloneTexture = texture => {\n\tconst shallowCopyLevels = texture => {\n\t\tconst result = [];\n\t\tfor (let mip = 0; mip < texture._levels.length; ++mip) {\n\t\t\tlet level = [];\n\t\t\tif (texture.cubemap) {\n\t\t\t\tfor (let face = 0; face < 6; ++face) {\n\t\t\t\t\tlevel.push(texture._levels[mip][face]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlevel = texture._levels[mip];\n\t\t\t}\n\t\t\tresult.push(level);\n\t\t}\n\t\treturn result;\n\t};\n\tconst result = new Texture(texture.device, texture);\n\tresult._levels = shallowCopyLevels(texture);\n\treturn result;\n};\nconst cloneTextureAsset = src => {\n\tconst result = new Asset(`${src.name}_clone`, src.type, src.file, src.data, src.options);\n\tresult.loaded = true;\n\tresult.resource = cloneTexture(src.resource);\n\tsrc.registry.add(result);\n\treturn result;\n};\nconst createVertexBufferInternal = (device, sourceDesc, flipV) => {\n\tconst positionDesc = sourceDesc[SEMANTIC_POSITION];\n\tif (!positionDesc) {\n\t\treturn null;\n\t}\n\tconst numVertices = positionDesc.count;\n\tconst vertexDesc = [];\n\tfor (const semantic in sourceDesc) {\n\t\tif (sourceDesc.hasOwnProperty(semantic)) {\n\t\t\tconst element = {\n\t\t\t\tsemantic: semantic,\n\t\t\t\tcomponents: sourceDesc[semantic].components,\n\t\t\t\ttype: sourceDesc[semantic].type,\n\t\t\t\tnormalize: !!sourceDesc[semantic].normalize\n\t\t\t};\n\t\t\tif (!VertexFormat.isElementValid(device, element)) {\n\t\t\t\telement.components++;\n\t\t\t}\n\t\t\tvertexDesc.push(element);\n\t\t}\n\t}\n\tvertexDesc.sort((lhs, rhs) => {\n\t\treturn attributeOrder[lhs.semantic] - attributeOrder[rhs.semantic];\n\t});\n\tlet i, j, k;\n\tlet source, target, sourceOffset;\n\tconst vertexFormat = new VertexFormat(device, vertexDesc);\n\tlet isCorrectlyInterleaved = true;\n\tfor (i = 0; i < vertexFormat.elements.length; ++i) {\n\t\ttarget = vertexFormat.elements[i];\n\t\tsource = sourceDesc[target.name];\n\t\tsourceOffset = source.offset - positionDesc.offset;\n\t\tif (source.buffer !== positionDesc.buffer || source.stride !== target.stride || source.size !== target.size || sourceOffset !== target.offset) {\n\t\t\tisCorrectlyInterleaved = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tconst vertexBuffer = new VertexBuffer(device, vertexFormat, numVertices);\n\tconst vertexData = vertexBuffer.lock();\n\tconst targetArray = new Uint32Array(vertexData);\n\tlet sourceArray;\n\tif (isCorrectlyInterleaved) {\n\t\tsourceArray = new Uint32Array(positionDesc.buffer, positionDesc.offset, numVertices * vertexBuffer.format.size / 4);\n\t\ttargetArray.set(sourceArray);\n\t} else {\n\t\tlet targetStride, sourceStride;\n\t\tfor (i = 0; i < vertexBuffer.format.elements.length; ++i) {\n\t\t\ttarget = vertexBuffer.format.elements[i];\n\t\t\ttargetStride = target.stride / 4;\n\t\t\tsource = sourceDesc[target.name];\n\t\t\tsourceStride = source.stride / 4;\n\t\t\tsourceArray = new Uint32Array(source.buffer, source.offset, (source.count - 1) * sourceStride + (source.size + 3) / 4);\n\t\t\tlet src = 0;\n\t\t\tlet dst = target.offset / 4;\n\t\t\tconst kend = Math.floor((source.size + 3) / 4);\n\t\t\tfor (j = 0; j < numVertices; ++j) {\n\t\t\t\tfor (k = 0; k < kend; ++k) {\n\t\t\t\t\ttargetArray[dst + k] = sourceArray[src + k];\n\t\t\t\t}\n\t\t\t\tsrc += sourceStride;\n\t\t\t\tdst += targetStride;\n\t\t\t}\n\t\t}\n\t}\n\tif (flipV) {\n\t\tflipTexCoordVs(vertexBuffer);\n\t}\n\tvertexBuffer.unlock();\n\treturn vertexBuffer;\n};\nconst createVertexBuffer = (device, attributes, indices, accessors, bufferViews, flipV, vertexBufferDict) => {\n\tconst useAttributes = {};\n\tconst attribIds = [];\n\tfor (const attrib in attributes) {\n\t\tif (attributes.hasOwnProperty(attrib) && gltfToEngineSemanticMap.hasOwnProperty(attrib)) {\n\t\t\tuseAttributes[attrib] = attributes[attrib];\n\t\t\tattribIds.push(`${attrib}:${attributes[attrib]}`);\n\t\t}\n\t}\n\tattribIds.sort();\n\tconst vbKey = attribIds.join();\n\tlet vb = vertexBufferDict[vbKey];\n\tif (!vb) {\n\t\tconst sourceDesc = {};\n\t\tfor (const attrib in useAttributes) {\n\t\t\tconst accessor = accessors[attributes[attrib]];\n\t\t\tconst accessorData = getAccessorData(accessor, bufferViews);\n\t\t\tconst bufferView = bufferViews[accessor.bufferView];\n\t\t\tconst semantic = gltfToEngineSemanticMap[attrib];\n\t\t\tconst size = getNumComponents(accessor.type) * getComponentSizeInBytes(accessor.componentType);\n\t\t\tconst stride = bufferView && bufferView.hasOwnProperty('byteStride') ? bufferView.byteStride : size;\n\t\t\tsourceDesc[semantic] = {\n\t\t\t\tbuffer: accessorData.buffer,\n\t\t\t\tsize: size,\n\t\t\t\toffset: accessorData.byteOffset,\n\t\t\t\tstride: stride,\n\t\t\t\tcount: accessor.count,\n\t\t\t\tcomponents: getNumComponents(accessor.type),\n\t\t\t\ttype: getComponentType(accessor.componentType),\n\t\t\t\tnormalize: accessor.normalized\n\t\t\t};\n\t\t}\n\t\tif (!sourceDesc.hasOwnProperty(SEMANTIC_NORMAL)) {\n\t\t\tgenerateNormals(sourceDesc, indices);\n\t\t}\n\t\tvb = createVertexBufferInternal(device, sourceDesc, flipV);\n\t\tvertexBufferDict[vbKey] = vb;\n\t}\n\treturn vb;\n};\nconst createSkin = (device, gltfSkin, accessors, bufferViews, nodes, glbSkins) => {\n\tlet i, j, bindMatrix;\n\tconst joints = gltfSkin.joints;\n\tconst numJoints = joints.length;\n\tconst ibp = [];\n\tif (gltfSkin.hasOwnProperty('inverseBindMatrices')) {\n\t\tconst inverseBindMatrices = gltfSkin.inverseBindMatrices;\n\t\tconst ibmData = getAccessorData(accessors[inverseBindMatrices], bufferViews, true);\n\t\tconst ibmValues = [];\n\t\tfor (i = 0; i < numJoints; i++) {\n\t\t\tfor (j = 0; j < 16; j++) {\n\t\t\t\tibmValues[j] = ibmData[i * 16 + j];\n\t\t\t}\n\t\t\tbindMatrix = new Mat4();\n\t\t\tbindMatrix.set(ibmValues);\n\t\t\tibp.push(bindMatrix);\n\t\t}\n\t} else {\n\t\tfor (i = 0; i < numJoints; i++) {\n\t\t\tbindMatrix = new Mat4();\n\t\t\tibp.push(bindMatrix);\n\t\t}\n\t}\n\tconst boneNames = [];\n\tfor (i = 0; i < numJoints; i++) {\n\t\tboneNames[i] = nodes[joints[i]].name;\n\t}\n\tconst key = boneNames.join('#');\n\tlet skin = glbSkins.get(key);\n\tif (!skin) {\n\t\tskin = new Skin(device, ibp, boneNames);\n\t\tglbSkins.set(key, skin);\n\t}\n\treturn skin;\n};\nconst createDracoMesh = (device, primitive, accessors, bufferViews, meshVariants, meshDefaultMaterials, promises) => {\n\tvar _primitive$extensions;\n\tconst result = new Mesh(device);\n\tresult.aabb = getAccessorBoundingBox(accessors[primitive.attributes.POSITION]);\n\tconst vertexDesc = [];\n\tfor (const [name, index] of Object.entries(primitive.attributes)) {\n\t\tvar _accessor$normalized;\n\t\tconst accessor = accessors[index];\n\t\tconst semantic = gltfToEngineSemanticMap[name];\n\t\tconst componentType = getComponentType(accessor.componentType);\n\t\tvertexDesc.push({\n\t\t\tsemantic: semantic,\n\t\t\tcomponents: getNumComponents(accessor.type),\n\t\t\ttype: componentType,\n\t\t\tnormalize: (_accessor$normalized = accessor.normalized) != null ? _accessor$normalized : semantic === SEMANTIC_COLOR && (componentType === TYPE_UINT8 || componentType === TYPE_UINT16)\n\t\t});\n\t}\n\tpromises.push(new Promise((resolve, reject) => {\n\t\tconst dracoExt = primitive.extensions.KHR_draco_mesh_compression;\n\t\tdracoDecode(bufferViews[dracoExt.bufferView].slice().buffer, (err, decompressedData) => {\n\t\t\tif (err) {\n\t\t\t\tconsole.log(err);\n\t\t\t\treject(err);\n\t\t\t} else {\n\t\t\t\tvar _primitive$attributes;\n\t\t\t\tconst order = {};\n\t\t\t\tfor (const [name, index] of Object.entries(dracoExt.attributes)) {\n\t\t\t\t\torder[gltfToEngineSemanticMap[name]] = decompressedData.attributes.indexOf(index);\n\t\t\t\t}\n\t\t\t\tvertexDesc.sort((a, b) => {\n\t\t\t\t\treturn order[a.semantic] - order[b.semantic];\n\t\t\t\t});\n\t\t\t\tif (!((_primitive$attributes = primitive.attributes) != null && _primitive$attributes.NORMAL)) {\n\t\t\t\t\tvertexDesc.splice(1, 0, {\n\t\t\t\t\t\tsemantic: 'NORMAL',\n\t\t\t\t\t\tcomponents: 3,\n\t\t\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst vertexFormat = new VertexFormat(device, vertexDesc);\n\t\t\t\tconst numVertices = decompressedData.vertices.byteLength / vertexFormat.size;\n\t\t\t\tconst indexFormat = numVertices <= 65535 ? INDEXFORMAT_UINT16 : INDEXFORMAT_UINT32;\n\t\t\t\tconst numIndices = decompressedData.indices.byteLength / (numVertices <= 65535 ? 2 : 4);\n\t\t\t\tconst vertexBuffer = new VertexBuffer(device, vertexFormat, numVertices, {\n\t\t\t\t\tdata: decompressedData.vertices\n\t\t\t\t});\n\t\t\t\tconst indexBuffer = new IndexBuffer(device, indexFormat, numIndices, BUFFER_STATIC, decompressedData.indices);\n\t\t\t\tresult.vertexBuffer = vertexBuffer;\n\t\t\t\tresult.indexBuffer[0] = indexBuffer;\n\t\t\t\tresult.primitive[0].type = getPrimitiveType(primitive);\n\t\t\t\tresult.primitive[0].base = 0;\n\t\t\t\tresult.primitive[0].count = indexBuffer ? numIndices : numVertices;\n\t\t\t\tresult.primitive[0].indexed = !!indexBuffer;\n\t\t\t\tresolve();\n\t\t\t}\n\t\t});\n\t}));\n\tif (primitive != null && (_primitive$extensions = primitive.extensions) != null && _primitive$extensions.KHR_materials_variants) {\n\t\tconst variants = primitive.extensions.KHR_materials_variants;\n\t\tconst tempMapping = {};\n\t\tvariants.mappings.forEach(mapping => {\n\t\t\tmapping.variants.forEach(variant => {\n\t\t\t\ttempMapping[variant] = mapping.material;\n\t\t\t});\n\t\t});\n\t\tmeshVariants[result.id] = tempMapping;\n\t}\n\tmeshDefaultMaterials[result.id] = primitive.material;\n\treturn result;\n};\nconst createMesh = (device, gltfMesh, accessors, bufferViews, flipV, vertexBufferDict, meshVariants, meshDefaultMaterials, assetOptions, promises) => {\n\tconst meshes = [];\n\tgltfMesh.primitives.forEach(primitive => {\n\t\tvar _primitive$extensions2;\n\t\tif ((_primitive$extensions2 = primitive.extensions) != null && _primitive$extensions2.KHR_draco_mesh_compression) {\n\t\t\tmeshes.push(createDracoMesh(device, primitive, accessors, bufferViews, meshVariants, meshDefaultMaterials, promises));\n\t\t} else {\n\t\t\tlet indices = primitive.hasOwnProperty('indices') ? getAccessorData(accessors[primitive.indices], bufferViews, true) : null;\n\t\t\tconst vertexBuffer = createVertexBuffer(device, primitive.attributes, indices, accessors, bufferViews, flipV, vertexBufferDict);\n\t\t\tconst primitiveType = getPrimitiveType(primitive);\n\t\t\tconst mesh = new Mesh(device);\n\t\t\tmesh.vertexBuffer = vertexBuffer;\n\t\t\tmesh.primitive[0].type = primitiveType;\n\t\t\tmesh.primitive[0].base = 0;\n\t\t\tmesh.primitive[0].indexed = indices !== null;\n\t\t\tif (indices !== null) {\n\t\t\t\tlet indexFormat;\n\t\t\t\tif (indices instanceof Uint8Array) {\n\t\t\t\t\tindexFormat = INDEXFORMAT_UINT8;\n\t\t\t\t} else if (indices instanceof Uint16Array) {\n\t\t\t\t\tindexFormat = INDEXFORMAT_UINT16;\n\t\t\t\t} else {\n\t\t\t\t\tindexFormat = INDEXFORMAT_UINT32;\n\t\t\t\t}\n\t\t\t\tif (indexFormat === INDEXFORMAT_UINT32 && !device.extUintElement) {\n\t\t\t\t\tindexFormat = INDEXFORMAT_UINT16;\n\t\t\t\t\tindices = new Uint16Array(indices);\n\t\t\t\t}\n\t\t\t\tif (indexFormat === INDEXFORMAT_UINT8 && device.isWebGPU) {\n\t\t\t\t\tindexFormat = INDEXFORMAT_UINT16;\n\t\t\t\t\tindices = new Uint16Array(indices);\n\t\t\t\t}\n\t\t\t\tconst indexBuffer = new IndexBuffer(device, indexFormat, indices.length, BUFFER_STATIC, indices);\n\t\t\t\tmesh.indexBuffer[0] = indexBuffer;\n\t\t\t\tmesh.primitive[0].count = indices.length;\n\t\t\t} else {\n\t\t\t\tmesh.primitive[0].count = vertexBuffer.numVertices;\n\t\t\t}\n\t\t\tif (primitive.hasOwnProperty('extensions') && primitive.extensions.hasOwnProperty('KHR_materials_variants')) {\n\t\t\t\tconst variants = primitive.extensions.KHR_materials_variants;\n\t\t\t\tconst tempMapping = {};\n\t\t\t\tvariants.mappings.forEach(mapping => {\n\t\t\t\t\tmapping.variants.forEach(variant => {\n\t\t\t\t\t\ttempMapping[variant] = mapping.material;\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\tmeshVariants[mesh.id] = tempMapping;\n\t\t\t}\n\t\t\tmeshDefaultMaterials[mesh.id] = primitive.material;\n\t\t\tlet accessor = accessors[primitive.attributes.POSITION];\n\t\t\tmesh.aabb = getAccessorBoundingBox(accessor);\n\t\t\tif (primitive.hasOwnProperty('targets')) {\n\t\t\t\tconst targets = [];\n\t\t\t\tprimitive.targets.forEach((target, index) => {\n\t\t\t\t\tconst options = {};\n\t\t\t\t\tif (target.hasOwnProperty('POSITION')) {\n\t\t\t\t\t\taccessor = accessors[target.POSITION];\n\t\t\t\t\t\toptions.deltaPositions = getAccessorDataFloat32(accessor, bufferViews);\n\t\t\t\t\t\toptions.deltaPositionsType = TYPE_FLOAT32;\n\t\t\t\t\t\toptions.aabb = getAccessorBoundingBox(accessor);\n\t\t\t\t\t}\n\t\t\t\t\tif (target.hasOwnProperty('NORMAL')) {\n\t\t\t\t\t\taccessor = accessors[target.NORMAL];\n\t\t\t\t\t\toptions.deltaNormals = getAccessorDataFloat32(accessor, bufferViews);\n\t\t\t\t\t\toptions.deltaNormalsType = TYPE_FLOAT32;\n\t\t\t\t\t}\n\t\t\t\t\tif (gltfMesh.hasOwnProperty('extras') && gltfMesh.extras.hasOwnProperty('targetNames')) {\n\t\t\t\t\t\toptions.name = gltfMesh.extras.targetNames[index];\n\t\t\t\t\t} else {\n\t\t\t\t\t\toptions.name = index.toString(10);\n\t\t\t\t\t}\n\t\t\t\t\tif (gltfMesh.hasOwnProperty('weights')) {\n\t\t\t\t\t\toptions.defaultWeight = gltfMesh.weights[index];\n\t\t\t\t\t}\n\t\t\t\t\toptions.preserveData = assetOptions.morphPreserveData;\n\t\t\t\t\ttargets.push(new MorphTarget(options));\n\t\t\t\t});\n\t\t\t\tmesh.morph = new Morph(targets, device, {\n\t\t\t\t\tpreferHighPrecision: assetOptions.morphPreferHighPrecision\n\t\t\t\t});\n\t\t\t}\n\t\t\tmeshes.push(mesh);\n\t\t}\n\t});\n\treturn meshes;\n};\nconst extractTextureTransform = (source, material, maps) => {\n\tvar _source$extensions;\n\tlet map;\n\tconst texCoord = source.texCoord;\n\tif (texCoord) {\n\t\tfor (map = 0; map < maps.length; ++map) {\n\t\t\tmaterial[`${maps[map]}MapUv`] = texCoord;\n\t\t}\n\t}\n\tconst zeros = [0, 0];\n\tconst ones = [1, 1];\n\tconst textureTransform = (_source$extensions = source.extensions) == null ? void 0 : _source$extensions.KHR_texture_transform;\n\tif (textureTransform) {\n\t\tconst offset = textureTransform.offset || zeros;\n\t\tconst scale = textureTransform.scale || ones;\n\t\tconst rotation = textureTransform.rotation ? -textureTransform.rotation * math.RAD_TO_DEG : 0;\n\t\tconst tilingVec = new Vec2(scale[0], scale[1]);\n\t\tconst offsetVec = new Vec2(offset[0], 1.0 - scale[1] - offset[1]);\n\t\tfor (map = 0; map < maps.length; ++map) {\n\t\t\tmaterial[`${maps[map]}MapTiling`] = tilingVec;\n\t\t\tmaterial[`${maps[map]}MapOffset`] = offsetVec;\n\t\t\tmaterial[`${maps[map]}MapRotation`] = rotation;\n\t\t}\n\t}\n};\nconst extensionPbrSpecGlossiness = (data, material, textures) => {\n\tlet color, texture;\n\tif (data.hasOwnProperty('diffuseFactor')) {\n\t\tcolor = data.diffuseFactor;\n\t\tmaterial.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));\n\t\tmaterial.opacity = color[3];\n\t} else {\n\t\tmaterial.diffuse.set(1, 1, 1);\n\t\tmaterial.opacity = 1;\n\t}\n\tif (data.hasOwnProperty('diffuseTexture')) {\n\t\tconst diffuseTexture = data.diffuseTexture;\n\t\ttexture = textures[diffuseTexture.index];\n\t\tmaterial.diffuseMap = texture;\n\t\tmaterial.diffuseMapChannel = 'rgb';\n\t\tmaterial.opacityMap = texture;\n\t\tmaterial.opacityMapChannel = 'a';\n\t\textractTextureTransform(diffuseTexture, material, ['diffuse', 'opacity']);\n\t}\n\tmaterial.useMetalness = false;\n\tif (data.hasOwnProperty('specularFactor')) {\n\t\tcolor = data.specularFactor;\n\t\tmaterial.specular.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));\n\t} else {\n\t\tmaterial.specular.set(1, 1, 1);\n\t}\n\tif (data.hasOwnProperty('glossinessFactor')) {\n\t\tmaterial.gloss = data.glossinessFactor;\n\t} else {\n\t\tmaterial.gloss = 1.0;\n\t}\n\tif (data.hasOwnProperty('specularGlossinessTexture')) {\n\t\tconst specularGlossinessTexture = data.specularGlossinessTexture;\n\t\tmaterial.specularEncoding = 'srgb';\n\t\tmaterial.specularMap = material.glossMap = textures[specularGlossinessTexture.index];\n\t\tmaterial.specularMapChannel = 'rgb';\n\t\tmaterial.glossMapChannel = 'a';\n\t\textractTextureTransform(specularGlossinessTexture, material, ['gloss', 'metalness']);\n\t}\n};\nconst extensionClearCoat = (data, material, textures) => {\n\tif (data.hasOwnProperty('clearcoatFactor')) {\n\t\tmaterial.clearCoat = data.clearcoatFactor * 0.25;\n\t} else {\n\t\tmaterial.clearCoat = 0;\n\t}\n\tif (data.hasOwnProperty('clearcoatTexture')) {\n\t\tconst clearcoatTexture = data.clearcoatTexture;\n\t\tmaterial.clearCoatMap = textures[clearcoatTexture.index];\n\t\tmaterial.clearCoatMapChannel = 'r';\n\t\textractTextureTransform(clearcoatTexture, material, ['clearCoat']);\n\t}\n\tif (data.hasOwnProperty('clearcoatRoughnessFactor')) {\n\t\tmaterial.clearCoatGloss = data.clearcoatRoughnessFactor;\n\t} else {\n\t\tmaterial.clearCoatGloss = 0;\n\t}\n\tif (data.hasOwnProperty('clearcoatRoughnessTexture')) {\n\t\tconst clearcoatRoughnessTexture = data.clearcoatRoughnessTexture;\n\t\tmaterial.clearCoatGlossMap = textures[clearcoatRoughnessTexture.index];\n\t\tmaterial.clearCoatGlossMapChannel = 'g';\n\t\textractTextureTransform(clearcoatRoughnessTexture, material, ['clearCoatGloss']);\n\t}\n\tif (data.hasOwnProperty('clearcoatNormalTexture')) {\n\t\tconst clearcoatNormalTexture = data.clearcoatNormalTexture;\n\t\tmaterial.clearCoatNormalMap = textures[clearcoatNormalTexture.index];\n\t\textractTextureTransform(clearcoatNormalTexture, material, ['clearCoatNormal']);\n\t\tif (clearcoatNormalTexture.hasOwnProperty('scale')) {\n\t\t\tmaterial.clearCoatBumpiness = clearcoatNormalTexture.scale;\n\t\t}\n\t}\n\tmaterial.clearCoatGlossInvert = true;\n};\nconst extensionUnlit = (data, material, textures) => {\n\tmaterial.useLighting = false;\n\tmaterial.emissive.copy(material.diffuse);\n\tmaterial.emissiveTint = material.diffuseTint;\n\tmaterial.emissiveMap = material.diffuseMap;\n\tmaterial.emissiveMapUv = material.diffuseMapUv;\n\tmaterial.emissiveMapTiling.copy(material.diffuseMapTiling);\n\tmaterial.emissiveMapOffset.copy(material.diffuseMapOffset);\n\tmaterial.emissiveMapRotation = material.diffuseMapRotation;\n\tmaterial.emissiveMapChannel = material.diffuseMapChannel;\n\tmaterial.emissiveVertexColor = material.diffuseVertexColor;\n\tmaterial.emissiveVertexColorChannel = material.diffuseVertexColorChannel;\n\tmaterial.useLighting = false;\n\tmaterial.useSkybox = false;\n\tmaterial.diffuse.set(0, 0, 0);\n\tmaterial.diffuseTint = false;\n\tmaterial.diffuseMap = null;\n\tmaterial.diffuseVertexColor = false;\n};\nconst extensionSpecular = (data, material, textures) => {\n\tmaterial.useMetalnessSpecularColor = true;\n\tif (data.hasOwnProperty('specularColorTexture')) {\n\t\tmaterial.specularEncoding = 'srgb';\n\t\tmaterial.specularMap = textures[data.specularColorTexture.index];\n\t\tmaterial.specularMapChannel = 'rgb';\n\t\textractTextureTransform(data.specularColorTexture, material, ['specular']);\n\t}\n\tif (data.hasOwnProperty('specularColorFactor')) {\n\t\tconst color = data.specularColorFactor;\n\t\tmaterial.specular.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));\n\t} else {\n\t\tmaterial.specular.set(1, 1, 1);\n\t}\n\tif (data.hasOwnProperty('specularFactor')) {\n\t\tmaterial.specularityFactor = data.specularFactor;\n\t} else {\n\t\tmaterial.specularityFactor = 1;\n\t}\n\tif (data.hasOwnProperty('specularTexture')) {\n\t\tmaterial.specularityFactorMapChannel = 'a';\n\t\tmaterial.specularityFactorMap = textures[data.specularTexture.index];\n\t\textractTextureTransform(data.specularTexture, material, ['specularityFactor']);\n\t}\n};\nconst extensionIor = (data, material, textures) => {\n\tif (data.hasOwnProperty('ior')) {\n\t\tmaterial.refractionIndex = 1.0 / data.ior;\n\t}\n};\nconst extensionDispersion = (data, material, textures) => {\n\tif (data.hasOwnProperty('dispersion')) {\n\t\tmaterial.dispersion = data.dispersion;\n\t}\n};\nconst extensionTransmission = (data, material, textures) => {\n\tmaterial.blendType = BLEND_NORMAL;\n\tmaterial.useDynamicRefraction = true;\n\tif (data.hasOwnProperty('transmissionFactor')) {\n\t\tmaterial.refraction = data.transmissionFactor;\n\t}\n\tif (data.hasOwnProperty('transmissionTexture')) {\n\t\tmaterial.refractionMapChannel = 'r';\n\t\tmaterial.refractionMap = textures[data.transmissionTexture.index];\n\t\textractTextureTransform(data.transmissionTexture, material, ['refraction']);\n\t}\n};\nconst extensionSheen = (data, material, textures) => {\n\tmaterial.useSheen = true;\n\tif (data.hasOwnProperty('sheenColorFactor')) {\n\t\tconst color = data.sheenColorFactor;\n\t\tmaterial.sheen.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));\n\t} else {\n\t\tmaterial.sheen.set(1, 1, 1);\n\t}\n\tif (data.hasOwnProperty('sheenColorTexture')) {\n\t\tmaterial.sheenMap = textures[data.sheenColorTexture.index];\n\t\tmaterial.sheenEncoding = 'srgb';\n\t\textractTextureTransform(data.sheenColorTexture, material, ['sheen']);\n\t}\n\tif (data.hasOwnProperty('sheenRoughnessFactor')) {\n\t\tmaterial.sheenGloss = data.sheenRoughnessFactor;\n\t} else {\n\t\tmaterial.sheenGloss = 0.0;\n\t}\n\tif (data.hasOwnProperty('sheenRoughnessTexture')) {\n\t\tmaterial.sheenGlossMap = textures[data.sheenRoughnessTexture.index];\n\t\tmaterial.sheenGlossMapChannel = 'a';\n\t\textractTextureTransform(data.sheenRoughnessTexture, material, ['sheenGloss']);\n\t}\n\tmaterial.sheenGlossInvert = true;\n};\nconst extensionVolume = (data, material, textures) => {\n\tmaterial.blendType = BLEND_NORMAL;\n\tmaterial.useDynamicRefraction = true;\n\tif (data.hasOwnProperty('thicknessFactor')) {\n\t\tmaterial.thickness = data.thicknessFactor;\n\t}\n\tif (data.hasOwnProperty('thicknessTexture')) {\n\t\tmaterial.thicknessMap = textures[data.thicknessTexture.index];\n\t\tmaterial.thicknessMapChannel = 'g';\n\t\textractTextureTransform(data.thicknessTexture, material, ['thickness']);\n\t}\n\tif (data.hasOwnProperty('attenuationDistance')) {\n\t\tmaterial.attenuationDistance = data.attenuationDistance;\n\t}\n\tif (data.hasOwnProperty('attenuationColor')) {\n\t\tconst color = data.attenuationColor;\n\t\tmaterial.attenuation.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));\n\t}\n};\nconst extensionEmissiveStrength = (data, material, textures) => {\n\tif (data.hasOwnProperty('emissiveStrength')) {\n\t\tmaterial.emissiveIntensity = data.emissiveStrength;\n\t}\n};\nconst extensionIridescence = (data, material, textures) => {\n\tmaterial.useIridescence = true;\n\tif (data.hasOwnProperty('iridescenceFactor')) {\n\t\tmaterial.iridescence = data.iridescenceFactor;\n\t}\n\tif (data.hasOwnProperty('iridescenceTexture')) {\n\t\tmaterial.iridescenceMapChannel = 'r';\n\t\tmaterial.iridescenceMap = textures[data.iridescenceTexture.index];\n\t\textractTextureTransform(data.iridescenceTexture, material, ['iridescence']);\n\t}\n\tif (data.hasOwnProperty('iridescenceIor')) {\n\t\tmaterial.iridescenceRefractionIndex = data.iridescenceIor;\n\t}\n\tif (data.hasOwnProperty('iridescenceThicknessMinimum')) {\n\t\tmaterial.iridescenceThicknessMin = data.iridescenceThicknessMinimum;\n\t}\n\tif (data.hasOwnProperty('iridescenceThicknessMaximum')) {\n\t\tmaterial.iridescenceThicknessMax = data.iridescenceThicknessMaximum;\n\t}\n\tif (data.hasOwnProperty('iridescenceThicknessTexture')) {\n\t\tmaterial.iridescenceThicknessMapChannel = 'g';\n\t\tmaterial.iridescenceThicknessMap = textures[data.iridescenceThicknessTexture.index];\n\t\textractTextureTransform(data.iridescenceThicknessTexture, material, ['iridescenceThickness']);\n\t}\n};\nconst createMaterial = (gltfMaterial, textures, flipV) => {\n\tconst material = new StandardMaterial();\n\tmaterial.occludeSpecular = SPECOCC_AO;\n\tmaterial.diffuseTint = true;\n\tmaterial.diffuseVertexColor = true;\n\tmaterial.specularTint = true;\n\tmaterial.specularVertexColor = true;\n\tif (gltfMaterial.hasOwnProperty('name')) {\n\t\tmaterial.name = gltfMaterial.name;\n\t}\n\tlet color, texture;\n\tif (gltfMaterial.hasOwnProperty('pbrMetallicRoughness')) {\n\t\tconst pbrData = gltfMaterial.pbrMetallicRoughness;\n\t\tif (pbrData.hasOwnProperty('baseColorFactor')) {\n\t\t\tcolor = pbrData.baseColorFactor;\n\t\t\tmaterial.diffuse.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));\n\t\t\tmaterial.opacity = color[3];\n\t\t} else {\n\t\t\tmaterial.diffuse.set(1, 1, 1);\n\t\t\tmaterial.opacity = 1;\n\t\t}\n\t\tif (pbrData.hasOwnProperty('baseColorTexture')) {\n\t\t\tconst baseColorTexture = pbrData.baseColorTexture;\n\t\t\ttexture = textures[baseColorTexture.index];\n\t\t\tmaterial.diffuseMap = texture;\n\t\t\tmaterial.diffuseMapChannel = 'rgb';\n\t\t\tmaterial.opacityMap = texture;\n\t\t\tmaterial.opacityMapChannel = 'a';\n\t\t\textractTextureTransform(baseColorTexture, material, ['diffuse', 'opacity']);\n\t\t}\n\t\tmaterial.useMetalness = true;\n\t\tmaterial.specular.set(1, 1, 1);\n\t\tif (pbrData.hasOwnProperty('metallicFactor')) {\n\t\t\tmaterial.metalness = pbrData.metallicFactor;\n\t\t} else {\n\t\t\tmaterial.metalness = 1;\n\t\t}\n\t\tif (pbrData.hasOwnProperty('roughnessFactor')) {\n\t\t\tmaterial.gloss = pbrData.roughnessFactor;\n\t\t} else {\n\t\t\tmaterial.gloss = 1;\n\t\t}\n\t\tmaterial.glossInvert = true;\n\t\tif (pbrData.hasOwnProperty('metallicRoughnessTexture')) {\n\t\t\tconst metallicRoughnessTexture = pbrData.metallicRoughnessTexture;\n\t\t\tmaterial.metalnessMap = material.glossMap = textures[metallicRoughnessTexture.index];\n\t\t\tmaterial.metalnessMapChannel = 'b';\n\t\t\tmaterial.glossMapChannel = 'g';\n\t\t\textractTextureTransform(metallicRoughnessTexture, material, ['gloss', 'metalness']);\n\t\t}\n\t}\n\tif (gltfMaterial.hasOwnProperty('normalTexture')) {\n\t\tconst normalTexture = gltfMaterial.normalTexture;\n\t\tmaterial.normalMap = textures[normalTexture.index];\n\t\textractTextureTransform(normalTexture, material, ['normal']);\n\t\tif (normalTexture.hasOwnProperty('scale')) {\n\t\t\tmaterial.bumpiness = normalTexture.scale;\n\t\t}\n\t}\n\tif (gltfMaterial.hasOwnProperty('occlusionTexture')) {\n\t\tconst occlusionTexture = gltfMaterial.occlusionTexture;\n\t\tmaterial.aoMap = textures[occlusionTexture.index];\n\t\tmaterial.aoMapChannel = 'r';\n\t\textractTextureTransform(occlusionTexture, material, ['ao']);\n\t}\n\tif (gltfMaterial.hasOwnProperty('emissiveFactor')) {\n\t\tcolor = gltfMaterial.emissiveFactor;\n\t\tmaterial.emissive.set(Math.pow(color[0], 1 / 2.2), Math.pow(color[1], 1 / 2.2), Math.pow(color[2], 1 / 2.2));\n\t\tmaterial.emissiveTint = true;\n\t} else {\n\t\tmaterial.emissive.set(0, 0, 0);\n\t\tmaterial.emissiveTint = false;\n\t}\n\tif (gltfMaterial.hasOwnProperty('emissiveTexture')) {\n\t\tconst emissiveTexture = gltfMaterial.emissiveTexture;\n\t\tmaterial.emissiveMap = textures[emissiveTexture.index];\n\t\textractTextureTransform(emissiveTexture, material, ['emissive']);\n\t}\n\tif (gltfMaterial.hasOwnProperty('alphaMode')) {\n\t\tswitch (gltfMaterial.alphaMode) {\n\t\t\tcase 'MASK':\n\t\t\t\tmaterial.blendType = BLEND_NONE;\n\t\t\t\tif (gltfMaterial.hasOwnProperty('alphaCutoff')) {\n\t\t\t\t\tmaterial.alphaTest = gltfMaterial.alphaCutoff;\n\t\t\t\t} else {\n\t\t\t\t\tmaterial.alphaTest = 0.5;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'BLEND':\n\t\t\t\tmaterial.blendType = BLEND_NORMAL;\n\t\t\t\tmaterial.depthWrite = false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\tcase 'OPAQUE':\n\t\t\t\tmaterial.blendType = BLEND_NONE;\n\t\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tmaterial.blendType = BLEND_NONE;\n\t}\n\tif (gltfMaterial.hasOwnProperty('doubleSided')) {\n\t\tmaterial.twoSidedLighting = gltfMaterial.doubleSided;\n\t\tmaterial.cull = gltfMaterial.doubleSided ? CULLFACE_NONE : CULLFACE_BACK;\n\t} else {\n\t\tmaterial.twoSidedLighting = false;\n\t\tmaterial.cull = CULLFACE_BACK;\n\t}\n\tconst extensions = {\n\t\t'KHR_materials_clearcoat': extensionClearCoat,\n\t\t'KHR_materials_emissive_strength': extensionEmissiveStrength,\n\t\t'KHR_materials_ior': extensionIor,\n\t\t'KHR_materials_dispersion': extensionDispersion,\n\t\t'KHR_materials_iridescence': extensionIridescence,\n\t\t'KHR_materials_pbrSpecularGlossiness': extensionPbrSpecGlossiness,\n\t\t'KHR_materials_sheen': extensionSheen,\n\t\t'KHR_materials_specular': extensionSpecular,\n\t\t'KHR_materials_transmission': extensionTransmission,\n\t\t'KHR_materials_unlit': extensionUnlit,\n\t\t'KHR_materials_volume': extensionVolume\n\t};\n\tif (gltfMaterial.hasOwnProperty('extensions')) {\n\t\tfor (const key in gltfMaterial.extensions) {\n\t\t\tconst extensionFunc = extensions[key];\n\t\t\tif (extensionFunc !== undefined) {\n\t\t\t\textensionFunc(gltfMaterial.extensions[key], material, textures);\n\t\t\t}\n\t\t}\n\t}\n\tmaterial.update();\n\treturn material;\n};\nconst createAnimation = (gltfAnimation, animationIndex, gltfAccessors, bufferViews, nodes, meshes, gltfNodes) => {\n\tconst createAnimData = gltfAccessor => {\n\t\treturn new AnimData(getNumComponents(gltfAccessor.type), getAccessorDataFloat32(gltfAccessor, bufferViews));\n\t};\n\tconst interpMap = {\n\t\t'STEP': INTERPOLATION_STEP,\n\t\t'LINEAR': INTERPOLATION_LINEAR,\n\t\t'CUBICSPLINE': INTERPOLATION_CUBIC\n\t};\n\tconst inputMap = {};\n\tconst outputMap = {};\n\tconst curveMap = {};\n\tlet outputCounter = 1;\n\tlet i;\n\tfor (i = 0; i < gltfAnimation.samplers.length; ++i) {\n\t\tconst sampler = gltfAnimation.samplers[i];\n\t\tif (!inputMap.hasOwnProperty(sampler.input)) {\n\t\t\tinputMap[sampler.input] = createAnimData(gltfAccessors[sampler.input]);\n\t\t}\n\t\tif (!outputMap.hasOwnProperty(sampler.output)) {\n\t\t\toutputMap[sampler.output] = createAnimData(gltfAccessors[sampler.output]);\n\t\t}\n\t\tconst interpolation = sampler.hasOwnProperty('interpolation') && interpMap.hasOwnProperty(sampler.interpolation) ? interpMap[sampler.interpolation] : INTERPOLATION_LINEAR;\n\t\tconst curve = {\n\t\t\tpaths: [],\n\t\t\tinput: sampler.input,\n\t\t\toutput: sampler.output,\n\t\t\tinterpolation: interpolation\n\t\t};\n\t\tcurveMap[i] = curve;\n\t}\n\tconst quatArrays = [];\n\tconst transformSchema = {\n\t\t'translation': 'localPosition',\n\t\t'rotation': 'localRotation',\n\t\t'scale': 'localScale'\n\t};\n\tconst constructNodePath = node => {\n\t\tconst path = [];\n\t\twhile (node) {\n\t\t\tpath.unshift(node.name);\n\t\t\tnode = node.parent;\n\t\t}\n\t\treturn path;\n\t};\n\tconst createMorphTargetCurves = (curve, gltfNode, entityPath) => {\n\t\tconst out = outputMap[curve.output];\n\t\tif (!out) {\n\t\t\treturn;\n\t\t}\n\t\tlet targetNames;\n\t\tif (meshes && meshes[gltfNode.mesh]) {\n\t\t\tconst mesh = meshes[gltfNode.mesh];\n\t\t\tif (mesh.hasOwnProperty('extras') && mesh.extras.hasOwnProperty('targetNames')) {\n\t\t\t\ttargetNames = mesh.extras.targetNames;\n\t\t\t}\n\t\t}\n\t\tconst outData = out.data;\n\t\tconst morphTargetCount = outData.length / inputMap[curve.input].data.length;\n\t\tconst keyframeCount = outData.length / morphTargetCount;\n\t\tconst singleBufferSize = keyframeCount * 4;\n\t\tconst buffer = new ArrayBuffer(singleBufferSize * morphTargetCount);\n\t\tfor (let j = 0; j < morphTargetCount; j++) {\n\t\t\tvar _targetNames;\n\t\t\tconst morphTargetOutput = new Float32Array(buffer, singleBufferSize * j, keyframeCount);\n\t\t\tfor (let k = 0; k < keyframeCount; k++) {\n\t\t\t\tmorphTargetOutput[k] = outData[k * morphTargetCount + j];\n\t\t\t}\n\t\t\tconst output = new AnimData(1, morphTargetOutput);\n\t\t\tconst weightName = (_targetNames = targetNames) != null && _targetNames[j] ? `name.${targetNames[j]}` : j;\n\t\t\toutputMap[-outputCounter] = output;\n\t\t\tconst morphCurve = {\n\t\t\t\tpaths: [{\n\t\t\t\t\tentityPath: entityPath,\n\t\t\t\t\tcomponent: 'graph',\n\t\t\t\t\tpropertyPath: [`weight.${weightName}`]\n\t\t\t\t}],\n\t\t\t\tinput: curve.input,\n\t\t\t\toutput: -outputCounter,\n\t\t\t\tinterpolation: curve.interpolation\n\t\t\t};\n\t\t\toutputCounter++;\n\t\t\tcurveMap[`morphCurve-${i}-${j}`] = morphCurve;\n\t\t}\n\t};\n\tfor (i = 0; i < gltfAnimation.channels.length; ++i) {\n\t\tconst channel = gltfAnimation.channels[i];\n\t\tconst target = channel.target;\n\t\tconst curve = curveMap[channel.sampler];\n\t\tconst node = nodes[target.node];\n\t\tconst gltfNode = gltfNodes[target.node];\n\t\tconst entityPath = constructNodePath(node);\n\t\tif (target.path.startsWith('weights')) {\n\t\t\tcreateMorphTargetCurves(curve, gltfNode, entityPath);\n\t\t\tcurveMap[channel.sampler].morphCurve = true;\n\t\t} else {\n\t\t\tcurve.paths.push({\n\t\t\t\tentityPath: entityPath,\n\t\t\t\tcomponent: 'graph',\n\t\t\t\tpropertyPath: [transformSchema[target.path]]\n\t\t\t});\n\t\t}\n\t}\n\tconst inputs = [];\n\tconst outputs = [];\n\tconst curves = [];\n\tfor (const inputKey in inputMap) {\n\t\tinputs.push(inputMap[inputKey]);\n\t\tinputMap[inputKey] = inputs.length - 1;\n\t}\n\tfor (const outputKey in outputMap) {\n\t\toutputs.push(outputMap[outputKey]);\n\t\toutputMap[outputKey] = outputs.length - 1;\n\t}\n\tfor (const curveKey in curveMap) {\n\t\tconst curveData = curveMap[curveKey];\n\t\tif (curveData.morphCurve) {\n\t\t\tcontinue;\n\t\t}\n\t\tcurves.push(new AnimCurve(curveData.paths, inputMap[curveData.input], outputMap[curveData.output], curveData.interpolation));\n\t\tif (curveData.paths.length > 0 && curveData.paths[0].propertyPath[0] === 'localRotation' && curveData.interpolation !== INTERPOLATION_CUBIC) {\n\t\t\tquatArrays.push(curves[curves.length - 1].output);\n\t\t}\n\t}\n\tquatArrays.sort();\n\tlet prevIndex = null;\n\tlet data;\n\tfor (i = 0; i < quatArrays.length; ++i) {\n\t\tconst index = quatArrays[i];\n\t\tif (i === 0 || index !== prevIndex) {\n\t\t\tdata = outputs[index];\n\t\t\tif (data.components === 4) {\n\t\t\t\tconst d = data.data;\n\t\t\t\tconst len = d.length - 4;\n\t\t\t\tfor (let j = 0; j < len; j += 4) {\n\t\t\t\t\tconst dp = d[j + 0] * d[j + 4] + d[j + 1] * d[j + 5] + d[j + 2] * d[j + 6] + d[j + 3] * d[j + 7];\n\t\t\t\t\tif (dp < 0) {\n\t\t\t\t\t\td[j + 4] *= -1;\n\t\t\t\t\t\td[j + 5] *= -1;\n\t\t\t\t\t\td[j + 6] *= -1;\n\t\t\t\t\t\td[j + 7] *= -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tprevIndex = index;\n\t\t}\n\t}\n\tlet duration = 0;\n\tfor (i = 0; i < inputs.length; i++) {\n\t\tdata = inputs[i]._data;\n\t\tduration = Math.max(duration, data.length === 0 ? 0 : data[data.length - 1]);\n\t}\n\treturn new AnimTrack(gltfAnimation.hasOwnProperty('name') ? gltfAnimation.name : `animation_${animationIndex}`, duration, inputs, outputs, curves);\n};\nconst tempMat = new Mat4();\nconst tempVec = new Vec3();\nconst createNode = (gltfNode, nodeIndex) => {\n\tconst entity = new GraphNode();\n\tif (gltfNode.hasOwnProperty('name') && gltfNode.name.length > 0) {\n\t\tentity.name = gltfNode.name;\n\t} else {\n\t\tentity.name = `node_${nodeIndex}`;\n\t}\n\tif (gltfNode.hasOwnProperty('matrix')) {\n\t\ttempMat.data.set(gltfNode.matrix);\n\t\ttempMat.getTranslation(tempVec);\n\t\tentity.setLocalPosition(tempVec);\n\t\ttempMat.getEulerAngles(tempVec);\n\t\tentity.setLocalEulerAngles(tempVec);\n\t\ttempMat.getScale(tempVec);\n\t\tentity.setLocalScale(tempVec);\n\t}\n\tif (gltfNode.hasOwnProperty('rotation')) {\n\t\tconst r = gltfNode.rotation;\n\t\tentity.setLocalRotation(r[0], r[1], r[2], r[3]);\n\t}\n\tif (gltfNode.hasOwnProperty('translation')) {\n\t\tconst t = gltfNode.translation;\n\t\tentity.setLocalPosition(t[0], t[1], t[2]);\n\t}\n\tif (gltfNode.hasOwnProperty('scale')) {\n\t\tconst s = gltfNode.scale;\n\t\tentity.setLocalScale(s[0], s[1], s[2]);\n\t}\n\treturn entity;\n};\nconst createCamera = (gltfCamera, node) => {\n\tconst projection = gltfCamera.type === 'orthographic' ? PROJECTION_ORTHOGRAPHIC : PROJECTION_PERSPECTIVE;\n\tconst gltfProperties = projection === PROJECTION_ORTHOGRAPHIC ? gltfCamera.orthographic : gltfCamera.perspective;\n\tconst componentData = {\n\t\tenabled: false,\n\t\tprojection: projection,\n\t\tnearClip: gltfProperties.znear,\n\t\taspectRatioMode: ASPECT_AUTO\n\t};\n\tif (gltfProperties.zfar) {\n\t\tcomponentData.farClip = gltfProperties.zfar;\n\t}\n\tif (projection === PROJECTION_ORTHOGRAPHIC) {\n\t\tcomponentData.orthoHeight = 0.5 * gltfProperties.ymag;\n\t\tif (gltfProperties.ymag) {\n\t\t\tcomponentData.aspectRatioMode = ASPECT_MANUAL;\n\t\t\tcomponentData.aspectRatio = gltfProperties.xmag / gltfProperties.ymag;\n\t\t}\n\t} else {\n\t\tcomponentData.fov = gltfProperties.yfov * math.RAD_TO_DEG;\n\t\tif (gltfProperties.aspectRatio) {\n\t\t\tcomponentData.aspectRatioMode = ASPECT_MANUAL;\n\t\t\tcomponentData.aspectRatio = gltfProperties.aspectRatio;\n\t\t}\n\t}\n\tconst cameraEntity = new Entity(gltfCamera.name);\n\tcameraEntity.addComponent('camera', componentData);\n\treturn cameraEntity;\n};\nconst createLight = (gltfLight, node) => {\n\tconst lightProps = {\n\t\tenabled: false,\n\t\ttype: gltfLight.type === 'point' ? 'omni' : gltfLight.type,\n\t\tcolor: gltfLight.hasOwnProperty('color') ? new Color(gltfLight.color) : Color.WHITE,\n\t\trange: gltfLight.hasOwnProperty('range') ? gltfLight.range : 9999,\n\t\tfalloffMode: LIGHTFALLOFF_INVERSESQUARED,\n\t\tintensity: gltfLight.hasOwnProperty('intensity') ? math.clamp(gltfLight.intensity, 0, 2) : 1\n\t};\n\tif (gltfLight.hasOwnProperty('spot')) {\n\t\tlightProps.innerConeAngle = gltfLight.spot.hasOwnProperty('innerConeAngle') ? gltfLight.spot.innerConeAngle * math.RAD_TO_DEG : 0;\n\t\tlightProps.outerConeAngle = gltfLight.spot.hasOwnProperty('outerConeAngle') ? gltfLight.spot.outerConeAngle * math.RAD_TO_DEG : Math.PI / 4;\n\t}\n\tif (gltfLight.hasOwnProperty('intensity')) {\n\t\tlightProps.luminance = gltfLight.intensity * Light.getLightUnitConversion(lightTypes[lightProps.type], lightProps.outerConeAngle, lightProps.innerConeAngle);\n\t}\n\tconst lightEntity = new Entity(node.name);\n\tlightEntity.rotateLocal(90, 0, 0);\n\tlightEntity.addComponent('light', lightProps);\n\treturn lightEntity;\n};\nconst createSkins = (device, gltf, nodes, bufferViews) => {\n\tif (!gltf.hasOwnProperty('skins') || gltf.skins.length === 0) {\n\t\treturn [];\n\t}\n\tconst glbSkins = new Map();\n\treturn gltf.skins.map(gltfSkin => {\n\t\treturn createSkin(device, gltfSkin, gltf.accessors, bufferViews, nodes, glbSkins);\n\t});\n};\nconst createMeshes = (device, gltf, bufferViews, flipV, options) => {\n\tvar _gltf$meshes, _gltf$accessors, _gltf$bufferViews;\n\tconst vertexBufferDict = {};\n\tconst meshVariants = {};\n\tconst meshDefaultMaterials = {};\n\tconst promises = [];\n\tconst valid = !options.skipMeshes && (gltf == null || (_gltf$meshes = gltf.meshes) == null ? void 0 : _gltf$meshes.length) && (gltf == null || (_gltf$accessors = gltf.accessors) == null ? void 0 : _gltf$accessors.length) && (gltf == null || (_gltf$bufferViews = gltf.bufferViews) == null ? void 0 : _gltf$bufferViews.length);\n\tconst meshes = valid ? gltf.meshes.map(gltfMesh => {\n\t\treturn createMesh(device, gltfMesh, gltf.accessors, bufferViews, flipV, vertexBufferDict, meshVariants, meshDefaultMaterials, options, promises);\n\t}) : [];\n\treturn {\n\t\tmeshes,\n\t\tmeshVariants,\n\t\tmeshDefaultMaterials,\n\t\tpromises\n\t};\n};\nconst createMaterials = (gltf, textures, options, flipV) => {\n\tvar _options$material, _options$material$pro, _options$material2, _options$material3;\n\tif (!gltf.hasOwnProperty('materials') || gltf.materials.length === 0) {\n\t\treturn [];\n\t}\n\tconst preprocess = options == null || (_options$material = options.material) == null ? void 0 : _options$material.preprocess;\n\tconst process = (_options$material$pro = options == null || (_options$material2 = options.material) == null ? void 0 : _options$material2.process) != null ? _options$material$pro : createMaterial;\n\tconst postprocess = options == null || (_options$material3 = options.material) == null ? void 0 : _options$material3.postprocess;\n\treturn gltf.materials.map(gltfMaterial => {\n\t\tif (preprocess) {\n\t\t\tpreprocess(gltfMaterial);\n\t\t}\n\t\tconst material = process(gltfMaterial, textures, flipV);\n\t\tif (postprocess) {\n\t\t\tpostprocess(gltfMaterial, material);\n\t\t}\n\t\treturn material;\n\t});\n};\nconst createVariants = gltf => {\n\tif (!gltf.hasOwnProperty('extensions') || !gltf.extensions.hasOwnProperty('KHR_materials_variants')) {\n\t\treturn null;\n\t}\n\tconst data = gltf.extensions.KHR_materials_variants.variants;\n\tconst variants = {};\n\tfor (let i = 0; i < data.length; i++) {\n\t\tvariants[data[i].name] = i;\n\t}\n\treturn variants;\n};\nconst createAnimations = (gltf, nodes, bufferViews, options) => {\n\tvar _options$animation, _options$animation2;\n\tif (!gltf.hasOwnProperty('animations') || gltf.animations.length === 0) {\n\t\treturn [];\n\t}\n\tconst preprocess = options == null || (_options$animation = options.animation) == null ? void 0 : _options$animation.preprocess;\n\tconst postprocess = options == null || (_options$animation2 = options.animation) == null ? void 0 : _options$animation2.postprocess;\n\treturn gltf.animations.map((gltfAnimation, index) => {\n\t\tif (preprocess) {\n\t\t\tpreprocess(gltfAnimation);\n\t\t}\n\t\tconst animation = createAnimation(gltfAnimation, index, gltf.accessors, bufferViews, nodes, gltf.meshes, gltf.nodes);\n\t\tif (postprocess) {\n\t\t\tpostprocess(gltfAnimation, animation);\n\t\t}\n\t\treturn animation;\n\t});\n};\nconst createNodes = (gltf, options) => {\n\tvar _options$node, _options$node$process, _options$node2, _options$node3;\n\tif (!gltf.hasOwnProperty('nodes') || gltf.nodes.length === 0) {\n\t\treturn [];\n\t}\n\tconst preprocess = options == null || (_options$node = options.node) == null ? void 0 : _options$node.preprocess;\n\tconst process = (_options$node$process = options == null || (_options$node2 = options.node) == null ? void 0 : _options$node2.process) != null ? _options$node$process : createNode;\n\tconst postprocess = options == null || (_options$node3 = options.node) == null ? void 0 : _options$node3.postprocess;\n\tconst nodes = gltf.nodes.map((gltfNode, index) => {\n\t\tif (preprocess) {\n\t\t\tpreprocess(gltfNode);\n\t\t}\n\t\tconst node = process(gltfNode, index);\n\t\tif (postprocess) {\n\t\t\tpostprocess(gltfNode, node);\n\t\t}\n\t\treturn node;\n\t});\n\tfor (let i = 0; i < gltf.nodes.length; ++i) {\n\t\tconst gltfNode = gltf.nodes[i];\n\t\tif (gltfNode.hasOwnProperty('children')) {\n\t\t\tconst parent = nodes[i];\n\t\t\tconst uniqueNames = {};\n\t\t\tfor (let j = 0; j < gltfNode.children.length; ++j) {\n\t\t\t\tconst child = nodes[gltfNode.children[j]];\n\t\t\t\tif (!child.parent) {\n\t\t\t\t\tif (uniqueNames.hasOwnProperty(child.name)) {\n\t\t\t\t\t\tchild.name += uniqueNames[child.name]++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tuniqueNames[child.name] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tparent.addChild(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nodes;\n};\nconst createScenes = (gltf, nodes) => {\n\tvar _gltf$scenes$0$nodes;\n\tconst scenes = [];\n\tconst count = gltf.scenes.length;\n\tif (count === 1 && ((_gltf$scenes$0$nodes = gltf.scenes[0].nodes) == null ? void 0 : _gltf$scenes$0$nodes.length) === 1) {\n\t\tconst nodeIndex = gltf.scenes[0].nodes[0];\n\t\tscenes.push(nodes[nodeIndex]);\n\t} else {\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst scene = gltf.scenes[i];\n\t\t\tif (scene.nodes) {\n\t\t\t\tconst sceneRoot = new GraphNode(scene.name);\n\t\t\t\tfor (let n = 0; n < scene.nodes.length; n++) {\n\t\t\t\t\tconst childNode = nodes[scene.nodes[n]];\n\t\t\t\t\tsceneRoot.addChild(childNode);\n\t\t\t\t}\n\t\t\t\tscenes.push(sceneRoot);\n\t\t\t}\n\t\t}\n\t}\n\treturn scenes;\n};\nconst createCameras = (gltf, nodes, options) => {\n\tlet cameras = null;\n\tif (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('cameras') && gltf.cameras.length > 0) {\n\t\tvar _options$camera, _options$camera$proce, _options$camera2, _options$camera3;\n\t\tconst preprocess = options == null || (_options$camera = options.camera) == null ? void 0 : _options$camera.preprocess;\n\t\tconst process = (_options$camera$proce = options == null || (_options$camera2 = options.camera) == null ? void 0 : _options$camera2.process) != null ? _options$camera$proce : createCamera;\n\t\tconst postprocess = options == null || (_options$camera3 = options.camera) == null ? void 0 : _options$camera3.postprocess;\n\t\tgltf.nodes.forEach((gltfNode, nodeIndex) => {\n\t\t\tif (gltfNode.hasOwnProperty('camera')) {\n\t\t\t\tconst gltfCamera = gltf.cameras[gltfNode.camera];\n\t\t\t\tif (gltfCamera) {\n\t\t\t\t\tif (preprocess) {\n\t\t\t\t\t\tpreprocess(gltfCamera);\n\t\t\t\t\t}\n\t\t\t\t\tconst camera = process(gltfCamera, nodes[nodeIndex]);\n\t\t\t\t\tif (postprocess) {\n\t\t\t\t\t\tpostprocess(gltfCamera, camera);\n\t\t\t\t\t}\n\t\t\t\t\tif (camera) {\n\t\t\t\t\t\tif (!cameras) cameras = new Map();\n\t\t\t\t\t\tcameras.set(gltfNode, camera);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\treturn cameras;\n};\nconst createLights = (gltf, nodes, options) => {\n\tlet lights = null;\n\tif (gltf.hasOwnProperty('nodes') && gltf.hasOwnProperty('extensions') && gltf.extensions.hasOwnProperty('KHR_lights_punctual') && gltf.extensions.KHR_lights_punctual.hasOwnProperty('lights')) {\n\t\tconst gltfLights = gltf.extensions.KHR_lights_punctual.lights;\n\t\tif (gltfLights.length) {\n\t\t\tvar _options$light, _options$light$proces, _options$light2, _options$light3;\n\t\t\tconst preprocess = options == null || (_options$light = options.light) == null ? void 0 : _options$light.preprocess;\n\t\t\tconst process = (_options$light$proces = options == null || (_options$light2 = options.light) == null ? void 0 : _options$light2.process) != null ? _options$light$proces : createLight;\n\t\t\tconst postprocess = options == null || (_options$light3 = options.light) == null ? void 0 : _options$light3.postprocess;\n\t\t\tgltf.nodes.forEach((gltfNode, nodeIndex) => {\n\t\t\t\tif (gltfNode.hasOwnProperty('extensions') && gltfNode.extensions.hasOwnProperty('KHR_lights_punctual') && gltfNode.extensions.KHR_lights_punctual.hasOwnProperty('light')) {\n\t\t\t\t\tconst lightIndex = gltfNode.extensions.KHR_lights_punctual.light;\n\t\t\t\t\tconst gltfLight = gltfLights[lightIndex];\n\t\t\t\t\tif (gltfLight) {\n\t\t\t\t\t\tif (preprocess) {\n\t\t\t\t\t\t\tpreprocess(gltfLight);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst light = process(gltfLight, nodes[nodeIndex]);\n\t\t\t\t\t\tif (postprocess) {\n\t\t\t\t\t\t\tpostprocess(gltfLight, light);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (light) {\n\t\t\t\t\t\t\tif (!lights) lights = new Map();\n\t\t\t\t\t\t\tlights.set(gltfNode, light);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\treturn lights;\n};\nconst linkSkins = (gltf, renders, skins) => {\n\tgltf.nodes.forEach(gltfNode => {\n\t\tif (gltfNode.hasOwnProperty('mesh') && gltfNode.hasOwnProperty('skin')) {\n\t\t\tconst meshGroup = renders[gltfNode.mesh].meshes;\n\t\t\tmeshGroup.forEach(mesh => {\n\t\t\t\tmesh.skin = skins[gltfNode.skin];\n\t\t\t});\n\t\t}\n\t});\n};\nconst createResources = async (device, gltf, bufferViews, textures, options) => {\n\tvar _options$global, _options$global2;\n\tconst preprocess = options == null || (_options$global = options.global) == null ? void 0 : _options$global.preprocess;\n\tconst postprocess = options == null || (_options$global2 = options.global) == null ? void 0 : _options$global2.postprocess;\n\tif (preprocess) {\n\t\tpreprocess(gltf);\n\t}\n\tconst flipV = gltf.asset && gltf.asset.generator === 'PlayCanvas';\n\tconst nodes = createNodes(gltf, options);\n\tconst scenes = createScenes(gltf, nodes);\n\tconst lights = createLights(gltf, nodes, options);\n\tconst cameras = createCameras(gltf, nodes, options);\n\tconst variants = createVariants(gltf);\n\tconst bufferViewData = await Promise.all(bufferViews);\n\tconst {\n\t\tmeshes,\n\t\tmeshVariants,\n\t\tmeshDefaultMaterials,\n\t\tpromises\n\t} = createMeshes(device, gltf, bufferViewData, flipV, options);\n\tconst animations = createAnimations(gltf, nodes, bufferViewData, options);\n\tconst textureAssets = await Promise.all(textures);\n\tconst textureInstances = textureAssets.map(t => t.resource);\n\tconst materials = createMaterials(gltf, textureInstances, options, flipV);\n\tconst skins = createSkins(device, gltf, nodes, bufferViewData);\n\tconst renders = [];\n\tfor (let i = 0; i < meshes.length; i++) {\n\t\trenders[i] = new Render();\n\t\trenders[i].meshes = meshes[i];\n\t}\n\tlinkSkins(gltf, renders, skins);\n\tconst result = new GlbResources();\n\tresult.gltf = gltf;\n\tresult.nodes = nodes;\n\tresult.scenes = scenes;\n\tresult.animations = animations;\n\tresult.textures = textureAssets;\n\tresult.materials = materials;\n\tresult.variants = variants;\n\tresult.meshVariants = meshVariants;\n\tresult.meshDefaultMaterials = meshDefaultMaterials;\n\tresult.renders = renders;\n\tresult.skins = skins;\n\tresult.lights = lights;\n\tresult.cameras = cameras;\n\tif (postprocess) {\n\t\tpostprocess(gltf, result);\n\t}\n\tawait Promise.all(promises);\n\treturn result;\n};\nconst applySampler = (texture, gltfSampler) => {\n\tconst getFilter = (filter, defaultValue) => {\n\t\tswitch (filter) {\n\t\t\tcase 9728:\n\t\t\t\treturn FILTER_NEAREST;\n\t\t\tcase 9729:\n\t\t\t\treturn FILTER_LINEAR;\n\t\t\tcase 9984:\n\t\t\t\treturn FILTER_NEAREST_MIPMAP_NEAREST;\n\t\t\tcase 9985:\n\t\t\t\treturn FILTER_LINEAR_MIPMAP_NEAREST;\n\t\t\tcase 9986:\n\t\t\t\treturn FILTER_NEAREST_MIPMAP_LINEAR;\n\t\t\tcase 9987:\n\t\t\t\treturn FILTER_LINEAR_MIPMAP_LINEAR;\n\t\t\tdefault:\n\t\t\t\treturn defaultValue;\n\t\t}\n\t};\n\tconst getWrap = (wrap, defaultValue) => {\n\t\tswitch (wrap) {\n\t\t\tcase 33071:\n\t\t\t\treturn ADDRESS_CLAMP_TO_EDGE;\n\t\t\tcase 33648:\n\t\t\t\treturn ADDRESS_MIRRORED_REPEAT;\n\t\t\tcase 10497:\n\t\t\t\treturn ADDRESS_REPEAT;\n\t\t\tdefault:\n\t\t\t\treturn defaultValue;\n\t\t}\n\t};\n\tif (texture) {\n\t\tvar _gltfSampler;\n\t\tgltfSampler = (_gltfSampler = gltfSampler) != null ? _gltfSampler : {};\n\t\ttexture.minFilter = getFilter(gltfSampler.minFilter, FILTER_LINEAR_MIPMAP_LINEAR);\n\t\ttexture.magFilter = getFilter(gltfSampler.magFilter, FILTER_LINEAR);\n\t\ttexture.addressU = getWrap(gltfSampler.wrapS, ADDRESS_REPEAT);\n\t\ttexture.addressV = getWrap(gltfSampler.wrapT, ADDRESS_REPEAT);\n\t}\n};\nlet gltfTextureUniqueId = 0;\nconst createImages = (gltf, bufferViews, urlBase, registry, options) => {\n\tvar _options$image, _options$image2, _options$image3;\n\tif (!gltf.images || gltf.images.length === 0) {\n\t\treturn [];\n\t}\n\tconst preprocess = options == null || (_options$image = options.image) == null ? void 0 : _options$image.preprocess;\n\tconst processAsync = options == null || (_options$image2 = options.image) == null ? void 0 : _options$image2.processAsync;\n\tconst postprocess = options == null || (_options$image3 = options.image) == null ? void 0 : _options$image3.postprocess;\n\tconst mimeTypeFileExtensions = {\n\t\t'image/png': 'png',\n\t\t'image/jpeg': 'jpg',\n\t\t'image/basis': 'basis',\n\t\t'image/ktx': 'ktx',\n\t\t'image/ktx2': 'ktx2',\n\t\t'image/vnd-ms.dds': 'dds'\n\t};\n\tconst loadTexture = (gltfImage, url, bufferView, mimeType, options) => {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst continuation = bufferViewData => {\n\t\t\t\tconst name = `${gltfImage.name || 'gltf-texture'}-${gltfTextureUniqueId++}`;\n\t\t\t\tconst file = {\n\t\t\t\t\turl: url || name\n\t\t\t\t};\n\t\t\t\tif (bufferViewData) {\n\t\t\t\t\tfile.contents = bufferViewData.slice(0).buffer;\n\t\t\t\t}\n\t\t\t\tif (mimeType) {\n\t\t\t\t\tconst extension = mimeTypeFileExtensions[mimeType];\n\t\t\t\t\tif (extension) {\n\t\t\t\t\t\tfile.filename = `${file.url}.${extension}`;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst asset = new Asset(name, 'texture', file, null, options);\n\t\t\t\tasset.on('load', asset => resolve(asset));\n\t\t\t\tasset.on('error', err => reject(err));\n\t\t\t\tregistry.add(asset);\n\t\t\t\tregistry.load(asset);\n\t\t\t};\n\t\t\tif (bufferView) {\n\t\t\t\tbufferView.then(bufferViewData => continuation(bufferViewData));\n\t\t\t} else {\n\t\t\t\tcontinuation(null);\n\t\t\t}\n\t\t});\n\t};\n\treturn gltf.images.map((gltfImage, i) => {\n\t\tif (preprocess) {\n\t\t\tpreprocess(gltfImage);\n\t\t}\n\t\tlet promise;\n\t\tif (processAsync) {\n\t\t\tpromise = new Promise((resolve, reject) => {\n\t\t\t\tprocessAsync(gltfImage, (err, textureAsset) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(textureAsset);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\tpromise = new Promise(resolve => {\n\t\t\t\tresolve(null);\n\t\t\t});\n\t\t}\n\t\tpromise = promise.then(textureAsset => {\n\t\t\tif (textureAsset) {\n\t\t\t\treturn textureAsset;\n\t\t\t} else if (gltfImage.hasOwnProperty('uri')) {\n\t\t\t\tif (isDataURI(gltfImage.uri)) {\n\t\t\t\t\treturn loadTexture(gltfImage, gltfImage.uri, null, getDataURIMimeType(gltfImage.uri), null);\n\t\t\t\t}\n\t\t\t\treturn loadTexture(gltfImage, ABSOLUTE_URL.test(gltfImage.uri) ? gltfImage.uri : path.join(urlBase, gltfImage.uri), null, null, {\n\t\t\t\t\tcrossOrigin: 'anonymous'\n\t\t\t\t});\n\t\t\t} else if (gltfImage.hasOwnProperty('bufferView') && gltfImage.hasOwnProperty('mimeType')) {\n\t\t\t\treturn loadTexture(gltfImage, null, bufferViews[gltfImage.bufferView], gltfImage.mimeType, null);\n\t\t\t}\n\t\t\treturn Promise.reject(new Error(`Invalid image found in gltf (neither uri or bufferView found). index=${i}`));\n\t\t});\n\t\tif (postprocess) {\n\t\t\tpromise = promise.then(textureAsset => {\n\t\t\t\tpostprocess(gltfImage, textureAsset);\n\t\t\t\treturn textureAsset;\n\t\t\t});\n\t\t}\n\t\treturn promise;\n\t});\n};\nconst createTextures = (gltf, images, options) => {\n\tvar _gltf$images, _gltf$textures, _options$texture, _options$texture2, _options$texture3;\n\tif (!(gltf != null && (_gltf$images = gltf.images) != null && _gltf$images.length) || !(gltf != null && (_gltf$textures = gltf.textures) != null && _gltf$textures.length)) {\n\t\treturn [];\n\t}\n\tconst preprocess = options == null || (_options$texture = options.texture) == null ? void 0 : _options$texture.preprocess;\n\tconst processAsync = options == null || (_options$texture2 = options.texture) == null ? void 0 : _options$texture2.processAsync;\n\tconst postprocess = options == null || (_options$texture3 = options.texture) == null ? void 0 : _options$texture3.postprocess;\n\tconst seenImages = new Set();\n\treturn gltf.textures.map(gltfTexture => {\n\t\tif (preprocess) {\n\t\t\tpreprocess(gltfTexture);\n\t\t}\n\t\tlet promise;\n\t\tif (processAsync) {\n\t\t\tpromise = new Promise((resolve, reject) => {\n\t\t\t\tprocessAsync(gltfTexture, gltf.images, (err, gltfImageIndex) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(gltfImageIndex);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\tpromise = new Promise(resolve => {\n\t\t\t\tresolve(null);\n\t\t\t});\n\t\t}\n\t\tpromise = promise.then(gltfImageIndex => {\n\t\t\tvar _ref, _ref2, _gltfImageIndex, _gltfTexture$extensio, _gltfTexture$extensio2;\n\t\t\tgltfImageIndex = (_ref = (_ref2 = (_gltfImageIndex = gltfImageIndex) != null ? _gltfImageIndex : gltfTexture == null || (_gltfTexture$extensio = gltfTexture.extensions) == null || (_gltfTexture$extensio = _gltfTexture$extensio.KHR_texture_basisu) == null ? void 0 : _gltfTexture$extensio.source) != null ? _ref2 : gltfTexture == null || (_gltfTexture$extensio2 = gltfTexture.extensions) == null || (_gltfTexture$extensio2 = _gltfTexture$extensio2.EXT_texture_webp) == null ? void 0 : _gltfTexture$extensio2.source) != null ? _ref : gltfTexture.source;\n\t\t\tconst cloneAsset = seenImages.has(gltfImageIndex);\n\t\t\tseenImages.add(gltfImageIndex);\n\t\t\treturn images[gltfImageIndex].then(imageAsset => {\n\t\t\t\tvar _gltf$samplers;\n\t\t\t\tconst asset = cloneAsset ? cloneTextureAsset(imageAsset) : imageAsset;\n\t\t\t\tapplySampler(asset.resource, ((_gltf$samplers = gltf.samplers) != null ? _gltf$samplers : [])[gltfTexture.sampler]);\n\t\t\t\treturn asset;\n\t\t\t});\n\t\t});\n\t\tif (postprocess) {\n\t\t\tpromise = promise.then(textureAsset => {\n\t\t\t\tpostprocess(gltfTexture, textureAsset);\n\t\t\t\treturn textureAsset;\n\t\t\t});\n\t\t}\n\t\treturn promise;\n\t});\n};\nconst loadBuffers = (gltf, binaryChunk, urlBase, options) => {\n\tvar _options$buffer, _options$buffer2, _options$buffer3;\n\tif (!gltf.buffers || gltf.buffers.length === 0) {\n\t\treturn [];\n\t}\n\tconst preprocess = options == null || (_options$buffer = options.buffer) == null ? void 0 : _options$buffer.preprocess;\n\tconst processAsync = options == null || (_options$buffer2 = options.buffer) == null ? void 0 : _options$buffer2.processAsync;\n\tconst postprocess = options == null || (_options$buffer3 = options.buffer) == null ? void 0 : _options$buffer3.postprocess;\n\treturn gltf.buffers.map((gltfBuffer, i) => {\n\t\tif (preprocess) {\n\t\t\tpreprocess(gltfBuffer);\n\t\t}\n\t\tlet promise;\n\t\tif (processAsync) {\n\t\t\tpromise = new Promise((resolve, reject) => {\n\t\t\t\tprocessAsync(gltfBuffer, (err, arrayBuffer) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(arrayBuffer);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\tpromise = new Promise(resolve => {\n\t\t\t\tresolve(null);\n\t\t\t});\n\t\t}\n\t\tpromise = promise.then(arrayBuffer => {\n\t\t\tif (arrayBuffer) {\n\t\t\t\treturn arrayBuffer;\n\t\t\t} else if (gltfBuffer.hasOwnProperty('uri')) {\n\t\t\t\tif (isDataURI(gltfBuffer.uri)) {\n\t\t\t\t\tconst byteString = atob(gltfBuffer.uri.split(',')[1]);\n\t\t\t\t\tconst binaryArray = new Uint8Array(byteString.length);\n\t\t\t\t\tfor (let j = 0; j < byteString.length; j++) {\n\t\t\t\t\t\tbinaryArray[j] = byteString.charCodeAt(j);\n\t\t\t\t\t}\n\t\t\t\t\treturn binaryArray;\n\t\t\t\t}\n\t\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\t\thttp.get(ABSOLUTE_URL.test(gltfBuffer.uri) ? gltfBuffer.uri : path.join(urlBase, gltfBuffer.uri), {\n\t\t\t\t\t\tcache: true,\n\t\t\t\t\t\tresponseType: 'arraybuffer',\n\t\t\t\t\t\tretry: false\n\t\t\t\t\t}, (err, result) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresolve(new Uint8Array(result));\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn binaryChunk;\n\t\t});\n\t\tif (postprocess) {\n\t\t\tpromise = promise.then(buffer => {\n\t\t\t\tpostprocess(gltf.buffers[i], buffer);\n\t\t\t\treturn buffer;\n\t\t\t});\n\t\t}\n\t\treturn promise;\n\t});\n};\nconst parseGltf = (gltfChunk, callback) => {\n\tconst decodeBinaryUtf8 = array => {\n\t\tif (typeof TextDecoder !== 'undefined') {\n\t\t\treturn new TextDecoder().decode(array);\n\t\t}\n\t\tlet str = '';\n\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\tstr += String.fromCharCode(array[i]);\n\t\t}\n\t\treturn decodeURIComponent(escape(str));\n\t};\n\tconst gltf = JSON.parse(decodeBinaryUtf8(gltfChunk));\n\tif (gltf.asset && gltf.asset.version && parseFloat(gltf.asset.version) < 2) {\n\t\tcallback(`Invalid gltf version. Expected version 2.0 or above but found version '${gltf.asset.version}'.`);\n\t\treturn;\n\t}\n\tcallback(null, gltf);\n};\nconst parseGlb = (glbData, callback) => {\n\tconst data = glbData instanceof ArrayBuffer ? new DataView(glbData) : new DataView(glbData.buffer, glbData.byteOffset, glbData.byteLength);\n\tconst magic = data.getUint32(0, true);\n\tconst version = data.getUint32(4, true);\n\tconst length = data.getUint32(8, true);\n\tif (magic !== 0x46546C67) {\n\t\tcallback(`Invalid magic number found in glb header. Expected 0x46546C67, found 0x${magic.toString(16)}`);\n\t\treturn;\n\t}\n\tif (version !== 2) {\n\t\tcallback(`Invalid version number found in glb header. Expected 2, found ${version}`);\n\t\treturn;\n\t}\n\tif (length <= 0 || length > data.byteLength) {\n\t\tcallback(`Invalid length found in glb header. Found ${length}`);\n\t\treturn;\n\t}\n\tconst chunks = [];\n\tlet offset = 12;\n\twhile (offset < length) {\n\t\tconst chunkLength = data.getUint32(offset, true);\n\t\tif (offset + chunkLength + 8 > data.byteLength) {\n\t\t\tcallback(`Invalid chunk length found in glb. Found ${chunkLength}`);\n\t\t}\n\t\tconst chunkType = data.getUint32(offset + 4, true);\n\t\tconst chunkData = new Uint8Array(data.buffer, data.byteOffset + offset + 8, chunkLength);\n\t\tchunks.push({\n\t\t\tlength: chunkLength,\n\t\t\ttype: chunkType,\n\t\t\tdata: chunkData\n\t\t});\n\t\toffset += chunkLength + 8;\n\t}\n\tif (chunks.length !== 1 && chunks.length !== 2) {\n\t\tcallback('Invalid number of chunks found in glb file.');\n\t\treturn;\n\t}\n\tif (chunks[0].type !== 0x4E4F534A) {\n\t\tcallback(`Invalid chunk type found in glb file. Expected 0x4E4F534A, found 0x${chunks[0].type.toString(16)}`);\n\t\treturn;\n\t}\n\tif (chunks.length > 1 && chunks[1].type !== 0x004E4942) {\n\t\tcallback(`Invalid chunk type found in glb file. Expected 0x004E4942, found 0x${chunks[1].type.toString(16)}`);\n\t\treturn;\n\t}\n\tcallback(null, {\n\t\tgltfChunk: chunks[0].data,\n\t\tbinaryChunk: chunks.length === 2 ? chunks[1].data : null\n\t});\n};\nconst parseChunk = (filename, data, callback) => {\n\tconst hasGlbHeader = () => {\n\t\tconst u8 = new Uint8Array(data);\n\t\treturn u8[0] === 103 && u8[1] === 108 && u8[2] === 84 && u8[3] === 70;\n\t};\n\tif (filename && filename.toLowerCase().endsWith('.glb') || hasGlbHeader()) {\n\t\tparseGlb(data, callback);\n\t} else {\n\t\tcallback(null, {\n\t\t\tgltfChunk: data,\n\t\t\tbinaryChunk: null\n\t\t});\n\t}\n};\nconst createBufferViews = (gltf, buffers, options) => {\n\tvar _options$bufferView, _options$bufferView2, _options$bufferView3, _gltf$bufferViews2;\n\tconst result = [];\n\tconst preprocess = options == null || (_options$bufferView = options.bufferView) == null ? void 0 : _options$bufferView.preprocess;\n\tconst processAsync = options == null || (_options$bufferView2 = options.bufferView) == null ? void 0 : _options$bufferView2.processAsync;\n\tconst postprocess = options == null || (_options$bufferView3 = options.bufferView) == null ? void 0 : _options$bufferView3.postprocess;\n\tif (!((_gltf$bufferViews2 = gltf.bufferViews) != null && _gltf$bufferViews2.length)) {\n\t\treturn result;\n\t}\n\tfor (let i = 0; i < gltf.bufferViews.length; ++i) {\n\t\tconst gltfBufferView = gltf.bufferViews[i];\n\t\tif (preprocess) {\n\t\t\tpreprocess(gltfBufferView);\n\t\t}\n\t\tlet promise;\n\t\tif (processAsync) {\n\t\t\tpromise = new Promise((resolve, reject) => {\n\t\t\t\tprocessAsync(gltfBufferView, buffers, (err, result) => {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\treject(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t} else {\n\t\t\tpromise = new Promise(resolve => {\n\t\t\t\tresolve(null);\n\t\t\t});\n\t\t}\n\t\tpromise = promise.then(buffer => {\n\t\t\tif (buffer) {\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t\treturn buffers[gltfBufferView.buffer].then(buffer => {\n\t\t\t\treturn new Uint8Array(buffer.buffer, buffer.byteOffset + (gltfBufferView.byteOffset || 0), gltfBufferView.byteLength);\n\t\t\t});\n\t\t});\n\t\tif (gltfBufferView.hasOwnProperty('byteStride')) {\n\t\t\tpromise = promise.then(typedArray => {\n\t\t\t\ttypedArray.byteStride = gltfBufferView.byteStride;\n\t\t\t\treturn typedArray;\n\t\t\t});\n\t\t}\n\t\tif (postprocess) {\n\t\t\tpromise = promise.then(typedArray => {\n\t\t\t\tpostprocess(gltfBufferView, typedArray);\n\t\t\t\treturn typedArray;\n\t\t\t});\n\t\t}\n\t\tresult.push(promise);\n\t}\n\treturn result;\n};\nclass GlbParser {\n\tstatic parse(filename, urlBase, data, device, registry, options, callback) {\n\t\tparseChunk(filename, data, (err, chunks) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tparseGltf(chunks.gltfChunk, (err, gltf) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tcallback(err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tconst buffers = loadBuffers(gltf, chunks.binaryChunk, urlBase, options);\n\t\t\t\tconst bufferViews = createBufferViews(gltf, buffers, options);\n\t\t\t\tconst images = createImages(gltf, bufferViews, urlBase, registry, options);\n\t\t\t\tconst textures = createTextures(gltf, images, options);\n\t\t\t\tcreateResources(device, gltf, bufferViews, textures, options).then(result => callback(null, result)).catch(err => callback(err));\n\t\t\t});\n\t\t});\n\t}\n\tstatic createDefaultMaterial() {\n\t\treturn createMaterial({\n\t\t\tname: 'defaultGlbMaterial'\n\t\t}, []);\n\t}\n}\n\nexport { GlbParser };\n","import { Entity } from '../entity.js';\nimport { GSplatInstance } from '../../scene/gsplat/gsplat-instance.js';\nimport { GSplat } from '../../scene/gsplat/gsplat.js';\nimport { GSplatCompressed } from '../../scene/gsplat/gsplat-compressed.js';\n\nclass GSplatResource {\n\tconstructor(device, splatData) {\n\t\tthis.device = void 0;\n\t\tthis.splatData = void 0;\n\t\tthis.splat = null;\n\t\tthis.device = device;\n\t\tthis.splatData = splatData;\n\t}\n\tdestroy() {\n\t\tvar _this$splat;\n\t\tthis.device = null;\n\t\tthis.splatData = null;\n\t\t(_this$splat = this.splat) == null || _this$splat.destroy();\n\t\tthis.splat = null;\n\t}\n\tcreateSplat() {\n\t\tif (!this.splat) {\n\t\t\tthis.splat = this.splatData.isCompressed ? new GSplatCompressed(this.device, this.splatData) : new GSplat(this.device, this.splatData);\n\t\t}\n\t\treturn this.splat;\n\t}\n\tinstantiate(options = {}) {\n\t\tconst splatInstance = this.createInstance(options);\n\t\tconst entity = new Entity();\n\t\tconst component = entity.addComponent('gsplat', {\n\t\t\tinstance: splatInstance\n\t\t});\n\t\tentity.setLocalEulerAngles(0, 0, 180);\n\t\tcomponent.customAabb = splatInstance.splat.aabb.clone();\n\t\treturn entity;\n\t}\n\tcreateInstance(options = {}) {\n\t\tconst splat = this.createSplat();\n\t\treturn new GSplatInstance(splat, options);\n\t}\n}\n\nexport { GSplatResource };\n","import { Mat4 } from '../../core/math/mat4.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { BoundingBox } from '../../core/shape/bounding-box.js';\nimport { SEMANTIC_COLOR, INDEXFORMAT_UINT32, INDEXFORMAT_UINT16, PRIMITIVE_POINTS, PRIMITIVE_LINES, PRIMITIVE_LINELOOP, PRIMITIVE_LINESTRIP, PRIMITIVE_TRIANGLES, PRIMITIVE_TRISTRIP, PRIMITIVE_TRIFAN, TYPE_INT8, TYPE_UINT8, TYPE_INT16, TYPE_UINT16, TYPE_INT32, TYPE_UINT32, TYPE_FLOAT32, SEMANTIC_POSITION, SEMANTIC_NORMAL, SEMANTIC_TANGENT, SEMANTIC_BLENDWEIGHT, SEMANTIC_BLENDINDICES, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1, SEMANTIC_TEXCOORD2, SEMANTIC_TEXCOORD3, SEMANTIC_TEXCOORD4, SEMANTIC_TEXCOORD5, SEMANTIC_TEXCOORD6, SEMANTIC_TEXCOORD7 } from '../../platform/graphics/constants.js';\nimport { IndexBuffer } from '../../platform/graphics/index-buffer.js';\nimport { VertexBuffer } from '../../platform/graphics/vertex-buffer.js';\nimport { VertexFormat } from '../../platform/graphics/vertex-format.js';\nimport { VertexIterator } from '../../platform/graphics/vertex-iterator.js';\nimport { GraphNode } from '../../scene/graph-node.js';\nimport { Mesh } from '../../scene/mesh.js';\nimport { MeshInstance } from '../../scene/mesh-instance.js';\nimport { Model } from '../../scene/model.js';\nimport { Morph } from '../../scene/morph.js';\nimport { MorphInstance } from '../../scene/morph-instance.js';\nimport { MorphTarget } from '../../scene/morph-target.js';\nimport { Skin } from '../../scene/skin.js';\nimport { SkinInstance } from '../../scene/skin-instance.js';\n\nconst JSON_PRIMITIVE_TYPE = {\n\t'points': PRIMITIVE_POINTS,\n\t'lines': PRIMITIVE_LINES,\n\t'lineloop': PRIMITIVE_LINELOOP,\n\t'linestrip': PRIMITIVE_LINESTRIP,\n\t'triangles': PRIMITIVE_TRIANGLES,\n\t'trianglestrip': PRIMITIVE_TRISTRIP,\n\t'trianglefan': PRIMITIVE_TRIFAN\n};\nconst JSON_VERTEX_ELEMENT_TYPE = {\n\t'int8': TYPE_INT8,\n\t'uint8': TYPE_UINT8,\n\t'int16': TYPE_INT16,\n\t'uint16': TYPE_UINT16,\n\t'int32': TYPE_INT32,\n\t'uint32': TYPE_UINT32,\n\t'float32': TYPE_FLOAT32\n};\nclass JsonModelParser {\n\tconstructor(modelHandler) {\n\t\tthis._device = modelHandler.device;\n\t\tthis._defaultMaterial = modelHandler.defaultMaterial;\n\t}\n\tparse(data, callback) {\n\t\tconst modelData = data.model;\n\t\tif (!modelData) {\n\t\t\tcallback(null, null);\n\t\t\treturn;\n\t\t}\n\t\tif (modelData.version <= 1) {\n\t\t\tcallback('JsonModelParser#parse: Trying to parse unsupported model format.');\n\t\t\treturn;\n\t\t}\n\t\tconst nodes = this._parseNodes(data);\n\t\tconst skins = this._parseSkins(data, nodes);\n\t\tconst vertexBuffers = this._parseVertexBuffers(data);\n\t\tconst indices = this._parseIndexBuffers(data, vertexBuffers);\n\t\tconst morphs = this._parseMorphs(data, nodes, vertexBuffers);\n\t\tconst meshes = this._parseMeshes(data, skins.skins, morphs.morphs, vertexBuffers, indices.buffer, indices.data);\n\t\tconst meshInstances = this._parseMeshInstances(data, nodes, meshes, skins.skins, skins.instances, morphs.morphs, morphs.instances);\n\t\tconst model = new Model();\n\t\tmodel.graph = nodes[0];\n\t\tmodel.meshInstances = meshInstances;\n\t\tmodel.skinInstances = skins.instances;\n\t\tmodel.morphInstances = morphs.instances;\n\t\tmodel.getGraph().syncHierarchy();\n\t\tcallback(null, model);\n\t}\n\t_parseNodes(data) {\n\t\tconst modelData = data.model;\n\t\tconst nodes = [];\n\t\tlet i;\n\t\tfor (i = 0; i < modelData.nodes.length; i++) {\n\t\t\tconst nodeData = modelData.nodes[i];\n\t\t\tconst node = new GraphNode(nodeData.name);\n\t\t\tnode.setLocalPosition(nodeData.position[0], nodeData.position[1], nodeData.position[2]);\n\t\t\tnode.setLocalEulerAngles(nodeData.rotation[0], nodeData.rotation[1], nodeData.rotation[2]);\n\t\t\tnode.setLocalScale(nodeData.scale[0], nodeData.scale[1], nodeData.scale[2]);\n\t\t\tnode.scaleCompensation = !!nodeData.scaleCompensation;\n\t\t\tnodes.push(node);\n\t\t}\n\t\tfor (i = 1; i < modelData.parents.length; i++) {\n\t\t\tnodes[modelData.parents[i]].addChild(nodes[i]);\n\t\t}\n\t\treturn nodes;\n\t}\n\t_parseSkins(data, nodes) {\n\t\tconst modelData = data.model;\n\t\tconst skins = [];\n\t\tconst skinInstances = [];\n\t\tlet i, j;\n\t\tfor (i = 0; i < modelData.skins.length; i++) {\n\t\t\tconst skinData = modelData.skins[i];\n\t\t\tconst inverseBindMatrices = [];\n\t\t\tfor (j = 0; j < skinData.inverseBindMatrices.length; j++) {\n\t\t\t\tconst ibm = skinData.inverseBindMatrices[j];\n\t\t\t\tinverseBindMatrices[j] = new Mat4().set(ibm);\n\t\t\t}\n\t\t\tconst skin = new Skin(this._device, inverseBindMatrices, skinData.boneNames);\n\t\t\tskins.push(skin);\n\t\t\tconst skinInstance = new SkinInstance(skin);\n\t\t\tconst bones = [];\n\t\t\tfor (j = 0; j < skin.boneNames.length; j++) {\n\t\t\t\tconst boneName = skin.boneNames[j];\n\t\t\t\tconst bone = nodes[0].findByName(boneName);\n\t\t\t\tbones.push(bone);\n\t\t\t}\n\t\t\tskinInstance.bones = bones;\n\t\t\tskinInstances.push(skinInstance);\n\t\t}\n\t\treturn {\n\t\t\tskins: skins,\n\t\t\tinstances: skinInstances\n\t\t};\n\t}\n\t_getMorphVertexCount(modelData, morphIndex, vertexBuffers) {\n\t\tfor (let i = 0; i < modelData.meshes.length; i++) {\n\t\t\tconst meshData = modelData.meshes[i];\n\t\t\tif (meshData.morph === morphIndex) {\n\t\t\t\tconst vertexBuffer = vertexBuffers[meshData.vertices];\n\t\t\t\treturn vertexBuffer.numVertices;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\t_parseMorphs(data, nodes, vertexBuffers) {\n\t\tconst modelData = data.model;\n\t\tconst morphs = [];\n\t\tconst morphInstances = [];\n\t\tlet i, j, vertexCount;\n\t\tlet targets, morphTarget, morphTargetArray;\n\t\tif (modelData.morphs) {\n\t\t\tconst sparseToFull = function sparseToFull(data, indices, totalCount) {\n\t\t\t\tconst full = new Float32Array(totalCount * 3);\n\t\t\t\tfor (let s = 0; s < indices.length; s++) {\n\t\t\t\t\tconst dstIndex = indices[s] * 3;\n\t\t\t\t\tfull[dstIndex] = data[s * 3];\n\t\t\t\t\tfull[dstIndex + 1] = data[s * 3 + 1];\n\t\t\t\t\tfull[dstIndex + 2] = data[s * 3 + 2];\n\t\t\t\t}\n\t\t\t\treturn full;\n\t\t\t};\n\t\t\tfor (i = 0; i < modelData.morphs.length; i++) {\n\t\t\t\ttargets = modelData.morphs[i].targets;\n\t\t\t\tmorphTargetArray = [];\n\t\t\t\tvertexCount = this._getMorphVertexCount(modelData, i, vertexBuffers);\n\t\t\t\tfor (j = 0; j < targets.length; j++) {\n\t\t\t\t\tconst targetAabb = targets[j].aabb;\n\t\t\t\t\tconst min = targetAabb.min;\n\t\t\t\t\tconst max = targetAabb.max;\n\t\t\t\t\tconst aabb = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));\n\t\t\t\t\tconst indices = targets[j].indices;\n\t\t\t\t\tlet deltaPositions = targets[j].deltaPositions;\n\t\t\t\t\tlet deltaNormals = targets[j].deltaNormals;\n\t\t\t\t\tif (indices) {\n\t\t\t\t\t\tdeltaPositions = sparseToFull(deltaPositions, indices, vertexCount);\n\t\t\t\t\t\tdeltaNormals = sparseToFull(deltaNormals, indices, vertexCount);\n\t\t\t\t\t}\n\t\t\t\t\tmorphTarget = new MorphTarget({\n\t\t\t\t\t\tdeltaPositions: deltaPositions,\n\t\t\t\t\t\tdeltaNormals: deltaNormals,\n\t\t\t\t\t\tname: targets[j].name,\n\t\t\t\t\t\taabb: aabb\n\t\t\t\t\t});\n\t\t\t\t\tmorphTargetArray.push(morphTarget);\n\t\t\t\t}\n\t\t\t\tconst morph = new Morph(morphTargetArray, this._device);\n\t\t\t\tmorphs.push(morph);\n\t\t\t\tconst morphInstance = new MorphInstance(morph);\n\t\t\t\tmorphInstances.push(morphInstance);\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tmorphs: morphs,\n\t\t\tinstances: morphInstances\n\t\t};\n\t}\n\t_parseVertexBuffers(data) {\n\t\tconst modelData = data.model;\n\t\tconst vertexBuffers = [];\n\t\tconst attributeMap = {\n\t\t\tposition: SEMANTIC_POSITION,\n\t\t\tnormal: SEMANTIC_NORMAL,\n\t\t\ttangent: SEMANTIC_TANGENT,\n\t\t\tblendWeight: SEMANTIC_BLENDWEIGHT,\n\t\t\tblendIndices: SEMANTIC_BLENDINDICES,\n\t\t\tcolor: SEMANTIC_COLOR,\n\t\t\ttexCoord0: SEMANTIC_TEXCOORD0,\n\t\t\ttexCoord1: SEMANTIC_TEXCOORD1,\n\t\t\ttexCoord2: SEMANTIC_TEXCOORD2,\n\t\t\ttexCoord3: SEMANTIC_TEXCOORD3,\n\t\t\ttexCoord4: SEMANTIC_TEXCOORD4,\n\t\t\ttexCoord5: SEMANTIC_TEXCOORD5,\n\t\t\ttexCoord6: SEMANTIC_TEXCOORD6,\n\t\t\ttexCoord7: SEMANTIC_TEXCOORD7\n\t\t};\n\t\tfor (let i = 0; i < modelData.vertices.length; i++) {\n\t\t\tconst vertexData = modelData.vertices[i];\n\t\t\tconst formatDesc = [];\n\t\t\tfor (const attributeName in vertexData) {\n\t\t\t\tconst attribute = vertexData[attributeName];\n\t\t\t\tformatDesc.push({\n\t\t\t\t\tsemantic: attributeMap[attributeName],\n\t\t\t\t\tcomponents: attribute.components,\n\t\t\t\t\ttype: JSON_VERTEX_ELEMENT_TYPE[attribute.type],\n\t\t\t\t\tnormalize: attributeMap[attributeName] === SEMANTIC_COLOR\n\t\t\t\t});\n\t\t\t}\n\t\t\tconst vertexFormat = new VertexFormat(this._device, formatDesc);\n\t\t\tconst numVertices = vertexData.position.data.length / vertexData.position.components;\n\t\t\tconst vertexBuffer = new VertexBuffer(this._device, vertexFormat, numVertices);\n\t\t\tconst iterator = new VertexIterator(vertexBuffer);\n\t\t\tfor (let j = 0; j < numVertices; j++) {\n\t\t\t\tfor (const attributeName in vertexData) {\n\t\t\t\t\tconst attribute = vertexData[attributeName];\n\t\t\t\t\tswitch (attribute.components) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\titerator.element[attributeMap[attributeName]].set(attribute.data[j]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\titerator.element[attributeMap[attributeName]].set(attribute.data[j * 2], 1.0 - attribute.data[j * 2 + 1]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\titerator.element[attributeMap[attributeName]].set(attribute.data[j * 3], attribute.data[j * 3 + 1], attribute.data[j * 3 + 2]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\titerator.element[attributeMap[attributeName]].set(attribute.data[j * 4], attribute.data[j * 4 + 1], attribute.data[j * 4 + 2], attribute.data[j * 4 + 3]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\titerator.next();\n\t\t\t}\n\t\t\titerator.end();\n\t\t\tvertexBuffers.push(vertexBuffer);\n\t\t}\n\t\treturn vertexBuffers;\n\t}\n\t_parseIndexBuffers(data, vertexBuffers) {\n\t\tconst modelData = data.model;\n\t\tlet indexBuffer = null;\n\t\tlet indexData = null;\n\t\tlet i;\n\t\tlet numIndices = 0;\n\t\tfor (i = 0; i < modelData.meshes.length; i++) {\n\t\t\tconst meshData = modelData.meshes[i];\n\t\t\tif (meshData.indices !== undefined) {\n\t\t\t\tnumIndices += meshData.indices.length;\n\t\t\t}\n\t\t}\n\t\tlet maxVerts = 0;\n\t\tfor (i = 0; i < vertexBuffers.length; i++) {\n\t\t\tmaxVerts = Math.max(maxVerts, vertexBuffers[i].numVertices);\n\t\t}\n\t\tif (numIndices > 0) {\n\t\t\tif (maxVerts > 0xFFFF && this._device.extUintElement) {\n\t\t\t\tindexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT32, numIndices);\n\t\t\t\tindexData = new Uint32Array(indexBuffer.lock());\n\t\t\t} else {\n\t\t\t\tindexBuffer = new IndexBuffer(this._device, INDEXFORMAT_UINT16, numIndices);\n\t\t\t\tindexData = new Uint16Array(indexBuffer.lock());\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tbuffer: indexBuffer,\n\t\t\tdata: indexData\n\t\t};\n\t}\n\t_parseMeshes(data, skins, morphs, vertexBuffers, indexBuffer, indexData) {\n\t\tconst modelData = data.model;\n\t\tconst meshes = [];\n\t\tlet indexBase = 0;\n\t\tfor (let i = 0; i < modelData.meshes.length; i++) {\n\t\t\tconst meshData = modelData.meshes[i];\n\t\t\tconst meshAabb = meshData.aabb;\n\t\t\tconst min = meshAabb.min;\n\t\t\tconst max = meshAabb.max;\n\t\t\tconst aabb = new BoundingBox(new Vec3((max[0] + min[0]) * 0.5, (max[1] + min[1]) * 0.5, (max[2] + min[2]) * 0.5), new Vec3((max[0] - min[0]) * 0.5, (max[1] - min[1]) * 0.5, (max[2] - min[2]) * 0.5));\n\t\t\tconst indexed = meshData.indices !== undefined;\n\t\t\tconst mesh = new Mesh(this._device);\n\t\t\tmesh.vertexBuffer = vertexBuffers[meshData.vertices];\n\t\t\tmesh.indexBuffer[0] = indexed ? indexBuffer : null;\n\t\t\tmesh.primitive[0].type = JSON_PRIMITIVE_TYPE[meshData.type];\n\t\t\tmesh.primitive[0].base = indexed ? meshData.base + indexBase : meshData.base;\n\t\t\tmesh.primitive[0].count = meshData.count;\n\t\t\tmesh.primitive[0].indexed = indexed;\n\t\t\tmesh.skin = meshData.skin !== undefined ? skins[meshData.skin] : null;\n\t\t\tmesh.morph = meshData.morph !== undefined ? morphs[meshData.morph] : null;\n\t\t\tmesh.aabb = aabb;\n\t\t\tif (indexed) {\n\t\t\t\tindexData.set(meshData.indices, indexBase);\n\t\t\t\tindexBase += meshData.indices.length;\n\t\t\t}\n\t\t\tmeshes.push(mesh);\n\t\t}\n\t\tif (indexBuffer !== null) {\n\t\t\tindexBuffer.unlock();\n\t\t}\n\t\treturn meshes;\n\t}\n\t_parseMeshInstances(data, nodes, meshes, skins, skinInstances, morphs, morphInstances) {\n\t\tconst modelData = data.model;\n\t\tconst meshInstances = [];\n\t\tlet i;\n\t\tfor (i = 0; i < modelData.meshInstances.length; i++) {\n\t\t\tconst meshInstanceData = modelData.meshInstances[i];\n\t\t\tconst node = nodes[meshInstanceData.node];\n\t\t\tconst mesh = meshes[meshInstanceData.mesh];\n\t\t\tconst meshInstance = new MeshInstance(mesh, this._defaultMaterial, node);\n\t\t\tif (mesh.skin) {\n\t\t\t\tconst skinIndex = skins.indexOf(mesh.skin);\n\t\t\t\tmeshInstance.skinInstance = skinInstances[skinIndex];\n\t\t\t}\n\t\t\tif (mesh.morph) {\n\t\t\t\tconst morphIndex = morphs.indexOf(mesh.morph);\n\t\t\t\tmeshInstance.morphInstance = morphInstances[morphIndex];\n\t\t\t}\n\t\t\tmeshInstances.push(meshInstance);\n\t\t}\n\t\treturn meshInstances;\n\t}\n}\n\nexport { JsonModelParser };\n","import { extends as _extends } from '../../../../_virtual/_rollupPluginBabelHelpers.js';\nimport { Color } from '../../../core/math/color.js';\nimport { Vec2 } from '../../../core/math/vec2.js';\nimport { Vec3 } from '../../../core/math/vec3.js';\nimport { Texture } from '../../../platform/graphics/texture.js';\nimport { BoundingBox } from '../../../core/shape/bounding-box.js';\nimport { SPECULAR_BLINN, SPECULAR_PHONG } from '../../../scene/constants.js';\nimport { StandardMaterial } from '../../../scene/materials/standard-material.js';\nimport { StandardMaterialValidator } from '../../../scene/materials/standard-material-validator.js';\nimport { standardMaterialParameterTypes } from '../../../scene/materials/standard-material-parameters.js';\nimport { __adjustStandardMaterialData } from '../../../deprecated/compatibility-v2-utils.js';\n\nclass JsonStandardMaterialParser {\n\tconstructor() {\n\t\tthis._validator = null;\n\t}\n\tparse(input) {\n\t\tconst migrated = this.migrate(input);\n\t\tconst validated = this._validate(migrated);\n\t\tconst material = new StandardMaterial();\n\t\tthis.initialize(material, validated);\n\t\treturn material;\n\t}\n\tinitialize(material, data) {\n\t\tif (!data.validated) {\n\t\t\tdata = this._validate(data);\n\t\t}\n\t\tif (data.chunks) {\n\t\t\tmaterial.chunks = _extends({}, data.chunks);\n\t\t}\n\t\tfor (const key in data) {\n\t\t\tconst type = standardMaterialParameterTypes[key];\n\t\t\tconst value = data[key];\n\t\t\tif (type === 'vec2') {\n\t\t\t\tmaterial[key] = new Vec2(value[0], value[1]);\n\t\t\t} else if (type === 'rgb') {\n\t\t\t\tmaterial[key] = new Color(value[0], value[1], value[2]);\n\t\t\t} else if (type === 'texture') {\n\t\t\t\tif (value instanceof Texture) {\n\t\t\t\t\tmaterial[key] = value;\n\t\t\t\t} else if (!(material[key] instanceof Texture && typeof value === 'number' && value > 0)) {\n\t\t\t\t\tmaterial[key] = null;\n\t\t\t\t}\n\t\t\t} else if (type === 'cubemap') {\n\t\t\t\tif (value instanceof Texture) {\n\t\t\t\t\tmaterial[key] = value;\n\t\t\t\t} else if (!(material[key] instanceof Texture && typeof value === 'number' && value > 0)) {\n\t\t\t\t\tmaterial[key] = null;\n\t\t\t\t}\n\t\t\t\tif (key === 'cubeMap' && !value) {\n\t\t\t\t\tmaterial.prefilteredCubemaps = null;\n\t\t\t\t}\n\t\t\t} else if (type === 'boundingbox') {\n\t\t\t\tconst center = new Vec3(value.center[0], value.center[1], value.center[2]);\n\t\t\t\tconst halfExtents = new Vec3(value.halfExtents[0], value.halfExtents[1], value.halfExtents[2]);\n\t\t\t\tmaterial[key] = new BoundingBox(center, halfExtents);\n\t\t\t} else {\n\t\t\t\tmaterial[key] = data[key];\n\t\t\t}\n\t\t}\n\t\tmaterial.update();\n\t}\n\tmigrate(data) {\n\t\tif (data.shader) {\n\t\t\tdata.shadingModel = data.shader === 'blinn' ? SPECULAR_BLINN : SPECULAR_PHONG;\n\t\t\tdelete data.shader;\n\t\t} else if (data.shadingModel === undefined) {\n\t\t\tdata.shadingModel = SPECULAR_BLINN;\n\t\t}\n\t\tif (data.mapping_format) {\n\t\t\tdata.mappingFormat = data.mapping_format;\n\t\t\tdelete data.mapping_format;\n\t\t}\n\t\tlet i;\n\t\tconst RENAMED_PROPERTIES = [['bumpMapFactor', 'bumpiness'], ['aoUvSet', 'aoMapUv'], ['aoMapVertexColor', 'aoVertexColor'], ['diffuseMapVertexColor', 'diffuseVertexColor'], ['emissiveMapVertexColor', 'emissiveVertexColor'], ['specularMapVertexColor', 'specularVertexColor'], ['metalnessMapVertexColor', 'metalnessVertexColor'], ['opacityMapVertexColor', 'opacityVertexColor'], ['glossMapVertexColor', 'glossVertexColor'], ['lightMapVertexColor', 'lightVertexColor'], ['diffuseMapTint', 'diffuseTint'], ['specularMapTint', 'specularTint'], ['emissiveMapTint', 'emissiveTint'], ['metalnessMapTint', 'metalnessTint'], ['clearCoatGlossiness', 'clearCoatGloss']];\n\t\tfor (i = 0; i < RENAMED_PROPERTIES.length; i++) {\n\t\t\tconst _old = RENAMED_PROPERTIES[i][0];\n\t\t\tconst _new = RENAMED_PROPERTIES[i][1];\n\t\t\tif (data[_old] !== undefined) {\n\t\t\t\tif (data[_new] === undefined) {\n\t\t\t\t\tdata[_new] = data[_old];\n\t\t\t\t}\n\t\t\t\tdelete data[_old];\n\t\t\t}\n\t\t}\n\t\tconst DEPRECATED_PROPERTIES = ['fresnelFactor', 'shadowSampleType'];\n\t\tfor (i = 0; i < DEPRECATED_PROPERTIES.length; i++) {\n\t\t\tconst name = DEPRECATED_PROPERTIES[i];\n\t\t\tif (data.hasOwnProperty(name)) {\n\t\t\t\tdelete data[name];\n\t\t\t}\n\t\t}\n\t\t__adjustStandardMaterialData(data);\n\t\treturn data;\n\t}\n\t_validate(data) {\n\t\tif (!data.validated) {\n\t\t\tif (!this._validator) {\n\t\t\t\tthis._validator = new StandardMaterialValidator();\n\t\t\t}\n\t\t\tthis._validator.validate(data);\n\t\t}\n\t\treturn data;\n\t}\n}\n\nexport { JsonStandardMaterialParser };\n","import { GSplatData } from '../../scene/gsplat/gsplat-data.js';\nimport { GSplatCompressedData } from '../../scene/gsplat/gsplat-compressed-data.js';\nimport { GSplatResource } from './gsplat-resource.js';\n\nconst magicBytes = new Uint8Array([112, 108, 121, 10]);\nconst endHeaderBytes = new Uint8Array([10, 101, 110, 100, 95, 104, 101, 97, 100, 101, 114, 10]);\nconst dataTypeMap = new Map([['char', Int8Array], ['uchar', Uint8Array], ['short', Int16Array], ['ushort', Uint16Array], ['int', Int32Array], ['uint', Uint32Array], ['float', Float32Array], ['double', Float64Array]]);\nclass StreamBuf {\n\tconstructor(reader) {\n\t\tthis.reader = void 0;\n\t\tthis.data = void 0;\n\t\tthis.view = void 0;\n\t\tthis.head = 0;\n\t\tthis.tail = 0;\n\t\tthis.reader = reader;\n\t}\n\tasync read() {\n\t\tconst {\n\t\t\tvalue,\n\t\t\tdone\n\t\t} = await this.reader.read();\n\t\tif (done) {\n\t\t\tthrow new Error('Stream finished before end of header');\n\t\t}\n\t\tthis.push(value);\n\t}\n\tpush(data) {\n\t\tif (!this.data) {\n\t\t\tthis.data = data;\n\t\t\tthis.view = new DataView(this.data.buffer);\n\t\t\tthis.tail = data.length;\n\t\t} else {\n\t\t\tconst remaining = this.tail - this.head;\n\t\t\tconst newSize = remaining + data.length;\n\t\t\tif (this.data.length >= newSize) {\n\t\t\t\tif (this.head > 0) {\n\t\t\t\t\tthis.data.copyWithin(0, this.head, this.tail);\n\t\t\t\t\tthis.data.set(data, remaining);\n\t\t\t\t\tthis.head = 0;\n\t\t\t\t\tthis.tail = newSize;\n\t\t\t\t} else {\n\t\t\t\t\tthis.data.set(data, this.tail);\n\t\t\t\t\tthis.tail += data.length;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst tmp = new Uint8Array(newSize);\n\t\t\t\tif (this.head > 0 || this.tail < this.data.length) {\n\t\t\t\t\ttmp.set(this.data.subarray(this.head, this.tail), 0);\n\t\t\t\t} else {\n\t\t\t\t\ttmp.set(this.data, 0);\n\t\t\t\t}\n\t\t\t\ttmp.set(data, remaining);\n\t\t\t\tthis.data = tmp;\n\t\t\t\tthis.view = new DataView(this.data.buffer);\n\t\t\t\tthis.head = 0;\n\t\t\t\tthis.tail = newSize;\n\t\t\t}\n\t\t}\n\t}\n\tcompact() {\n\t\tif (this.head > 0) {\n\t\t\tthis.data.copyWithin(0, this.head, this.tail);\n\t\t\tthis.tail -= this.head;\n\t\t\tthis.head = 0;\n\t\t}\n\t}\n\tget remaining() {\n\t\treturn this.tail - this.head;\n\t}\n\tgetInt8() {\n\t\tconst result = this.view.getInt8(this.head);\n\t\tthis.head++;\n\t\treturn result;\n\t}\n\tgetUint8() {\n\t\tconst result = this.view.getUint8(this.head);\n\t\tthis.head++;\n\t\treturn result;\n\t}\n\tgetInt16() {\n\t\tconst result = this.view.getInt16(this.head, true);\n\t\tthis.head += 2;\n\t\treturn result;\n\t}\n\tgetUint16() {\n\t\tconst result = this.view.getUint16(this.head, true);\n\t\tthis.head += 2;\n\t\treturn result;\n\t}\n\tgetInt32() {\n\t\tconst result = this.view.getInt32(this.head, true);\n\t\tthis.head += 4;\n\t\treturn result;\n\t}\n\tgetUint32() {\n\t\tconst result = this.view.getUint32(this.head, true);\n\t\tthis.head += 4;\n\t\treturn result;\n\t}\n\tgetFloat32() {\n\t\tconst result = this.view.getFloat32(this.head, true);\n\t\tthis.head += 4;\n\t\treturn result;\n\t}\n\tgetFloat64() {\n\t\tconst result = this.view.getFloat64(this.head, true);\n\t\tthis.head += 8;\n\t\treturn result;\n\t}\n}\nconst parseHeader = lines => {\n\tconst elements = [];\n\tlet format;\n\tfor (let i = 1; i < lines.length; ++i) {\n\t\tconst words = lines[i].split(' ');\n\t\tswitch (words[0]) {\n\t\t\tcase 'format':\n\t\t\t\tformat = words[1];\n\t\t\t\tbreak;\n\t\t\tcase 'element':\n\t\t\t\telements.push({\n\t\t\t\t\tname: words[1],\n\t\t\t\t\tcount: parseInt(words[2], 10),\n\t\t\t\t\tproperties: []\n\t\t\t\t});\n\t\t\t\tbreak;\n\t\t\tcase 'property':\n\t\t\t\t{\n\t\t\t\t\tif (!dataTypeMap.has(words[1])) {\n\t\t\t\t\t\tthrow new Error(`Unrecognized property data type '${words[1]}' in ply header`);\n\t\t\t\t\t}\n\t\t\t\t\tconst element = elements[elements.length - 1];\n\t\t\t\t\telement.properties.push({\n\t\t\t\t\t\ttype: words[1],\n\t\t\t\t\t\tname: words[2],\n\t\t\t\t\t\tstorage: null,\n\t\t\t\t\t\tbyteSize: dataTypeMap.get(words[1]).BYTES_PER_ELEMENT\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unrecognized header value '${words[0]}' in ply header`);\n\t\t}\n\t}\n\treturn {\n\t\telements,\n\t\tformat\n\t};\n};\nconst isCompressedPly = elements => {\n\tconst chunkProperties = ['min_x', 'min_y', 'min_z', 'max_x', 'max_y', 'max_z', 'min_scale_x', 'min_scale_y', 'min_scale_z', 'max_scale_x', 'max_scale_y', 'max_scale_z', 'min_r', 'min_g', 'min_b', 'max_r', 'max_g', 'max_b'];\n\tconst vertexProperties = ['packed_position', 'packed_rotation', 'packed_scale', 'packed_color'];\n\tconst shProperties = new Array(45).fill('').map((_, i) => `f_rest_${i}`);\n\tconst hasBaseElements = () => {\n\t\treturn elements[0].name === 'chunk' && elements[0].properties.every((p, i) => p.name === chunkProperties[i] && p.type === 'float') && elements[1].name === 'vertex' && elements[1].properties.every((p, i) => p.name === vertexProperties[i] && p.type === 'uint');\n\t};\n\tconst hasSHElements = () => {\n\t\treturn elements[2].name === 'sh' && [9, 24, 45].indexOf(elements[2].properties.length) !== -1 && elements[2].properties.every((p, i) => p.name === shProperties[i] && p.type === 'uchar');\n\t};\n\treturn elements.length === 2 && hasBaseElements() || elements.length === 3 && hasBaseElements() && hasSHElements();\n};\nconst isFloatPly = elements => {\n\treturn elements.length === 1 && elements[0].name === 'vertex' && elements[0].properties.every(p => p.type === 'float');\n};\nconst readCompressedPly = async (streamBuf, elements, littleEndian) => {\n\tconst result = new GSplatCompressedData();\n\tconst numChunks = elements[0].count;\n\tconst numChunkProperties = elements[0].properties.length;\n\tconst numVertices = elements[1].count;\n\tconst evalStorageSize = count => {\n\t\tconst width = Math.ceil(Math.sqrt(count));\n\t\tconst height = Math.ceil(count / width);\n\t\treturn width * height;\n\t};\n\tresult.numSplats = numVertices;\n\tresult.chunkData = new Float32Array(numChunks * numChunkProperties);\n\tresult.vertexData = new Uint32Array(evalStorageSize(numVertices) * 4);\n\tconst read = async (buffer, length) => {\n\t\tconst target = new Uint8Array(buffer);\n\t\tlet cursor = 0;\n\t\twhile (cursor < length) {\n\t\t\twhile (streamBuf.remaining === 0) {\n\t\t\t\tawait streamBuf.read();\n\t\t\t}\n\t\t\tconst toCopy = Math.min(length - cursor, streamBuf.remaining);\n\t\t\tconst src = streamBuf.data;\n\t\t\tfor (let i = 0; i < toCopy; ++i) {\n\t\t\t\ttarget[cursor++] = src[streamBuf.head++];\n\t\t\t}\n\t\t}\n\t};\n\tawait read(result.chunkData.buffer, numChunks * numChunkProperties * 4);\n\tawait read(result.vertexData.buffer, numVertices * 4 * 4);\n\tif (elements.length === 3) {\n\t\tresult.shData = new Uint8Array(elements[2].count * elements[2].properties.length);\n\t\tawait read(result.shData.buffer, result.shData.byteLength);\n\t}\n\treturn result;\n};\nconst readFloatPly = async (streamBuf, elements, littleEndian) => {\n\tconst element = elements[0];\n\tconst properties = element.properties;\n\tconst numProperties = properties.length;\n\tconst storage = properties.map(p => p.storage);\n\tconst inputSize = properties.reduce((a, p) => a + p.byteSize, 0);\n\tlet vertexIdx = 0;\n\tlet floatData;\n\tconst checkFloatData = () => {\n\t\tvar _floatData;\n\t\tconst buffer = streamBuf.data.buffer;\n\t\tif (((_floatData = floatData) == null ? void 0 : _floatData.buffer) !== buffer) {\n\t\t\tfloatData = new Float32Array(buffer, 0, buffer.byteLength / 4);\n\t\t}\n\t};\n\tcheckFloatData();\n\twhile (vertexIdx < element.count) {\n\t\twhile (streamBuf.remaining < inputSize) {\n\t\t\tawait streamBuf.read();\n\t\t\tcheckFloatData();\n\t\t}\n\t\tconst toRead = Math.min(element.count - vertexIdx, Math.floor(streamBuf.remaining / inputSize));\n\t\tfor (let j = 0; j < numProperties; ++j) {\n\t\t\tconst s = storage[j];\n\t\t\tfor (let n = 0; n < toRead; ++n) {\n\t\t\t\ts[n + vertexIdx] = floatData[n * numProperties + j];\n\t\t\t}\n\t\t}\n\t\tvertexIdx += toRead;\n\t\tstreamBuf.head += toRead * inputSize;\n\t}\n\treturn new GSplatData(elements);\n};\nconst readGeneralPly = async (streamBuf, elements, littleEndian) => {\n\tfor (let i = 0; i < elements.length; ++i) {\n\t\tconst element = elements[i];\n\t\tconst inputSize = element.properties.reduce((a, p) => a + p.byteSize, 0);\n\t\tconst propertyParsingFunctions = element.properties.map(p => {\n\t\t\tif (p.storage) {\n\t\t\t\tswitch (p.type) {\n\t\t\t\t\tcase 'char':\n\t\t\t\t\t\treturn (streamBuf, c) => {\n\t\t\t\t\t\t\tp.storage[c] = streamBuf.getInt8();\n\t\t\t\t\t\t};\n\t\t\t\t\tcase 'uchar':\n\t\t\t\t\t\treturn (streamBuf, c) => {\n\t\t\t\t\t\t\tp.storage[c] = streamBuf.getUint8();\n\t\t\t\t\t\t};\n\t\t\t\t\tcase 'short':\n\t\t\t\t\t\treturn (streamBuf, c) => {\n\t\t\t\t\t\t\tp.storage[c] = streamBuf.getInt16();\n\t\t\t\t\t\t};\n\t\t\t\t\tcase 'ushort':\n\t\t\t\t\t\treturn (streamBuf, c) => {\n\t\t\t\t\t\t\tp.storage[c] = streamBuf.getUint16();\n\t\t\t\t\t\t};\n\t\t\t\t\tcase 'int':\n\t\t\t\t\t\treturn (streamBuf, c) => {\n\t\t\t\t\t\t\tp.storage[c] = streamBuf.getInt32();\n\t\t\t\t\t\t};\n\t\t\t\t\tcase 'uint':\n\t\t\t\t\t\treturn (streamBuf, c) => {\n\t\t\t\t\t\t\tp.storage[c] = streamBuf.getUint32();\n\t\t\t\t\t\t};\n\t\t\t\t\tcase 'float':\n\t\t\t\t\t\treturn (streamBuf, c) => {\n\t\t\t\t\t\t\tp.storage[c] = streamBuf.getFloat32();\n\t\t\t\t\t\t};\n\t\t\t\t\tcase 'double':\n\t\t\t\t\t\treturn (streamBuf, c) => {\n\t\t\t\t\t\t\tp.storage[c] = streamBuf.getFloat64();\n\t\t\t\t\t\t};\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error(`Unsupported property data type '${p.type}' in ply header`);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn streamBuf => {\n\t\t\t\t\tstreamBuf.head += p.byteSize;\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t\tlet c = 0;\n\t\twhile (c < element.count) {\n\t\t\twhile (streamBuf.remaining < inputSize) {\n\t\t\t\tawait streamBuf.read();\n\t\t\t}\n\t\t\tconst toRead = Math.min(element.count - c, Math.floor(streamBuf.remaining / inputSize));\n\t\t\tfor (let n = 0; n < toRead; ++n) {\n\t\t\t\tfor (let j = 0; j < element.properties.length; ++j) {\n\t\t\t\t\tpropertyParsingFunctions[j](streamBuf, c);\n\t\t\t\t}\n\t\t\t\tc++;\n\t\t\t}\n\t\t}\n\t}\n\treturn new GSplatData(elements);\n};\nconst readPly = async (reader, propertyFilter = null) => {\n\tconst find = (buf, search) => {\n\t\tconst endIndex = buf.length - search.length;\n\t\tlet i, j;\n\t\tfor (i = 0; i <= endIndex; ++i) {\n\t\t\tfor (j = 0; j < search.length; ++j) {\n\t\t\t\tif (buf[i + j] !== search[j]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (j === search.length) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t};\n\tconst startsWith = (a, b) => {\n\t\tif (a.length < b.length) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (let i = 0; i < b.length; ++i) {\n\t\t\tif (a[i] !== b[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t};\n\tconst streamBuf = new StreamBuf(reader);\n\tlet headerLength;\n\twhile (true) {\n\t\tawait streamBuf.read();\n\t\tif (streamBuf.tail >= magicBytes.length && !startsWith(streamBuf.data, magicBytes)) {\n\t\t\tthrow new Error('Invalid ply header');\n\t\t}\n\t\theaderLength = find(streamBuf.data, endHeaderBytes);\n\t\tif (headerLength !== -1) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tconst lines = new TextDecoder('ascii').decode(streamBuf.data.subarray(0, headerLength)).split('\\n').filter(line => !line.startsWith('comment '));\n\tconst {\n\t\telements,\n\t\tformat\n\t} = parseHeader(lines);\n\tif (format !== 'binary_little_endian' && format !== 'binary_big_endian') {\n\t\tthrow new Error('Unsupported ply format');\n\t}\n\tstreamBuf.head = headerLength + endHeaderBytes.length;\n\tstreamBuf.compact();\n\tif (isCompressedPly(elements)) {\n\t\treturn await readCompressedPly(streamBuf, elements);\n\t}\n\telements.forEach(e => {\n\t\te.properties.forEach(p => {\n\t\t\tconst storageType = dataTypeMap.get(p.type);\n\t\t\tif (storageType) {\n\t\t\t\tconst storage = !propertyFilter || propertyFilter(p.name) ? new storageType(e.count) : null;\n\t\t\t\tp.storage = storage;\n\t\t\t}\n\t\t});\n\t});\n\tif (isFloatPly(elements)) {\n\t\treturn await readFloatPly(streamBuf, elements);\n\t}\n\treturn await readGeneralPly(streamBuf, elements);\n};\nconst defaultElementFilter = val => true;\nclass PlyParser {\n\tconstructor(device, assets, maxRetries) {\n\t\tthis.device = void 0;\n\t\tthis.assets = void 0;\n\t\tthis.maxRetries = void 0;\n\t\tthis.device = device;\n\t\tthis.assets = assets;\n\t\tthis.maxRetries = maxRetries;\n\t}\n\tasync load(url, callback, asset) {\n\t\tconst response = await fetch(url.load);\n\t\tif (!response || !response.body) {\n\t\t\tcallback('Error loading resource', null);\n\t\t} else {\n\t\t\tvar _asset$data$elementFi;\n\t\t\treadPly(response.body.getReader(), (_asset$data$elementFi = asset.data.elementFilter) != null ? _asset$data$elementFi : defaultElementFilter).then(gsplatData => {\n\t\t\t\tif (!gsplatData.isCompressed) {\n\t\t\t\t\tvar _asset$data$reorder;\n\t\t\t\t\tif ((_asset$data$reorder = asset.data.reorder) != null ? _asset$data$reorder : true) {\n\t\t\t\t\t\tgsplatData.reorderData();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst resource = new GSplatResource(this.device, gsplatData.isCompressed && asset.data.decompress ? gsplatData.decompress() : gsplatData);\n\t\t\t\tcallback(null, resource);\n\t\t\t}).catch(err => {\n\t\t\t\tcallback(err, null);\n\t\t\t});\n\t\t}\n\t}\n\topen(url, data) {\n\t\treturn data;\n\t}\n}\n\nexport { PlyParser };\n","import { Entity } from '../entity.js';\nimport { CompressUtils } from '../../scene/compress/compress-utils.js';\nimport { Decompress } from '../../scene/compress/decompress.js';\n\nclass SceneParser {\n\tconstructor(app, isTemplate) {\n\t\tthis._app = app;\n\t\tthis._isTemplate = isTemplate;\n\t}\n\tparse(data) {\n\t\tconst entities = {};\n\t\tlet parent = null;\n\t\tconst compressed = data.compressedFormat;\n\t\tif (compressed && !data.entDecompressed) {\n\t\t\tdata.entDecompressed = true;\n\t\t\tdata.entities = new Decompress(data.entities, compressed).run();\n\t\t}\n\t\tfor (const id in data.entities) {\n\t\t\tconst curData = data.entities[id];\n\t\t\tconst curEnt = this._createEntity(curData, compressed);\n\t\t\tentities[id] = curEnt;\n\t\t\tif (curData.parent === null) {\n\t\t\t\tparent = curEnt;\n\t\t\t}\n\t\t}\n\t\tfor (const id in data.entities) {\n\t\t\tconst curEnt = entities[id];\n\t\t\tconst children = data.entities[id].children;\n\t\t\tconst len = children.length;\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tconst childEnt = entities[children[i]];\n\t\t\t\tif (childEnt) {\n\t\t\t\t\tcurEnt.addChild(childEnt);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._openComponentData(parent, data.entities);\n\t\treturn parent;\n\t}\n\t_createEntity(data, compressed) {\n\t\tvar _data$enabled;\n\t\tconst entity = new Entity(data.name, this._app);\n\t\tentity.setGuid(data.resource_id);\n\t\tthis._setPosRotScale(entity, data, compressed);\n\t\tentity._enabled = (_data$enabled = data.enabled) != null ? _data$enabled : true;\n\t\tif (this._isTemplate) {\n\t\t\tentity._template = true;\n\t\t} else {\n\t\t\tentity._enabledInHierarchy = entity._enabled;\n\t\t}\n\t\tentity.template = data.template;\n\t\tif (data.tags) {\n\t\t\tfor (let i = 0; i < data.tags.length; i++) {\n\t\t\t\tentity.tags.add(data.tags[i]);\n\t\t\t}\n\t\t}\n\t\tif (data.labels) {\n\t\t\tdata.labels.forEach(label => {\n\t\t\t\tentity.addLabel(label);\n\t\t\t});\n\t\t}\n\t\treturn entity;\n\t}\n\t_setPosRotScale(entity, data, compressed) {\n\t\tif (compressed) {\n\t\t\tCompressUtils.setCompressedPRS(entity, data, compressed);\n\t\t} else {\n\t\t\tconst p = data.position;\n\t\t\tconst r = data.rotation;\n\t\t\tconst s = data.scale;\n\t\t\tentity.setLocalPosition(p[0], p[1], p[2]);\n\t\t\tentity.setLocalEulerAngles(r[0], r[1], r[2]);\n\t\t\tentity.setLocalScale(s[0], s[1], s[2]);\n\t\t}\n\t}\n\t_openComponentData(entity, entities) {\n\t\tconst systemsList = this._app.systems.list;\n\t\tlet len = systemsList.length;\n\t\tconst entityData = entities[entity.getGuid()];\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst system = systemsList[i];\n\t\t\tconst componentData = entityData.components[system.id];\n\t\t\tif (componentData) {\n\t\t\t\tsystem.addComponent(entity, componentData);\n\t\t\t}\n\t\t}\n\t\tlen = entityData.children.length;\n\t\tconst children = entity._children;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tif (children[i]) {\n\t\t\t\tchildren[i] = this._openComponentData(children[i], entities);\n\t\t\t}\n\t\t}\n\t\treturn entity;\n\t}\n}\n\nexport { SceneParser };\n","import { extends as _extends } from '../../../../_virtual/_rollupPluginBabelHelpers.js';\nimport { ADDRESS_CLAMP_TO_EDGE, ADDRESS_REPEAT } from '../../../platform/graphics/constants.js';\nimport { Texture } from '../../../platform/graphics/texture.js';\nimport { Asset } from '../../asset/asset.js';\nimport { basisTranscode } from '../../handlers/basis.js';\nimport { TextureParser } from './texture.js';\n\nclass BasisParser extends TextureParser {\n\tconstructor(registry, device) {\n\t\tsuper();\n\t\tthis.device = device;\n\t\tthis.maxRetries = 0;\n\t}\n\tload(url, callback, asset) {\n\t\tconst device = this.device;\n\t\tconst transcode = data => {\n\t\t\tvar _asset$file;\n\t\t\tconst basisModuleFound = basisTranscode(device, url.load, data, callback, {\n\t\t\t\tisGGGR: ((asset == null || (_asset$file = asset.file) == null || (_asset$file = _asset$file.variants) == null || (_asset$file = _asset$file.basis) == null ? void 0 : _asset$file.opt) & 8) !== 0\n\t\t\t});\n\t\t\tif (!basisModuleFound) {\n\t\t\t\tcallback(`Basis module not found. Asset '${asset.name}' basis texture variant will not be loaded.`);\n\t\t\t}\n\t\t};\n\t\tAsset.fetchArrayBuffer(url.load, (err, result) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else {\n\t\t\t\ttranscode(result);\n\t\t\t}\n\t\t}, asset, this.maxRetries);\n\t}\n\topen(url, data, device, textureOptions = {}) {\n\t\tconst texture = new Texture(device, _extends({\n\t\t\tname: url,\n\t\t\taddressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\taddressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\twidth: data.width,\n\t\t\theight: data.height,\n\t\t\tformat: data.format,\n\t\t\tcubemap: data.cubemap,\n\t\t\tlevels: data.levels\n\t\t}, textureOptions));\n\t\ttexture.upload();\n\t\treturn texture;\n\t}\n}\n\nexport { BasisParser };\n","import { extends as _extends } from '../../../../_virtual/_rollupPluginBabelHelpers.js';\nimport { PIXELFORMAT_RGB8, ADDRESS_CLAMP_TO_EDGE, ADDRESS_REPEAT, PIXELFORMAT_DXT1, PIXELFORMAT_DXT5, PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F, PIXELFORMAT_ETC1, PIXELFORMAT_PVRTC_2BPP_RGB_1, PIXELFORMAT_PVRTC_2BPP_RGBA_1, PIXELFORMAT_PVRTC_4BPP_RGB_1, PIXELFORMAT_PVRTC_4BPP_RGBA_1, PIXELFORMAT_RGBA8 } from '../../../platform/graphics/constants.js';\nimport { Texture } from '../../../platform/graphics/texture.js';\nimport { Asset } from '../../asset/asset.js';\nimport { TextureParser } from './texture.js';\n\nclass DdsParser extends TextureParser {\n\tconstructor(registry) {\n\t\tsuper();\n\t\tthis.maxRetries = 0;\n\t}\n\tload(url, callback, asset) {\n\t\tAsset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);\n\t}\n\topen(url, data, device, textureOptions = {}) {\n\t\tconst header = new Uint32Array(data, 0, 128 / 4);\n\t\tconst width = header[4];\n\t\tconst height = header[3];\n\t\tconst mips = Math.max(header[7], 1);\n\t\tconst isFourCc = header[20] === 4;\n\t\tconst fcc = header[21];\n\t\tconst bpp = header[22];\n\t\tconst isCubemap = header[28] === 65024;\n\t\tconst FCC_DXT1 = 827611204;\n\t\tconst FCC_DXT5 = 894720068;\n\t\tconst FCC_FP16 = 113;\n\t\tconst FCC_FP32 = 116;\n\t\tconst FCC_ETC1 = 826496069;\n\t\tconst FCC_PVRTC_2BPP_RGB_1 = 825438800;\n\t\tconst FCC_PVRTC_2BPP_RGBA_1 = 825504336;\n\t\tconst FCC_PVRTC_4BPP_RGB_1 = 825439312;\n\t\tconst FCC_PVRTC_4BPP_RGBA_1 = 825504848;\n\t\tlet compressed = false;\n\t\tlet etc1 = false;\n\t\tlet pvrtc2 = false;\n\t\tlet pvrtc4 = false;\n\t\tlet format = null;\n\t\tlet componentSize = 1;\n\t\tlet texture;\n\t\tif (isFourCc) {\n\t\t\tif (fcc === FCC_DXT1) {\n\t\t\t\tformat = PIXELFORMAT_DXT1;\n\t\t\t\tcompressed = true;\n\t\t\t} else if (fcc === FCC_DXT5) {\n\t\t\t\tformat = PIXELFORMAT_DXT5;\n\t\t\t\tcompressed = true;\n\t\t\t} else if (fcc === FCC_FP16) {\n\t\t\t\tformat = PIXELFORMAT_RGBA16F;\n\t\t\t\tcomponentSize = 2;\n\t\t\t} else if (fcc === FCC_FP32) {\n\t\t\t\tformat = PIXELFORMAT_RGBA32F;\n\t\t\t\tcomponentSize = 4;\n\t\t\t} else if (fcc === FCC_ETC1) {\n\t\t\t\tformat = PIXELFORMAT_ETC1;\n\t\t\t\tcompressed = true;\n\t\t\t\tetc1 = true;\n\t\t\t} else if (fcc === FCC_PVRTC_2BPP_RGB_1 || fcc === FCC_PVRTC_2BPP_RGBA_1) {\n\t\t\t\tformat = fcc === FCC_PVRTC_2BPP_RGB_1 ? PIXELFORMAT_PVRTC_2BPP_RGB_1 : PIXELFORMAT_PVRTC_2BPP_RGBA_1;\n\t\t\t\tcompressed = true;\n\t\t\t\tpvrtc2 = true;\n\t\t\t} else if (fcc === FCC_PVRTC_4BPP_RGB_1 || fcc === FCC_PVRTC_4BPP_RGBA_1) {\n\t\t\t\tformat = fcc === FCC_PVRTC_4BPP_RGB_1 ? PIXELFORMAT_PVRTC_4BPP_RGB_1 : PIXELFORMAT_PVRTC_4BPP_RGBA_1;\n\t\t\t\tcompressed = true;\n\t\t\t\tpvrtc4 = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (bpp === 32) {\n\t\t\t\tformat = PIXELFORMAT_RGBA8;\n\t\t\t}\n\t\t}\n\t\tif (!format) {\n\t\t\ttexture = new Texture(device, {\n\t\t\t\twidth: 4,\n\t\t\t\theight: 4,\n\t\t\t\tformat: PIXELFORMAT_RGB8,\n\t\t\t\tname: 'dds-legacy-empty'\n\t\t\t});\n\t\t\treturn texture;\n\t\t}\n\t\ttexture = new Texture(device, _extends({\n\t\t\tname: url,\n\t\t\taddressU: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\taddressV: isCubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tformat: format,\n\t\t\tcubemap: isCubemap,\n\t\t\tmipmaps: mips > 1\n\t\t}, textureOptions));\n\t\tlet offset = 128;\n\t\tconst faces = isCubemap ? 6 : 1;\n\t\tlet mipSize;\n\t\tconst DXT_BLOCK_WIDTH = 4;\n\t\tconst DXT_BLOCK_HEIGHT = 4;\n\t\tconst blockSize = fcc === FCC_DXT1 ? 8 : 16;\n\t\tlet numBlocksAcross, numBlocksDown, numBlocks;\n\t\tfor (let face = 0; face < faces; face++) {\n\t\t\tlet mipWidth = width;\n\t\t\tlet mipHeight = height;\n\t\t\tfor (let i = 0; i < mips; i++) {\n\t\t\t\tif (compressed) {\n\t\t\t\t\tif (etc1) {\n\t\t\t\t\t\tmipSize = Math.floor((mipWidth + 3) / 4) * Math.floor((mipHeight + 3) / 4) * 8;\n\t\t\t\t\t} else if (pvrtc2) {\n\t\t\t\t\t\tmipSize = Math.max(mipWidth, 16) * Math.max(mipHeight, 8) / 4;\n\t\t\t\t\t} else if (pvrtc4) {\n\t\t\t\t\t\tmipSize = Math.max(mipWidth, 8) * Math.max(mipHeight, 8) / 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnumBlocksAcross = Math.floor((mipWidth + DXT_BLOCK_WIDTH - 1) / DXT_BLOCK_WIDTH);\n\t\t\t\t\t\tnumBlocksDown = Math.floor((mipHeight + DXT_BLOCK_HEIGHT - 1) / DXT_BLOCK_HEIGHT);\n\t\t\t\t\t\tnumBlocks = numBlocksAcross * numBlocksDown;\n\t\t\t\t\t\tmipSize = numBlocks * blockSize;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tmipSize = mipWidth * mipHeight * 4;\n\t\t\t\t}\n\t\t\t\tconst mipBuff = format === PIXELFORMAT_RGBA32F ? new Float32Array(data, offset, mipSize) : format === PIXELFORMAT_RGBA16F ? new Uint16Array(data, offset, mipSize) : new Uint8Array(data, offset, mipSize);\n\t\t\t\tif (!isCubemap) {\n\t\t\t\t\ttexture._levels[i] = mipBuff;\n\t\t\t\t} else {\n\t\t\t\t\tif (!texture._levels[i]) texture._levels[i] = [];\n\t\t\t\t\ttexture._levels[i][face] = mipBuff;\n\t\t\t\t}\n\t\t\t\toffset += mipSize * componentSize;\n\t\t\t\tmipWidth = Math.max(mipWidth * 0.5, 1);\n\t\t\t\tmipHeight = Math.max(mipHeight * 0.5, 1);\n\t\t\t}\n\t\t}\n\t\ttexture.upload();\n\t\treturn texture;\n\t}\n}\n\nexport { DdsParser };\n","import { extends as _extends } from '../../../../_virtual/_rollupPluginBabelHelpers.js';\nimport { ReadStream } from '../../../core/read-stream.js';\nimport { ADDRESS_REPEAT, ADDRESS_CLAMP_TO_EDGE, FILTER_NEAREST, PIXELFORMAT_RGBA8, TEXTURETYPE_RGBE } from '../../../platform/graphics/constants.js';\nimport { Texture } from '../../../platform/graphics/texture.js';\nimport { Asset } from '../../asset/asset.js';\nimport { TextureParser } from './texture.js';\n\nclass HdrParser extends TextureParser {\n\tconstructor(registry) {\n\t\tsuper();\n\t\tthis.maxRetries = 0;\n\t}\n\tload(url, callback, asset) {\n\t\tAsset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);\n\t}\n\topen(url, data, device, textureOptions = {}) {\n\t\tconst textureData = this.parse(data);\n\t\tif (!textureData) {\n\t\t\treturn null;\n\t\t}\n\t\tconst texture = new Texture(device, _extends({\n\t\t\tname: url,\n\t\t\taddressU: ADDRESS_REPEAT,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\twidth: textureData.width,\n\t\t\theight: textureData.height,\n\t\t\tlevels: textureData.levels,\n\t\t\tformat: PIXELFORMAT_RGBA8,\n\t\t\ttype: TEXTURETYPE_RGBE,\n\t\t\tmipmaps: false\n\t\t}, textureOptions));\n\t\ttexture.upload();\n\t\treturn texture;\n\t}\n\tparse(data) {\n\t\tconst readStream = new ReadStream(data);\n\t\tconst magic = readStream.readLine();\n\t\tif (!magic.startsWith('#?RADIANCE')) {\n\t\t\treturn null;\n\t\t}\n\t\tconst variables = {};\n\t\twhile (true) {\n\t\t\tconst line = readStream.readLine();\n\t\t\tif (line.length === 0) {\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tconst parts = line.split('=');\n\t\t\t\tif (parts.length === 2) {\n\t\t\t\t\tvariables[parts[0]] = parts[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!variables.hasOwnProperty('FORMAT')) {\n\t\t\treturn null;\n\t\t}\n\t\tconst resolution = readStream.readLine().split(' ');\n\t\tif (resolution.length !== 4) {\n\t\t\treturn null;\n\t\t}\n\t\tconst height = parseInt(resolution[1], 10);\n\t\tconst width = parseInt(resolution[3], 10);\n\t\tconst pixels = this._readPixels(readStream, width, height, resolution[0] === '-Y');\n\t\tif (!pixels) {\n\t\t\treturn null;\n\t\t}\n\t\treturn {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tlevels: [pixels]\n\t\t};\n\t}\n\t_readPixels(readStream, width, height, flipY) {\n\t\tif (width < 8 || width > 0x7fff) {\n\t\t\treturn this._readPixelsFlat(readStream, width, height);\n\t\t}\n\t\tconst rgbe = [0, 0, 0, 0];\n\t\treadStream.readArray(rgbe);\n\t\tif (rgbe[0] !== 2 || rgbe[1] !== 2 || (rgbe[2] & 0x80) !== 0) {\n\t\t\treadStream.skip(-4);\n\t\t\treturn this._readPixelsFlat(readStream, width, height);\n\t\t}\n\t\tconst buffer = new ArrayBuffer(width * height * 4);\n\t\tconst view = new Uint8Array(buffer);\n\t\tlet scanstart = flipY ? 0 : width * 4 * (height - 1);\n\t\tlet x, y, i, channel, count, value;\n\t\tfor (y = 0; y < height; ++y) {\n\t\t\tif (y) {\n\t\t\t\treadStream.readArray(rgbe);\n\t\t\t}\n\t\t\tif ((rgbe[2] << 8) + rgbe[3] !== width) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tfor (channel = 0; channel < 4; ++channel) {\n\t\t\t\tx = 0;\n\t\t\t\twhile (x < width) {\n\t\t\t\t\tcount = readStream.readU8();\n\t\t\t\t\tif (count > 128) {\n\t\t\t\t\t\tcount -= 128;\n\t\t\t\t\t\tif (x + count > width) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvalue = readStream.readU8();\n\t\t\t\t\t\tfor (i = 0; i < count; ++i) {\n\t\t\t\t\t\t\tview[scanstart + channel + 4 * x++] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (count === 0 || x + count > width) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (i = 0; i < count; ++i) {\n\t\t\t\t\t\t\tview[scanstart + channel + 4 * x++] = readStream.readU8();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tscanstart += width * 4 * (flipY ? 1 : -1);\n\t\t}\n\t\treturn view;\n\t}\n\t_readPixelsFlat(readStream, width, height) {\n\t\treturn readStream.remainingBytes === width * height * 4 ? new Uint8Array(readStream.arraybuffer, readStream.offset) : null;\n\t}\n}\n\nexport { HdrParser };\n","import { extends as _extends } from '../../../../_virtual/_rollupPluginBabelHelpers.js';\nimport { PIXELFORMAT_RGBA8 } from '../../../platform/graphics/constants.js';\nimport { Texture } from '../../../platform/graphics/texture.js';\nimport { http } from '../../../platform/net/http.js';\nimport { ABSOLUTE_URL } from '../../asset/constants.js';\nimport { TextureParser } from './texture.js';\n\nclass ImgParser extends TextureParser {\n\tconstructor(registry, device) {\n\t\tsuper();\n\t\tthis.crossOrigin = registry.prefix ? 'anonymous' : null;\n\t\tthis.maxRetries = 0;\n\t\tthis.device = device;\n\t}\n\tload(url, callback, asset) {\n\t\tvar _asset$file;\n\t\tconst hasContents = !!(asset != null && (_asset$file = asset.file) != null && _asset$file.contents);\n\t\tif (hasContents) {\n\t\t\tif (this.device.supportsImageBitmap) {\n\t\t\t\tthis._loadImageBitmapFromBlob(new Blob([asset.file.contents]), callback);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\turl = {\n\t\t\t\tload: URL.createObjectURL(new Blob([asset.file.contents])),\n\t\t\t\toriginal: url.original\n\t\t\t};\n\t\t}\n\t\tconst handler = (err, result) => {\n\t\t\tif (hasContents) {\n\t\t\t\tURL.revokeObjectURL(url.load);\n\t\t\t}\n\t\t\tcallback(err, result);\n\t\t};\n\t\tlet crossOrigin;\n\t\tif (asset && asset.options && asset.options.hasOwnProperty('crossOrigin')) {\n\t\t\tcrossOrigin = asset.options.crossOrigin;\n\t\t} else if (ABSOLUTE_URL.test(url.load)) {\n\t\t\tcrossOrigin = this.crossOrigin;\n\t\t}\n\t\tif (this.device.supportsImageBitmap) {\n\t\t\tthis._loadImageBitmap(url.load, url.original, crossOrigin, handler);\n\t\t} else {\n\t\t\tthis._loadImage(url.load, url.original, crossOrigin, handler);\n\t\t}\n\t}\n\topen(url, data, device, textureOptions = {}) {\n\t\tconst texture = new Texture(device, _extends({\n\t\t\tname: url,\n\t\t\twidth: data.width,\n\t\t\theight: data.height,\n\t\t\tformat: PIXELFORMAT_RGBA8\n\t\t}, textureOptions));\n\t\ttexture.setSource(data);\n\t\treturn texture;\n\t}\n\t_loadImage(url, originalUrl, crossOrigin, callback) {\n\t\tconst image = new Image();\n\t\tif (crossOrigin) {\n\t\t\timage.crossOrigin = crossOrigin;\n\t\t}\n\t\tlet retries = 0;\n\t\tconst maxRetries = this.maxRetries;\n\t\tlet retryTimeout;\n\t\timage.onload = function () {\n\t\t\tcallback(null, image);\n\t\t};\n\t\timage.onerror = function () {\n\t\t\tif (retryTimeout) return;\n\t\t\tif (maxRetries > 0 && ++retries <= maxRetries) {\n\t\t\t\tconst retryDelay = Math.pow(2, retries) * 100;\n\t\t\t\tconsole.log(`Error loading Texture from: '${originalUrl}' - Retrying in ${retryDelay}ms...`);\n\t\t\t\tconst idx = url.indexOf('?');\n\t\t\t\tconst separator = idx >= 0 ? '&' : '?';\n\t\t\t\tretryTimeout = setTimeout(() => {\n\t\t\t\t\timage.src = `${url + separator}retry=${Date.now()}`;\n\t\t\t\t\tretryTimeout = null;\n\t\t\t\t}, retryDelay);\n\t\t\t} else {\n\t\t\t\tcallback(`Error loading Texture from: '${originalUrl}'`);\n\t\t\t}\n\t\t};\n\t\timage.src = url;\n\t}\n\t_loadImageBitmap(url, originalUrl, crossOrigin, callback) {\n\t\tconst options = {\n\t\t\tcache: true,\n\t\t\tresponseType: 'blob',\n\t\t\tretry: this.maxRetries > 0,\n\t\t\tmaxRetries: this.maxRetries\n\t\t};\n\t\thttp.get(url, options, (err, blob) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(err);\n\t\t\t} else {\n\t\t\t\tthis._loadImageBitmapFromBlob(blob, callback);\n\t\t\t}\n\t\t});\n\t}\n\t_loadImageBitmapFromBlob(blob, callback) {\n\t\tcreateImageBitmap(blob, {\n\t\t\tpremultiplyAlpha: 'none',\n\t\t\tcolorSpaceConversion: 'none'\n\t\t}).then(imageBitmap => callback(null, imageBitmap)).catch(e => callback(e));\n\t}\n}\n\nexport { ImgParser };\n","import { extends as _extends } from '../../../../_virtual/_rollupPluginBabelHelpers.js';\nimport { ADDRESS_CLAMP_TO_EDGE, ADDRESS_REPEAT, PIXELFORMAT_DXT1, PIXELFORMAT_DXT3, PIXELFORMAT_DXT5, PIXELFORMAT_ETC1, PIXELFORMAT_ETC2_RGB, PIXELFORMAT_ETC2_RGBA, PIXELFORMAT_PVRTC_4BPP_RGB_1, PIXELFORMAT_PVRTC_2BPP_RGB_1, PIXELFORMAT_PVRTC_4BPP_RGBA_1, PIXELFORMAT_PVRTC_2BPP_RGBA_1, PIXELFORMAT_RGB8, PIXELFORMAT_RGBA8, PIXELFORMAT_SRGB, PIXELFORMAT_SRGBA, PIXELFORMAT_111110F, PIXELFORMAT_RGB16F, PIXELFORMAT_RGBA16F } from '../../../platform/graphics/constants.js';\nimport { Texture } from '../../../platform/graphics/texture.js';\nimport { Asset } from '../../asset/asset.js';\nimport { TextureParser } from './texture.js';\n\nconst IDENTIFIER = [0x58544BAB, 0xBB313120, 0x0A1A0A0D];\nconst KNOWN_FORMATS = {\n\t0x83F0: PIXELFORMAT_DXT1,\n\t0x83F2: PIXELFORMAT_DXT3,\n\t0x83F3: PIXELFORMAT_DXT5,\n\t0x8D64: PIXELFORMAT_ETC1,\n\t0x9274: PIXELFORMAT_ETC2_RGB,\n\t0x9278: PIXELFORMAT_ETC2_RGBA,\n\t0x8C00: PIXELFORMAT_PVRTC_4BPP_RGB_1,\n\t0x8C01: PIXELFORMAT_PVRTC_2BPP_RGB_1,\n\t0x8C02: PIXELFORMAT_PVRTC_4BPP_RGBA_1,\n\t0x8C03: PIXELFORMAT_PVRTC_2BPP_RGBA_1,\n\t0x8051: PIXELFORMAT_RGB8,\n\t0x8058: PIXELFORMAT_RGBA8,\n\t0x8C41: PIXELFORMAT_SRGB,\n\t0x8C43: PIXELFORMAT_SRGBA,\n\t0x8C3A: PIXELFORMAT_111110F,\n\t0x881B: PIXELFORMAT_RGB16F,\n\t0x881A: PIXELFORMAT_RGBA16F\n};\nfunction createContainer(pixelFormat, buffer, byteOffset, byteSize) {\n\treturn pixelFormat === PIXELFORMAT_111110F ? new Uint32Array(buffer, byteOffset, byteSize / 4) : new Uint8Array(buffer, byteOffset, byteSize);\n}\nclass KtxParser extends TextureParser {\n\tconstructor(registry) {\n\t\tsuper();\n\t\tthis.maxRetries = 0;\n\t}\n\tload(url, callback, asset) {\n\t\tAsset.fetchArrayBuffer(url.load, callback, asset, this.maxRetries);\n\t}\n\topen(url, data, device, textureOptions = {}) {\n\t\tconst textureData = this.parse(data);\n\t\tif (!textureData) {\n\t\t\treturn null;\n\t\t}\n\t\tconst texture = new Texture(device, _extends({\n\t\t\tname: url,\n\t\t\taddressU: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\taddressV: textureData.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\twidth: textureData.width,\n\t\t\theight: textureData.height,\n\t\t\tformat: textureData.format,\n\t\t\tcubemap: textureData.cubemap,\n\t\t\tlevels: textureData.levels\n\t\t}, textureOptions));\n\t\ttexture.upload();\n\t\treturn texture;\n\t}\n\tparse(data) {\n\t\tconst dataU32 = new Uint32Array(data);\n\t\tif (IDENTIFIER[0] !== dataU32[0] || IDENTIFIER[1] !== dataU32[1] || IDENTIFIER[2] !== dataU32[2]) {\n\t\t\treturn null;\n\t\t}\n\t\tconst header = {\n\t\t\tendianness: dataU32[3],\n\t\t\tglType: dataU32[4],\n\t\t\tglTypeSize: dataU32[5],\n\t\t\tglFormat: dataU32[6],\n\t\t\tglInternalFormat: dataU32[7],\n\t\t\tglBaseInternalFormat: dataU32[8],\n\t\t\tpixelWidth: dataU32[9],\n\t\t\tpixelHeight: dataU32[10],\n\t\t\tpixelDepth: dataU32[11],\n\t\t\tnumberOfArrayElements: dataU32[12],\n\t\t\tnumberOfFaces: dataU32[13],\n\t\t\tnumberOfMipmapLevels: dataU32[14],\n\t\t\tbytesOfKeyValueData: dataU32[15]\n\t\t};\n\t\tif (header.pixelDepth > 1) {\n\t\t\treturn null;\n\t\t}\n\t\tif (header.numberOfArrayElements !== 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst format = KNOWN_FORMATS[header.glInternalFormat];\n\t\tif (format === undefined) {\n\t\t\treturn null;\n\t\t}\n\t\tlet offset = 16 + header.bytesOfKeyValueData / 4;\n\t\tconst isCubemap = header.numberOfFaces > 1;\n\t\tconst levels = [];\n\t\tfor (let mipmapLevel = 0; mipmapLevel < (header.numberOfMipmapLevels || 1); mipmapLevel++) {\n\t\t\tconst imageSizeInBytes = dataU32[offset++];\n\t\t\tif (isCubemap) {\n\t\t\t\tlevels.push([]);\n\t\t\t}\n\t\t\tconst target = isCubemap ? levels[mipmapLevel] : levels;\n\t\t\tfor (let face = 0; face < (isCubemap ? 6 : 1); ++face) {\n\t\t\t\ttarget.push(createContainer(format, data, offset * 4, imageSizeInBytes));\n\t\t\t\toffset += imageSizeInBytes + 3 >> 2;\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tformat: format,\n\t\t\twidth: header.pixelWidth,\n\t\t\theight: header.pixelHeight,\n\t\t\tlevels: levels,\n\t\t\tcubemap: isCubemap\n\t\t};\n\t}\n}\n\nexport { KtxParser };\n","import { extends as _extends } from '../../../../_virtual/_rollupPluginBabelHelpers.js';\nimport { ReadStream } from '../../../core/read-stream.js';\nimport { ADDRESS_CLAMP_TO_EDGE, ADDRESS_REPEAT } from '../../../platform/graphics/constants.js';\nimport { Texture } from '../../../platform/graphics/texture.js';\nimport { Asset } from '../../asset/asset.js';\nimport { basisTranscode } from '../../handlers/basis.js';\nimport { TextureParser } from './texture.js';\n\nconst KHRConstants = {\n\tKHR_DF_MODEL_ETC1S: 163,\n\tKHR_DF_MODEL_UASTC: 166\n};\nclass Ktx2Parser extends TextureParser {\n\tconstructor(registry, device) {\n\t\tsuper();\n\t\tthis.maxRetries = 0;\n\t\tthis.device = device;\n\t}\n\tload(url, callback, asset) {\n\t\tAsset.fetchArrayBuffer(url.load, (err, result) => {\n\t\t\tif (err) {\n\t\t\t\tcallback(err, result);\n\t\t\t} else {\n\t\t\t\tthis.parse(result, url, callback, asset);\n\t\t\t}\n\t\t}, asset, this.maxRetries);\n\t}\n\topen(url, data, device, textureOptions = {}) {\n\t\tconst texture = new Texture(device, _extends({\n\t\t\tname: url,\n\t\t\taddressU: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\taddressV: data.cubemap ? ADDRESS_CLAMP_TO_EDGE : ADDRESS_REPEAT,\n\t\t\twidth: data.width,\n\t\t\theight: data.height,\n\t\t\tformat: data.format,\n\t\t\tcubemap: data.cubemap,\n\t\t\tlevels: data.levels\n\t\t}, textureOptions));\n\t\ttexture.upload();\n\t\treturn texture;\n\t}\n\tparse(arraybuffer, url, callback, asset) {\n\t\tconst rs = new ReadStream(arraybuffer);\n\t\tconst magic = [rs.readU32be(), rs.readU32be(), rs.readU32be()];\n\t\tif (magic[0] !== 0xAB4B5458 || magic[1] !== 0x203230BB || magic[2] !== 0x0D0A1A0A) {\n\t\t\treturn null;\n\t\t}\n\t\tconst header = {\n\t\t\tvkFormat: rs.readU32(),\n\t\t\ttypeSize: rs.readU32(),\n\t\t\tpixelWidth: rs.readU32(),\n\t\t\tpixelHeight: rs.readU32(),\n\t\t\tpixelDepth: rs.readU32(),\n\t\t\tlayerCount: rs.readU32(),\n\t\t\tfaceCount: rs.readU32(),\n\t\t\tlevelCount: rs.readU32(),\n\t\t\tsupercompressionScheme: rs.readU32()\n\t\t};\n\t\tconst index = {\n\t\t\tdfdByteOffset: rs.readU32(),\n\t\t\tdfdByteLength: rs.readU32(),\n\t\t\tkvdByteOffset: rs.readU32(),\n\t\t\tkvdByteLength: rs.readU32(),\n\t\t\tsgdByteOffset: rs.readU64(),\n\t\t\tsgdByteLength: rs.readU64()\n\t\t};\n\t\tconst levels = [];\n\t\tfor (let i = 0; i < Math.max(1, header.levelCount); ++i) {\n\t\t\tlevels.push({\n\t\t\t\tbyteOffset: rs.readU64(),\n\t\t\t\tbyteLength: rs.readU64(),\n\t\t\t\tuncompressedByteLength: rs.readU64()\n\t\t\t});\n\t\t}\n\t\tconst dfdTotalSize = rs.readU32();\n\t\tif (dfdTotalSize !== index.kvdByteOffset - index.dfdByteOffset) {\n\t\t\treturn null;\n\t\t}\n\t\trs.skip(8);\n\t\tconst colorModel = rs.readU8();\n\t\trs.skip(index.dfdByteLength - 9);\n\t\trs.skip(index.kvdByteLength);\n\t\tif (header.supercompressionScheme === 1 || colorModel === KHRConstants.KHR_DF_MODEL_UASTC) {\n\t\t\tvar _asset$file;\n\t\t\tconst basisModuleFound = basisTranscode(this.device, url.load, arraybuffer, callback, {\n\t\t\t\tisGGGR: ((asset == null || (_asset$file = asset.file) == null || (_asset$file = _asset$file.variants) == null || (_asset$file = _asset$file.basis) == null ? void 0 : _asset$file.opt) & 8) !== 0,\n\t\t\t\tisKTX2: true\n\t\t\t});\n\t\t\tif (!basisModuleFound) {\n\t\t\t\tcallback(`Basis module not found. Asset \"${asset.name}\" basis texture variant will not be loaded.`);\n\t\t\t}\n\t\t} else {\n\t\t\tcallback('unsupported KTX2 pixel format');\n\t\t}\n\t}\n}\n\nexport { Ktx2Parser };\n","class TextureParser {\n\tload(url, callback, asset) {\n\t\tthrow new Error('not implemented');\n\t}\n\topen(url, data, device) {\n\t\tthrow new Error('not implemented');\n\t}\n}\n\nexport { TextureParser };\n","class SceneRegistryItem {\n\tconstructor(name, url) {\n\t\tthis.name = void 0;\n\t\tthis.url = void 0;\n\t\tthis.data = null;\n\t\tthis._loading = false;\n\t\tthis._onLoadedCallbacks = [];\n\t\tthis.name = name;\n\t\tthis.url = url;\n\t}\n\tget loaded() {\n\t\treturn !!this.data;\n\t}\n\tget loading() {\n\t\treturn this._loading;\n\t}\n}\n\nexport { SceneRegistryItem };\n","import { path } from '../core/path.js';\nimport { ABSOLUTE_URL } from './asset/constants.js';\nimport { SceneRegistryItem } from './scene-registry-item.js';\n\nclass SceneRegistry {\n\tconstructor(app) {\n\t\tthis._app = void 0;\n\t\tthis._list = [];\n\t\tthis._index = {};\n\t\tthis._urlIndex = {};\n\t\tthis._app = app;\n\t}\n\tdestroy() {\n\t\tthis._app = null;\n\t}\n\tlist() {\n\t\treturn this._list;\n\t}\n\tadd(name, url) {\n\t\tif (this._index.hasOwnProperty(name)) {\n\t\t\treturn false;\n\t\t}\n\t\tconst item = new SceneRegistryItem(name, url);\n\t\tconst i = this._list.push(item);\n\t\tthis._index[item.name] = i - 1;\n\t\tthis._urlIndex[item.url] = i - 1;\n\t\treturn true;\n\t}\n\tfind(name) {\n\t\tif (this._index.hasOwnProperty(name)) {\n\t\t\treturn this._list[this._index[name]];\n\t\t}\n\t\treturn null;\n\t}\n\tfindByUrl(url) {\n\t\tif (this._urlIndex.hasOwnProperty(url)) {\n\t\t\treturn this._list[this._urlIndex[url]];\n\t\t}\n\t\treturn null;\n\t}\n\tremove(name) {\n\t\tif (this._index.hasOwnProperty(name)) {\n\t\t\tconst idx = this._index[name];\n\t\t\tlet item = this._list[idx];\n\t\t\tdelete this._urlIndex[item.url];\n\t\t\tdelete this._index[name];\n\t\t\tthis._list.splice(idx, 1);\n\t\t\tfor (let i = 0; i < this._list.length; i++) {\n\t\t\t\titem = this._list[i];\n\t\t\t\tthis._index[item.name] = i;\n\t\t\t\tthis._urlIndex[item.url] = i;\n\t\t\t}\n\t\t}\n\t}\n\t_loadSceneData(sceneItem, storeInCache, callback) {\n\t\tconst app = this._app;\n\t\tlet url = sceneItem;\n\t\tif (typeof sceneItem === 'string') {\n\t\t\tsceneItem = this.findByUrl(url) || this.find(url) || new SceneRegistryItem('Untitled', url);\n\t\t}\n\t\turl = sceneItem.url;\n\t\tif (!url) {\n\t\t\tcallback('Cannot find scene to load');\n\t\t\treturn;\n\t\t}\n\t\tif (sceneItem.loaded) {\n\t\t\tcallback(null, sceneItem);\n\t\t\treturn;\n\t\t}\n\t\tif (app.assets && app.assets.prefix && !ABSOLUTE_URL.test(url)) {\n\t\t\turl = path.join(app.assets.prefix, url);\n\t\t}\n\t\tsceneItem._onLoadedCallbacks.push(callback);\n\t\tif (!sceneItem._loading) {\n\t\t\tconst handler = app.loader.getHandler('hierarchy');\n\t\t\thandler.load(url, (err, data) => {\n\t\t\t\tsceneItem.data = data;\n\t\t\t\tsceneItem._loading = false;\n\t\t\t\tfor (let i = 0; i < sceneItem._onLoadedCallbacks.length; i++) {\n\t\t\t\t\tsceneItem._onLoadedCallbacks[i](err, sceneItem);\n\t\t\t\t}\n\t\t\t\tif (!storeInCache) {\n\t\t\t\t\tsceneItem.data = null;\n\t\t\t\t}\n\t\t\t\tsceneItem._onLoadedCallbacks.length = 0;\n\t\t\t});\n\t\t}\n\t\tsceneItem._loading = true;\n\t}\n\tloadSceneData(sceneItem, callback) {\n\t\tthis._loadSceneData(sceneItem, true, callback);\n\t}\n\tunloadSceneData(sceneItem) {\n\t\tif (typeof sceneItem === 'string') {\n\t\t\tsceneItem = this.findByUrl(sceneItem);\n\t\t}\n\t\tif (sceneItem) {\n\t\t\tsceneItem.data = null;\n\t\t}\n\t}\n\t_loadSceneHierarchy(sceneItem, onBeforeAddHierarchy, callback) {\n\t\tthis._loadSceneData(sceneItem, false, (err, sceneItem) => {\n\t\t\tif (err) {\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(err);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (onBeforeAddHierarchy) {\n\t\t\t\tonBeforeAddHierarchy(sceneItem);\n\t\t\t}\n\t\t\tconst app = this._app;\n\t\t\tconst _loaded = () => {\n\t\t\t\tconst handler = app.loader.getHandler('hierarchy');\n\t\t\t\tapp.systems.script.preloading = true;\n\t\t\t\tconst entity = handler.open(sceneItem.url, sceneItem.data);\n\t\t\t\tapp.systems.script.preloading = false;\n\t\t\t\tapp.loader.clearCache(sceneItem.url, 'hierarchy');\n\t\t\t\tapp.root.addChild(entity);\n\t\t\t\tapp.systems.fire('initialize', entity);\n\t\t\t\tapp.systems.fire('postInitialize', entity);\n\t\t\t\tapp.systems.fire('postPostInitialize', entity);\n\t\t\t\tif (callback) callback(null, entity);\n\t\t\t};\n\t\t\tapp._preloadScripts(sceneItem.data, _loaded);\n\t\t});\n\t}\n\tloadSceneHierarchy(sceneItem, callback) {\n\t\tthis._loadSceneHierarchy(sceneItem, null, callback);\n\t}\n\tloadSceneSettings(sceneItem, callback) {\n\t\tthis._loadSceneData(sceneItem, false, (err, sceneItem) => {\n\t\t\tif (!err) {\n\t\t\t\tthis._app.applySceneSettings(sceneItem.data.settings);\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(null);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(err);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\tchangeScene(sceneItem, callback) {\n\t\tconst app = this._app;\n\t\tconst onBeforeAddHierarchy = sceneItem => {\n\t\t\tconst {\n\t\t\t\tchildren\n\t\t\t} = app.root;\n\t\t\twhile (children.length) {\n\t\t\t\tchildren[0].destroy();\n\t\t\t}\n\t\t\tapp.applySceneSettings(sceneItem.data.settings);\n\t\t};\n\t\tthis._loadSceneHierarchy(sceneItem, onBeforeAddHierarchy, callback);\n\t}\n\tloadScene(url, callback) {\n\t\tconst app = this._app;\n\t\tconst handler = app.loader.getHandler('scene');\n\t\tif (app.assets && app.assets.prefix && !ABSOLUTE_URL.test(url)) {\n\t\t\turl = path.join(app.assets.prefix, url);\n\t\t}\n\t\thandler.load(url, (err, data) => {\n\t\t\tif (!err) {\n\t\t\t\tconst _loaded = () => {\n\t\t\t\t\tapp.systems.script.preloading = true;\n\t\t\t\t\tconst scene = handler.open(url, data);\n\t\t\t\t\tconst sceneItem = this.findByUrl(url);\n\t\t\t\t\tif (sceneItem && !sceneItem.loaded) {\n\t\t\t\t\t\tsceneItem.data = data;\n\t\t\t\t\t}\n\t\t\t\t\tapp.systems.script.preloading = false;\n\t\t\t\t\tapp.loader.clearCache(url, 'scene');\n\t\t\t\t\tapp.loader.patch({\n\t\t\t\t\t\tresource: scene,\n\t\t\t\t\t\ttype: 'scene'\n\t\t\t\t\t}, app.assets);\n\t\t\t\t\tapp.root.addChild(scene.root);\n\t\t\t\t\tif (app.systems.rigidbody && typeof Ammo !== 'undefined') {\n\t\t\t\t\t\tapp.systems.rigidbody.gravity.set(scene._gravity.x, scene._gravity.y, scene._gravity.z);\n\t\t\t\t\t}\n\t\t\t\t\tif (callback) {\n\t\t\t\t\t\tcallback(null, scene);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tapp._preloadScripts(data, _loaded);\n\t\t\t} else {\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(err);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport { SceneRegistry };\n","import { events } from '../core/events.js';\nimport { getApplication } from './globals.js';\nimport { ScriptTypes } from './script/script-types.js';\n\nlet _legacy = false;\nlet _createdLoadingScreen = false;\nconst script = {\n\tapp: null,\n\tcreate(name, callback) {\n\t\tif (!_legacy) {\n\t\t\treturn;\n\t\t}\n\t\tconst ScriptType = callback(script.app);\n\t\tScriptType._pcScriptName = name;\n\t\tScriptTypes.push(ScriptType, _legacy);\n\t\tthis.fire('created', name, callback);\n\t},\n\tattribute(name, type, defaultValue, options) {},\n\tcreateLoadingScreen(callback) {\n\t\tif (_createdLoadingScreen) {\n\t\t\treturn;\n\t\t}\n\t\t_createdLoadingScreen = true;\n\t\tconst app = getApplication();\n\t\tcallback(app);\n\t}\n};\nObject.defineProperty(script, 'legacy', {\n\tget: function () {\n\t\treturn _legacy;\n\t},\n\tset: function (value) {\n\t\t_legacy = value;\n\t}\n});\nevents.attach(script);\n\nexport { script };\n","const SCRIPT_INITIALIZE = 'initialize';\nconst SCRIPT_POST_INITIALIZE = 'postInitialize';\nconst SCRIPT_UPDATE = 'update';\nconst SCRIPT_POST_UPDATE = 'postUpdate';\nconst SCRIPT_SWAP = 'swap';\n\nexport { SCRIPT_INITIALIZE, SCRIPT_POST_INITIALIZE, SCRIPT_POST_UPDATE, SCRIPT_SWAP, SCRIPT_UPDATE };\n","import { Color } from '../../core/math/color.js';\nimport { Curve } from '../../core/math/curve.js';\nimport { CurveSet } from '../../core/math/curve-set.js';\nimport { Vec2 } from '../../core/math/vec2.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { Vec4 } from '../../core/math/vec4.js';\nimport { GraphNode } from '../../scene/graph-node.js';\nimport { Asset } from '../asset/asset.js';\n\nconst components = ['x', 'y', 'z', 'w'];\nconst vecLookup = [undefined, undefined, Vec2, Vec3, Vec4];\nfunction rawToValue(app, args, value, old) {\n\tswitch (args.type) {\n\t\tcase 'boolean':\n\t\t\treturn !!value;\n\t\tcase 'number':\n\t\t\tif (typeof value === 'number') {\n\t\t\t\treturn value;\n\t\t\t} else if (typeof value === 'string') {\n\t\t\t\tconst v = parseInt(value, 10);\n\t\t\t\tif (isNaN(v)) return null;\n\t\t\t\treturn v;\n\t\t\t} else if (typeof value === 'boolean') {\n\t\t\t\treturn 0 + value;\n\t\t\t}\n\t\t\treturn null;\n\t\tcase 'json':\n\t\t\t{\n\t\t\t\tconst result = {};\n\t\t\t\tif (Array.isArray(args.schema)) {\n\t\t\t\t\tif (!value || typeof value !== 'object') {\n\t\t\t\t\t\tvalue = {};\n\t\t\t\t\t}\n\t\t\t\t\tfor (let i = 0; i < args.schema.length; i++) {\n\t\t\t\t\t\tconst field = args.schema[i];\n\t\t\t\t\t\tif (!field.name) continue;\n\t\t\t\t\t\tif (field.array) {\n\t\t\t\t\t\t\tresult[field.name] = [];\n\t\t\t\t\t\t\tconst arr = Array.isArray(value[field.name]) ? value[field.name] : [];\n\t\t\t\t\t\t\tfor (let j = 0; j < arr.length; j++) {\n\t\t\t\t\t\t\t\tresult[field.name].push(rawToValue(app, field, arr[j]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst val = value.hasOwnProperty(field.name) ? value[field.name] : field.default;\n\t\t\t\t\t\t\tresult[field.name] = rawToValue(app, field, val);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\tcase 'asset':\n\t\t\tif (value instanceof Asset) {\n\t\t\t\treturn value;\n\t\t\t} else if (typeof value === 'number') {\n\t\t\t\treturn app.assets.get(value) || null;\n\t\t\t} else if (typeof value === 'string') {\n\t\t\t\treturn app.assets.get(parseInt(value, 10)) || null;\n\t\t\t}\n\t\t\treturn null;\n\t\tcase 'entity':\n\t\t\tif (value instanceof GraphNode) {\n\t\t\t\treturn value;\n\t\t\t} else if (typeof value === 'string') {\n\t\t\t\treturn app.getEntityFromIndex(value);\n\t\t\t}\n\t\t\treturn null;\n\t\tcase 'rgb':\n\t\tcase 'rgba':\n\t\t\tif (value instanceof Color) {\n\t\t\t\tif (old instanceof Color) {\n\t\t\t\t\told.copy(value);\n\t\t\t\t\treturn old;\n\t\t\t\t}\n\t\t\t\treturn value.clone();\n\t\t\t} else if (value instanceof Array && value.length >= 3 && value.length <= 4) {\n\t\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\t\tif (typeof value[i] !== 'number') {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!old) old = new Color();\n\t\t\t\told.r = value[0];\n\t\t\t\told.g = value[1];\n\t\t\t\told.b = value[2];\n\t\t\t\told.a = value.length === 3 ? 1 : value[3];\n\t\t\t\treturn old;\n\t\t\t} else if (typeof value === 'string' && /#(?:[0-9a-f]{2}){3,4}/i.test(value)) {\n\t\t\t\tif (!old) {\n\t\t\t\t\told = new Color();\n\t\t\t\t}\n\t\t\t\told.fromString(value);\n\t\t\t\treturn old;\n\t\t\t}\n\t\t\treturn null;\n\t\tcase 'vec2':\n\t\tcase 'vec3':\n\t\tcase 'vec4':\n\t\t\t{\n\t\t\t\tconst len = parseInt(args.type.slice(3), 10);\n\t\t\t\tconst vecType = vecLookup[len];\n\t\t\t\tif (value instanceof vecType) {\n\t\t\t\t\tif (old instanceof vecType) {\n\t\t\t\t\t\told.copy(value);\n\t\t\t\t\t\treturn old;\n\t\t\t\t\t}\n\t\t\t\t\treturn value.clone();\n\t\t\t\t} else if (value instanceof Array && value.length === len) {\n\t\t\t\t\tfor (let i = 0; i < value.length; i++) {\n\t\t\t\t\t\tif (typeof value[i] !== 'number') {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!old) old = new vecType();\n\t\t\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\t\t\told[components[i]] = value[i];\n\t\t\t\t\t}\n\t\t\t\t\treturn old;\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t}\n\t\tcase 'curve':\n\t\t\tif (value) {\n\t\t\t\tlet curve;\n\t\t\t\tif (value instanceof Curve || value instanceof CurveSet) {\n\t\t\t\t\tcurve = value.clone();\n\t\t\t\t} else {\n\t\t\t\t\tconst CurveType = value.keys[0] instanceof Array ? CurveSet : Curve;\n\t\t\t\t\tcurve = new CurveType(value.keys);\n\t\t\t\t\tcurve.type = value.type;\n\t\t\t\t}\n\t\t\t\treturn curve;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn value;\n}\nfunction attributeToValue(app, schema, value, current) {\n\tif (schema.array) {\n\t\treturn value.map((item, index) => rawToValue(app, schema, item, current ? current[index] : null));\n\t}\n\treturn rawToValue(app, schema, value, current);\n}\nfunction assignAttributesToScript(app, attributeSchemaMap, data, script) {\n\tif (!data) return;\n\tfor (const attributeName in attributeSchemaMap) {\n\t\tconst attributeSchema = attributeSchemaMap[attributeName];\n\t\tconst dataToAssign = data[attributeName];\n\t\tif (dataToAssign === undefined) continue;\n\t\tscript[attributeName] = attributeToValue(app, attributeSchema, dataToAssign, script[attributeName]);\n\t}\n}\nclass ScriptAttributes {\n\tconstructor(scriptType) {\n\t\tthis.scriptType = scriptType;\n\t\tthis.index = {};\n\t}\n\tadd(name, args) {\n\t\tif (this.index[name]) {\n\t\t\treturn;\n\t\t} else if (ScriptAttributes.reservedNames.has(name)) {\n\t\t\treturn;\n\t\t}\n\t\tthis.index[name] = args;\n\t\tObject.defineProperty(this.scriptType.prototype, name, {\n\t\t\tget: function () {\n\t\t\t\treturn this.__attributes[name];\n\t\t\t},\n\t\t\tset: function (raw) {\n\t\t\t\tconst evt = 'attr';\n\t\t\t\tconst evtName = `attr:${name}`;\n\t\t\t\tconst old = this.__attributes[name];\n\t\t\t\tlet oldCopy = old;\n\t\t\t\tif (old && args.type !== 'json' && args.type !== 'entity' && old.clone) {\n\t\t\t\t\tif (this.hasEvent(evt) || this.hasEvent(evtName)) {\n\t\t\t\t\t\toldCopy = old.clone();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (args.array) {\n\t\t\t\t\tthis.__attributes[name] = [];\n\t\t\t\t\tif (raw) {\n\t\t\t\t\t\tfor (let i = 0, len = raw.length; i < len; i++) {\n\t\t\t\t\t\t\tthis.__attributes[name].push(rawToValue(this.app, args, raw[i], old ? old[i] : null));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.__attributes[name] = rawToValue(this.app, args, raw, old);\n\t\t\t\t}\n\t\t\t\tthis.fire(evt, name, this.__attributes[name], oldCopy);\n\t\t\t\tthis.fire(evtName, this.__attributes[name], oldCopy);\n\t\t\t}\n\t\t});\n\t}\n\tremove(name) {\n\t\tif (!this.index[name]) {\n\t\t\treturn false;\n\t\t}\n\t\tdelete this.index[name];\n\t\tdelete this.scriptType.prototype[name];\n\t\treturn true;\n\t}\n\thas(name) {\n\t\treturn !!this.index[name];\n\t}\n\tget(name) {\n\t\treturn this.index[name] || null;\n\t}\n}\nScriptAttributes.assignAttributesToScript = assignAttributesToScript;\nScriptAttributes.attributeToValue = attributeToValue;\nScriptAttributes.reservedNames = new Set(['app', 'entity', 'enabled', '_enabled', '_enabledOld', '_destroyed', '__attributes', '__attributesRaw', '__scriptType', '__executionOrder', '_callbacks', '_callbackActive', 'has', 'get', 'on', 'off', 'fire', 'once', 'hasEvent']);\n\nexport { ScriptAttributes, assignAttributesToScript };\n","import { EventHandler } from '../../core/event-handler.js';\nimport { AppBase } from '../app-base.js';\nimport { ScriptAttributes } from './script-attributes.js';\nimport { ScriptType } from './script-type.js';\nimport { ScriptTypes } from './script-types.js';\nimport { Script } from './script.js';\n\nconst reservedScriptNames = new Set(['system', 'entity', 'create', 'destroy', 'swap', 'move', 'data', 'scripts', '_scripts', '_scriptsIndex', '_scriptsData', 'enabled', '_oldState', 'onEnable', 'onDisable', 'onPostStateChange', '_onSetEnabled', '_checkState', '_onBeforeRemove', '_onInitializeAttributes', '_onInitialize', '_onPostInitialize', '_onUpdate', '_onPostUpdate', '_callbacks', '_callbackActive', 'has', 'get', 'on', 'off', 'fire', 'once', 'hasEvent']);\nfunction getReservedScriptNames() {\n\treturn reservedScriptNames;\n}\nfunction createScript(name, app) {\n\tif (reservedScriptNames.has(name)) {\n\t\tthrow new Error(`Script name '${name}' is reserved, please rename the script`);\n\t}\n\tconst scriptType = function scriptType(args) {\n\t\tEventHandler.prototype.initEventHandler.call(this);\n\t\tScriptType.prototype.initScriptType.call(this, args);\n\t};\n\tscriptType.prototype = Object.create(ScriptType.prototype);\n\tscriptType.prototype.constructor = scriptType;\n\tscriptType.extend = ScriptType.extend;\n\tscriptType.attributes = new ScriptAttributes(scriptType);\n\tregisterScript(scriptType, name, app);\n\treturn scriptType;\n}\nconst reservedAttributes = {};\nScriptAttributes.reservedNames.forEach((value, value2, set) => {\n\treservedAttributes[value] = 1;\n});\ncreateScript.reservedAttributes = reservedAttributes;\nfunction registerScript(script, name, app) {\n\tif (typeof script !== 'function') {\n\t\tthrow new Error(`script class: '${script}' must be a constructor function (i.e. class).`);\n\t}\n\tif (!(script.prototype instanceof Script)) {\n\t\tthrow new Error(`script class: '${ScriptType.__getScriptName(script)}' does not extend pc.Script.`);\n\t}\n\tname = name || script.__name || ScriptType.__getScriptName(script);\n\tif (reservedScriptNames.has(name)) {\n\t\tthrow new Error(`script name: '${name}' is reserved, please change script name`);\n\t}\n\tscript.__name = name;\n\tconst registry = app ? app.scripts : AppBase.getApplication().scripts;\n\tregistry.add(script);\n\tScriptTypes.push(script);\n}\n\nexport { createScript, getReservedScriptNames, registerScript };\n","import { EventHandler } from '../../core/event-handler.js';\n\nclass ScriptRegistry extends EventHandler {\n\tconstructor(app) {\n\t\tsuper();\n\t\tthis._scripts = {};\n\t\tthis._list = [];\n\t\tthis._scriptSchemas = new Map();\n\t\tthis.app = app;\n\t}\n\tdestroy() {\n\t\tthis.app = null;\n\t\tthis.off();\n\t}\n\taddSchema(id, schema) {\n\t\tif (!schema) return;\n\t\tthis._scriptSchemas.set(id, schema);\n\t}\n\tgetSchema(id) {\n\t\treturn this._scriptSchemas.get(id);\n\t}\n\tadd(script) {\n\t\tconst scriptName = script.__name;\n\t\tif (this._scripts.hasOwnProperty(scriptName)) {\n\t\t\tsetTimeout(() => {\n\t\t\t\tif (script.prototype.swap) {\n\t\t\t\t\tconst old = this._scripts[scriptName];\n\t\t\t\t\tconst ind = this._list.indexOf(old);\n\t\t\t\t\tthis._list[ind] = script;\n\t\t\t\t\tthis._scripts[scriptName] = script;\n\t\t\t\t\tthis.fire('swap', scriptName, script);\n\t\t\t\t\tthis.fire(`swap:${scriptName}`, script);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(`script registry already has '${scriptName}' script, define 'swap' method for new script type to enable code hot swapping`);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn false;\n\t\t}\n\t\tthis._scripts[scriptName] = script;\n\t\tthis._list.push(script);\n\t\tthis.fire('add', scriptName, script);\n\t\tthis.fire(`add:${scriptName}`, script);\n\t\tsetTimeout(() => {\n\t\t\tif (!this._scripts.hasOwnProperty(scriptName)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!this.app || !this.app.systems || !this.app.systems.script) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst components = this.app.systems.script._components;\n\t\t\tlet attributes;\n\t\t\tconst scriptInstances = [];\n\t\t\tconst scriptInstancesInitialized = [];\n\t\t\tfor (components.loopIndex = 0; components.loopIndex < components.length; components.loopIndex++) {\n\t\t\t\tconst component = components.items[components.loopIndex];\n\t\t\t\tif (component._scriptsIndex[scriptName] && component._scriptsIndex[scriptName].awaiting) {\n\t\t\t\t\tif (component._scriptsData && component._scriptsData[scriptName]) {\n\t\t\t\t\t\tattributes = component._scriptsData[scriptName].attributes;\n\t\t\t\t\t}\n\t\t\t\t\tconst scriptInstance = component.create(scriptName, {\n\t\t\t\t\t\tpreloading: true,\n\t\t\t\t\t\tind: component._scriptsIndex[scriptName].ind,\n\t\t\t\t\t\tattributes: attributes\n\t\t\t\t\t});\n\t\t\t\t\tif (scriptInstance) {\n\t\t\t\t\t\tscriptInstances.push(scriptInstance);\n\t\t\t\t\t}\n\t\t\t\t\tfor (const script of component.scripts) {\n\t\t\t\t\t\tcomponent.initializeAttributes(script);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i = 0; i < scriptInstances.length; i++) {\n\t\t\t\tif (scriptInstances[i].enabled) {\n\t\t\t\t\tscriptInstances[i]._initialized = true;\n\t\t\t\t\tscriptInstancesInitialized.push(scriptInstances[i]);\n\t\t\t\t\tif (scriptInstances[i].initialize) {\n\t\t\t\t\t\tscriptInstances[i].initialize();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i = 0; i < scriptInstancesInitialized.length; i++) {\n\t\t\t\tif (!scriptInstancesInitialized[i].enabled || scriptInstancesInitialized[i]._postInitialized) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tscriptInstancesInitialized[i]._postInitialized = true;\n\t\t\t\tif (scriptInstancesInitialized[i].postInitialize) {\n\t\t\t\t\tscriptInstancesInitialized[i].postInitialize();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn true;\n\t}\n\tremove(nameOrType) {\n\t\tlet scriptType = nameOrType;\n\t\tlet scriptName = nameOrType;\n\t\tif (typeof scriptName !== 'string') {\n\t\t\tscriptName = scriptType.__name;\n\t\t} else {\n\t\t\tscriptType = this.get(scriptName);\n\t\t}\n\t\tif (this.get(scriptName) !== scriptType) {\n\t\t\treturn false;\n\t\t}\n\t\tdelete this._scripts[scriptName];\n\t\tconst ind = this._list.indexOf(scriptType);\n\t\tthis._list.splice(ind, 1);\n\t\tthis.fire('remove', scriptName, scriptType);\n\t\tthis.fire(`remove:${scriptName}`, scriptType);\n\t\treturn true;\n\t}\n\tget(name) {\n\t\treturn this._scripts[name] || null;\n\t}\n\thas(nameOrType) {\n\t\tif (typeof nameOrType === 'string') {\n\t\t\treturn this._scripts.hasOwnProperty(nameOrType);\n\t\t}\n\t\tif (!nameOrType) return false;\n\t\tconst scriptName = nameOrType.__name;\n\t\treturn this._scripts[scriptName] === nameOrType;\n\t}\n\tlist() {\n\t\treturn this._list;\n\t}\n}\n\nexport { ScriptRegistry };\n","import { ScriptAttributes } from './script-attributes.js';\nimport { Script } from './script.js';\n\nclass ScriptType extends Script {\n\tconstructor(args) {\n\t\tsuper(args);\n\t\tthis.__attributes = void 0;\n\t\tthis.__attributesRaw = void 0;\n\t\tthis.initScriptType(args);\n\t}\n\tstatic get attributes() {\n\t\tif (!this.hasOwnProperty('__attributes')) this.__attributes = new ScriptAttributes(this);\n\t\treturn this.__attributes;\n\t}\n\tinitScript(args) {\n\t\tScript.prototype.initScript.call(this, args);\n\t\tthis.__attributes = {};\n\t\tthis.__attributesRaw = args.attributes || {};\n\t}\n\tinitScriptType(args) {\n\t\tthis.initScript(args);\n\t}\n\t__initializeAttributes(force) {\n\t\tif (!force && !this.__attributesRaw) {\n\t\t\treturn;\n\t\t}\n\t\tfor (const key in this.__scriptType.attributes.index) {\n\t\t\tif (this.__attributesRaw && this.__attributesRaw.hasOwnProperty(key)) {\n\t\t\t\tthis[key] = this.__attributesRaw[key];\n\t\t\t} else if (!this.__attributes.hasOwnProperty(key)) {\n\t\t\t\tif (this.__scriptType.attributes.index[key].hasOwnProperty('default')) {\n\t\t\t\t\tthis[key] = this.__scriptType.attributes.index[key].default;\n\t\t\t\t} else {\n\t\t\t\t\tthis[key] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.__attributesRaw = null;\n\t}\n\tstatic extend(methods) {\n\t\tfor (const key in methods) {\n\t\t\tif (!methods.hasOwnProperty(key)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis.prototype[key] = methods[key];\n\t\t}\n\t}\n}\n\nexport { ScriptType };\n","class ScriptTypes {\n\tstatic push(Type, isLegacy) {\n\t\tif (isLegacy && ScriptTypes._types.length > 0) {\n\t\t\tconsole.assert('Script Ordering Error. Contact support@playcanvas.com');\n\t\t} else {\n\t\t\tScriptTypes._types.push(Type);\n\t\t}\n\t}\n}\nScriptTypes._types = [];\n\nexport { ScriptTypes };\n","import { EventHandler } from '../../core/event-handler.js';\nimport { SCRIPT_INITIALIZE, SCRIPT_POST_INITIALIZE } from './constants.js';\n\nclass Script extends EventHandler {\n\tconstructor(args) {\n\t\tsuper();\n\t\tthis.app = void 0;\n\t\tthis.entity = void 0;\n\t\tthis._enabled = void 0;\n\t\tthis._enabledOld = void 0;\n\t\tthis._initialized = void 0;\n\t\tthis._postInitialized = void 0;\n\t\tthis.__destroyed = void 0;\n\t\tthis.__scriptType = void 0;\n\t\tthis.__executionOrder = void 0;\n\t\tthis.initScript(args);\n\t}\n\tset enabled(value) {\n\t\tthis._enabled = !!value;\n\t\tif (this.enabled === this._enabledOld) return;\n\t\tthis._enabledOld = this.enabled;\n\t\tthis.fire(this.enabled ? 'enable' : 'disable');\n\t\tthis.fire('state', this.enabled);\n\t\tif (!this._initialized && this.enabled) {\n\t\t\tthis._initialized = true;\n\t\t\tthis.fire('preInitialize');\n\t\t\tif (this.initialize) {\n\t\t\t\tthis.entity.script._scriptMethod(this, SCRIPT_INITIALIZE);\n\t\t\t}\n\t\t}\n\t\tif (this._initialized && !this._postInitialized && this.enabled && !this.entity.script._beingEnabled) {\n\t\t\tthis._postInitialized = true;\n\t\t\tif (this.postInitialize) {\n\t\t\t\tthis.entity.script._scriptMethod(this, SCRIPT_POST_INITIALIZE);\n\t\t\t}\n\t\t}\n\t}\n\tget enabled() {\n\t\treturn this._enabled && !this._destroyed && this.entity.script.enabled && this.entity.enabled;\n\t}\n\tinitScript(args) {\n\t\tconst script = this.constructor;\n\t\tthis.app = args.app;\n\t\tthis.entity = args.entity;\n\t\tthis._enabled = typeof args.enabled === 'boolean' ? args.enabled : true;\n\t\tthis._enabledOld = this.enabled;\n\t\tthis.__destroyed = false;\n\t\tthis.__scriptType = script;\n\t\tthis.__executionOrder = -1;\n\t}\n\tstatic get scriptName() {\n\t\treturn this.__name;\n\t}\n}\nScript.EVENT_ENABLE = 'enable';\nScript.EVENT_DISABLE = 'disable';\nScript.EVENT_STATE = 'state';\nScript.EVENT_DESTROY = 'destroy';\nScript.EVENT_ATTR = 'attr';\nScript.EVENT_ERROR = 'error';\nScript.__name = null;\nScript.__getScriptName = getScriptName;\nconst funcNameRegex = /^\\s*function(?:\\s|\\s*\\/\\*.*\\*\\/\\s*)+([^(\\s\\/]*)\\s*/;\nfunction getScriptName(constructorFn) {\n\tif (typeof constructorFn !== 'function') return undefined;\n\tif ('name' in Function.prototype) return constructorFn.name;\n\tif (constructorFn === Function || constructorFn === Function.prototype.constructor) return 'Function';\n\tconst match = `${constructorFn}`.match(funcNameRegex);\n\treturn match ? match[1] : undefined;\n}\n\nexport { Script, getScriptName };\n","import { getApplication } from './globals.js';\n\nclass ApplicationStats {\n\tconstructor(device) {\n\t\tthis.frame = {\n\t\t\tfps: 0,\n\t\t\tms: 0,\n\t\t\tdt: 0,\n\t\t\tupdateStart: 0,\n\t\t\tupdateTime: 0,\n\t\t\trenderStart: 0,\n\t\t\trenderTime: 0,\n\t\t\tphysicsStart: 0,\n\t\t\tphysicsTime: 0,\n\t\t\tcullTime: 0,\n\t\t\tsortTime: 0,\n\t\t\tskinTime: 0,\n\t\t\tmorphTime: 0,\n\t\t\tinstancingTime: 0,\n\t\t\ttriangles: 0,\n\t\t\totherPrimitives: 0,\n\t\t\tshaders: 0,\n\t\t\tmaterials: 0,\n\t\t\tcameras: 0,\n\t\t\tshadowMapUpdates: 0,\n\t\t\tshadowMapTime: 0,\n\t\t\tdepthMapTime: 0,\n\t\t\tforwardTime: 0,\n\t\t\tlightClustersTime: 0,\n\t\t\tlightClusters: 0,\n\t\t\t_timeToCountFrames: 0,\n\t\t\t_fpsAccum: 0\n\t\t};\n\t\tthis.drawCalls = {\n\t\t\tforward: 0,\n\t\t\tdepth: 0,\n\t\t\tshadow: 0,\n\t\t\timmediate: 0,\n\t\t\tmisc: 0,\n\t\t\ttotal: 0,\n\t\t\tskinned: 0,\n\t\t\tinstanced: 0,\n\t\t\tremovedByInstancing: 0\n\t\t};\n\t\tthis.misc = {\n\t\t\trenderTargetCreationTime: 0\n\t\t};\n\t\tthis.particles = {\n\t\t\tupdatesPerFrame: 0,\n\t\t\t_updatesPerFrame: 0,\n\t\t\tframeTime: 0,\n\t\t\t_frameTime: 0\n\t\t};\n\t\tthis.shaders = device._shaderStats;\n\t\tthis.vram = device._vram;\n\t\tObject.defineProperty(this.vram, 'totalUsed', {\n\t\t\tget: function () {\n\t\t\t\treturn this.tex + this.vb + this.ib;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(this.vram, 'geom', {\n\t\t\tget: function () {\n\t\t\t\treturn this.vb + this.ib;\n\t\t\t}\n\t\t});\n\t}\n\tget scene() {\n\t\treturn getApplication().scene._stats;\n\t}\n\tget lightmapper() {\n\t\tvar _getApplication$light;\n\t\treturn (_getApplication$light = getApplication().lightmapper) == null ? void 0 : _getApplication$light.stats;\n\t}\n\tget batcher() {\n\t\tconst batcher = getApplication()._batcher;\n\t\treturn batcher ? batcher._stats : null;\n\t}\n}\n\nexport { ApplicationStats };\n","import { SceneParser } from './parsers/scene.js';\n\nclass Template {\n\tconstructor(app, data) {\n\t\tthis._app = void 0;\n\t\tthis._data = void 0;\n\t\tthis._templateRoot = null;\n\t\tthis._app = app;\n\t\tthis._data = data;\n\t}\n\tinstantiate() {\n\t\tif (!this._templateRoot) {\n\t\t\tthis._parseTemplate();\n\t\t}\n\t\treturn this._templateRoot.clone();\n\t}\n\t_parseTemplate() {\n\t\tconst parser = new SceneParser(this._app, true);\n\t\tthis._templateRoot = parser.parse(this._data);\n\t}\n}\n\nexport { Template };\n","const XRTYPE_INLINE = 'inline';\nconst XRTYPE_VR = 'immersive-vr';\nconst XRTYPE_AR = 'immersive-ar';\nconst XRSPACE_VIEWER = 'viewer';\nconst XRSPACE_LOCAL = 'local';\nconst XRSPACE_LOCALFLOOR = 'local-floor';\nconst XRSPACE_BOUNDEDFLOOR = 'bounded-floor';\nconst XRSPACE_UNBOUNDED = 'unbounded';\nconst XRTARGETRAY_GAZE = 'gaze';\nconst XRTARGETRAY_SCREEN = 'screen';\nconst XRTARGETRAY_POINTER = 'tracked-pointer';\nconst XREYE_NONE = 'none';\nconst XREYE_LEFT = 'left';\nconst XREYE_RIGHT = 'right';\nconst XRHAND_NONE = 'none';\nconst XRHAND_LEFT = 'left';\nconst XRHAND_RIGHT = 'right';\nconst XRTRACKABLE_POINT = 'point';\nconst XRTRACKABLE_PLANE = 'plane';\nconst XRTRACKABLE_MESH = 'mesh';\nconst XRDEPTHSENSINGUSAGE_CPU = 'cpu-optimized';\nconst XRDEPTHSENSINGUSAGE_GPU = 'gpu-optimized';\nconst XRDEPTHSENSINGFORMAT_L8A8 = 'luminance-alpha';\nconst XRDEPTHSENSINGFORMAT_F32 = 'float32';\n\nexport { XRDEPTHSENSINGFORMAT_F32, XRDEPTHSENSINGFORMAT_L8A8, XRDEPTHSENSINGUSAGE_CPU, XRDEPTHSENSINGUSAGE_GPU, XREYE_LEFT, XREYE_NONE, XREYE_RIGHT, XRHAND_LEFT, XRHAND_NONE, XRHAND_RIGHT, XRSPACE_BOUNDEDFLOOR, XRSPACE_LOCAL, XRSPACE_LOCALFLOOR, XRSPACE_UNBOUNDED, XRSPACE_VIEWER, XRTARGETRAY_GAZE, XRTARGETRAY_POINTER, XRTARGETRAY_SCREEN, XRTRACKABLE_MESH, XRTRACKABLE_PLANE, XRTRACKABLE_POINT, XRTYPE_AR, XRTYPE_INLINE, XRTYPE_VR };\n","import { EventHandler } from '../../core/event-handler.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { Quat } from '../../core/math/quat.js';\n\nclass XrAnchor extends EventHandler {\n\tconstructor(anchors, xrAnchor, uuid = null) {\n\t\tsuper();\n\t\tthis._position = new Vec3();\n\t\tthis._rotation = new Quat();\n\t\tthis._uuid = null;\n\t\tthis._uuidRequests = null;\n\t\tthis._anchors = anchors;\n\t\tthis._xrAnchor = xrAnchor;\n\t\tthis._uuid = uuid;\n\t}\n\tdestroy() {\n\t\tif (!this._xrAnchor) return;\n\t\tconst xrAnchor = this._xrAnchor;\n\t\tthis._xrAnchor.delete();\n\t\tthis._xrAnchor = null;\n\t\tthis.fire('destroy', xrAnchor, this);\n\t}\n\tupdate(frame) {\n\t\tif (!this._xrAnchor) {\n\t\t\treturn;\n\t\t}\n\t\tconst pose = frame.getPose(this._xrAnchor.anchorSpace, this._anchors.manager._referenceSpace);\n\t\tif (pose) {\n\t\t\tif (this._position.equals(pose.transform.position) && this._rotation.equals(pose.transform.orientation)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._position.copy(pose.transform.position);\n\t\t\tthis._rotation.copy(pose.transform.orientation);\n\t\t\tthis.fire('change');\n\t\t}\n\t}\n\tgetPosition() {\n\t\treturn this._position;\n\t}\n\tgetRotation() {\n\t\treturn this._rotation;\n\t}\n\tpersist(callback) {\n\t\tif (!this._anchors.persistence) {\n\t\t\tcallback == null || callback(new Error('Persistent Anchors are not supported'), null);\n\t\t\treturn;\n\t\t}\n\t\tif (this._uuid) {\n\t\t\tcallback == null || callback(null, this._uuid);\n\t\t\treturn;\n\t\t}\n\t\tif (this._uuidRequests) {\n\t\t\tif (callback) this._uuidRequests.push(callback);\n\t\t\treturn;\n\t\t}\n\t\tthis._uuidRequests = [];\n\t\tthis._xrAnchor.requestPersistentHandle().then(uuid => {\n\t\t\tthis._uuid = uuid;\n\t\t\tthis._anchors._indexByUuid.set(this._uuid, this);\n\t\t\tcallback == null || callback(null, uuid);\n\t\t\tfor (const uuidRequest of this._uuidRequests) {\n\t\t\t\tuuidRequest(null, uuid);\n\t\t\t}\n\t\t\tthis._uuidRequests = null;\n\t\t\tthis.fire('persist', uuid);\n\t\t}).catch(ex => {\n\t\t\tcallback == null || callback(ex, null);\n\t\t\tfor (const uuidRequest of this._uuidRequests) {\n\t\t\t\tuuidRequest(ex, null);\n\t\t\t}\n\t\t\tthis._uuidRequests = null;\n\t\t});\n\t}\n\tforget(callback) {\n\t\tif (!this._uuid) {\n\t\t\tcallback == null || callback(new Error('Anchor is not persistent'));\n\t\t\treturn;\n\t\t}\n\t\tthis._anchors.forget(this._uuid, ex => {\n\t\t\tthis._uuid = null;\n\t\t\tcallback == null || callback(ex);\n\t\t\tthis.fire('forget');\n\t\t});\n\t}\n\tget uuid() {\n\t\treturn this._uuid;\n\t}\n\tget persistent() {\n\t\treturn !!this._uuid;\n\t}\n}\nXrAnchor.EVENT_DESTROY = 'destroy';\nXrAnchor.EVENT_CHANGE = 'change';\nXrAnchor.EVENT_PERSIST = 'persist';\nXrAnchor.EVENT_FORGET = 'forget';\n\nexport { XrAnchor };\n","import { EventHandler } from '../../core/event-handler.js';\nimport { platform } from '../../core/platform.js';\nimport { XrAnchor } from './xr-anchor.js';\n\nclass XrAnchors extends EventHandler {\n\tconstructor(manager) {\n\t\tvar _window;\n\t\tsuper();\n\t\tthis.manager = void 0;\n\t\tthis._supported = platform.browser && !!window.XRAnchor;\n\t\tthis._available = false;\n\t\tthis._checkingAvailability = false;\n\t\tthis._persistence = platform.browser && !!((_window = window) != null && (_window = _window.XRSession) != null && _window.prototype.restorePersistentAnchor);\n\t\tthis._creationQueue = [];\n\t\tthis._index = new Map();\n\t\tthis._indexByUuid = new Map();\n\t\tthis._list = [];\n\t\tthis._callbacksAnchors = new Map();\n\t\tthis.manager = manager;\n\t\tif (this._supported) {\n\t\t\tthis.manager.on('start', this._onSessionStart, this);\n\t\t\tthis.manager.on('end', this._onSessionEnd, this);\n\t\t}\n\t}\n\t_onSessionStart() {\n\t\tconst available = this.manager.session.enabledFeatures.indexOf('anchors') !== -1;\n\t\tif (!available) return;\n\t\tthis._available = available;\n\t\tthis.fire('available');\n\t}\n\t_onSessionEnd() {\n\t\tif (!this._available) return;\n\t\tthis._available = false;\n\t\tfor (let _i = 0; _i < this._creationQueue.length; _i++) {\n\t\t\tif (!this._creationQueue[_i].callback) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._creationQueue[_i].callback(new Error('session ended'), null);\n\t\t}\n\t\tthis._creationQueue.length = 0;\n\t\tthis._index.clear();\n\t\tthis._indexByUuid.clear();\n\t\tlet i = this._list.length;\n\t\twhile (i--) {\n\t\t\tthis._list[i].destroy();\n\t\t}\n\t\tthis._list.length = 0;\n\t\tthis.fire('unavailable');\n\t}\n\t_createAnchor(xrAnchor, uuid = null) {\n\t\tconst anchor = new XrAnchor(this, xrAnchor, uuid);\n\t\tthis._index.set(xrAnchor, anchor);\n\t\tif (uuid) this._indexByUuid.set(uuid, anchor);\n\t\tthis._list.push(anchor);\n\t\tanchor.once('destroy', this._onAnchorDestroy, this);\n\t\treturn anchor;\n\t}\n\t_onAnchorDestroy(xrAnchor, anchor) {\n\t\tthis._index.delete(xrAnchor);\n\t\tif (anchor.uuid) this._indexByUuid.delete(anchor.uuid);\n\t\tconst ind = this._list.indexOf(anchor);\n\t\tif (ind !== -1) this._list.splice(ind, 1);\n\t\tthis.fire('destroy', anchor);\n\t}\n\tcreate(position, rotation, callback) {\n\t\tif (!this._available) {\n\t\t\tcallback == null || callback(new Error('Anchors API is not available'), null);\n\t\t\treturn;\n\t\t}\n\t\tif (window.XRHitTestResult && position instanceof XRHitTestResult) {\n\t\t\tconst hitResult = position;\n\t\t\tcallback = rotation;\n\t\t\tif (!this._supported) {\n\t\t\t\tcallback == null || callback(new Error('Anchors API is not supported'), null);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!hitResult.createAnchor) {\n\t\t\t\tcallback == null || callback(new Error('Creating Anchor from Hit Test is not supported'), null);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\thitResult.createAnchor().then(xrAnchor => {\n\t\t\t\tconst anchor = this._createAnchor(xrAnchor);\n\t\t\t\tcallback == null || callback(null, anchor);\n\t\t\t\tthis.fire('add', anchor);\n\t\t\t}).catch(ex => {\n\t\t\t\tcallback == null || callback(ex, null);\n\t\t\t\tthis.fire('error', ex);\n\t\t\t});\n\t\t} else {\n\t\t\tthis._creationQueue.push({\n\t\t\t\ttransform: new XRRigidTransform(position, rotation),\n\t\t\t\tcallback: callback\n\t\t\t});\n\t\t}\n\t}\n\trestore(uuid, callback) {\n\t\tif (!this._available) {\n\t\t\tcallback == null || callback(new Error('Anchors API is not available'), null);\n\t\t\treturn;\n\t\t}\n\t\tif (!this._persistence) {\n\t\t\tcallback == null || callback(new Error('Anchor Persistence is not supported'), null);\n\t\t\treturn;\n\t\t}\n\t\tif (!this.manager.active) {\n\t\t\tcallback == null || callback(new Error('WebXR session is not active'), null);\n\t\t\treturn;\n\t\t}\n\t\tthis.manager.session.restorePersistentAnchor(uuid).then(xrAnchor => {\n\t\t\tconst anchor = this._createAnchor(xrAnchor, uuid);\n\t\t\tcallback == null || callback(null, anchor);\n\t\t\tthis.fire('add', anchor);\n\t\t}).catch(ex => {\n\t\t\tcallback == null || callback(ex, null);\n\t\t\tthis.fire('error', ex);\n\t\t});\n\t}\n\tforget(uuid, callback) {\n\t\tif (!this._available) {\n\t\t\tcallback == null || callback(new Error('Anchors API is not available'));\n\t\t\treturn;\n\t\t}\n\t\tif (!this._persistence) {\n\t\t\tcallback == null || callback(new Error('Anchor Persistence is not supported'));\n\t\t\treturn;\n\t\t}\n\t\tif (!this.manager.active) {\n\t\t\tcallback == null || callback(new Error('WebXR session is not active'));\n\t\t\treturn;\n\t\t}\n\t\tthis.manager.session.deletePersistentAnchor(uuid).then(() => {\n\t\t\tcallback == null || callback(null);\n\t\t}).catch(ex => {\n\t\t\tcallback == null || callback(ex);\n\t\t\tthis.fire('error', ex);\n\t\t});\n\t}\n\tupdate(frame) {\n\t\tif (!this._available) {\n\t\t\tif (!this.manager.session.enabledFeatures && !this._checkingAvailability) {\n\t\t\t\tthis._checkingAvailability = true;\n\t\t\t\tframe.createAnchor(new XRRigidTransform(), this.manager._referenceSpace).then(xrAnchor => {\n\t\t\t\t\txrAnchor.delete();\n\t\t\t\t\tif (this.manager.active) {\n\t\t\t\t\t\tthis._available = true;\n\t\t\t\t\t\tthis.fire('available');\n\t\t\t\t\t}\n\t\t\t\t}).catch(() => {});\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tif (this._creationQueue.length) {\n\t\t\tfor (let i = 0; i < this._creationQueue.length; i++) {\n\t\t\t\tconst request = this._creationQueue[i];\n\t\t\t\tframe.createAnchor(request.transform, this.manager._referenceSpace).then(xrAnchor => {\n\t\t\t\t\tif (request.callback) {\n\t\t\t\t\t\tthis._callbacksAnchors.set(xrAnchor, request.callback);\n\t\t\t\t\t}\n\t\t\t\t}).catch(ex => {\n\t\t\t\t\tif (request.callback) {\n\t\t\t\t\t\trequest.callback(ex, null);\n\t\t\t\t\t}\n\t\t\t\t\tthis.fire('error', ex);\n\t\t\t\t});\n\t\t\t}\n\t\t\tthis._creationQueue.length = 0;\n\t\t}\n\t\tfor (const [xrAnchor, anchor] of this._index) {\n\t\t\tif (frame.trackedAnchors.has(xrAnchor)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._index.delete(xrAnchor);\n\t\t\tanchor.destroy();\n\t\t}\n\t\tfor (let i = 0; i < this._list.length; i++) {\n\t\t\tthis._list[i].update(frame);\n\t\t}\n\t\tfor (const xrAnchor of frame.trackedAnchors) {\n\t\t\tif (this._index.has(xrAnchor)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tconst tmp = xrAnchor.anchorSpace;\n\t\t\t} catch (ex) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst anchor = this._createAnchor(xrAnchor);\n\t\t\tanchor.update(frame);\n\t\t\tconst callback = this._callbacksAnchors.get(xrAnchor);\n\t\t\tif (callback) {\n\t\t\t\tthis._callbacksAnchors.delete(xrAnchor);\n\t\t\t\tcallback(null, anchor);\n\t\t\t}\n\t\t\tthis.fire('add', anchor);\n\t\t}\n\t}\n\tget supported() {\n\t\treturn this._supported;\n\t}\n\tget available() {\n\t\treturn this._available;\n\t}\n\tget persistence() {\n\t\treturn this._persistence;\n\t}\n\tget uuids() {\n\t\tif (!this._available) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!this._persistence) {\n\t\t\treturn null;\n\t\t}\n\t\tif (!this.manager.active) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this.manager.session.persistentAnchors;\n\t}\n\tget list() {\n\t\treturn this._list;\n\t}\n}\nXrAnchors.EVENT_AVAILABLE = 'available';\nXrAnchors.EVENT_UNAVAILABLE = 'unavailable';\nXrAnchors.EVENT_ERROR = 'error';\nXrAnchors.EVENT_ADD = 'add';\nXrAnchors.EVENT_DESTROY = 'destroy';\n\nexport { XrAnchors };\n","import { EventHandler } from '../../core/event-handler.js';\nimport { Mat4 } from '../../core/math/mat4.js';\n\nclass XrDepthSensing extends EventHandler {\n\tconstructor(manager) {\n\t\tsuper();\n\t\tthis._manager = void 0;\n\t\tthis._views = void 0;\n\t\tthis._available = false;\n\t\tthis._evtDepthResize = null;\n\t\tthis._uvMatrix = Mat4.IDENTITY.clone();\n\t\tthis._manager = manager;\n\t\tthis._views = manager.views;\n\t\tif (this._views.supportedDepth) {\n\t\t\tthis._manager.on('start', this._onSessionStart, this);\n\t\t\tthis._manager.on('end', this._onSessionEnd, this);\n\t\t}\n\t}\n\t_onSessionStart() {\n\t\tif (this._views.availableDepth) {\n\t\t\tvar _this$_views$list$;\n\t\t\tthis._evtDepthResize = (_this$_views$list$ = this._views.list[0]) == null ? void 0 : _this$_views$list$.on('depth:resize', this._onDepthResize, this);\n\t\t}\n\t}\n\t_onSessionEnd() {\n\t\tif (this._evtDepthResize) {\n\t\t\tthis._evtDepthResize.off();\n\t\t\tthis._evtDepthResize = null;\n\t\t}\n\t\tif (this._available) {\n\t\t\tthis._available = false;\n\t\t\tthis.fire('unavailable');\n\t\t}\n\t}\n\t_onDepthResize(width, height) {\n\t\tthis.fire('resize', width, height);\n\t}\n\tgetDepth(u, v) {\n\t\tvar _this$_views$list$0$g, _this$_views$list$2;\n\t\treturn (_this$_views$list$0$g = (_this$_views$list$2 = this._views.list[0]) == null ? void 0 : _this$_views$list$2.getDepth(u, v)) != null ? _this$_views$list$0$g : null;\n\t}\n\tupdate() {\n\t\tif (this._manager.session && this.supported && this._views.availableDepth && this._views.list.length && !this._available) {\n\t\t\tthis._available = true;\n\t\t\tthis.fire('available');\n\t\t}\n\t}\n\tget supported() {\n\t\treturn this._views.supportedDepth;\n\t}\n\tget available() {\n\t\treturn this._views.availableDepth;\n\t}\n\tget usage() {\n\t\treturn this._views.depthUsage;\n\t}\n\tget dataFormat() {\n\t\treturn this._views.depthFormat;\n\t}\n\tget width() {\n\t\tvar _this$_views$list$0$t, _this$_views$list$3;\n\t\treturn (_this$_views$list$0$t = (_this$_views$list$3 = this._views.list[0]) == null || (_this$_views$list$3 = _this$_views$list$3.textureDepth) == null ? void 0 : _this$_views$list$3.width) != null ? _this$_views$list$0$t : 0;\n\t}\n\tget height() {\n\t\tvar _this$_views$list$0$t2, _this$_views$list$4;\n\t\treturn (_this$_views$list$0$t2 = (_this$_views$list$4 = this._views.list[0]) == null || (_this$_views$list$4 = _this$_views$list$4.textureDepth) == null ? void 0 : _this$_views$list$4.height) != null ? _this$_views$list$0$t2 : 0;\n\t}\n\tget texture() {\n\t\tvar _this$_views$list$5;\n\t\treturn (_this$_views$list$5 = this._views.list[0]) == null ? void 0 : _this$_views$list$5.textureDepth;\n\t}\n\tget uvMatrix() {\n\t\tvar _this$_views$list$0$d, _this$_views$list$6;\n\t\treturn (_this$_views$list$0$d = (_this$_views$list$6 = this._views.list[0]) == null ? void 0 : _this$_views$list$6.depthUvMatrix) != null ? _this$_views$list$0$d : this._uvMatrix;\n\t}\n\tget rawValueToMeters() {\n\t\tvar _this$_views$list$0$d2, _this$_views$list$7;\n\t\treturn (_this$_views$list$0$d2 = (_this$_views$list$7 = this._views.list[0]) == null ? void 0 : _this$_views$list$7.depthValueToMeters) != null ? _this$_views$list$0$d2 : 0;\n\t}\n}\nXrDepthSensing.EVENT_AVAILABLE = 'available';\nXrDepthSensing.EVENT_UNAVAILABLE = 'unavailable';\nXrDepthSensing.EVENT_RESIZE = 'resize';\n\nexport { XrDepthSensing };\n","import { platform } from '../../core/platform.js';\n\nclass XrDomOverlay {\n\tconstructor(manager) {\n\t\tthis._manager = void 0;\n\t\tthis._supported = platform.browser && !!window.XRDOMOverlayState;\n\t\tthis._root = null;\n\t\tthis._manager = manager;\n\t}\n\tget supported() {\n\t\treturn this._supported;\n\t}\n\tget available() {\n\t\treturn this._supported && this._manager.active && this._manager._session.domOverlayState !== null;\n\t}\n\tget state() {\n\t\tif (!this._supported || !this._manager.active || !this._manager._session.domOverlayState) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._manager._session.domOverlayState.type;\n\t}\n\tset root(value) {\n\t\tif (!this._supported || this._manager.active) {\n\t\t\treturn;\n\t\t}\n\t\tthis._root = value;\n\t}\n\tget root() {\n\t\treturn this._root;\n\t}\n}\n\nexport { XrDomOverlay };\n","class XrFinger {\n\tconstructor(index, hand) {\n\t\tthis._index = void 0;\n\t\tthis._hand = void 0;\n\t\tthis._joints = [];\n\t\tthis._tip = null;\n\t\tthis._index = index;\n\t\tthis._hand = hand;\n\t\tthis._hand._fingers.push(this);\n\t}\n\tget index() {\n\t\treturn this._index;\n\t}\n\tget hand() {\n\t\treturn this._hand;\n\t}\n\tget joints() {\n\t\treturn this._joints;\n\t}\n\tget tip() {\n\t\treturn this._tip;\n\t}\n}\n\nexport { XrFinger };\n","import { EventHandler } from '../../core/event-handler.js';\nimport { platform } from '../../core/platform.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { XRHAND_LEFT } from './constants.js';\nimport { XrFinger } from './xr-finger.js';\nimport { XrJoint } from './xr-joint.js';\n\nlet fingerJointIds = [];\nconst vecA = new Vec3();\nconst vecB = new Vec3();\nconst vecC = new Vec3();\nif (platform.browser && window.XRHand) {\n\tfingerJointIds = [['thumb-metacarpal', 'thumb-phalanx-proximal', 'thumb-phalanx-distal', 'thumb-tip'], ['index-finger-metacarpal', 'index-finger-phalanx-proximal', 'index-finger-phalanx-intermediate', 'index-finger-phalanx-distal', 'index-finger-tip'], ['middle-finger-metacarpal', 'middle-finger-phalanx-proximal', 'middle-finger-phalanx-intermediate', 'middle-finger-phalanx-distal', 'middle-finger-tip'], ['ring-finger-metacarpal', 'ring-finger-phalanx-proximal', 'ring-finger-phalanx-intermediate', 'ring-finger-phalanx-distal', 'ring-finger-tip'], ['pinky-finger-metacarpal', 'pinky-finger-phalanx-proximal', 'pinky-finger-phalanx-intermediate', 'pinky-finger-phalanx-distal', 'pinky-finger-tip']];\n}\nclass XrHand extends EventHandler {\n\tconstructor(inputSource) {\n\t\tsuper();\n\t\tthis._manager = void 0;\n\t\tthis._inputSource = void 0;\n\t\tthis._tracking = false;\n\t\tthis._fingers = [];\n\t\tthis._joints = [];\n\t\tthis._jointsById = {};\n\t\tthis._tips = [];\n\t\tthis._wrist = null;\n\t\tconst xrHand = inputSource._xrInputSource.hand;\n\t\tthis._manager = inputSource._manager;\n\t\tthis._inputSource = inputSource;\n\t\tif (xrHand.get('wrist')) {\n\t\t\tconst joint = new XrJoint(0, 'wrist', this, null);\n\t\t\tthis._wrist = joint;\n\t\t\tthis._joints.push(joint);\n\t\t\tthis._jointsById.wrist = joint;\n\t\t}\n\t\tfor (let f = 0; f < fingerJointIds.length; f++) {\n\t\t\tconst finger = new XrFinger(f, this);\n\t\t\tfor (let j = 0; j < fingerJointIds[f].length; j++) {\n\t\t\t\tconst jointId = fingerJointIds[f][j];\n\t\t\t\tif (!xrHand.get(jointId)) continue;\n\t\t\t\tconst joint = new XrJoint(j, jointId, this, finger);\n\t\t\t\tthis._joints.push(joint);\n\t\t\t\tthis._jointsById[jointId] = joint;\n\t\t\t\tif (joint.tip) {\n\t\t\t\t\tthis._tips.push(joint);\n\t\t\t\t\tfinger._tip = joint;\n\t\t\t\t}\n\t\t\t\tfinger._joints.push(joint);\n\t\t\t}\n\t\t}\n\t}\n\tupdate(frame) {\n\t\tconst xrInputSource = this._inputSource._xrInputSource;\n\t\tfor (let j = 0; j < this._joints.length; j++) {\n\t\t\tconst joint = this._joints[j];\n\t\t\tconst jointSpace = xrInputSource.hand.get(joint._id);\n\t\t\tif (jointSpace) {\n\t\t\t\tlet pose;\n\t\t\t\tif (frame.session.visibilityState !== 'hidden') {\n\t\t\t\t\tpose = frame.getJointPose(jointSpace, this._manager._referenceSpace);\n\t\t\t\t}\n\t\t\t\tif (pose) {\n\t\t\t\t\tjoint.update(pose);\n\t\t\t\t\tif (joint.wrist && !this._tracking) {\n\t\t\t\t\t\tthis._tracking = true;\n\t\t\t\t\t\tthis.fire('tracking');\n\t\t\t\t\t}\n\t\t\t\t} else if (joint.wrist) {\n\t\t\t\t\tif (this._tracking) {\n\t\t\t\t\t\tthis._tracking = false;\n\t\t\t\t\t\tthis.fire('trackinglost');\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst j1 = this._jointsById['thumb-metacarpal'];\n\t\tconst j4 = this._jointsById['thumb-tip'];\n\t\tconst j6 = this._jointsById['index-finger-phalanx-proximal'];\n\t\tconst j9 = this._jointsById['index-finger-tip'];\n\t\tconst j16 = this._jointsById['ring-finger-phalanx-proximal'];\n\t\tconst j21 = this._jointsById['pinky-finger-phalanx-proximal'];\n\t\tif (j1 && j4 && j6 && j9 && j16 && j21) {\n\t\t\tthis._inputSource._dirtyRay = true;\n\t\t\tthis._inputSource._rayLocal.origin.lerp(j4._localPosition, j9._localPosition, 0.5);\n\t\t\tlet jointL = j1;\n\t\t\tlet jointR = j21;\n\t\t\tif (this._inputSource.handedness === XRHAND_LEFT) {\n\t\t\t\tconst t = jointL;\n\t\t\t\tjointL = jointR;\n\t\t\t\tjointR = t;\n\t\t\t}\n\t\t\tvecA.sub2(jointL._localPosition, this._wrist._localPosition);\n\t\t\tvecB.sub2(jointR._localPosition, this._wrist._localPosition);\n\t\t\tvecC.cross(vecA, vecB).normalize();\n\t\t\tvecA.lerp(j6._localPosition, j16._localPosition, 0.5);\n\t\t\tvecA.sub(this._wrist._localPosition).normalize();\n\t\t\tthis._inputSource._rayLocal.direction.lerp(vecC, vecA, 0.5).normalize();\n\t\t}\n\t\tconst squeezing = this._fingerIsClosed(1) && this._fingerIsClosed(2) && this._fingerIsClosed(3) && this._fingerIsClosed(4);\n\t\tif (squeezing) {\n\t\t\tif (!this._inputSource._squeezing) {\n\t\t\t\tthis._inputSource._squeezing = true;\n\t\t\t\tthis._inputSource.fire('squeezestart');\n\t\t\t\tthis._manager.input.fire('squeezestart', this._inputSource);\n\t\t\t}\n\t\t} else {\n\t\t\tif (this._inputSource._squeezing) {\n\t\t\t\tthis._inputSource._squeezing = false;\n\t\t\t\tthis._inputSource.fire('squeeze');\n\t\t\t\tthis._manager.input.fire('squeeze', this._inputSource);\n\t\t\t\tthis._inputSource.fire('squeezeend');\n\t\t\t\tthis._manager.input.fire('squeezeend', this._inputSource);\n\t\t\t}\n\t\t}\n\t}\n\t_fingerIsClosed(index) {\n\t\tconst finger = this._fingers[index];\n\t\tvecA.sub2(finger.joints[0]._localPosition, finger.joints[1]._localPosition).normalize();\n\t\tvecB.sub2(finger.joints[2]._localPosition, finger.joints[3]._localPosition).normalize();\n\t\treturn vecA.dot(vecB) < -0.8;\n\t}\n\tgetJointById(id) {\n\t\treturn this._jointsById[id] || null;\n\t}\n\tget fingers() {\n\t\treturn this._fingers;\n\t}\n\tget joints() {\n\t\treturn this._joints;\n\t}\n\tget tips() {\n\t\treturn this._tips;\n\t}\n\tget wrist() {\n\t\treturn this._wrist;\n\t}\n\tget tracking() {\n\t\treturn this._tracking;\n\t}\n}\nXrHand.EVENT_TRACKING = 'tracking';\nXrHand.EVENT_TRACKINGLOST = 'trackinglost';\n\nexport { XrHand };\n","import { EventHandler } from '../../core/event-handler.js';\nimport { Quat } from '../../core/math/quat.js';\nimport { Vec3 } from '../../core/math/vec3.js';\n\nconst poolVec3 = [];\nconst poolQuat = [];\nclass XrHitTestSource extends EventHandler {\n\tconstructor(manager, xrHitTestSource, transient, inputSource = null) {\n\t\tsuper();\n\t\tthis.manager = void 0;\n\t\tthis._xrHitTestSource = void 0;\n\t\tthis._transient = void 0;\n\t\tthis._inputSource = void 0;\n\t\tthis.manager = manager;\n\t\tthis._xrHitTestSource = xrHitTestSource;\n\t\tthis._transient = transient;\n\t\tthis._inputSource = inputSource;\n\t}\n\tremove() {\n\t\tif (!this._xrHitTestSource) {\n\t\t\treturn;\n\t\t}\n\t\tconst sources = this.manager.hitTest.sources;\n\t\tconst ind = sources.indexOf(this);\n\t\tif (ind !== -1) sources.splice(ind, 1);\n\t\tthis.onStop();\n\t}\n\tonStop() {\n\t\tthis._xrHitTestSource.cancel();\n\t\tthis._xrHitTestSource = null;\n\t\tthis.fire('remove');\n\t\tthis.manager.hitTest.fire('remove', this);\n\t}\n\tupdate(frame) {\n\t\tif (this._transient) {\n\t\t\tconst transientResults = frame.getHitTestResultsForTransientInput(this._xrHitTestSource);\n\t\t\tfor (let i = 0; i < transientResults.length; i++) {\n\t\t\t\tconst transientResult = transientResults[i];\n\t\t\t\tif (!transientResult.results.length) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlet inputSource;\n\t\t\t\tif (transientResult.inputSource) {\n\t\t\t\t\tinputSource = this.manager.input._getByInputSource(transientResult.inputSource);\n\t\t\t\t}\n\t\t\t\tthis.updateHitResults(transientResult.results, inputSource);\n\t\t\t}\n\t\t} else {\n\t\t\tconst results = frame.getHitTestResults(this._xrHitTestSource);\n\t\t\tif (!results.length) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis.updateHitResults(results);\n\t\t}\n\t}\n\tupdateHitResults(results, inputSource) {\n\t\tvar _poolVec3$pop, _poolVec3$pop2, _poolQuat$pop;\n\t\tif (this._inputSource && this._inputSource !== inputSource) {\n\t\t\treturn;\n\t\t}\n\t\tconst origin = (_poolVec3$pop = poolVec3.pop()) != null ? _poolVec3$pop : new Vec3();\n\t\tif (inputSource) {\n\t\t\torigin.copy(inputSource.getOrigin());\n\t\t} else {\n\t\t\torigin.copy(this.manager.camera.getPosition());\n\t\t}\n\t\tlet candidateDistance = Infinity;\n\t\tlet candidateHitTestResult = null;\n\t\tconst position = (_poolVec3$pop2 = poolVec3.pop()) != null ? _poolVec3$pop2 : new Vec3();\n\t\tconst rotation = (_poolQuat$pop = poolQuat.pop()) != null ? _poolQuat$pop : new Quat();\n\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\tconst pose = results[i].getPose(this.manager._referenceSpace);\n\t\t\tconst distance = origin.distance(pose.transform.position);\n\t\t\tif (distance >= candidateDistance) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcandidateDistance = distance;\n\t\t\tcandidateHitTestResult = results[i];\n\t\t\tposition.copy(pose.transform.position);\n\t\t\trotation.copy(pose.transform.orientation);\n\t\t}\n\t\tthis.fire('result', position, rotation, inputSource || this._inputSource, candidateHitTestResult);\n\t\tthis.manager.hitTest.fire('result', this, position, rotation, inputSource || this._inputSource, candidateHitTestResult);\n\t\tpoolVec3.push(origin);\n\t\tpoolVec3.push(position);\n\t\tpoolQuat.push(rotation);\n\t}\n}\nXrHitTestSource.EVENT_REMOVE = 'remove';\nXrHitTestSource.EVENT_RESULT = 'result';\n\nexport { XrHitTestSource };\n","import { platform } from '../../core/platform.js';\nimport { EventHandler } from '../../core/event-handler.js';\nimport { XRSPACE_VIEWER } from './constants.js';\nimport { XrHitTestSource } from './xr-hit-test-source.js';\n\nclass XrHitTest extends EventHandler {\n\tconstructor(manager) {\n\t\tsuper();\n\t\tthis.manager = void 0;\n\t\tthis._supported = platform.browser && !!(window.XRSession && window.XRSession.prototype.requestHitTestSource);\n\t\tthis._available = false;\n\t\tthis._checkingAvailability = false;\n\t\tthis.sources = [];\n\t\tthis.manager = manager;\n\t\tif (this._supported) {\n\t\t\tthis.manager.on('start', this._onSessionStart, this);\n\t\t\tthis.manager.on('end', this._onSessionEnd, this);\n\t\t}\n\t}\n\t_onSessionStart() {\n\t\tif (this.manager.session.enabledFeatures) {\n\t\t\tconst available = this.manager.session.enabledFeatures.indexOf('hit-test') !== -1;\n\t\t\tif (!available) return;\n\t\t\tthis._available = available;\n\t\t\tthis.fire('available');\n\t\t} else if (!this._checkingAvailability) {\n\t\t\tthis._checkingAvailability = true;\n\t\t\tthis.manager.session.requestReferenceSpace(XRSPACE_VIEWER).then(referenceSpace => {\n\t\t\t\tthis.manager.session.requestHitTestSource({\n\t\t\t\t\tspace: referenceSpace\n\t\t\t\t}).then(hitTestSource => {\n\t\t\t\t\thitTestSource.cancel();\n\t\t\t\t\tif (this.manager.active) {\n\t\t\t\t\t\tthis._available = true;\n\t\t\t\t\t\tthis.fire('available');\n\t\t\t\t\t}\n\t\t\t\t}).catch(() => {});\n\t\t\t}).catch(() => {});\n\t\t}\n\t}\n\t_onSessionEnd() {\n\t\tif (!this._available) return;\n\t\tthis._available = false;\n\t\tfor (let i = 0; i < this.sources.length; i++) {\n\t\t\tthis.sources[i].onStop();\n\t\t}\n\t\tthis.sources = [];\n\t\tthis.fire('unavailable');\n\t}\n\tstart(options = {}) {\n\t\tif (!this._supported) {\n\t\t\toptions.callback == null || options.callback(new Error('XR HitTest is not supported'), null);\n\t\t\treturn;\n\t\t}\n\t\tif (!this._available) {\n\t\t\toptions.callback == null || options.callback(new Error('XR HitTest is not available'), null);\n\t\t\treturn;\n\t\t}\n\t\tif (!options.profile && !options.spaceType) {\n\t\t\toptions.spaceType = XRSPACE_VIEWER;\n\t\t}\n\t\tlet xrRay;\n\t\tconst offsetRay = options.offsetRay;\n\t\tif (offsetRay) {\n\t\t\tconst origin = new DOMPoint(offsetRay.origin.x, offsetRay.origin.y, offsetRay.origin.z, 1.0);\n\t\t\tconst direction = new DOMPoint(offsetRay.direction.x, offsetRay.direction.y, offsetRay.direction.z, 0.0);\n\t\t\txrRay = new XRRay(origin, direction);\n\t\t}\n\t\tconst callback = options.callback;\n\t\tif (options.spaceType) {\n\t\t\tthis.manager.session.requestReferenceSpace(options.spaceType).then(referenceSpace => {\n\t\t\t\tif (!this.manager.session) {\n\t\t\t\t\tconst err = new Error('XR Session is not started (2)');\n\t\t\t\t\tif (callback) callback(err);\n\t\t\t\t\tthis.fire('error', err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tthis.manager.session.requestHitTestSource({\n\t\t\t\t\tspace: referenceSpace,\n\t\t\t\t\tentityTypes: options.entityTypes || undefined,\n\t\t\t\t\toffsetRay: xrRay\n\t\t\t\t}).then(xrHitTestSource => {\n\t\t\t\t\tthis._onHitTestSource(xrHitTestSource, false, options.inputSource, callback);\n\t\t\t\t}).catch(ex => {\n\t\t\t\t\tif (callback) callback(ex);\n\t\t\t\t\tthis.fire('error', ex);\n\t\t\t\t});\n\t\t\t}).catch(ex => {\n\t\t\t\tif (callback) callback(ex);\n\t\t\t\tthis.fire('error', ex);\n\t\t\t});\n\t\t} else {\n\t\t\tthis.manager.session.requestHitTestSourceForTransientInput({\n\t\t\t\tprofile: options.profile,\n\t\t\t\tentityTypes: options.entityTypes || undefined,\n\t\t\t\toffsetRay: xrRay\n\t\t\t}).then(xrHitTestSource => {\n\t\t\t\tthis._onHitTestSource(xrHitTestSource, true, options.inputSource, callback);\n\t\t\t}).catch(ex => {\n\t\t\t\tif (callback) callback(ex);\n\t\t\t\tthis.fire('error', ex);\n\t\t\t});\n\t\t}\n\t}\n\t_onHitTestSource(xrHitTestSource, transient, inputSource, callback) {\n\t\tif (!this.manager.session) {\n\t\t\txrHitTestSource.cancel();\n\t\t\tconst err = new Error('XR Session is not started (3)');\n\t\t\tif (callback) callback(err);\n\t\t\tthis.fire('error', err);\n\t\t\treturn;\n\t\t}\n\t\tconst hitTestSource = new XrHitTestSource(this.manager, xrHitTestSource, transient, inputSource != null ? inputSource : null);\n\t\tthis.sources.push(hitTestSource);\n\t\tif (callback) callback(null, hitTestSource);\n\t\tthis.fire('add', hitTestSource);\n\t}\n\tupdate(frame) {\n\t\tif (!this._available) {\n\t\t\treturn;\n\t\t}\n\t\tfor (let i = 0; i < this.sources.length; i++) {\n\t\t\tthis.sources[i].update(frame);\n\t\t}\n\t}\n\tget supported() {\n\t\treturn this._supported;\n\t}\n\tget available() {\n\t\treturn this._available;\n\t}\n}\nXrHitTest.EVENT_AVAILABLE = 'available';\nXrHitTest.EVENT_UNAVAILABLE = 'unavailable';\nXrHitTest.EVENT_ADD = 'add';\nXrHitTest.EVENT_REMOVE = 'remove';\nXrHitTest.EVENT_RESULT = 'result';\nXrHitTest.EVENT_ERROR = 'error';\n\nexport { XrHitTest };\n","import { EventHandler } from '../../core/event-handler.js';\nimport { platform } from '../../core/platform.js';\nimport { XrTrackedImage } from './xr-tracked-image.js';\n\nclass XrImageTracking extends EventHandler {\n\tconstructor(manager) {\n\t\tsuper();\n\t\tthis._manager = void 0;\n\t\tthis._supported = platform.browser && !!window.XRImageTrackingResult;\n\t\tthis._available = false;\n\t\tthis._images = [];\n\t\tthis._manager = manager;\n\t\tif (this._supported) {\n\t\t\tthis._manager.on('start', this._onSessionStart, this);\n\t\t\tthis._manager.on('end', this._onSessionEnd, this);\n\t\t}\n\t}\n\tadd(image, width) {\n\t\tif (!this._supported || this._manager.active) return null;\n\t\tconst trackedImage = new XrTrackedImage(image, width);\n\t\tthis._images.push(trackedImage);\n\t\treturn trackedImage;\n\t}\n\tremove(trackedImage) {\n\t\tif (this._manager.active) return;\n\t\tconst ind = this._images.indexOf(trackedImage);\n\t\tif (ind !== -1) {\n\t\t\ttrackedImage.destroy();\n\t\t\tthis._images.splice(ind, 1);\n\t\t}\n\t}\n\t_onSessionStart() {\n\t\tthis._manager.session.getTrackedImageScores().then(images => {\n\t\t\tthis._available = true;\n\t\t\tfor (let i = 0; i < images.length; i++) {\n\t\t\t\tthis._images[i]._trackable = images[i] === 'trackable';\n\t\t\t}\n\t\t}).catch(err => {\n\t\t\tthis._available = false;\n\t\t\tthis.fire('error', err);\n\t\t});\n\t}\n\t_onSessionEnd() {\n\t\tthis._available = false;\n\t\tfor (let i = 0; i < this._images.length; i++) {\n\t\t\tconst image = this._images[i];\n\t\t\timage._pose = null;\n\t\t\timage._measuredWidth = 0;\n\t\t\tif (image._tracking) {\n\t\t\t\timage._tracking = false;\n\t\t\t\timage.fire('untracked');\n\t\t\t}\n\t\t}\n\t}\n\tprepareImages(callback) {\n\t\tif (this._images.length) {\n\t\t\tPromise.all(this._images.map(trackedImage => {\n\t\t\t\treturn trackedImage.prepare();\n\t\t\t})).then(bitmaps => {\n\t\t\t\tcallback(null, bitmaps);\n\t\t\t}).catch(err => {\n\t\t\t\tcallback(err, null);\n\t\t\t});\n\t\t} else {\n\t\t\tcallback(null, null);\n\t\t}\n\t}\n\tupdate(frame) {\n\t\tif (!this._available) return;\n\t\tconst results = frame.getImageTrackingResults();\n\t\tconst index = {};\n\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\tindex[results[i].index] = results[i];\n\t\t\tconst trackedImage = this._images[results[i].index];\n\t\t\ttrackedImage._emulated = results[i].trackingState === 'emulated';\n\t\t\ttrackedImage._measuredWidth = results[i].measuredWidthInMeters;\n\t\t\ttrackedImage._pose = frame.getPose(results[i].imageSpace, this._manager._referenceSpace);\n\t\t}\n\t\tfor (let i = 0; i < this._images.length; i++) {\n\t\t\tif (this._images[i]._tracking && !index[i]) {\n\t\t\t\tthis._images[i]._tracking = false;\n\t\t\t\tthis._images[i].fire('untracked');\n\t\t\t} else if (!this._images[i]._tracking && index[i]) {\n\t\t\t\tthis._images[i]._tracking = true;\n\t\t\t\tthis._images[i].fire('tracked');\n\t\t\t}\n\t\t}\n\t}\n\tget supported() {\n\t\treturn this._supported;\n\t}\n\tget available() {\n\t\treturn this._available;\n\t}\n\tget images() {\n\t\treturn this._images;\n\t}\n}\nXrImageTracking.EVENT_ERROR = 'error';\n\nexport { XrImageTracking };\n","import { EventHandler } from '../../core/event-handler.js';\nimport { Mat4 } from '../../core/math/mat4.js';\nimport { Quat } from '../../core/math/quat.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { Ray } from '../../core/shape/ray.js';\nimport { XrHand } from './xr-hand.js';\nimport { now } from '../../core/time.js';\n\nconst vec3A = new Vec3();\nconst quat = new Quat();\nlet ids = 0;\nclass XrInputSource extends EventHandler {\n\tconstructor(manager, xrInputSource) {\n\t\tsuper();\n\t\tthis._id = void 0;\n\t\tthis._manager = void 0;\n\t\tthis._xrInputSource = void 0;\n\t\tthis._ray = new Ray();\n\t\tthis._rayLocal = new Ray();\n\t\tthis._grip = false;\n\t\tthis._hand = null;\n\t\tthis._velocitiesAvailable = false;\n\t\tthis._velocitiesTimestamp = now();\n\t\tthis._localTransform = null;\n\t\tthis._worldTransform = null;\n\t\tthis._position = new Vec3();\n\t\tthis._rotation = new Quat();\n\t\tthis._localPosition = null;\n\t\tthis._localPositionLast = null;\n\t\tthis._localRotation = null;\n\t\tthis._linearVelocity = null;\n\t\tthis._dirtyLocal = true;\n\t\tthis._dirtyRay = false;\n\t\tthis._selecting = false;\n\t\tthis._squeezing = false;\n\t\tthis._elementInput = true;\n\t\tthis._elementEntity = null;\n\t\tthis._hitTestSources = [];\n\t\tthis._id = ++ids;\n\t\tthis._manager = manager;\n\t\tthis._xrInputSource = xrInputSource;\n\t\tif (xrInputSource.hand) {\n\t\t\tthis._hand = new XrHand(this);\n\t\t}\n\t}\n\tget id() {\n\t\treturn this._id;\n\t}\n\tget inputSource() {\n\t\treturn this._xrInputSource;\n\t}\n\tget targetRayMode() {\n\t\treturn this._xrInputSource.targetRayMode;\n\t}\n\tget handedness() {\n\t\treturn this._xrInputSource.handedness;\n\t}\n\tget profiles() {\n\t\treturn this._xrInputSource.profiles;\n\t}\n\tget grip() {\n\t\treturn this._grip;\n\t}\n\tget hand() {\n\t\treturn this._hand;\n\t}\n\tget gamepad() {\n\t\treturn this._xrInputSource.gamepad || null;\n\t}\n\tget selecting() {\n\t\treturn this._selecting;\n\t}\n\tget squeezing() {\n\t\treturn this._squeezing;\n\t}\n\tset elementInput(value) {\n\t\tif (this._elementInput === value) {\n\t\t\treturn;\n\t\t}\n\t\tthis._elementInput = value;\n\t\tif (!this._elementInput) {\n\t\t\tthis._elementEntity = null;\n\t\t}\n\t}\n\tget elementInput() {\n\t\treturn this._elementInput;\n\t}\n\tget elementEntity() {\n\t\treturn this._elementEntity;\n\t}\n\tget hitTestSources() {\n\t\treturn this._hitTestSources;\n\t}\n\tupdate(frame) {\n\t\tif (this._hand) {\n\t\t\tthis._hand.update(frame);\n\t\t} else {\n\t\t\tconst gripSpace = this._xrInputSource.gripSpace;\n\t\t\tif (gripSpace) {\n\t\t\t\tconst gripPose = frame.getPose(gripSpace, this._manager._referenceSpace);\n\t\t\t\tif (gripPose) {\n\t\t\t\t\tif (!this._grip) {\n\t\t\t\t\t\tthis._grip = true;\n\t\t\t\t\t\tthis._localTransform = new Mat4();\n\t\t\t\t\t\tthis._worldTransform = new Mat4();\n\t\t\t\t\t\tthis._localPositionLast = new Vec3();\n\t\t\t\t\t\tthis._localPosition = new Vec3();\n\t\t\t\t\t\tthis._localRotation = new Quat();\n\t\t\t\t\t\tthis._linearVelocity = new Vec3();\n\t\t\t\t\t}\n\t\t\t\t\tconst timestamp = now();\n\t\t\t\t\tconst dt = (timestamp - this._velocitiesTimestamp) / 1000;\n\t\t\t\t\tthis._velocitiesTimestamp = timestamp;\n\t\t\t\t\tthis._dirtyLocal = true;\n\t\t\t\t\tthis._localPositionLast.copy(this._localPosition);\n\t\t\t\t\tthis._localPosition.copy(gripPose.transform.position);\n\t\t\t\t\tthis._localRotation.copy(gripPose.transform.orientation);\n\t\t\t\t\tthis._velocitiesAvailable = true;\n\t\t\t\t\tif (this._manager.input.velocitiesSupported && gripPose.linearVelocity) {\n\t\t\t\t\t\tthis._linearVelocity.copy(gripPose.linearVelocity);\n\t\t\t\t\t} else if (dt > 0) {\n\t\t\t\t\t\tvec3A.sub2(this._localPosition, this._localPositionLast).divScalar(dt);\n\t\t\t\t\t\tthis._linearVelocity.lerp(this._linearVelocity, vec3A, 0.15);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis._velocitiesAvailable = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst targetRayPose = frame.getPose(this._xrInputSource.targetRaySpace, this._manager._referenceSpace);\n\t\t\tif (targetRayPose) {\n\t\t\t\tthis._dirtyRay = true;\n\t\t\t\tthis._rayLocal.origin.copy(targetRayPose.transform.position);\n\t\t\t\tthis._rayLocal.direction.set(0, 0, -1);\n\t\t\t\tquat.copy(targetRayPose.transform.orientation);\n\t\t\t\tquat.transformVector(this._rayLocal.direction, this._rayLocal.direction);\n\t\t\t}\n\t\t}\n\t}\n\t_updateTransforms() {\n\t\tif (this._dirtyLocal) {\n\t\t\tthis._dirtyLocal = false;\n\t\t\tthis._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);\n\t\t}\n\t\tconst parent = this._manager.camera.parent;\n\t\tif (parent) {\n\t\t\tthis._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);\n\t\t} else {\n\t\t\tthis._worldTransform.copy(this._localTransform);\n\t\t}\n\t}\n\t_updateRayTransforms() {\n\t\tconst dirty = this._dirtyRay;\n\t\tthis._dirtyRay = false;\n\t\tconst parent = this._manager.camera.parent;\n\t\tif (parent) {\n\t\t\tconst parentTransform = this._manager.camera.parent.getWorldTransform();\n\t\t\tparentTransform.getTranslation(this._position);\n\t\t\tthis._rotation.setFromMat4(parentTransform);\n\t\t\tthis._rotation.transformVector(this._rayLocal.origin, this._ray.origin);\n\t\t\tthis._ray.origin.add(this._position);\n\t\t\tthis._rotation.transformVector(this._rayLocal.direction, this._ray.direction);\n\t\t} else if (dirty) {\n\t\t\tthis._ray.origin.copy(this._rayLocal.origin);\n\t\t\tthis._ray.direction.copy(this._rayLocal.direction);\n\t\t}\n\t}\n\tgetPosition() {\n\t\tif (!this._position) return null;\n\t\tthis._updateTransforms();\n\t\tthis._worldTransform.getTranslation(this._position);\n\t\treturn this._position;\n\t}\n\tgetLocalPosition() {\n\t\treturn this._localPosition;\n\t}\n\tgetRotation() {\n\t\tif (!this._rotation) return null;\n\t\tthis._updateTransforms();\n\t\tthis._rotation.setFromMat4(this._worldTransform);\n\t\treturn this._rotation;\n\t}\n\tgetLocalRotation() {\n\t\treturn this._localRotation;\n\t}\n\tgetLinearVelocity() {\n\t\tif (!this._velocitiesAvailable) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._linearVelocity;\n\t}\n\tgetOrigin() {\n\t\tthis._updateRayTransforms();\n\t\treturn this._ray.origin;\n\t}\n\tgetDirection() {\n\t\tthis._updateRayTransforms();\n\t\treturn this._ray.direction;\n\t}\n\thitTestStart(options = {}) {\n\t\toptions.inputSource = this;\n\t\toptions.profile = this._xrInputSource.profiles[0];\n\t\tconst callback = options.callback;\n\t\toptions.callback = (err, hitTestSource) => {\n\t\t\tif (hitTestSource) this.onHitTestSourceAdd(hitTestSource);\n\t\t\tif (callback) callback(err, hitTestSource);\n\t\t};\n\t\tthis._manager.hitTest.start(options);\n\t}\n\tonHitTestSourceAdd(hitTestSource) {\n\t\tthis._hitTestSources.push(hitTestSource);\n\t\tthis.fire('hittest:add', hitTestSource);\n\t\thitTestSource.on('result', (position, rotation, inputSource, hitTestResult) => {\n\t\t\tif (inputSource !== this) return;\n\t\t\tthis.fire('hittest:result', hitTestSource, position, rotation, hitTestResult);\n\t\t});\n\t\thitTestSource.once('remove', () => {\n\t\t\tthis.onHitTestSourceRemove(hitTestSource);\n\t\t\tthis.fire('hittest:remove', hitTestSource);\n\t\t});\n\t}\n\tonHitTestSourceRemove(hitTestSource) {\n\t\tconst ind = this._hitTestSources.indexOf(hitTestSource);\n\t\tif (ind !== -1) this._hitTestSources.splice(ind, 1);\n\t}\n}\nXrInputSource.EVENT_REMOVE = 'remove';\nXrInputSource.EVENT_SELECT = 'select';\nXrInputSource.EVENT_SELECTSTART = 'selectstart';\nXrInputSource.EVENT_SELECTEND = 'selectend';\nXrInputSource.EVENT_SQUEEZE = 'squeeze';\nXrInputSource.EVENT_SQUEEZESTART = 'squeezestart';\nXrInputSource.EVENT_SQUEEZEEND = 'squeezeend';\nXrInputSource.EVENT_HITTESTADD = 'hittest:add';\nXrInputSource.EVENT_HITTESTREMOVE = 'hittest:remove';\nXrInputSource.EVENT_HITTESTRESULT = 'hittest:result';\n\nexport { XrInputSource };\n","import { EventHandler } from '../../core/event-handler.js';\nimport { platform } from '../../core/platform.js';\nimport { XrInputSource } from './xr-input-source.js';\n\nclass XrInput extends EventHandler {\n\tconstructor(manager) {\n\t\tvar _window$XRPose;\n\t\tsuper();\n\t\tthis.manager = void 0;\n\t\tthis._inputSources = [];\n\t\tthis._onInputSourcesChangeEvt = void 0;\n\t\tthis.velocitiesSupported = false;\n\t\tthis.manager = manager;\n\t\tthis.velocitiesSupported = !!(platform.browser && (_window$XRPose = window.XRPose) != null && (_window$XRPose = _window$XRPose.prototype) != null && _window$XRPose.hasOwnProperty('linearVelocity'));\n\t\tthis._onInputSourcesChangeEvt = evt => {\n\t\t\tthis._onInputSourcesChange(evt);\n\t\t};\n\t\tthis.manager.on('start', this._onSessionStart, this);\n\t\tthis.manager.on('end', this._onSessionEnd, this);\n\t}\n\t_onSessionStart() {\n\t\tconst session = this.manager.session;\n\t\tsession.addEventListener('inputsourceschange', this._onInputSourcesChangeEvt);\n\t\tsession.addEventListener('select', evt => {\n\t\t\tconst inputSource = this._getByInputSource(evt.inputSource);\n\t\t\tinputSource.update(evt.frame);\n\t\t\tinputSource.fire('select', evt);\n\t\t\tthis.fire('select', inputSource, evt);\n\t\t});\n\t\tsession.addEventListener('selectstart', evt => {\n\t\t\tconst inputSource = this._getByInputSource(evt.inputSource);\n\t\t\tinputSource.update(evt.frame);\n\t\t\tinputSource._selecting = true;\n\t\t\tinputSource.fire('selectstart', evt);\n\t\t\tthis.fire('selectstart', inputSource, evt);\n\t\t});\n\t\tsession.addEventListener('selectend', evt => {\n\t\t\tconst inputSource = this._getByInputSource(evt.inputSource);\n\t\t\tinputSource.update(evt.frame);\n\t\t\tinputSource._selecting = false;\n\t\t\tinputSource.fire('selectend', evt);\n\t\t\tthis.fire('selectend', inputSource, evt);\n\t\t});\n\t\tsession.addEventListener('squeeze', evt => {\n\t\t\tconst inputSource = this._getByInputSource(evt.inputSource);\n\t\t\tinputSource.update(evt.frame);\n\t\t\tinputSource.fire('squeeze', evt);\n\t\t\tthis.fire('squeeze', inputSource, evt);\n\t\t});\n\t\tsession.addEventListener('squeezestart', evt => {\n\t\t\tconst inputSource = this._getByInputSource(evt.inputSource);\n\t\t\tinputSource.update(evt.frame);\n\t\t\tinputSource._squeezing = true;\n\t\t\tinputSource.fire('squeezestart', evt);\n\t\t\tthis.fire('squeezestart', inputSource, evt);\n\t\t});\n\t\tsession.addEventListener('squeezeend', evt => {\n\t\t\tconst inputSource = this._getByInputSource(evt.inputSource);\n\t\t\tinputSource.update(evt.frame);\n\t\t\tinputSource._squeezing = false;\n\t\t\tinputSource.fire('squeezeend', evt);\n\t\t\tthis.fire('squeezeend', inputSource, evt);\n\t\t});\n\t\tconst inputSources = session.inputSources;\n\t\tfor (let i = 0; i < inputSources.length; i++) {\n\t\t\tthis._addInputSource(inputSources[i]);\n\t\t}\n\t}\n\t_onSessionEnd() {\n\t\tlet i = this._inputSources.length;\n\t\twhile (i--) {\n\t\t\tconst inputSource = this._inputSources[i];\n\t\t\tthis._inputSources.splice(i, 1);\n\t\t\tinputSource.fire('remove');\n\t\t\tthis.fire('remove', inputSource);\n\t\t}\n\t\tconst session = this.manager.session;\n\t\tsession.removeEventListener('inputsourceschange', this._onInputSourcesChangeEvt);\n\t}\n\t_onInputSourcesChange(evt) {\n\t\tfor (let i = 0; i < evt.removed.length; i++) {\n\t\t\tthis._removeInputSource(evt.removed[i]);\n\t\t}\n\t\tfor (let i = 0; i < evt.added.length; i++) {\n\t\t\tthis._addInputSource(evt.added[i]);\n\t\t}\n\t}\n\t_getByInputSource(xrInputSource) {\n\t\tfor (let i = 0; i < this._inputSources.length; i++) {\n\t\t\tif (this._inputSources[i].inputSource === xrInputSource) {\n\t\t\t\treturn this._inputSources[i];\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t_addInputSource(xrInputSource) {\n\t\tif (this._getByInputSource(xrInputSource)) {\n\t\t\treturn;\n\t\t}\n\t\tconst inputSource = new XrInputSource(this.manager, xrInputSource);\n\t\tthis._inputSources.push(inputSource);\n\t\tthis.fire('add', inputSource);\n\t}\n\t_removeInputSource(xrInputSource) {\n\t\tfor (let i = 0; i < this._inputSources.length; i++) {\n\t\t\tif (this._inputSources[i].inputSource !== xrInputSource) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst inputSource = this._inputSources[i];\n\t\t\tthis._inputSources.splice(i, 1);\n\t\t\tlet h = inputSource.hitTestSources.length;\n\t\t\twhile (h--) {\n\t\t\t\tinputSource.hitTestSources[h].remove();\n\t\t\t}\n\t\t\tinputSource.fire('remove');\n\t\t\tthis.fire('remove', inputSource);\n\t\t\treturn;\n\t\t}\n\t}\n\tupdate(frame) {\n\t\tfor (let i = 0; i < this._inputSources.length; i++) {\n\t\t\tthis._inputSources[i].update(frame);\n\t\t}\n\t}\n\tget inputSources() {\n\t\treturn this._inputSources;\n\t}\n}\nXrInput.EVENT_ADD = 'add';\nXrInput.EVENT_REMOVE = 'remove';\nXrInput.EVENT_SELECT = 'select';\nXrInput.EVENT_SELECTSTART = 'selectstart';\nXrInput.EVENT_SELECTEND = 'selectend';\nXrInput.EVENT_SQUEEZE = 'squeeze';\nXrInput.EVENT_SQUEEZESTART = 'squeezestart';\nXrInput.EVENT_SQUEEZEEND = 'squeezeend';\n\nexport { XrInput };\n","import { platform } from '../../core/platform.js';\nimport { Mat4 } from '../../core/math/mat4.js';\nimport { Quat } from '../../core/math/quat.js';\nimport { Vec3 } from '../../core/math/vec3.js';\n\nconst tipJointIds = platform.browser && window.XRHand ? ['thumb-tip', 'index-finger-tip', 'middle-finger-tip', 'ring-finger-tip', 'pinky-finger-tip'] : [];\nconst tipJointIdsIndex = {};\nfor (let i = 0; i < tipJointIds.length; i++) {\n\ttipJointIdsIndex[tipJointIds[i]] = true;\n}\nclass XrJoint {\n\tconstructor(index, id, hand, finger = null) {\n\t\tthis._index = void 0;\n\t\tthis._id = void 0;\n\t\tthis._hand = void 0;\n\t\tthis._finger = void 0;\n\t\tthis._wrist = void 0;\n\t\tthis._tip = void 0;\n\t\tthis._radius = null;\n\t\tthis._localTransform = new Mat4();\n\t\tthis._worldTransform = new Mat4();\n\t\tthis._localPosition = new Vec3();\n\t\tthis._localRotation = new Quat();\n\t\tthis._position = new Vec3();\n\t\tthis._rotation = new Quat();\n\t\tthis._dirtyLocal = true;\n\t\tthis._index = index;\n\t\tthis._id = id;\n\t\tthis._hand = hand;\n\t\tthis._finger = finger;\n\t\tthis._wrist = id === 'wrist';\n\t\tthis._tip = this._finger && !!tipJointIdsIndex[id];\n\t}\n\tupdate(pose) {\n\t\tthis._dirtyLocal = true;\n\t\tthis._radius = pose.radius;\n\t\tthis._localPosition.copy(pose.transform.position);\n\t\tthis._localRotation.copy(pose.transform.orientation);\n\t}\n\t_updateTransforms() {\n\t\tif (this._dirtyLocal) {\n\t\t\tthis._dirtyLocal = false;\n\t\t\tthis._localTransform.setTRS(this._localPosition, this._localRotation, Vec3.ONE);\n\t\t}\n\t\tconst manager = this._hand._manager;\n\t\tconst parent = manager.camera.parent;\n\t\tif (parent) {\n\t\t\tthis._worldTransform.mul2(parent.getWorldTransform(), this._localTransform);\n\t\t} else {\n\t\t\tthis._worldTransform.copy(this._localTransform);\n\t\t}\n\t}\n\tgetPosition() {\n\t\tthis._updateTransforms();\n\t\tthis._worldTransform.getTranslation(this._position);\n\t\treturn this._position;\n\t}\n\tgetRotation() {\n\t\tthis._updateTransforms();\n\t\tthis._rotation.setFromMat4(this._worldTransform);\n\t\treturn this._rotation;\n\t}\n\tget index() {\n\t\treturn this._index;\n\t}\n\tget hand() {\n\t\treturn this._hand;\n\t}\n\tget finger() {\n\t\treturn this._finger;\n\t}\n\tget wrist() {\n\t\treturn this._wrist;\n\t}\n\tget tip() {\n\t\treturn this._tip;\n\t}\n\tget radius() {\n\t\treturn this._radius || 0.005;\n\t}\n}\n\nexport { XrJoint };\n","import { EventHandler } from '../../core/event-handler.js';\nimport { Color } from '../../core/math/color.js';\nimport { Mat4 } from '../../core/math/mat4.js';\nimport { Quat } from '../../core/math/quat.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { XRTYPE_AR } from './constants.js';\n\nconst vec3A = new Vec3();\nconst vec3B = new Vec3();\nconst mat4A = new Mat4();\nconst mat4B = new Mat4();\nclass XrLightEstimation extends EventHandler {\n\tconstructor(manager) {\n\t\tsuper();\n\t\tthis._manager = void 0;\n\t\tthis._supported = false;\n\t\tthis._available = false;\n\t\tthis._lightProbeRequested = false;\n\t\tthis._lightProbe = null;\n\t\tthis._intensity = 0;\n\t\tthis._rotation = new Quat();\n\t\tthis._color = new Color();\n\t\tthis._sphericalHarmonics = new Float32Array(27);\n\t\tthis._manager = manager;\n\t\tthis._manager.on('start', this._onSessionStart, this);\n\t\tthis._manager.on('end', this._onSessionEnd, this);\n\t}\n\t_onSessionStart() {\n\t\tconst supported = !!this._manager.session.requestLightProbe;\n\t\tif (!supported) return;\n\t\tthis._supported = true;\n\t}\n\t_onSessionEnd() {\n\t\tthis._supported = false;\n\t\tthis._available = false;\n\t\tthis._lightProbeRequested = false;\n\t\tthis._lightProbe = null;\n\t}\n\tstart() {\n\t\tlet err;\n\t\tif (!this._manager.session) {\n\t\t\terr = new Error('XR session is not running');\n\t\t}\n\t\tif (!err && this._manager.type !== XRTYPE_AR) {\n\t\t\terr = new Error('XR session type is not AR');\n\t\t}\n\t\tif (!err && !this._supported) {\n\t\t\terr = new Error('light-estimation is not supported');\n\t\t}\n\t\tif (!err && this._lightProbe || this._lightProbeRequested) {\n\t\t\terr = new Error('light estimation is already requested');\n\t\t}\n\t\tif (err) {\n\t\t\tthis.fire('error', err);\n\t\t\treturn;\n\t\t}\n\t\tthis._lightProbeRequested = true;\n\t\tthis._manager.session.requestLightProbe().then(lightProbe => {\n\t\t\tconst wasRequested = this._lightProbeRequested;\n\t\t\tthis._lightProbeRequested = false;\n\t\t\tif (this._manager.active) {\n\t\t\t\tif (wasRequested) {\n\t\t\t\t\tthis._lightProbe = lightProbe;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.fire('error', new Error('XR session is not active'));\n\t\t\t}\n\t\t}).catch(ex => {\n\t\t\tthis._lightProbeRequested = false;\n\t\t\tthis.fire('error', ex);\n\t\t});\n\t}\n\tend() {\n\t\tthis._lightProbeRequested = false;\n\t\tthis._lightProbe = null;\n\t\tthis._available = false;\n\t}\n\tupdate(frame) {\n\t\tif (!this._lightProbe) return;\n\t\tconst lightEstimate = frame.getLightEstimate(this._lightProbe);\n\t\tif (!lightEstimate) return;\n\t\tif (!this._available) {\n\t\t\tthis._available = true;\n\t\t\tthis.fire('available');\n\t\t}\n\t\tconst pli = lightEstimate.primaryLightIntensity;\n\t\tthis._intensity = Math.max(1.0, Math.max(pli.x, Math.max(pli.y, pli.z)));\n\t\tvec3A.copy(pli).mulScalar(1 / this._intensity);\n\t\tthis._color.set(vec3A.x, vec3A.y, vec3A.z);\n\t\tvec3A.set(0, 0, 0);\n\t\tvec3B.copy(lightEstimate.primaryLightDirection);\n\t\tmat4A.setLookAt(vec3B, vec3A, Vec3.UP);\n\t\tmat4B.setFromAxisAngle(Vec3.RIGHT, 90);\n\t\tmat4A.mul(mat4B);\n\t\tthis._rotation.setFromMat4(mat4A);\n\t\tthis._sphericalHarmonics.set(lightEstimate.sphericalHarmonicsCoefficients);\n\t}\n\tget supported() {\n\t\treturn this._supported;\n\t}\n\tget available() {\n\t\treturn this._available;\n\t}\n\tget intensity() {\n\t\treturn this._available ? this._intensity : null;\n\t}\n\tget color() {\n\t\treturn this._available ? this._color : null;\n\t}\n\tget rotation() {\n\t\treturn this._available ? this._rotation : null;\n\t}\n\tget sphericalHarmonics() {\n\t\treturn this._available ? this._sphericalHarmonics : null;\n\t}\n}\nXrLightEstimation.EVENT_AVAILABLE = 'available';\nXrLightEstimation.EVENT_ERROR = 'error';\n\nexport { XrLightEstimation };\n","import { EventHandler } from '../../core/event-handler.js';\nimport { platform } from '../../core/platform.js';\nimport { Mat4 } from '../../core/math/mat4.js';\nimport { Quat } from '../../core/math/quat.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { XRTYPE_INLINE, XRTYPE_VR, XRTYPE_AR, XRDEPTHSENSINGUSAGE_CPU, XRDEPTHSENSINGFORMAT_L8A8 } from './constants.js';\nimport { DEVICETYPE_WEBGL1, DEVICETYPE_WEBGL2 } from '../../platform/graphics/constants.js';\nimport { XrDepthSensing } from './xr-depth-sensing.js';\nimport { XrDomOverlay } from './xr-dom-overlay.js';\nimport { XrHitTest } from './xr-hit-test.js';\nimport { XrImageTracking } from './xr-image-tracking.js';\nimport { XrInput } from './xr-input.js';\nimport { XrLightEstimation } from './xr-light-estimation.js';\nimport { XrPlaneDetection } from './xr-plane-detection.js';\nimport { XrAnchors } from './xr-anchors.js';\nimport { XrMeshDetection } from './xr-mesh-detection.js';\nimport { XrViews } from './xr-views.js';\n\nclass XrManager extends EventHandler {\n\tconstructor(app) {\n\t\tsuper();\n\t\tthis.app = void 0;\n\t\tthis._supported = platform.browser && !!navigator.xr;\n\t\tthis._available = {};\n\t\tthis._type = null;\n\t\tthis._spaceType = null;\n\t\tthis._session = null;\n\t\tthis._baseLayer = null;\n\t\tthis.webglBinding = null;\n\t\tthis._referenceSpace = null;\n\t\tthis.depthSensing = void 0;\n\t\tthis.domOverlay = void 0;\n\t\tthis.hitTest = void 0;\n\t\tthis.imageTracking = void 0;\n\t\tthis.planeDetection = void 0;\n\t\tthis.meshDetection = void 0;\n\t\tthis.input = void 0;\n\t\tthis.lightEstimation = void 0;\n\t\tthis.views = void 0;\n\t\tthis.anchors = void 0;\n\t\tthis._camera = null;\n\t\tthis._localPosition = new Vec3();\n\t\tthis._localRotation = new Quat();\n\t\tthis._depthNear = 0.1;\n\t\tthis._depthFar = 1000;\n\t\tthis._supportedFrameRates = null;\n\t\tthis._width = 0;\n\t\tthis._height = 0;\n\t\tthis._framebufferScaleFactor = 1.0;\n\t\tthis.app = app;\n\t\tthis._available[XRTYPE_INLINE] = false;\n\t\tthis._available[XRTYPE_VR] = false;\n\t\tthis._available[XRTYPE_AR] = false;\n\t\tthis.views = new XrViews(this);\n\t\tthis.depthSensing = new XrDepthSensing(this);\n\t\tthis.domOverlay = new XrDomOverlay(this);\n\t\tthis.hitTest = new XrHitTest(this);\n\t\tthis.imageTracking = new XrImageTracking(this);\n\t\tthis.planeDetection = new XrPlaneDetection(this);\n\t\tthis.meshDetection = new XrMeshDetection(this);\n\t\tthis.input = new XrInput(this);\n\t\tthis.lightEstimation = new XrLightEstimation(this);\n\t\tthis.anchors = new XrAnchors(this);\n\t\tthis.views = new XrViews(this);\n\t\tif (this._supported) {\n\t\t\tnavigator.xr.addEventListener('devicechange', () => {\n\t\t\t\tthis._deviceAvailabilityCheck();\n\t\t\t});\n\t\t\tthis._deviceAvailabilityCheck();\n\t\t\tthis.app.graphicsDevice.on('devicelost', this._onDeviceLost, this);\n\t\t\tthis.app.graphicsDevice.on('devicerestored', this._onDeviceRestored, this);\n\t\t}\n\t}\n\tdestroy() {}\n\tstart(camera, type, spaceType, options) {\n\t\tvar _options$framebufferS, _this$app$graphicsDev, _this$app$graphicsDev2;\n\t\tlet callback = options;\n\t\tif (typeof options === 'object') {\n\t\t\tcallback = options.callback;\n\t\t}\n\t\tif (!this._available[type]) {\n\t\t\tif (callback) callback(new Error('XR is not available'));\n\t\t\treturn;\n\t\t}\n\t\tif (this._session) {\n\t\t\tif (callback) callback(new Error('XR session is already started'));\n\t\t\treturn;\n\t\t}\n\t\tthis._camera = camera;\n\t\tthis._camera.camera.xr = this;\n\t\tthis._type = type;\n\t\tthis._spaceType = spaceType;\n\t\tthis._framebufferScaleFactor = (_options$framebufferS = options == null ? void 0 : options.framebufferScaleFactor) != null ? _options$framebufferS : 1.0;\n\t\tthis._setClipPlanes(camera.nearClip, camera.farClip);\n\t\tconst opts = {\n\t\t\trequiredFeatures: [spaceType],\n\t\t\toptionalFeatures: []\n\t\t};\n\t\tconst webgl = ((_this$app$graphicsDev = this.app.graphicsDevice) == null ? void 0 : _this$app$graphicsDev.isWebGL1) || ((_this$app$graphicsDev2 = this.app.graphicsDevice) == null ? void 0 : _this$app$graphicsDev2.isWebGL2);\n\t\tif (type === XRTYPE_AR) {\n\t\t\topts.optionalFeatures.push('light-estimation');\n\t\t\topts.optionalFeatures.push('hit-test');\n\t\t\tif (options) {\n\t\t\t\tif (options.imageTracking && this.imageTracking.supported) {\n\t\t\t\t\topts.optionalFeatures.push('image-tracking');\n\t\t\t\t}\n\t\t\t\tif (options.planeDetection) {\n\t\t\t\t\topts.optionalFeatures.push('plane-detection');\n\t\t\t\t}\n\t\t\t\tif (options.meshDetection) {\n\t\t\t\t\topts.optionalFeatures.push('mesh-detection');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.domOverlay.supported && this.domOverlay.root) {\n\t\t\t\topts.optionalFeatures.push('dom-overlay');\n\t\t\t\topts.domOverlay = {\n\t\t\t\t\troot: this.domOverlay.root\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (options && options.anchors && this.anchors.supported) {\n\t\t\t\topts.optionalFeatures.push('anchors');\n\t\t\t}\n\t\t\tif (options && options.depthSensing && this.depthSensing.supported) {\n\t\t\t\topts.optionalFeatures.push('depth-sensing');\n\t\t\t\tconst usagePreference = [];\n\t\t\t\tconst dataFormatPreference = [];\n\t\t\t\tif (!navigator.userAgent.includes('OculusBrowser')) {\n\t\t\t\t\tusagePreference.push(XRDEPTHSENSINGUSAGE_CPU);\n\t\t\t\t\tdataFormatPreference.push(XRDEPTHSENSINGFORMAT_L8A8);\n\t\t\t\t\tif (options.depthSensing.usagePreference) {\n\t\t\t\t\t\tconst ind = usagePreference.indexOf(options.depthSensing.usagePreference);\n\t\t\t\t\t\tif (ind !== -1) usagePreference.splice(ind, 1);\n\t\t\t\t\t\tusagePreference.unshift(options.depthSensing.usagePreference);\n\t\t\t\t\t}\n\t\t\t\t\tif (options.depthSensing.dataFormatPreference) {\n\t\t\t\t\t\tconst ind = dataFormatPreference.indexOf(options.depthSensing.dataFormatPreference);\n\t\t\t\t\t\tif (ind !== -1) dataFormatPreference.splice(ind, 1);\n\t\t\t\t\t\tdataFormatPreference.unshift(options.depthSensing.dataFormatPreference);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\topts.depthSensing = {\n\t\t\t\t\tusagePreference: usagePreference,\n\t\t\t\t\tdataFormatPreference: dataFormatPreference\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (webgl && options && options.cameraColor && this.views.supportedColor) {\n\t\t\t\topts.optionalFeatures.push('camera-access');\n\t\t\t}\n\t\t}\n\t\topts.optionalFeatures.push('hand-tracking');\n\t\tif (options && options.optionalFeatures) {\n\t\t\topts.optionalFeatures = opts.optionalFeatures.concat(options.optionalFeatures);\n\t\t}\n\t\tif (this.imageTracking.supported && this.imageTracking.images.length) {\n\t\t\tthis.imageTracking.prepareImages((err, trackedImages) => {\n\t\t\t\tif (err) {\n\t\t\t\t\tif (callback) callback(err);\n\t\t\t\t\tthis.fire('error', err);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (trackedImages !== null) {\n\t\t\t\t\topts.trackedImages = trackedImages;\n\t\t\t\t}\n\t\t\t\tthis._onStartOptionsReady(type, spaceType, opts, callback);\n\t\t\t});\n\t\t} else {\n\t\t\tthis._onStartOptionsReady(type, spaceType, opts, callback);\n\t\t}\n\t}\n\t_onStartOptionsReady(type, spaceType, options, callback) {\n\t\tnavigator.xr.requestSession(type, options).then(session => {\n\t\t\tthis._onSessionStart(session, spaceType, callback);\n\t\t}).catch(ex => {\n\t\t\tthis._camera.camera.xr = null;\n\t\t\tthis._camera = null;\n\t\t\tthis._type = null;\n\t\t\tthis._spaceType = null;\n\t\t\tif (callback) callback(ex);\n\t\t\tthis.fire('error', ex);\n\t\t});\n\t}\n\tend(callback) {\n\t\tif (!this._session) {\n\t\t\tif (callback) callback(new Error('XR Session is not initialized'));\n\t\t\treturn;\n\t\t}\n\t\tthis.webglBinding = null;\n\t\tif (callback) this.once('end', callback);\n\t\tthis._session.end();\n\t}\n\tisAvailable(type) {\n\t\treturn this._available[type];\n\t}\n\t_deviceAvailabilityCheck() {\n\t\tfor (const key in this._available) {\n\t\t\tthis._sessionSupportCheck(key);\n\t\t}\n\t}\n\tinitiateRoomCapture(callback) {\n\t\tif (!this._session) {\n\t\t\tcallback(new Error('Session is not active'));\n\t\t\treturn;\n\t\t}\n\t\tif (!this._session.initiateRoomCapture) {\n\t\t\tcallback(new Error('Session does not support manual room capture'));\n\t\t\treturn;\n\t\t}\n\t\tthis._session.initiateRoomCapture().then(() => {\n\t\t\tif (callback) callback(null);\n\t\t}).catch(err => {\n\t\t\tif (callback) callback(err);\n\t\t});\n\t}\n\tupdateTargetFrameRate(frameRate, callback) {\n\t\tvar _this$_session;\n\t\tif (!((_this$_session = this._session) != null && _this$_session.updateTargetFrameRate)) {\n\t\t\tcallback == null || callback(new Error('unable to update frameRate'));\n\t\t\treturn;\n\t\t}\n\t\tthis._session.updateTargetFrameRate(frameRate).then(() => {\n\t\t\tcallback == null || callback();\n\t\t}).catch(err => {\n\t\t\tcallback == null || callback(err);\n\t\t});\n\t}\n\t_sessionSupportCheck(type) {\n\t\tnavigator.xr.isSessionSupported(type).then(available => {\n\t\t\tif (this._available[type] === available) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._available[type] = available;\n\t\t\tthis.fire('available', type, available);\n\t\t\tthis.fire(`available:${type}`, available);\n\t\t}).catch(ex => {\n\t\t\tthis.fire('error', ex);\n\t\t});\n\t}\n\t_onSessionStart(session, spaceType, callback) {\n\t\tlet failed = false;\n\t\tthis._session = session;\n\t\tconst onVisibilityChange = () => {\n\t\t\tthis.fire('visibility:change', session.visibilityState);\n\t\t};\n\t\tconst onClipPlanesChange = () => {\n\t\t\tthis._setClipPlanes(this._camera.nearClip, this._camera.farClip);\n\t\t};\n\t\tconst onEnd = () => {\n\t\t\tif (this._camera) {\n\t\t\t\tthis._camera.off('set_nearClip', onClipPlanesChange);\n\t\t\t\tthis._camera.off('set_farClip', onClipPlanesChange);\n\t\t\t\tthis._camera.camera.xr = null;\n\t\t\t\tthis._camera = null;\n\t\t\t}\n\t\t\tsession.removeEventListener('end', onEnd);\n\t\t\tsession.removeEventListener('visibilitychange', onVisibilityChange);\n\t\t\tif (!failed) this.fire('end');\n\t\t\tthis._session = null;\n\t\t\tthis._referenceSpace = null;\n\t\t\tthis._width = 0;\n\t\t\tthis._height = 0;\n\t\t\tthis._type = null;\n\t\t\tthis._spaceType = null;\n\t\t\tif (this.app.systems) {\n\t\t\t\tthis.app.tick();\n\t\t\t}\n\t\t};\n\t\tsession.addEventListener('end', onEnd);\n\t\tsession.addEventListener('visibilitychange', onVisibilityChange);\n\t\tthis._camera.on('set_nearClip', onClipPlanesChange);\n\t\tthis._camera.on('set_farClip', onClipPlanesChange);\n\t\tthis._createBaseLayer();\n\t\tif (this.session.supportedFrameRates) {\n\t\t\tthis._supportedFrameRates = Array.from(this.session.supportedFrameRates);\n\t\t} else {\n\t\t\tthis._supportedFrameRates = null;\n\t\t}\n\t\tthis._session.addEventListener('frameratechange', () => {\n\t\t\tvar _this$_session2;\n\t\t\tthis.fire('frameratechange', (_this$_session2 = this._session) == null ? void 0 : _this$_session2.frameRate);\n\t\t});\n\t\tsession.requestReferenceSpace(spaceType).then(referenceSpace => {\n\t\t\tthis._referenceSpace = referenceSpace;\n\t\t\tthis.app.tick();\n\t\t\tif (callback) callback(null);\n\t\t\tthis.fire('start');\n\t\t}).catch(ex => {\n\t\t\tfailed = true;\n\t\t\tsession.end();\n\t\t\tif (callback) callback(ex);\n\t\t\tthis.fire('error', ex);\n\t\t});\n\t}\n\t_setClipPlanes(near, far) {\n\t\tif (this._depthNear === near && this._depthFar === far) {\n\t\t\treturn;\n\t\t}\n\t\tthis._depthNear = near;\n\t\tthis._depthFar = far;\n\t\tif (!this._session) {\n\t\t\treturn;\n\t\t}\n\t\tthis._session.updateRenderState({\n\t\t\tdepthNear: this._depthNear,\n\t\t\tdepthFar: this._depthFar\n\t\t});\n\t}\n\t_createBaseLayer() {\n\t\tconst device = this.app.graphicsDevice;\n\t\tconst framebufferScaleFactor = device.maxPixelRatio / window.devicePixelRatio * this._framebufferScaleFactor;\n\t\tthis._baseLayer = new XRWebGLLayer(this._session, device.gl, {\n\t\t\talpha: true,\n\t\t\tdepth: true,\n\t\t\tstencil: true,\n\t\t\tframebufferScaleFactor: framebufferScaleFactor,\n\t\t\tantialias: false\n\t\t});\n\t\tconst deviceType = device.deviceType;\n\t\tif ((deviceType === DEVICETYPE_WEBGL1 || deviceType === DEVICETYPE_WEBGL2) && window.XRWebGLBinding) {\n\t\t\ttry {\n\t\t\t\tthis.webglBinding = new XRWebGLBinding(this._session, device.gl);\n\t\t\t} catch (ex) {\n\t\t\t\tthis.fire('error', ex);\n\t\t\t}\n\t\t}\n\t\tthis._session.updateRenderState({\n\t\t\tbaseLayer: this._baseLayer,\n\t\t\tdepthNear: this._depthNear,\n\t\t\tdepthFar: this._depthFar\n\t\t});\n\t}\n\t_onDeviceLost() {\n\t\tif (!this._session) {\n\t\t\treturn;\n\t\t}\n\t\tif (this.webglBinding) {\n\t\t\tthis.webglBinding = null;\n\t\t}\n\t\tthis._baseLayer = null;\n\t\tthis._session.updateRenderState({\n\t\t\tbaseLayer: this._baseLayer,\n\t\t\tdepthNear: this._depthNear,\n\t\t\tdepthFar: this._depthFar\n\t\t});\n\t}\n\t_onDeviceRestored() {\n\t\tif (!this._session) {\n\t\t\treturn;\n\t\t}\n\t\tsetTimeout(() => {\n\t\t\tthis.app.graphicsDevice.gl.makeXRCompatible().then(() => {\n\t\t\t\tthis._createBaseLayer();\n\t\t\t}).catch(ex => {\n\t\t\t\tthis.fire('error', ex);\n\t\t\t});\n\t\t}, 0);\n\t}\n\tupdate(frame) {\n\t\tif (!this._session) return false;\n\t\tconst width = frame.session.renderState.baseLayer.framebufferWidth;\n\t\tconst height = frame.session.renderState.baseLayer.framebufferHeight;\n\t\tif (this._width !== width || this._height !== height) {\n\t\t\tthis._width = width;\n\t\t\tthis._height = height;\n\t\t\tthis.app.graphicsDevice.setResolution(width, height);\n\t\t}\n\t\tconst pose = frame.getViewerPose(this._referenceSpace);\n\t\tif (!pose) return false;\n\t\tconst lengthOld = this.views.list.length;\n\t\tthis.views.update(frame, pose.views);\n\t\tconst posePosition = pose.transform.position;\n\t\tconst poseOrientation = pose.transform.orientation;\n\t\tthis._localPosition.set(posePosition.x, posePosition.y, posePosition.z);\n\t\tthis._localRotation.set(poseOrientation.x, poseOrientation.y, poseOrientation.z, poseOrientation.w);\n\t\tif (lengthOld === 0 && this.views.list.length > 0) {\n\t\t\tconst viewProjMat = new Mat4();\n\t\t\tconst view = this.views.list[0];\n\t\t\tviewProjMat.copy(view.projMat);\n\t\t\tconst data = viewProjMat.data;\n\t\t\tconst fov = 2.0 * Math.atan(1.0 / data[5]) * 180.0 / Math.PI;\n\t\t\tconst aspectRatio = data[5] / data[0];\n\t\t\tconst farClip = data[14] / (data[10] + 1);\n\t\t\tconst nearClip = data[14] / (data[10] - 1);\n\t\t\tconst horizontalFov = false;\n\t\t\tconst camera = this._camera.camera;\n\t\t\tcamera.setXrProperties({\n\t\t\t\taspectRatio,\n\t\t\t\tfarClip,\n\t\t\t\tfov,\n\t\t\t\thorizontalFov,\n\t\t\t\tnearClip\n\t\t\t});\n\t\t}\n\t\tthis._camera.camera._node.setLocalPosition(this._localPosition);\n\t\tthis._camera.camera._node.setLocalRotation(this._localRotation);\n\t\tthis.input.update(frame);\n\t\tif (this._type === XRTYPE_AR) {\n\t\t\tif (this.hitTest.supported) {\n\t\t\t\tthis.hitTest.update(frame);\n\t\t\t}\n\t\t\tif (this.lightEstimation.supported) {\n\t\t\t\tthis.lightEstimation.update(frame);\n\t\t\t}\n\t\t\tif (this.imageTracking.supported) {\n\t\t\t\tthis.imageTracking.update(frame);\n\t\t\t}\n\t\t\tif (this.anchors.supported) {\n\t\t\t\tthis.anchors.update(frame);\n\t\t\t}\n\t\t\tif (this.planeDetection.supported) {\n\t\t\t\tthis.planeDetection.update(frame);\n\t\t\t}\n\t\t\tif (this.depthSensing.supported) {\n\t\t\t\tthis.depthSensing.update();\n\t\t\t}\n\t\t\tif (this.meshDetection.supported) {\n\t\t\t\tthis.meshDetection.update(frame);\n\t\t\t}\n\t\t}\n\t\tthis.fire('update', frame);\n\t\treturn true;\n\t}\n\tget supported() {\n\t\treturn this._supported;\n\t}\n\tget active() {\n\t\treturn !!this._session;\n\t}\n\tget type() {\n\t\treturn this._type;\n\t}\n\tget spaceType() {\n\t\treturn this._spaceType;\n\t}\n\tget session() {\n\t\treturn this._session;\n\t}\n\tget frameRate() {\n\t\tvar _this$_session$frameR, _this$_session3;\n\t\treturn (_this$_session$frameR = (_this$_session3 = this._session) == null ? void 0 : _this$_session3.frameRate) != null ? _this$_session$frameR : null;\n\t}\n\tget supportedFrameRates() {\n\t\treturn this._supportedFrameRates;\n\t}\n\tget framebufferScaleFactor() {\n\t\treturn this._framebufferScaleFactor;\n\t}\n\tset fixedFoveation(value) {\n\t\tvar _this$_baseLayer$fixe, _this$_baseLayer;\n\t\tif (((_this$_baseLayer$fixe = (_this$_baseLayer = this._baseLayer) == null ? void 0 : _this$_baseLayer.fixedFoveation) != null ? _this$_baseLayer$fixe : null) !== null) {\n\t\t\tif (this.app.graphicsDevice.samples > 1) ;\n\t\t\tthis._baseLayer.fixedFoveation = value;\n\t\t}\n\t}\n\tget fixedFoveation() {\n\t\tvar _this$_baseLayer$fixe2, _this$_baseLayer2;\n\t\treturn (_this$_baseLayer$fixe2 = (_this$_baseLayer2 = this._baseLayer) == null ? void 0 : _this$_baseLayer2.fixedFoveation) != null ? _this$_baseLayer$fixe2 : null;\n\t}\n\tget camera() {\n\t\treturn this._camera ? this._camera.entity : null;\n\t}\n\tget visibilityState() {\n\t\tif (!this._session) {\n\t\t\treturn null;\n\t\t}\n\t\treturn this._session.visibilityState;\n\t}\n}\nXrManager.EVENT_AVAILABLE = 'available';\nXrManager.EVENT_START = 'start';\nXrManager.EVENT_END = 'end';\nXrManager.EVENT_UPDATE = 'update';\nXrManager.EVENT_ERROR = 'error';\n\nexport { XrManager };\n","import { platform } from '../../core/platform.js';\nimport { EventHandler } from '../../core/event-handler.js';\nimport { XrMesh } from './xr-mesh.js';\n\nclass XrMeshDetection extends EventHandler {\n\tconstructor(manager) {\n\t\tsuper();\n\t\tthis._manager = void 0;\n\t\tthis._supported = platform.browser && !!window.XRMesh;\n\t\tthis._available = false;\n\t\tthis._index = new Map();\n\t\tthis._list = [];\n\t\tthis._manager = manager;\n\t\tif (this._supported) {\n\t\t\tthis._manager.on('start', this._onSessionStart, this);\n\t\t\tthis._manager.on('end', this._onSessionEnd, this);\n\t\t}\n\t}\n\tupdate(frame) {\n\t\tif (!this._available) {\n\t\t\tif (!this._manager.session.enabledFeatures && frame.detectedMeshes.size) {\n\t\t\t\tthis._available = true;\n\t\t\t\tthis.fire('available');\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tfor (const xrMesh of frame.detectedMeshes) {\n\t\t\tlet mesh = this._index.get(xrMesh);\n\t\t\tif (!mesh) {\n\t\t\t\tmesh = new XrMesh(this, xrMesh);\n\t\t\t\tthis._index.set(xrMesh, mesh);\n\t\t\t\tthis._list.push(mesh);\n\t\t\t\tmesh.update(frame);\n\t\t\t\tthis.fire('add', mesh);\n\t\t\t} else {\n\t\t\t\tmesh.update(frame);\n\t\t\t}\n\t\t}\n\t\tfor (const mesh of this._index.values()) {\n\t\t\tif (frame.detectedMeshes.has(mesh.xrMesh)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._removeMesh(mesh);\n\t\t}\n\t}\n\t_removeMesh(mesh) {\n\t\tthis._index.delete(mesh.xrMesh);\n\t\tthis._list.splice(this._list.indexOf(mesh), 1);\n\t\tmesh.destroy();\n\t\tthis.fire('remove', mesh);\n\t}\n\t_onSessionStart() {\n\t\tif (this._manager.session.enabledFeatures) {\n\t\t\tconst available = this._manager.session.enabledFeatures.indexOf('mesh-detection') !== -1;\n\t\t\tif (!available) return;\n\t\t\tthis._available = available;\n\t\t\tthis.fire('available');\n\t\t}\n\t}\n\t_onSessionEnd() {\n\t\tif (!this._available) return;\n\t\tthis._available = false;\n\t\tfor (const mesh of this._index.values()) {\n\t\t\tthis._removeMesh(mesh);\n\t\t}\n\t\tthis.fire('unavailable');\n\t}\n\tget supported() {\n\t\treturn this._supported;\n\t}\n\tget available() {\n\t\treturn this._available;\n\t}\n\tget meshes() {\n\t\treturn this._list;\n\t}\n}\nXrMeshDetection.EVENT_AVAILABLE = 'available';\nXrMeshDetection.EVENT_UNAVAILABLE = 'unavailable';\nXrMeshDetection.EVENT_ADD = 'add';\nXrMeshDetection.EVENT_REMOVE = 'remove';\n\nexport { XrMeshDetection };\n","import { EventHandler } from '../../core/event-handler.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { Quat } from '../../core/math/quat.js';\n\nclass XrMesh extends EventHandler {\n\tconstructor(meshDetection, xrMesh) {\n\t\tsuper();\n\t\tthis._meshDetection = void 0;\n\t\tthis._xrMesh = void 0;\n\t\tthis._lastChanged = 0;\n\t\tthis._position = new Vec3();\n\t\tthis._rotation = new Quat();\n\t\tthis._meshDetection = meshDetection;\n\t\tthis._xrMesh = xrMesh;\n\t\tthis._lastChanged = this._xrMesh.lastChangedTime;\n\t}\n\tget xrMesh() {\n\t\treturn this._xrMesh;\n\t}\n\tget label() {\n\t\treturn this._xrMesh.semanticLabel || '';\n\t}\n\tget vertices() {\n\t\treturn this._xrMesh.vertices;\n\t}\n\tget indices() {\n\t\treturn this._xrMesh.indices;\n\t}\n\tdestroy() {\n\t\tif (!this._xrMesh) return;\n\t\tthis._xrMesh = null;\n\t\tthis.fire('remove');\n\t}\n\tupdate(frame) {\n\t\tconst manager = this._meshDetection._manager;\n\t\tconst pose = frame.getPose(this._xrMesh.meshSpace, manager._referenceSpace);\n\t\tif (pose) {\n\t\t\tthis._position.copy(pose.transform.position);\n\t\t\tthis._rotation.copy(pose.transform.orientation);\n\t\t}\n\t\tif (this._lastChanged !== this._xrMesh.lastChangedTime) {\n\t\t\tthis._lastChanged = this._xrMesh.lastChangedTime;\n\t\t\tthis.fire('change');\n\t\t}\n\t}\n\tgetPosition() {\n\t\treturn this._position;\n\t}\n\tgetRotation() {\n\t\treturn this._rotation;\n\t}\n}\nXrMesh.EVENT_REMOVE = 'remove';\nXrMesh.EVENT_CHANGE = 'change';\n\nexport { XrMesh };\n","import { platform } from '../../core/platform.js';\nimport { EventHandler } from '../../core/event-handler.js';\nimport { XrPlane } from './xr-plane.js';\n\nclass XrPlaneDetection extends EventHandler {\n\tconstructor(manager) {\n\t\tsuper();\n\t\tthis._manager = void 0;\n\t\tthis._supported = platform.browser && !!window.XRPlane;\n\t\tthis._available = false;\n\t\tthis._planesIndex = new Map();\n\t\tthis._planes = [];\n\t\tthis._manager = manager;\n\t\tif (this._supported) {\n\t\t\tthis._manager.on('start', this._onSessionStart, this);\n\t\t\tthis._manager.on('end', this._onSessionEnd, this);\n\t\t}\n\t}\n\t_onSessionStart() {\n\t\tif (this._manager.session.enabledFeatures) {\n\t\t\tconst available = this._manager.session.enabledFeatures.indexOf('plane-detection') !== -1;\n\t\t\tif (available) {\n\t\t\t\tthis._available = true;\n\t\t\t\tthis.fire('available');\n\t\t\t}\n\t\t}\n\t}\n\t_onSessionEnd() {\n\t\tfor (let i = 0; i < this._planes.length; i++) {\n\t\t\tthis._planes[i].destroy();\n\t\t\tthis.fire('remove', this._planes[i]);\n\t\t}\n\t\tthis._planesIndex.clear();\n\t\tthis._planes.length = 0;\n\t\tif (this._available) {\n\t\t\tthis._available = false;\n\t\t\tthis.fire('unavailable');\n\t\t}\n\t}\n\tupdate(frame) {\n\t\tif (!this._available) {\n\t\t\tif (!this._manager.session.enabledFeatures && frame.detectedPlanes.size) {\n\t\t\t\tthis._available = true;\n\t\t\t\tthis.fire('available');\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tconst detectedPlanes = frame.detectedPlanes;\n\t\tfor (const [xrPlane, plane] of this._planesIndex) {\n\t\t\tif (detectedPlanes.has(xrPlane)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis._planesIndex.delete(xrPlane);\n\t\t\tthis._planes.splice(this._planes.indexOf(plane), 1);\n\t\t\tplane.destroy();\n\t\t\tthis.fire('remove', plane);\n\t\t}\n\t\tfor (const xrPlane of detectedPlanes) {\n\t\t\tlet plane = this._planesIndex.get(xrPlane);\n\t\t\tif (!plane) {\n\t\t\t\tplane = new XrPlane(this, xrPlane);\n\t\t\t\tthis._planesIndex.set(xrPlane, plane);\n\t\t\t\tthis._planes.push(plane);\n\t\t\t\tplane.update(frame);\n\t\t\t\tthis.fire('add', plane);\n\t\t\t} else {\n\t\t\t\tplane.update(frame);\n\t\t\t}\n\t\t}\n\t}\n\tget supported() {\n\t\treturn this._supported;\n\t}\n\tget available() {\n\t\treturn this._available;\n\t}\n\tget planes() {\n\t\treturn this._planes;\n\t}\n}\nXrPlaneDetection.EVENT_AVAILABLE = 'available';\nXrPlaneDetection.EVENT_UNAVAILABLE = 'unavailable';\nXrPlaneDetection.EVENT_ADD = 'add';\nXrPlaneDetection.EVENT_REMOVE = 'remove';\n\nexport { XrPlaneDetection };\n","import { EventHandler } from '../../core/event-handler.js';\nimport { Quat } from '../../core/math/quat.js';\nimport { Vec3 } from '../../core/math/vec3.js';\n\nlet ids = 0;\nclass XrPlane extends EventHandler {\n\tconstructor(planeDetection, xrPlane) {\n\t\tsuper();\n\t\tthis._id = void 0;\n\t\tthis._planeDetection = void 0;\n\t\tthis._xrPlane = void 0;\n\t\tthis._lastChangedTime = void 0;\n\t\tthis._orientation = void 0;\n\t\tthis._position = new Vec3();\n\t\tthis._rotation = new Quat();\n\t\tthis._id = ++ids;\n\t\tthis._planeDetection = planeDetection;\n\t\tthis._xrPlane = xrPlane;\n\t\tthis._lastChangedTime = xrPlane.lastChangedTime;\n\t\tthis._orientation = xrPlane.orientation;\n\t}\n\tdestroy() {\n\t\tif (!this._xrPlane) return;\n\t\tthis._xrPlane = null;\n\t\tthis.fire('remove');\n\t}\n\tupdate(frame) {\n\t\tconst manager = this._planeDetection._manager;\n\t\tconst pose = frame.getPose(this._xrPlane.planeSpace, manager._referenceSpace);\n\t\tif (pose) {\n\t\t\tthis._position.copy(pose.transform.position);\n\t\t\tthis._rotation.copy(pose.transform.orientation);\n\t\t}\n\t\tif (this._lastChangedTime !== this._xrPlane.lastChangedTime) {\n\t\t\tthis._lastChangedTime = this._xrPlane.lastChangedTime;\n\t\t\tthis.fire('change');\n\t\t}\n\t}\n\tgetPosition() {\n\t\treturn this._position;\n\t}\n\tgetRotation() {\n\t\treturn this._rotation;\n\t}\n\tget id() {\n\t\treturn this._id;\n\t}\n\tget orientation() {\n\t\treturn this._orientation;\n\t}\n\tget points() {\n\t\treturn this._xrPlane.polygon;\n\t}\n\tget label() {\n\t\treturn this._xrPlane.semanticLabel || '';\n\t}\n}\nXrPlane.EVENT_REMOVE = 'remove';\nXrPlane.EVENT_CHANGE = 'change';\n\nexport { XrPlane };\n","import { EventHandler } from '../../core/event-handler.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { Quat } from '../../core/math/quat.js';\n\nclass XrTrackedImage extends EventHandler {\n\tconstructor(image, width) {\n\t\tsuper();\n\t\tthis._image = void 0;\n\t\tthis._width = void 0;\n\t\tthis._bitmap = null;\n\t\tthis._measuredWidth = 0;\n\t\tthis._trackable = false;\n\t\tthis._tracking = false;\n\t\tthis._emulated = false;\n\t\tthis._pose = null;\n\t\tthis._position = new Vec3();\n\t\tthis._rotation = new Quat();\n\t\tthis._image = image;\n\t\tthis._width = width;\n\t}\n\tget image() {\n\t\treturn this._image;\n\t}\n\tset width(value) {\n\t\tthis._width = value;\n\t}\n\tget width() {\n\t\treturn this._width;\n\t}\n\tget trackable() {\n\t\treturn this._trackable;\n\t}\n\tget tracking() {\n\t\treturn this._tracking;\n\t}\n\tget emulated() {\n\t\treturn this._emulated;\n\t}\n\tprepare() {\n\t\tif (this._bitmap) {\n\t\t\treturn {\n\t\t\t\timage: this._bitmap,\n\t\t\t\twidthInMeters: this._width\n\t\t\t};\n\t\t}\n\t\treturn createImageBitmap(this._image).then(bitmap => {\n\t\t\tthis._bitmap = bitmap;\n\t\t\treturn {\n\t\t\t\timage: this._bitmap,\n\t\t\t\twidthInMeters: this._width\n\t\t\t};\n\t\t});\n\t}\n\tdestroy() {\n\t\tthis._image = null;\n\t\tthis._pose = null;\n\t\tif (this._bitmap) {\n\t\t\tthis._bitmap.close();\n\t\t\tthis._bitmap = null;\n\t\t}\n\t}\n\tgetPosition() {\n\t\tif (this._pose) this._position.copy(this._pose.transform.position);\n\t\treturn this._position;\n\t}\n\tgetRotation() {\n\t\tif (this._pose) this._rotation.copy(this._pose.transform.orientation);\n\t\treturn this._rotation;\n\t}\n}\nXrTrackedImage.EVENT_TRACKED = 'tracked';\nXrTrackedImage.EVENT_UNTRACKED = 'untracked';\n\nexport { XrTrackedImage };\n","import { EventHandler } from '../../core/event-handler.js';\nimport { Texture } from '../../platform/graphics/texture.js';\nimport { Vec4 } from '../../core/math/vec4.js';\nimport { Mat3 } from '../../core/math/mat3.js';\nimport { Mat4 } from '../../core/math/mat4.js';\nimport { PIXELFORMAT_RGB8, ADDRESS_CLAMP_TO_EDGE, FILTER_LINEAR } from '../../platform/graphics/constants.js';\n\nclass XrView extends EventHandler {\n\tconstructor(manager, xrView, viewsCount) {\n\t\tsuper();\n\t\tthis._manager = void 0;\n\t\tthis._xrView = void 0;\n\t\tthis._positionData = new Float32Array(3);\n\t\tthis._viewport = new Vec4();\n\t\tthis._projMat = new Mat4();\n\t\tthis._projViewOffMat = new Mat4();\n\t\tthis._viewMat = new Mat4();\n\t\tthis._viewOffMat = new Mat4();\n\t\tthis._viewMat3 = new Mat3();\n\t\tthis._viewInvMat = new Mat4();\n\t\tthis._viewInvOffMat = new Mat4();\n\t\tthis._xrCamera = null;\n\t\tthis._textureColor = null;\n\t\tthis._textureDepth = null;\n\t\tthis._depthInfo = null;\n\t\tthis._emptyDepthBuffer = new Uint8Array(32);\n\t\tthis._depthMatrix = new Mat4();\n\t\tthis._manager = manager;\n\t\tthis._xrView = xrView;\n\t\tconst device = this._manager.app.graphicsDevice;\n\t\tif (this._manager.views.supportedColor) {\n\t\t\tthis._xrCamera = this._xrView.camera;\n\t\t\tif (this._manager.views.availableColor && this._xrCamera) {\n\t\t\t\tthis._textureColor = new Texture(device, {\n\t\t\t\t\tformat: PIXELFORMAT_RGB8,\n\t\t\t\t\tmipmaps: false,\n\t\t\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\t\t\tminFilter: FILTER_LINEAR,\n\t\t\t\t\tmagFilter: FILTER_LINEAR,\n\t\t\t\t\twidth: this._xrCamera.width,\n\t\t\t\t\theight: this._xrCamera.height,\n\t\t\t\t\tname: `XrView-${this._xrView.eye}-Color`\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (this._manager.views.supportedDepth && this._manager.views.availableDepth) {\n\t\t\tthis._textureDepth = new Texture(device, {\n\t\t\t\tformat: this._manager.views.depthPixelFormat,\n\t\t\t\tarrayLength: viewsCount === 1 ? 0 : viewsCount,\n\t\t\t\tmipmaps: false,\n\t\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\t\tminFilter: FILTER_LINEAR,\n\t\t\t\tmagFilter: FILTER_LINEAR,\n\t\t\t\twidth: 4,\n\t\t\t\theight: 4,\n\t\t\t\tname: `XrView-${this._xrView.eye}-Depth`\n\t\t\t});\n\t\t\tfor (let i = 0; i < this._textureDepth._levels.length; i++) {\n\t\t\t\tthis._textureDepth._levels[i] = this._emptyDepthBuffer;\n\t\t\t}\n\t\t}\n\t\tif (this._textureColor || this._textureDepth) {\n\t\t\tdevice.on('devicelost', this._onDeviceLost, this);\n\t\t}\n\t}\n\tget textureColor() {\n\t\treturn this._textureColor;\n\t}\n\tget textureDepth() {\n\t\treturn this._textureDepth;\n\t}\n\tget depthUvMatrix() {\n\t\treturn this._depthMatrix;\n\t}\n\tget depthValueToMeters() {\n\t\tvar _this$_depthInfo;\n\t\treturn ((_this$_depthInfo = this._depthInfo) == null ? void 0 : _this$_depthInfo.rawValueToMeters) || 0;\n\t}\n\tget eye() {\n\t\treturn this._xrView.eye;\n\t}\n\tget viewport() {\n\t\treturn this._viewport;\n\t}\n\tget projMat() {\n\t\treturn this._projMat;\n\t}\n\tget projViewOffMat() {\n\t\treturn this._projViewOffMat;\n\t}\n\tget viewOffMat() {\n\t\treturn this._viewOffMat;\n\t}\n\tget viewInvOffMat() {\n\t\treturn this._viewInvOffMat;\n\t}\n\tget viewMat3() {\n\t\treturn this._viewMat3;\n\t}\n\tget positionData() {\n\t\treturn this._positionData;\n\t}\n\tupdate(frame, xrView) {\n\t\tthis._xrView = xrView;\n\t\tif (this._manager.views.availableColor) {\n\t\t\tthis._xrCamera = this._xrView.camera;\n\t\t}\n\t\tconst layer = frame.session.renderState.baseLayer;\n\t\tconst viewport = layer.getViewport(this._xrView);\n\t\tthis._viewport.x = viewport.x;\n\t\tthis._viewport.y = viewport.y;\n\t\tthis._viewport.z = viewport.width;\n\t\tthis._viewport.w = viewport.height;\n\t\tthis._projMat.set(this._xrView.projectionMatrix);\n\t\tthis._viewMat.set(this._xrView.transform.inverse.matrix);\n\t\tthis._viewInvMat.set(this._xrView.transform.matrix);\n\t\tthis._updateTextureColor();\n\t\tthis._updateDepth(frame);\n\t}\n\t_updateTextureColor() {\n\t\tif (!this._manager.views.availableColor || !this._xrCamera || !this._textureColor) {\n\t\t\treturn;\n\t\t}\n\t\tconst binding = this._manager.webglBinding;\n\t\tif (!binding) {\n\t\t\treturn;\n\t\t}\n\t\tconst texture = binding.getCameraImage(this._xrCamera);\n\t\tif (!texture) {\n\t\t\treturn;\n\t\t}\n\t\tconst device = this._manager.app.graphicsDevice;\n\t\tconst gl = device.gl;\n\t\tif (!this._frameBufferSource) {\n\t\t\tthis._frameBufferSource = gl.createFramebuffer();\n\t\t\tthis._frameBuffer = gl.createFramebuffer();\n\t\t} else {\n\t\t\tvar _device$extDrawBuffer, _device$extDrawBuffer2;\n\t\t\tconst attachmentBaseConstant = device.isWebGL2 ? gl.COLOR_ATTACHMENT0 : (_device$extDrawBuffer = (_device$extDrawBuffer2 = device.extDrawBuffers) == null ? void 0 : _device$extDrawBuffer2.COLOR_ATTACHMENT0_WEBGL) != null ? _device$extDrawBuffer : gl.COLOR_ATTACHMENT0;\n\t\t\tconst width = this._xrCamera.width;\n\t\t\tconst height = this._xrCamera.height;\n\t\t\tdevice.setFramebuffer(this._frameBufferSource);\n\t\t\tgl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentBaseConstant, gl.TEXTURE_2D, texture, 0);\n\t\t\tdevice.setFramebuffer(this._frameBuffer);\n\t\t\tgl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentBaseConstant, gl.TEXTURE_2D, this._textureColor.impl._glTexture, 0);\n\t\t\tgl.bindFramebuffer(gl.READ_FRAMEBUFFER, this._frameBufferSource);\n\t\t\tgl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this._frameBuffer);\n\t\t\tgl.blitFramebuffer(0, height, width, 0, 0, 0, width, height, gl.COLOR_BUFFER_BIT, gl.NEAREST);\n\t\t}\n\t}\n\t_updateDepth(frame) {\n\t\tvar _this$_depthInfo2, _this$_depthInfo3;\n\t\tif (!this._manager.views.availableDepth || !this._textureDepth) {\n\t\t\treturn;\n\t\t}\n\t\tconst gpu = this._manager.views.depthGpuOptimized;\n\t\tconst infoSource = gpu ? this._manager.webglBinding : frame;\n\t\tif (!infoSource) {\n\t\t\tthis._depthInfo = null;\n\t\t\treturn;\n\t\t}\n\t\tconst depthInfo = infoSource.getDepthInformation(this._xrView);\n\t\tif (!depthInfo) {\n\t\t\tthis._depthInfo = null;\n\t\t\treturn;\n\t\t}\n\t\tlet matrixDirty = !this._depthInfo !== !depthInfo;\n\t\tthis._depthInfo = depthInfo;\n\t\tconst width = ((_this$_depthInfo2 = this._depthInfo) == null ? void 0 : _this$_depthInfo2.width) || 4;\n\t\tconst height = ((_this$_depthInfo3 = this._depthInfo) == null ? void 0 : _this$_depthInfo3.height) || 4;\n\t\tlet resized = false;\n\t\tif (this._textureDepth.width !== width || this._textureDepth.height !== height) {\n\t\t\tthis._textureDepth._width = width;\n\t\t\tthis._textureDepth._height = height;\n\t\t\tmatrixDirty = true;\n\t\t\tresized = true;\n\t\t}\n\t\tif (matrixDirty) {\n\t\t\tif (this._depthInfo) {\n\t\t\t\tthis._depthMatrix.data.set(this._depthInfo.normDepthBufferFromNormView.matrix);\n\t\t\t} else {\n\t\t\t\tthis._depthMatrix.setIdentity();\n\t\t\t}\n\t\t}\n\t\tif (this._depthInfo) {\n\t\t\tif (gpu) {\n\t\t\t\tif (this._depthInfo.texture) {\n\t\t\t\t\tthis._textureDepth.impl._glTexture = this._depthInfo.texture;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._textureDepth._levels[0] = new Uint8Array(this._depthInfo.data);\n\t\t\t\tthis._textureDepth.upload();\n\t\t\t}\n\t\t} else {\n\t\t\tthis._textureDepth._levels[0] = this._emptyDepthBuffer;\n\t\t\tthis._textureDepth.upload();\n\t\t}\n\t\tif (resized) this.fire('depth:resize', width, height);\n\t}\n\tupdateTransforms(transform) {\n\t\tif (transform) {\n\t\t\tthis._viewInvOffMat.mul2(transform, this._viewInvMat);\n\t\t\tthis.viewOffMat.copy(this._viewInvOffMat).invert();\n\t\t} else {\n\t\t\tthis._viewInvOffMat.copy(this._viewInvMat);\n\t\t\tthis.viewOffMat.copy(this._viewMat);\n\t\t}\n\t\tthis._viewMat3.setFromMat4(this._viewOffMat);\n\t\tthis._projViewOffMat.mul2(this._projMat, this._viewOffMat);\n\t\tthis._positionData[0] = this._viewInvOffMat.data[12];\n\t\tthis._positionData[1] = this._viewInvOffMat.data[13];\n\t\tthis._positionData[2] = this._viewInvOffMat.data[14];\n\t}\n\t_onDeviceLost() {\n\t\tthis._frameBufferSource = null;\n\t\tthis._frameBuffer = null;\n\t\tthis._depthInfo = null;\n\t}\n\tgetDepth(u, v) {\n\t\tvar _this$_depthInfo$getD, _this$_depthInfo4;\n\t\tif (this._manager.views.depthGpuOptimized) {\n\t\t\treturn null;\n\t\t}\n\t\treturn (_this$_depthInfo$getD = (_this$_depthInfo4 = this._depthInfo) == null ? void 0 : _this$_depthInfo4.getDepthInMeters(u, v)) != null ? _this$_depthInfo$getD : null;\n\t}\n\tdestroy() {\n\t\tthis._depthInfo = null;\n\t\tif (this._textureColor) {\n\t\t\tthis._textureColor.destroy();\n\t\t\tthis._textureColor = null;\n\t\t}\n\t\tif (this._textureDepth) {\n\t\t\tthis._textureDepth.destroy();\n\t\t\tthis._textureDepth = null;\n\t\t}\n\t\tif (this._frameBufferSource) {\n\t\t\tconst gl = this._manager.app.graphicsDevice.gl;\n\t\t\tgl.deleteFramebuffer(this._frameBufferSource);\n\t\t\tthis._frameBufferSource = null;\n\t\t\tgl.deleteFramebuffer(this._frameBuffer);\n\t\t\tthis._frameBuffer = null;\n\t\t}\n\t}\n}\nXrView.EVENT_DEPTHRESIZE = 'depth:resize';\n\nexport { XrView };\n","import { platform } from '../../core/platform.js';\nimport { EventHandler } from '../../core/event-handler.js';\nimport { XrView } from './xr-view.js';\nimport { XRDEPTHSENSINGFORMAT_L8A8, XRDEPTHSENSINGFORMAT_F32, XRDEPTHSENSINGUSAGE_GPU, XRTYPE_AR } from './constants.js';\nimport { PIXELFORMAT_LA8, PIXELFORMAT_R32F } from '../../platform/graphics/constants.js';\n\nclass XrViews extends EventHandler {\n\tconstructor(manager) {\n\t\tsuper();\n\t\tthis._manager = void 0;\n\t\tthis._index = new Map();\n\t\tthis._indexTmp = new Map();\n\t\tthis._list = [];\n\t\tthis._supportedColor = platform.browser && !!window.XRCamera && !!window.XRWebGLBinding;\n\t\tthis._supportedDepth = platform.browser && !!window.XRDepthInformation;\n\t\tthis._availableColor = false;\n\t\tthis._availableDepth = false;\n\t\tthis._depthUsage = '';\n\t\tthis._depthFormat = '';\n\t\tthis._depthFormats = {\n\t\t\t[XRDEPTHSENSINGFORMAT_L8A8]: PIXELFORMAT_LA8,\n\t\t\t[XRDEPTHSENSINGFORMAT_F32]: PIXELFORMAT_R32F\n\t\t};\n\t\tthis._manager = manager;\n\t\tthis._manager.on('start', this._onSessionStart, this);\n\t\tthis._manager.on('end', this._onSessionEnd, this);\n\t}\n\tget list() {\n\t\treturn this._list;\n\t}\n\tget supportedColor() {\n\t\treturn this._supportedColor;\n\t}\n\tget supportedDepth() {\n\t\treturn this._supportedDepth;\n\t}\n\tget availableColor() {\n\t\treturn this._availableColor;\n\t}\n\tget availableDepth() {\n\t\treturn this._availableDepth;\n\t}\n\tget depthUsage() {\n\t\treturn this._depthUsage;\n\t}\n\tget depthGpuOptimized() {\n\t\treturn this._depthUsage === XRDEPTHSENSINGUSAGE_GPU;\n\t}\n\tget depthFormat() {\n\t\treturn this._depthFormat;\n\t}\n\tget depthPixelFormat() {\n\t\tvar _this$_depthFormats$t;\n\t\treturn (_this$_depthFormats$t = this._depthFormats[this._depthFormat]) != null ? _this$_depthFormats$t : null;\n\t}\n\tupdate(frame, xrViews) {\n\t\tfor (let i = 0; i < xrViews.length; i++) {\n\t\t\tthis._indexTmp.set(xrViews[i].eye, xrViews[i]);\n\t\t}\n\t\tfor (const [eye, xrView] of this._indexTmp) {\n\t\t\tlet view = this._index.get(eye);\n\t\t\tif (!view) {\n\t\t\t\tview = new XrView(this._manager, xrView, xrViews.length);\n\t\t\t\tthis._index.set(eye, view);\n\t\t\t\tthis._list.push(view);\n\t\t\t\tview.update(frame, xrView);\n\t\t\t\tthis.fire('add', view);\n\t\t\t} else {\n\t\t\t\tview.update(frame, xrView);\n\t\t\t}\n\t\t}\n\t\tfor (const [eye, view] of this._index) {\n\t\t\tif (this._indexTmp.has(eye)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tview.destroy();\n\t\t\tthis._index.delete(eye);\n\t\t\tconst ind = this._list.indexOf(view);\n\t\t\tif (ind !== -1) this._list.splice(ind, 1);\n\t\t\tthis.fire('remove', view);\n\t\t}\n\t\tthis._indexTmp.clear();\n\t}\n\tget(eye) {\n\t\treturn this._index.get(eye) || null;\n\t}\n\t_onSessionStart() {\n\t\tif (this._manager.type !== XRTYPE_AR) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this._manager.session.enabledFeatures) {\n\t\t\treturn;\n\t\t}\n\t\tthis._availableColor = this._manager.session.enabledFeatures.indexOf('camera-access') !== -1;\n\t\tthis._availableDepth = this._manager.session.enabledFeatures.indexOf('depth-sensing') !== -1;\n\t\tif (this._availableDepth) {\n\t\t\tconst session = this._manager.session;\n\t\t\tthis._depthUsage = session.depthUsage;\n\t\t\tthis._depthFormat = session.depthDataFormat;\n\t\t}\n\t}\n\t_onSessionEnd() {\n\t\tfor (const view of this._index.values()) {\n\t\t\tview.destroy();\n\t\t}\n\t\tthis._index.clear();\n\t\tthis._availableColor = false;\n\t\tthis._availableDepth = false;\n\t\tthis._depthUsage = '';\n\t\tthis._depthFormat = '';\n\t\tthis._list.length = 0;\n\t}\n}\nXrViews.EVENT_ADD = 'add';\nXrViews.EVENT_REMOVE = 'remove';\n\nexport { XrViews };\n","function hasAudioContext() {\n\treturn !!(typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined');\n}\n\nexport { hasAudioContext };\n","import { math } from '../../core/math/math.js';\nimport { hasAudioContext } from './capabilities.js';\n\nclass Channel {\n\tconstructor(manager, sound, options = {}) {\n\t\tvar _options$volume, _options$loop, _options$pitch;\n\t\tthis.volume = (_options$volume = options.volume) != null ? _options$volume : 1;\n\t\tthis.loop = (_options$loop = options.loop) != null ? _options$loop : false;\n\t\tthis.pitch = (_options$pitch = options.pitch) != null ? _options$pitch : 1;\n\t\tthis.sound = sound;\n\t\tthis.paused = false;\n\t\tthis.suspended = false;\n\t\tthis.manager = manager;\n\t\tthis.source = null;\n\t\tif (hasAudioContext()) {\n\t\t\tthis.startTime = 0;\n\t\t\tthis.startOffset = 0;\n\t\t\tconst context = manager.context;\n\t\t\tthis.gain = context.createGain();\n\t\t} else if (sound.audio) {\n\t\t\tthis.source = sound.audio.cloneNode(false);\n\t\t\tthis.source.pause();\n\t\t}\n\t}\n\tgetVolume() {\n\t\treturn this.volume;\n\t}\n\tgetLoop() {\n\t\treturn this.loop;\n\t}\n\tsetLoop(loop) {\n\t\tthis.loop = loop;\n\t\tif (this.source) {\n\t\t\tthis.source.loop = loop;\n\t\t}\n\t}\n\tgetPitch() {\n\t\treturn this.pitch;\n\t}\n\tonManagerVolumeChange() {\n\t\tthis.setVolume(this.getVolume());\n\t}\n\tonManagerSuspend() {\n\t\tif (this.isPlaying() && !this.suspended) {\n\t\t\tthis.suspended = true;\n\t\t\tthis.pause();\n\t\t}\n\t}\n\tonManagerResume() {\n\t\tif (this.suspended) {\n\t\t\tthis.suspended = false;\n\t\t\tthis.unpause();\n\t\t}\n\t}\n\tplay() {\n\t\tif (this.source) {\n\t\t\tthrow new Error('Call stop() before calling play()');\n\t\t}\n\t\tthis._createSource();\n\t\tif (!this.source) {\n\t\t\treturn;\n\t\t}\n\t\tthis.startTime = this.manager.context.currentTime;\n\t\tthis.source.start(0, this.startOffset % this.source.buffer.duration);\n\t\tthis.setVolume(this.volume);\n\t\tthis.setLoop(this.loop);\n\t\tthis.setPitch(this.pitch);\n\t\tthis.manager.on('volumechange', this.onManagerVolumeChange, this);\n\t\tthis.manager.on('suspend', this.onManagerSuspend, this);\n\t\tthis.manager.on('resume', this.onManagerResume, this);\n\t\tif (this.manager.suspended) {\n\t\t\tthis.onManagerSuspend();\n\t\t}\n\t}\n\tpause() {\n\t\tif (this.source) {\n\t\t\tthis.paused = true;\n\t\t\tthis.startOffset += this.manager.context.currentTime - this.startTime;\n\t\t\tthis.source.stop(0);\n\t\t\tthis.source = null;\n\t\t}\n\t}\n\tunpause() {\n\t\tif (this.source || !this.paused) {\n\t\t\tconsole.warn('Call pause() before unpausing.');\n\t\t\treturn;\n\t\t}\n\t\tthis._createSource();\n\t\tif (!this.source) {\n\t\t\treturn;\n\t\t}\n\t\tthis.startTime = this.manager.context.currentTime;\n\t\tthis.source.start(0, this.startOffset % this.source.buffer.duration);\n\t\tthis.setVolume(this.volume);\n\t\tthis.setLoop(this.loop);\n\t\tthis.setPitch(this.pitch);\n\t\tthis.paused = false;\n\t}\n\tstop() {\n\t\tif (this.source) {\n\t\t\tthis.source.stop(0);\n\t\t\tthis.source = null;\n\t\t}\n\t\tthis.manager.off('volumechange', this.onManagerVolumeChange, this);\n\t\tthis.manager.off('suspend', this.onManagerSuspend, this);\n\t\tthis.manager.off('resume', this.onManagerResume, this);\n\t}\n\tsetVolume(volume) {\n\t\tvolume = math.clamp(volume, 0, 1);\n\t\tthis.volume = volume;\n\t\tif (this.gain) {\n\t\t\tthis.gain.gain.value = volume * this.manager.volume;\n\t\t}\n\t}\n\tsetPitch(pitch) {\n\t\tthis.pitch = pitch;\n\t\tif (this.source) {\n\t\t\tthis.source.playbackRate.value = pitch;\n\t\t}\n\t}\n\tisPlaying() {\n\t\treturn !this.paused && this.source.playbackState === this.source.PLAYING_STATE;\n\t}\n\tgetDuration() {\n\t\treturn this.source ? this.source.buffer.duration : 0;\n\t}\n\t_createSource() {\n\t\tconst context = this.manager.context;\n\t\tif (this.sound.buffer) {\n\t\t\tthis.source = context.createBufferSource();\n\t\t\tthis.source.buffer = this.sound.buffer;\n\t\t\tthis.source.connect(this.gain);\n\t\t\tthis.gain.connect(context.destination);\n\t\t\tif (!this.loop) {\n\t\t\t\tthis.source.onended = this.pause.bind(this);\n\t\t\t}\n\t\t}\n\t}\n}\nif (!hasAudioContext()) {\n\tObject.assign(Channel.prototype, {\n\t\tplay: function () {\n\t\t\tif (this.source) {\n\t\t\t\tthis.paused = false;\n\t\t\t\tthis.setVolume(this.volume);\n\t\t\t\tthis.setLoop(this.loop);\n\t\t\t\tthis.setPitch(this.pitch);\n\t\t\t\tthis.source.play();\n\t\t\t}\n\t\t\tthis.manager.on('volumechange', this.onManagerVolumeChange, this);\n\t\t\tthis.manager.on('suspend', this.onManagerSuspend, this);\n\t\t\tthis.manager.on('resume', this.onManagerResume, this);\n\t\t\tif (this.manager.suspended) {\n\t\t\t\tthis.onManagerSuspend();\n\t\t\t}\n\t\t},\n\t\tpause: function () {\n\t\t\tif (this.source) {\n\t\t\t\tthis.paused = true;\n\t\t\t\tthis.source.pause();\n\t\t\t}\n\t\t},\n\t\tunpause: function () {\n\t\t\tif (this.source) {\n\t\t\t\tthis.paused = false;\n\t\t\t\tthis.source.play();\n\t\t\t}\n\t\t},\n\t\tstop: function () {\n\t\t\tif (this.source) {\n\t\t\t\tthis.source.pause();\n\t\t\t}\n\t\t\tthis.manager.off('volumechange', this.onManagerVolumeChange, this);\n\t\t\tthis.manager.off('suspend', this.onManagerSuspend, this);\n\t\t\tthis.manager.off('resume', this.onManagerResume, this);\n\t\t},\n\t\tsetVolume: function (volume) {\n\t\t\tvolume = math.clamp(volume, 0, 1);\n\t\t\tthis.volume = volume;\n\t\t\tif (this.source) {\n\t\t\t\tthis.source.volume = volume * this.manager.volume;\n\t\t\t}\n\t\t},\n\t\tsetPitch: function (pitch) {\n\t\t\tthis.pitch = pitch;\n\t\t\tif (this.source) {\n\t\t\t\tthis.source.playbackRate = pitch;\n\t\t\t}\n\t\t},\n\t\tgetDuration: function () {\n\t\t\treturn this.source && !isNaN(this.source.duration) ? this.source.duration : 0;\n\t\t},\n\t\tisPlaying: function () {\n\t\t\treturn !this.source.paused;\n\t\t}\n\t});\n}\n\nexport { Channel };\n","import { math } from '../../core/math/math.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { DISTANCE_INVERSE, DISTANCE_LINEAR, DISTANCE_EXPONENTIAL } from './constants.js';\nimport { hasAudioContext } from './capabilities.js';\nimport { Channel } from './channel.js';\n\nconst MAX_DISTANCE = 10000;\nclass Channel3d extends Channel {\n\tconstructor(manager, sound, options) {\n\t\tsuper(manager, sound, options);\n\t\tthis.position = new Vec3();\n\t\tthis.velocity = new Vec3();\n\t\tif (hasAudioContext()) {\n\t\t\tthis.panner = manager.context.createPanner();\n\t\t} else {\n\t\t\tthis.maxDistance = MAX_DISTANCE;\n\t\t\tthis.minDistance = 1;\n\t\t\tthis.rollOffFactor = 1;\n\t\t\tthis.distanceModel = DISTANCE_INVERSE;\n\t\t}\n\t}\n\tgetPosition() {\n\t\treturn this.position;\n\t}\n\tsetPosition(position) {\n\t\tthis.position.copy(position);\n\t\tconst panner = this.panner;\n\t\tif ('positionX' in panner) {\n\t\t\tpanner.positionX.value = position.x;\n\t\t\tpanner.positionY.value = position.y;\n\t\t\tpanner.positionZ.value = position.z;\n\t\t} else if (panner.setPosition) {\n\t\t\tpanner.setPosition(position.x, position.y, position.z);\n\t\t}\n\t}\n\tgetVelocity() {\n\t\treturn this.velocity;\n\t}\n\tsetVelocity(velocity) {\n\t\tthis.velocity.copy(velocity);\n\t}\n\tgetMaxDistance() {\n\t\treturn this.panner.maxDistance;\n\t}\n\tsetMaxDistance(max) {\n\t\tthis.panner.maxDistance = max;\n\t}\n\tgetMinDistance() {\n\t\treturn this.panner.refDistance;\n\t}\n\tsetMinDistance(min) {\n\t\tthis.panner.refDistance = min;\n\t}\n\tgetRollOffFactor() {\n\t\treturn this.panner.rolloffFactor;\n\t}\n\tsetRollOffFactor(factor) {\n\t\tthis.panner.rolloffFactor = factor;\n\t}\n\tgetDistanceModel() {\n\t\treturn this.panner.distanceModel;\n\t}\n\tsetDistanceModel(distanceModel) {\n\t\tthis.panner.distanceModel = distanceModel;\n\t}\n\t_createSource() {\n\t\tconst context = this.manager.context;\n\t\tthis.source = context.createBufferSource();\n\t\tthis.source.buffer = this.sound.buffer;\n\t\tthis.source.connect(this.panner);\n\t\tthis.panner.connect(this.gain);\n\t\tthis.gain.connect(context.destination);\n\t\tif (!this.loop) {\n\t\t\tthis.source.onended = this.pause.bind(this);\n\t\t}\n\t}\n}\nif (!hasAudioContext()) {\n\tlet offset = new Vec3();\n\tconst fallOff = function fallOff(posOne, posTwo, refDistance, maxDistance, rolloffFactor, distanceModel) {\n\t\toffset = offset.sub2(posOne, posTwo);\n\t\tconst distance = offset.length();\n\t\tif (distance < refDistance) {\n\t\t\treturn 1;\n\t\t} else if (distance > maxDistance) {\n\t\t\treturn 0;\n\t\t}\n\t\tlet result = 0;\n\t\tif (distanceModel === DISTANCE_LINEAR) {\n\t\t\tresult = 1 - rolloffFactor * (distance - refDistance) / (maxDistance - refDistance);\n\t\t} else if (distanceModel === DISTANCE_INVERSE) {\n\t\t\tresult = refDistance / (refDistance + rolloffFactor * (distance - refDistance));\n\t\t} else if (distanceModel === DISTANCE_EXPONENTIAL) {\n\t\t\tresult = Math.pow(distance / refDistance, -rolloffFactor);\n\t\t}\n\t\treturn math.clamp(result, 0, 1);\n\t};\n\tObject.assign(Channel3d.prototype, {\n\t\tsetPosition: function (position) {\n\t\t\tthis.position.copy(position);\n\t\t\tif (this.source) {\n\t\t\t\tconst listener = this.manager.listener;\n\t\t\t\tconst lpos = listener.getPosition();\n\t\t\t\tconst factor = fallOff(lpos, this.position, this.minDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);\n\t\t\t\tconst v = this.getVolume();\n\t\t\t\tthis.source.volume = v * factor;\n\t\t\t}\n\t\t},\n\t\tgetMaxDistance: function () {\n\t\t\treturn this.maxDistance;\n\t\t},\n\t\tsetMaxDistance: function (max) {\n\t\t\tthis.maxDistance = max;\n\t\t},\n\t\tgetMinDistance: function () {\n\t\t\treturn this.minDistance;\n\t\t},\n\t\tsetMinDistance: function (min) {\n\t\t\tthis.minDistance = min;\n\t\t},\n\t\tgetRollOffFactor: function () {\n\t\t\treturn this.rollOffFactor;\n\t\t},\n\t\tsetRollOffFactor: function (factor) {\n\t\t\tthis.rollOffFactor = factor;\n\t\t},\n\t\tgetDistanceModel: function () {\n\t\t\treturn this.distanceModel;\n\t\t},\n\t\tsetDistanceModel: function (distanceModel) {\n\t\t\tthis.distanceModel = distanceModel;\n\t\t}\n\t});\n}\n\nexport { Channel3d };\n","const DISTANCE_LINEAR = 'linear';\nconst DISTANCE_INVERSE = 'inverse';\nconst DISTANCE_EXPONENTIAL = 'exponential';\n\nexport { DISTANCE_EXPONENTIAL, DISTANCE_INVERSE, DISTANCE_LINEAR };\n","import { TEXTUREDIMENSION_2D, SAMPLETYPE_FLOAT, SHADERSTAGE_COMPUTE, PIXELFORMAT_RGBA8, SAMPLETYPE_UINT, SAMPLETYPE_INT, TEXTUREDIMENSION_CUBE, TEXTUREDIMENSION_3D, TEXTUREDIMENSION_2D_ARRAY } from './constants.js';\n\nlet id = 0;\nconst textureDimensionInfo = {\n\t[TEXTUREDIMENSION_2D]: 'texture2D',\n\t[TEXTUREDIMENSION_CUBE]: 'textureCube',\n\t[TEXTUREDIMENSION_3D]: 'texture3D',\n\t[TEXTUREDIMENSION_2D_ARRAY]: 'texture2DArray'\n};\nclass BindBaseFormat {\n\tconstructor(name, visibility) {\n\t\tthis.slot = -1;\n\t\tthis.scopeId = null;\n\t\tthis.name = name;\n\t\tthis.visibility = visibility;\n\t}\n}\nclass BindUniformBufferFormat extends BindBaseFormat {}\nclass BindStorageBufferFormat extends BindBaseFormat {\n\tconstructor(name, visibility, readOnly = false) {\n\t\tsuper(name, visibility);\n\t\tthis.readOnly = readOnly;\n\t}\n}\nclass BindTextureFormat extends BindBaseFormat {\n\tconstructor(name, visibility, textureDimension = TEXTUREDIMENSION_2D, sampleType = SAMPLETYPE_FLOAT, hasSampler = true) {\n\t\tsuper(name, visibility);\n\t\tthis.textureDimension = textureDimension;\n\t\tthis.sampleType = sampleType;\n\t\tthis.hasSampler = hasSampler;\n\t}\n}\nclass BindStorageTextureFormat extends BindBaseFormat {\n\tconstructor(name, format = PIXELFORMAT_RGBA8, textureDimension = TEXTUREDIMENSION_2D, write = true, read = false) {\n\t\tsuper(name, SHADERSTAGE_COMPUTE);\n\t\tthis.format = format;\n\t\tthis.textureDimension = textureDimension;\n\t\tthis.write = write;\n\t\tthis.read = read;\n\t}\n}\nclass BindGroupFormat {\n\tconstructor(graphicsDevice, formats) {\n\t\tthis.uniformBufferFormats = [];\n\t\tthis.textureFormats = [];\n\t\tthis.storageTextureFormats = [];\n\t\tthis.storageBufferFormats = [];\n\t\tthis.id = id++;\n\t\tlet slot = 0;\n\t\tformats.forEach(format => {\n\t\t\tformat.slot = slot++;\n\t\t\tif (format instanceof BindTextureFormat && format.hasSampler) {\n\t\t\t\tslot++;\n\t\t\t}\n\t\t\tif (format instanceof BindUniformBufferFormat) {\n\t\t\t\tthis.uniformBufferFormats.push(format);\n\t\t\t} else if (format instanceof BindTextureFormat) {\n\t\t\t\tthis.textureFormats.push(format);\n\t\t\t} else if (format instanceof BindStorageTextureFormat) {\n\t\t\t\tthis.storageTextureFormats.push(format);\n\t\t\t} else if (format instanceof BindStorageBufferFormat) {\n\t\t\t\tthis.storageBufferFormats.push(format);\n\t\t\t} else ;\n\t\t});\n\t\tthis.device = graphicsDevice;\n\t\tconst scope = graphicsDevice.scope;\n\t\tthis.bufferFormatsMap = new Map();\n\t\tthis.uniformBufferFormats.forEach((bf, i) => this.bufferFormatsMap.set(bf.name, i));\n\t\tthis.textureFormatsMap = new Map();\n\t\tthis.textureFormats.forEach((tf, i) => {\n\t\t\tthis.textureFormatsMap.set(tf.name, i);\n\t\t\ttf.scopeId = scope.resolve(tf.name);\n\t\t});\n\t\tthis.storageTextureFormatsMap = new Map();\n\t\tthis.storageTextureFormats.forEach((tf, i) => {\n\t\t\tthis.storageTextureFormatsMap.set(tf.name, i);\n\t\t\ttf.scopeId = scope.resolve(tf.name);\n\t\t});\n\t\tthis.storageBufferFormatsMap = new Map();\n\t\tthis.storageBufferFormats.forEach((bf, i) => {\n\t\t\tthis.storageBufferFormatsMap.set(bf.name, i);\n\t\t\tbf.scopeId = scope.resolve(bf.name);\n\t\t});\n\t\tthis.impl = graphicsDevice.createBindGroupFormatImpl(this);\n\t}\n\tdestroy() {\n\t\tthis.impl.destroy();\n\t}\n\tgetTexture(name) {\n\t\tconst index = this.textureFormatsMap.get(name);\n\t\tif (index !== undefined) {\n\t\t\treturn this.textureFormats[index];\n\t\t}\n\t\treturn null;\n\t}\n\tgetStorageTexture(name) {\n\t\tconst index = this.storageTextureFormatsMap.get(name);\n\t\tif (index !== undefined) {\n\t\t\treturn this.storageTextureFormats[index];\n\t\t}\n\t\treturn null;\n\t}\n\tgetShaderDeclarationTextures(bindGroup) {\n\t\tlet code = '';\n\t\tthis.textureFormats.forEach(format => {\n\t\t\tlet textureType = textureDimensionInfo[format.textureDimension];\n\t\t\tconst isArray = textureType === 'texture2DArray';\n\t\t\tconst sampleTypePrefix = format.sampleType === SAMPLETYPE_UINT ? 'u' : format.sampleType === SAMPLETYPE_INT ? 'i' : '';\n\t\t\ttextureType = `${sampleTypePrefix}${textureType}`;\n\t\t\tlet namePostfix = '';\n\t\t\tlet extraCode = '';\n\t\t\tif (isArray) {\n\t\t\t\tnamePostfix = '_texture';\n\t\t\t\textraCode = `#define ${format.name} ${sampleTypePrefix}sampler2DArray(${format.name}${namePostfix}, ${format.name}_sampler)\\n`;\n\t\t\t}\n\t\t\tcode += `layout(set = ${bindGroup}, binding = ${format.slot}) uniform ${textureType} ${format.name}${namePostfix};\\n`;\n\t\t\tif (format.hasSampler) {\n\t\t\t\tcode += `layout(set = ${bindGroup}, binding = ${format.slot + 1}) uniform sampler ${format.name}_sampler;\\n`;\n\t\t\t}\n\t\t\tcode += extraCode;\n\t\t});\n\t\treturn code;\n\t}\n\tloseContext() {}\n}\n\nexport { BindGroupFormat, BindStorageBufferFormat, BindStorageTextureFormat, BindTextureFormat, BindUniformBufferFormat };\n","import { UNIFORM_BUFFER_DEFAULT_SLOT_NAME } from './constants.js';\n\nlet id = 0;\nclass BindGroup {\n\tconstructor(graphicsDevice, format, defaultUniformBuffer) {\n\t\tthis.renderVersionUpdated = -1;\n\t\tthis.uniformBuffers = void 0;\n\t\tthis.uniformBufferOffsets = [];\n\t\tthis.id = id++;\n\t\tthis.device = graphicsDevice;\n\t\tthis.format = format;\n\t\tthis.dirty = true;\n\t\tthis.impl = graphicsDevice.createBindGroupImpl(this);\n\t\tthis.textures = [];\n\t\tthis.storageTextures = [];\n\t\tthis.storageBuffers = [];\n\t\tthis.uniformBuffers = [];\n\t\tthis.defaultUniformBuffer = defaultUniformBuffer;\n\t\tif (defaultUniformBuffer) {\n\t\t\tthis.setUniformBuffer(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, defaultUniformBuffer);\n\t\t}\n\t}\n\tdestroy() {\n\t\tthis.impl.destroy();\n\t\tthis.impl = null;\n\t\tthis.format = null;\n\t\tthis.defaultUniformBuffer = null;\n\t}\n\tsetUniformBuffer(name, uniformBuffer) {\n\t\tconst index = this.format.bufferFormatsMap.get(name);\n\t\tif (this.uniformBuffers[index] !== uniformBuffer) {\n\t\t\tthis.uniformBuffers[index] = uniformBuffer;\n\t\t\tthis.dirty = true;\n\t\t}\n\t}\n\tsetStorageBuffer(name, storageBuffer) {\n\t\tconst index = this.format.storageBufferFormatsMap.get(name);\n\t\tif (this.storageBuffers[index] !== storageBuffer) {\n\t\t\tthis.storageBuffers[index] = storageBuffer;\n\t\t\tthis.dirty = true;\n\t\t}\n\t}\n\tsetTexture(name, texture) {\n\t\tconst index = this.format.textureFormatsMap.get(name);\n\t\tif (this.textures[index] !== texture) {\n\t\t\tthis.textures[index] = texture;\n\t\t\tthis.dirty = true;\n\t\t} else if (this.renderVersionUpdated < texture.renderVersionDirty) {\n\t\t\tthis.dirty = true;\n\t\t}\n\t}\n\tsetStorageTexture(name, texture) {\n\t\tconst index = this.format.storageTextureFormatsMap.get(name);\n\t\tif (this.storageTextures[index] !== texture) {\n\t\t\tthis.storageTextures[index] = texture;\n\t\t\tthis.dirty = true;\n\t\t} else if (this.renderVersionUpdated < texture.renderVersionDirty) {\n\t\t\tthis.dirty = true;\n\t\t}\n\t}\n\tupdateUniformBuffers() {\n\t\tfor (let i = 0; i < this.uniformBuffers.length; i++) {\n\t\t\tthis.uniformBuffers[i].update();\n\t\t}\n\t}\n\tupdate() {\n\t\tconst {\n\t\t\ttextureFormats,\n\t\t\tstorageTextureFormats,\n\t\t\tstorageBufferFormats\n\t\t} = this.format;\n\t\tfor (let i = 0; i < textureFormats.length; i++) {\n\t\t\tconst textureFormat = textureFormats[i];\n\t\t\tconst value = textureFormat.scopeId.value;\n\t\t\tthis.setTexture(textureFormat.name, value);\n\t\t}\n\t\tfor (let i = 0; i < storageTextureFormats.length; i++) {\n\t\t\tconst storageTextureFormat = storageTextureFormats[i];\n\t\t\tconst value = storageTextureFormat.scopeId.value;\n\t\t\tthis.setStorageTexture(storageTextureFormat.name, value);\n\t\t}\n\t\tfor (let i = 0; i < storageBufferFormats.length; i++) {\n\t\t\tconst storageBufferFormat = storageBufferFormats[i];\n\t\t\tconst value = storageBufferFormat.scopeId.value;\n\t\t\tthis.setStorageBuffer(storageBufferFormat.name, value);\n\t\t}\n\t\tthis.uniformBufferOffsets.length = this.uniformBuffers.length;\n\t\tfor (let i = 0; i < this.uniformBuffers.length; i++) {\n\t\t\tconst uniformBuffer = this.uniformBuffers[i];\n\t\t\tthis.uniformBufferOffsets[i] = uniformBuffer.offset;\n\t\t\tif (this.renderVersionUpdated < uniformBuffer.renderVersionDirty) {\n\t\t\t\tthis.dirty = true;\n\t\t\t}\n\t\t}\n\t\tif (this.dirty) {\n\t\t\tthis.dirty = false;\n\t\t\tthis.renderVersionUpdated = this.device.renderVersion;\n\t\t\tthis.impl.update(this);\n\t\t}\n\t}\n}\n\nexport { BindGroup };\n","import { BitPacking } from '../../core/math/bit-packing.js';\nimport { BLENDEQUATION_ADD, BLENDMODE_ONE, BLENDMODE_ZERO, BLENDMODE_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_ALPHA } from './constants.js';\n\nvar _BlendState;\nconst opMask = 0b111;\nconst factorMask = 0b1111;\nconst colorOpShift = 0;\nconst colorSrcFactorShift = 3;\nconst colorDstFactorShift = 7;\nconst alphaOpShift = 11;\nconst alphaSrcFactorShift = 14;\nconst alphaDstFactorShift = 18;\nconst redWriteShift = 22;\nconst greenWriteShift = 23;\nconst blueWriteShift = 24;\nconst alphaWriteShift = 25;\nconst blendShift = 26;\nconst allWriteMasks = 0b1111;\nconst allWriteShift = redWriteShift;\nclass BlendState {\n\tconstructor(blend = false, colorOp = BLENDEQUATION_ADD, colorSrcFactor = BLENDMODE_ONE, colorDstFactor = BLENDMODE_ZERO, alphaOp, alphaSrcFactor, alphaDstFactor, redWrite = true, greenWrite = true, blueWrite = true, alphaWrite = true) {\n\t\tthis.target0 = 0;\n\t\tthis.setColorBlend(colorOp, colorSrcFactor, colorDstFactor);\n\t\tthis.setAlphaBlend(alphaOp != null ? alphaOp : colorOp, alphaSrcFactor != null ? alphaSrcFactor : colorSrcFactor, alphaDstFactor != null ? alphaDstFactor : colorDstFactor);\n\t\tthis.setColorWrite(redWrite, greenWrite, blueWrite, alphaWrite);\n\t\tthis.blend = blend;\n\t}\n\tset blend(value) {\n\t\tthis.target0 = BitPacking.set(this.target0, value ? 1 : 0, blendShift);\n\t}\n\tget blend() {\n\t\treturn BitPacking.all(this.target0, blendShift);\n\t}\n\tsetColorBlend(op, srcFactor, dstFactor) {\n\t\tthis.target0 = BitPacking.set(this.target0, op, colorOpShift, opMask);\n\t\tthis.target0 = BitPacking.set(this.target0, srcFactor, colorSrcFactorShift, factorMask);\n\t\tthis.target0 = BitPacking.set(this.target0, dstFactor, colorDstFactorShift, factorMask);\n\t}\n\tsetAlphaBlend(op, srcFactor, dstFactor) {\n\t\tthis.target0 = BitPacking.set(this.target0, op, alphaOpShift, opMask);\n\t\tthis.target0 = BitPacking.set(this.target0, srcFactor, alphaSrcFactorShift, factorMask);\n\t\tthis.target0 = BitPacking.set(this.target0, dstFactor, alphaDstFactorShift, factorMask);\n\t}\n\tsetColorWrite(redWrite, greenWrite, blueWrite, alphaWrite) {\n\t\tthis.redWrite = redWrite;\n\t\tthis.greenWrite = greenWrite;\n\t\tthis.blueWrite = blueWrite;\n\t\tthis.alphaWrite = alphaWrite;\n\t}\n\tget colorOp() {\n\t\treturn BitPacking.get(this.target0, colorOpShift, opMask);\n\t}\n\tget colorSrcFactor() {\n\t\treturn BitPacking.get(this.target0, colorSrcFactorShift, factorMask);\n\t}\n\tget colorDstFactor() {\n\t\treturn BitPacking.get(this.target0, colorDstFactorShift, factorMask);\n\t}\n\tget alphaOp() {\n\t\treturn BitPacking.get(this.target0, alphaOpShift, opMask);\n\t}\n\tget alphaSrcFactor() {\n\t\treturn BitPacking.get(this.target0, alphaSrcFactorShift, factorMask);\n\t}\n\tget alphaDstFactor() {\n\t\treturn BitPacking.get(this.target0, alphaDstFactorShift, factorMask);\n\t}\n\tset redWrite(value) {\n\t\tthis.target0 = BitPacking.set(this.target0, value ? 1 : 0, redWriteShift);\n\t}\n\tget redWrite() {\n\t\treturn BitPacking.all(this.target0, redWriteShift);\n\t}\n\tset greenWrite(value) {\n\t\tthis.target0 = BitPacking.set(this.target0, value ? 1 : 0, greenWriteShift);\n\t}\n\tget greenWrite() {\n\t\treturn BitPacking.all(this.target0, greenWriteShift);\n\t}\n\tset blueWrite(value) {\n\t\tthis.target0 = BitPacking.set(this.target0, value ? 1 : 0, blueWriteShift);\n\t}\n\tget blueWrite() {\n\t\treturn BitPacking.all(this.target0, blueWriteShift);\n\t}\n\tset alphaWrite(value) {\n\t\tthis.target0 = BitPacking.set(this.target0, value ? 1 : 0, alphaWriteShift);\n\t}\n\tget alphaWrite() {\n\t\treturn BitPacking.all(this.target0, alphaWriteShift);\n\t}\n\tget allWrite() {\n\t\treturn BitPacking.get(this.target0, allWriteShift, allWriteMasks);\n\t}\n\tcopy(rhs) {\n\t\tthis.target0 = rhs.target0;\n\t\treturn this;\n\t}\n\tclone() {\n\t\tconst clone = new this.constructor();\n\t\treturn clone.copy(this);\n\t}\n\tget key() {\n\t\treturn this.target0;\n\t}\n\tequals(rhs) {\n\t\treturn this.target0 === rhs.target0;\n\t}\n}\n_BlendState = BlendState;\nBlendState.NOBLEND = Object.freeze(new _BlendState());\nBlendState.NOWRITE = Object.freeze(new _BlendState(undefined, undefined, undefined, undefined, undefined, undefined, undefined, false, false, false, false));\nBlendState.ALPHABLEND = Object.freeze(new _BlendState(true, BLENDEQUATION_ADD, BLENDMODE_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_ALPHA));\nBlendState.ADDBLEND = Object.freeze(new _BlendState(true, BLENDEQUATION_ADD, BLENDMODE_ONE, BLENDMODE_ONE));\n\nexport { BlendState };\n","const ADDRESS_REPEAT = 0;\nconst ADDRESS_CLAMP_TO_EDGE = 1;\nconst ADDRESS_MIRRORED_REPEAT = 2;\nconst BLENDMODE_ZERO = 0;\nconst BLENDMODE_ONE = 1;\nconst BLENDMODE_SRC_COLOR = 2;\nconst BLENDMODE_ONE_MINUS_SRC_COLOR = 3;\nconst BLENDMODE_DST_COLOR = 4;\nconst BLENDMODE_ONE_MINUS_DST_COLOR = 5;\nconst BLENDMODE_SRC_ALPHA = 6;\nconst BLENDMODE_SRC_ALPHA_SATURATE = 7;\nconst BLENDMODE_ONE_MINUS_SRC_ALPHA = 8;\nconst BLENDMODE_DST_ALPHA = 9;\nconst BLENDMODE_ONE_MINUS_DST_ALPHA = 10;\nconst BLENDMODE_CONSTANT = 11;\nconst BLENDMODE_ONE_MINUS_CONSTANT = 12;\nconst BLENDEQUATION_ADD = 0;\nconst BLENDEQUATION_SUBTRACT = 1;\nconst BLENDEQUATION_REVERSE_SUBTRACT = 2;\nconst BLENDEQUATION_MIN = 3;\nconst BLENDEQUATION_MAX = 4;\nconst BUFFERUSAGE_READ = 0x0001;\nconst BUFFERUSAGE_WRITE = 0x0002;\nconst BUFFERUSAGE_COPY_SRC = 0x0004;\nconst BUFFERUSAGE_COPY_DST = 0x0008;\nconst BUFFERUSAGE_INDEX = 0x0010;\nconst BUFFERUSAGE_VERTEX = 0x0020;\nconst BUFFERUSAGE_UNIFORM = 0x0040;\nconst BUFFERUSAGE_STORAGE = 0x0080;\nconst BUFFERUSAGE_INDIRECT = 0x0100;\nconst BUFFER_STATIC = 0;\nconst BUFFER_DYNAMIC = 1;\nconst BUFFER_STREAM = 2;\nconst BUFFER_GPUDYNAMIC = 3;\nconst CLEARFLAG_COLOR = 1;\nconst CLEARFLAG_DEPTH = 2;\nconst CLEARFLAG_STENCIL = 4;\nconst CUBEFACE_POSX = 0;\nconst CUBEFACE_NEGX = 1;\nconst CUBEFACE_POSY = 2;\nconst CUBEFACE_NEGY = 3;\nconst CUBEFACE_POSZ = 4;\nconst CUBEFACE_NEGZ = 5;\nconst CULLFACE_NONE = 0;\nconst CULLFACE_BACK = 1;\nconst CULLFACE_FRONT = 2;\nconst CULLFACE_FRONTANDBACK = 3;\nconst FILTER_NEAREST = 0;\nconst FILTER_LINEAR = 1;\nconst FILTER_NEAREST_MIPMAP_NEAREST = 2;\nconst FILTER_NEAREST_MIPMAP_LINEAR = 3;\nconst FILTER_LINEAR_MIPMAP_NEAREST = 4;\nconst FILTER_LINEAR_MIPMAP_LINEAR = 5;\nconst FUNC_NEVER = 0;\nconst FUNC_LESS = 1;\nconst FUNC_EQUAL = 2;\nconst FUNC_LESSEQUAL = 3;\nconst FUNC_GREATER = 4;\nconst FUNC_NOTEQUAL = 5;\nconst FUNC_GREATEREQUAL = 6;\nconst FUNC_ALWAYS = 7;\nconst INDEXFORMAT_UINT8 = 0;\nconst INDEXFORMAT_UINT16 = 1;\nconst INDEXFORMAT_UINT32 = 2;\nconst PIXELFORMAT_A8 = 0;\nconst PIXELFORMAT_L8 = 1;\nconst PIXELFORMAT_LA8 = 2;\nconst PIXELFORMAT_RGB565 = 3;\nconst PIXELFORMAT_RGBA5551 = 4;\nconst PIXELFORMAT_RGBA4 = 5;\nconst PIXELFORMAT_RGB8 = 6;\nconst PIXELFORMAT_RGBA8 = 7;\nconst PIXELFORMAT_DXT1 = 8;\nconst PIXELFORMAT_DXT3 = 9;\nconst PIXELFORMAT_DXT5 = 10;\nconst PIXELFORMAT_RGB16F = 11;\nconst PIXELFORMAT_RGBA16F = 12;\nconst PIXELFORMAT_RGB32F = 13;\nconst PIXELFORMAT_RGBA32F = 14;\nconst PIXELFORMAT_R32F = 15;\nconst PIXELFORMAT_DEPTH = 16;\nconst PIXELFORMAT_DEPTHSTENCIL = 17;\nconst PIXELFORMAT_111110F = 18;\nconst PIXELFORMAT_SRGB = 19;\nconst PIXELFORMAT_SRGBA = 20;\nconst PIXELFORMAT_ETC1 = 21;\nconst PIXELFORMAT_ETC2_RGB = 22;\nconst PIXELFORMAT_ETC2_RGBA = 23;\nconst PIXELFORMAT_PVRTC_2BPP_RGB_1 = 24;\nconst PIXELFORMAT_PVRTC_2BPP_RGBA_1 = 25;\nconst PIXELFORMAT_PVRTC_4BPP_RGB_1 = 26;\nconst PIXELFORMAT_PVRTC_4BPP_RGBA_1 = 27;\nconst PIXELFORMAT_ASTC_4x4 = 28;\nconst PIXELFORMAT_ATC_RGB = 29;\nconst PIXELFORMAT_ATC_RGBA = 30;\nconst PIXELFORMAT_BGRA8 = 31;\nconst PIXELFORMAT_R8I = 32;\nconst PIXELFORMAT_R8U = 33;\nconst PIXELFORMAT_R16I = 34;\nconst PIXELFORMAT_R16U = 35;\nconst PIXELFORMAT_R32I = 36;\nconst PIXELFORMAT_R32U = 37;\nconst PIXELFORMAT_RG8I = 38;\nconst PIXELFORMAT_RG8U = 39;\nconst PIXELFORMAT_RG16I = 40;\nconst PIXELFORMAT_RG16U = 41;\nconst PIXELFORMAT_RG32I = 42;\nconst PIXELFORMAT_RG32U = 43;\nconst PIXELFORMAT_RGBA8I = 44;\nconst PIXELFORMAT_RGBA8U = 45;\nconst PIXELFORMAT_RGBA16I = 46;\nconst PIXELFORMAT_RGBA16U = 47;\nconst PIXELFORMAT_RGBA32I = 48;\nconst PIXELFORMAT_RGBA32U = 49;\nconst PIXELFORMAT_R16F = 50;\nconst PIXELFORMAT_RG16F = 51;\nconst pixelFormatInfo = new Map([[PIXELFORMAT_A8, {\n\tname: 'A8',\n\tsize: 1\n}], [PIXELFORMAT_L8, {\n\tname: 'L8',\n\tsize: 1\n}], [PIXELFORMAT_LA8, {\n\tname: 'LA8',\n\tsize: 2\n}], [PIXELFORMAT_RGB565, {\n\tname: 'RGB565',\n\tsize: 2\n}], [PIXELFORMAT_RGBA5551, {\n\tname: 'RGBA5551',\n\tsize: 2\n}], [PIXELFORMAT_RGBA4, {\n\tname: 'RGBA4',\n\tsize: 2\n}], [PIXELFORMAT_RGB8, {\n\tname: 'RGB8',\n\tsize: 4\n}], [PIXELFORMAT_RGBA8, {\n\tname: 'RGBA8',\n\tsize: 4\n}], [PIXELFORMAT_R16F, {\n\tname: 'R16F',\n\tsize: 2\n}], [PIXELFORMAT_RG16F, {\n\tname: 'RG16F',\n\tsize: 4\n}], [PIXELFORMAT_RGB16F, {\n\tname: 'RGB16F',\n\tsize: 8\n}], [PIXELFORMAT_RGBA16F, {\n\tname: 'RGBA16F',\n\tsize: 8\n}], [PIXELFORMAT_RGB32F, {\n\tname: 'RGB32F',\n\tsize: 16\n}], [PIXELFORMAT_RGBA32F, {\n\tname: 'RGBA32F',\n\tsize: 16\n}], [PIXELFORMAT_R32F, {\n\tname: 'R32F',\n\tsize: 4\n}], [PIXELFORMAT_DEPTH, {\n\tname: 'DEPTH',\n\tsize: 4\n}], [PIXELFORMAT_DEPTHSTENCIL, {\n\tname: 'DEPTHSTENCIL',\n\tsize: 4\n}], [PIXELFORMAT_111110F, {\n\tname: '111110F',\n\tsize: 4\n}], [PIXELFORMAT_SRGB, {\n\tname: 'SRGB',\n\tsize: 4\n}], [PIXELFORMAT_SRGBA, {\n\tname: 'SRGBA',\n\tsize: 4\n}], [PIXELFORMAT_BGRA8, {\n\tname: 'BGRA8',\n\tsize: 4\n}], [PIXELFORMAT_DXT1, {\n\tname: 'DXT1',\n\tblockSize: 8\n}], [PIXELFORMAT_DXT3, {\n\tname: 'DXT3',\n\tblockSize: 16\n}], [PIXELFORMAT_DXT5, {\n\tname: 'DXT5',\n\tblockSize: 16\n}], [PIXELFORMAT_ETC1, {\n\tname: 'ETC1',\n\tblockSize: 8\n}], [PIXELFORMAT_ETC2_RGB, {\n\tname: 'ETC2_RGB',\n\tblockSize: 8\n}], [PIXELFORMAT_ETC2_RGBA, {\n\tname: 'ETC2_RGBA',\n\tblockSize: 16\n}], [PIXELFORMAT_PVRTC_2BPP_RGB_1, {\n\tname: 'PVRTC_2BPP_RGB_1',\n\tblockSize: 8\n}], [PIXELFORMAT_PVRTC_2BPP_RGBA_1, {\n\tname: 'PVRTC_2BPP_RGBA_1',\n\tblockSize: 8\n}], [PIXELFORMAT_PVRTC_4BPP_RGB_1, {\n\tname: 'PVRTC_4BPP_RGB_1',\n\tblockSize: 8\n}], [PIXELFORMAT_PVRTC_4BPP_RGBA_1, {\n\tname: 'PVRTC_4BPP_RGBA_1',\n\tblockSize: 8\n}], [PIXELFORMAT_ASTC_4x4, {\n\tname: 'ASTC_4x4',\n\tblockSize: 16\n}], [PIXELFORMAT_ATC_RGB, {\n\tname: 'ATC_RGB',\n\tblockSize: 8\n}], [PIXELFORMAT_ATC_RGBA, {\n\tname: 'ATC_RGBA',\n\tblockSize: 16\n}], [PIXELFORMAT_R8I, {\n\tname: 'R8I',\n\tsize: 1,\n\tisInt: true\n}], [PIXELFORMAT_R8U, {\n\tname: 'R8U',\n\tsize: 1,\n\tisInt: true\n}], [PIXELFORMAT_R16I, {\n\tname: 'R16I',\n\tsize: 2,\n\tisInt: true\n}], [PIXELFORMAT_R16U, {\n\tname: 'R16U',\n\tsize: 2,\n\tisInt: true\n}], [PIXELFORMAT_R32I, {\n\tname: 'R32I',\n\tsize: 4,\n\tisInt: true\n}], [PIXELFORMAT_R32U, {\n\tname: 'R32U',\n\tsize: 4,\n\tisInt: true\n}], [PIXELFORMAT_RG8I, {\n\tname: 'RG8I',\n\tsize: 2,\n\tisInt: true\n}], [PIXELFORMAT_RG8U, {\n\tname: 'RG8U',\n\tsize: 2,\n\tisInt: true\n}], [PIXELFORMAT_RG16I, {\n\tname: 'RG16I',\n\tsize: 4,\n\tisInt: true\n}], [PIXELFORMAT_RG16U, {\n\tname: 'RG16U',\n\tsize: 4,\n\tisInt: true\n}], [PIXELFORMAT_RG32I, {\n\tname: 'RG32I',\n\tsize: 8,\n\tisInt: true\n}], [PIXELFORMAT_RG32U, {\n\tname: 'RG32U',\n\tsize: 8,\n\tisInt: true\n}], [PIXELFORMAT_RGBA8I, {\n\tname: 'RGBA8I',\n\tsize: 4,\n\tisInt: true\n}], [PIXELFORMAT_RGBA8U, {\n\tname: 'RGBA8U',\n\tsize: 4,\n\tisInt: true\n}], [PIXELFORMAT_RGBA16I, {\n\tname: 'RGBA16I',\n\tsize: 8,\n\tisInt: true\n}], [PIXELFORMAT_RGBA16U, {\n\tname: 'RGBA16U',\n\tsize: 8,\n\tisInt: true\n}], [PIXELFORMAT_RGBA32I, {\n\tname: 'RGBA32I',\n\tsize: 16,\n\tisInt: true\n}], [PIXELFORMAT_RGBA32U, {\n\tname: 'RGBA32U',\n\tsize: 16,\n\tisInt: true\n}]]);\nconst isCompressedPixelFormat = format => {\n\tvar _pixelFormatInfo$get;\n\treturn ((_pixelFormatInfo$get = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo$get.blockSize) !== undefined;\n};\nconst isIntegerPixelFormat = format => {\n\tvar _pixelFormatInfo$get2;\n\treturn ((_pixelFormatInfo$get2 = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo$get2.isInt) === true;\n};\nconst getPixelFormatArrayType = format => {\n\tswitch (format) {\n\t\tcase PIXELFORMAT_R32F:\n\t\tcase PIXELFORMAT_RGB32F:\n\t\tcase PIXELFORMAT_RGBA32F:\n\t\t\treturn Float32Array;\n\t\tcase PIXELFORMAT_R32I:\n\t\tcase PIXELFORMAT_RG32I:\n\t\tcase PIXELFORMAT_RGBA32I:\n\t\t\treturn Int32Array;\n\t\tcase PIXELFORMAT_R32U:\n\t\tcase PIXELFORMAT_RG32U:\n\t\tcase PIXELFORMAT_RGBA32U:\n\t\t\treturn Uint32Array;\n\t\tcase PIXELFORMAT_R16I:\n\t\tcase PIXELFORMAT_RG16I:\n\t\tcase PIXELFORMAT_RGBA16I:\n\t\t\treturn Int16Array;\n\t\tcase PIXELFORMAT_R16U:\n\t\tcase PIXELFORMAT_RG16U:\n\t\tcase PIXELFORMAT_RGBA16U:\n\t\tcase PIXELFORMAT_RGB565:\n\t\tcase PIXELFORMAT_RGBA5551:\n\t\tcase PIXELFORMAT_RGBA4:\n\t\tcase PIXELFORMAT_R16F:\n\t\tcase PIXELFORMAT_RG16F:\n\t\tcase PIXELFORMAT_RGB16F:\n\t\tcase PIXELFORMAT_RGBA16F:\n\t\t\treturn Uint16Array;\n\t\tcase PIXELFORMAT_R8I:\n\t\tcase PIXELFORMAT_RG8I:\n\t\tcase PIXELFORMAT_RGBA8I:\n\t\t\treturn Int8Array;\n\t\tdefault:\n\t\t\treturn Uint8Array;\n\t}\n};\nconst PRIMITIVE_POINTS = 0;\nconst PRIMITIVE_LINES = 1;\nconst PRIMITIVE_LINELOOP = 2;\nconst PRIMITIVE_LINESTRIP = 3;\nconst PRIMITIVE_TRIANGLES = 4;\nconst PRIMITIVE_TRISTRIP = 5;\nconst PRIMITIVE_TRIFAN = 6;\nconst SEMANTIC_POSITION = 'POSITION';\nconst SEMANTIC_NORMAL = 'NORMAL';\nconst SEMANTIC_TANGENT = 'TANGENT';\nconst SEMANTIC_BLENDWEIGHT = 'BLENDWEIGHT';\nconst SEMANTIC_BLENDINDICES = 'BLENDINDICES';\nconst SEMANTIC_COLOR = 'COLOR';\nconst SEMANTIC_TEXCOORD = 'TEXCOORD';\nconst SEMANTIC_TEXCOORD0 = 'TEXCOORD0';\nconst SEMANTIC_TEXCOORD1 = 'TEXCOORD1';\nconst SEMANTIC_TEXCOORD2 = 'TEXCOORD2';\nconst SEMANTIC_TEXCOORD3 = 'TEXCOORD3';\nconst SEMANTIC_TEXCOORD4 = 'TEXCOORD4';\nconst SEMANTIC_TEXCOORD5 = 'TEXCOORD5';\nconst SEMANTIC_TEXCOORD6 = 'TEXCOORD6';\nconst SEMANTIC_TEXCOORD7 = 'TEXCOORD7';\nconst SEMANTIC_ATTR = 'ATTR';\nconst SEMANTIC_ATTR0 = 'ATTR0';\nconst SEMANTIC_ATTR1 = 'ATTR1';\nconst SEMANTIC_ATTR2 = 'ATTR2';\nconst SEMANTIC_ATTR3 = 'ATTR3';\nconst SEMANTIC_ATTR4 = 'ATTR4';\nconst SEMANTIC_ATTR5 = 'ATTR5';\nconst SEMANTIC_ATTR6 = 'ATTR6';\nconst SEMANTIC_ATTR7 = 'ATTR7';\nconst SEMANTIC_ATTR8 = 'ATTR8';\nconst SEMANTIC_ATTR9 = 'ATTR9';\nconst SEMANTIC_ATTR10 = 'ATTR10';\nconst SEMANTIC_ATTR11 = 'ATTR11';\nconst SEMANTIC_ATTR12 = 'ATTR12';\nconst SEMANTIC_ATTR13 = 'ATTR13';\nconst SEMANTIC_ATTR14 = 'ATTR14';\nconst SEMANTIC_ATTR15 = 'ATTR15';\nconst SHADERTAG_MATERIAL = 1;\nconst STENCILOP_KEEP = 0;\nconst STENCILOP_ZERO = 1;\nconst STENCILOP_REPLACE = 2;\nconst STENCILOP_INCREMENT = 3;\nconst STENCILOP_INCREMENTWRAP = 4;\nconst STENCILOP_DECREMENT = 5;\nconst STENCILOP_DECREMENTWRAP = 6;\nconst STENCILOP_INVERT = 7;\nconst TEXTURELOCK_NONE = 0;\nconst TEXTURELOCK_READ = 1;\nconst TEXTURELOCK_WRITE = 2;\nconst TEXTURETYPE_DEFAULT = 'default';\nconst TEXTURETYPE_RGBM = 'rgbm';\nconst TEXTURETYPE_RGBE = 'rgbe';\nconst TEXTURETYPE_RGBP = 'rgbp';\nconst TEXTURETYPE_SWIZZLEGGGR = 'swizzleGGGR';\nconst TEXHINT_NONE = 0;\nconst TEXHINT_SHADOWMAP = 1;\nconst TEXHINT_ASSET = 2;\nconst TEXHINT_LIGHTMAP = 3;\nconst TEXTUREDIMENSION_1D = '1d';\nconst TEXTUREDIMENSION_2D = '2d';\nconst TEXTUREDIMENSION_2D_ARRAY = '2d-array';\nconst TEXTUREDIMENSION_CUBE = 'cube';\nconst TEXTUREDIMENSION_CUBE_ARRAY = 'cube-array';\nconst TEXTUREDIMENSION_3D = '3d';\nconst SAMPLETYPE_FLOAT = 0;\nconst SAMPLETYPE_UNFILTERABLE_FLOAT = 1;\nconst SAMPLETYPE_DEPTH = 2;\nconst SAMPLETYPE_INT = 3;\nconst SAMPLETYPE_UINT = 4;\nconst TEXTUREPROJECTION_NONE = 'none';\nconst TEXTUREPROJECTION_CUBE = 'cube';\nconst TEXTUREPROJECTION_EQUIRECT = 'equirect';\nconst TEXTUREPROJECTION_OCTAHEDRAL = 'octahedral';\nconst SHADERLANGUAGE_GLSL = 'glsl';\nconst SHADERLANGUAGE_WGSL = 'wgsl';\nconst TYPE_INT8 = 0;\nconst TYPE_UINT8 = 1;\nconst TYPE_INT16 = 2;\nconst TYPE_UINT16 = 3;\nconst TYPE_INT32 = 4;\nconst TYPE_UINT32 = 5;\nconst TYPE_FLOAT32 = 6;\nconst TYPE_FLOAT16 = 7;\nconst UNIFORMTYPE_BOOL = 0;\nconst UNIFORMTYPE_INT = 1;\nconst UNIFORMTYPE_FLOAT = 2;\nconst UNIFORMTYPE_VEC2 = 3;\nconst UNIFORMTYPE_VEC3 = 4;\nconst UNIFORMTYPE_VEC4 = 5;\nconst UNIFORMTYPE_IVEC2 = 6;\nconst UNIFORMTYPE_IVEC3 = 7;\nconst UNIFORMTYPE_IVEC4 = 8;\nconst UNIFORMTYPE_BVEC2 = 9;\nconst UNIFORMTYPE_BVEC3 = 10;\nconst UNIFORMTYPE_BVEC4 = 11;\nconst UNIFORMTYPE_MAT2 = 12;\nconst UNIFORMTYPE_MAT3 = 13;\nconst UNIFORMTYPE_MAT4 = 14;\nconst UNIFORMTYPE_TEXTURE2D = 15;\nconst UNIFORMTYPE_TEXTURECUBE = 16;\nconst UNIFORMTYPE_FLOATARRAY = 17;\nconst UNIFORMTYPE_TEXTURE2D_SHADOW = 18;\nconst UNIFORMTYPE_TEXTURECUBE_SHADOW = 19;\nconst UNIFORMTYPE_TEXTURE3D = 20;\nconst UNIFORMTYPE_VEC2ARRAY = 21;\nconst UNIFORMTYPE_VEC3ARRAY = 22;\nconst UNIFORMTYPE_VEC4ARRAY = 23;\nconst UNIFORMTYPE_MAT4ARRAY = 24;\nconst UNIFORMTYPE_TEXTURE2D_ARRAY = 25;\nconst UNIFORMTYPE_UINT = 26;\nconst UNIFORMTYPE_UVEC2 = 27;\nconst UNIFORMTYPE_UVEC3 = 28;\nconst UNIFORMTYPE_UVEC4 = 29;\nconst UNIFORMTYPE_INTARRAY = 30;\nconst UNIFORMTYPE_UINTARRAY = 31;\nconst UNIFORMTYPE_BOOLARRAY = 32;\nconst UNIFORMTYPE_IVEC2ARRAY = 33;\nconst UNIFORMTYPE_UVEC2ARRAY = 34;\nconst UNIFORMTYPE_BVEC2ARRAY = 35;\nconst UNIFORMTYPE_IVEC3ARRAY = 36;\nconst UNIFORMTYPE_UVEC3ARRAY = 37;\nconst UNIFORMTYPE_BVEC3ARRAY = 38;\nconst UNIFORMTYPE_IVEC4ARRAY = 39;\nconst UNIFORMTYPE_UVEC4ARRAY = 40;\nconst UNIFORMTYPE_BVEC4ARRAY = 41;\nconst UNIFORMTYPE_ITEXTURE2D = 42;\nconst UNIFORMTYPE_UTEXTURE2D = 43;\nconst UNIFORMTYPE_ITEXTURECUBE = 44;\nconst UNIFORMTYPE_UTEXTURECUBE = 45;\nconst UNIFORMTYPE_ITEXTURE3D = 46;\nconst UNIFORMTYPE_UTEXTURE3D = 47;\nconst UNIFORMTYPE_ITEXTURE2D_ARRAY = 48;\nconst UNIFORMTYPE_UTEXTURE2D_ARRAY = 49;\nconst uniformTypeToName = ['bool', 'int', 'float', 'vec2', 'vec3', 'vec4', 'ivec2', 'ivec3', 'ivec4', 'bvec2', 'bvec3', 'bvec4', 'mat2', 'mat3', 'mat4', 'sampler2D', 'samplerCube', '', 'sampler2DShadow', 'samplerCubeShadow', 'sampler3D', '', '', '', '', 'sampler2DArray', 'uint', 'uvec2', 'uvec3', 'uvec4', '', '', '', '', '', '', '', '', '', '', '', '', 'isampler2D', 'usampler2D', 'isamplerCube', 'usamplerCube', 'isampler3D', 'usampler3D', 'isampler2DArray', 'usampler2DArray'];\nconst uniformTypeToStorage = new Uint8Array([TYPE_INT32, TYPE_INT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_INT32, TYPE_INT32, TYPE_INT32, TYPE_INT32, TYPE_INT32, TYPE_INT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_INT32, TYPE_INT32, TYPE_FLOAT32, TYPE_INT32, TYPE_INT32, TYPE_INT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_FLOAT32, TYPE_INT32, TYPE_UINT32, TYPE_UINT32, TYPE_UINT32, TYPE_UINT32, TYPE_INT32, TYPE_UINT32, TYPE_INT32, TYPE_INT32, TYPE_UINT32, TYPE_INT32, TYPE_INT32, TYPE_UINT32, TYPE_INT32, TYPE_INT32, TYPE_UINT32, TYPE_INT32, TYPE_INT32, TYPE_UINT32, TYPE_INT32, TYPE_UINT32, TYPE_INT32, TYPE_UINT32, TYPE_INT32, TYPE_UINT32]);\nconst DEVICETYPE_WEBGL1 = 'webgl1';\nconst DEVICETYPE_WEBGL2 = 'webgl2';\nconst DEVICETYPE_WEBGPU = 'webgpu';\nconst DEVICETYPE_NULL = 'null';\nconst SHADERSTAGE_VERTEX = 1;\nconst SHADERSTAGE_FRAGMENT = 2;\nconst SHADERSTAGE_COMPUTE = 4;\nconst BINDGROUP_MESH = 0;\nconst BINDGROUP_VIEW = 1;\nconst bindGroupNames = ['mesh', 'view'];\nconst UNIFORM_BUFFER_DEFAULT_SLOT_NAME = 'default';\nconst typedArrayTypes = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Uint16Array];\nconst typedArrayTypesByteSize = [1, 1, 2, 2, 4, 4, 4, 2];\nconst vertexTypesNames = ['INT8', 'UINT8', 'INT16', 'UINT16', 'INT32', 'UINT32', 'FLOAT32', 'FLOAT16'];\nconst typedArrayToType = {\n\t'Int8Array': TYPE_INT8,\n\t'Uint8Array': TYPE_UINT8,\n\t'Int16Array': TYPE_INT16,\n\t'Uint16Array': TYPE_UINT16,\n\t'Int32Array': TYPE_INT32,\n\t'Uint32Array': TYPE_UINT32,\n\t'Float32Array': TYPE_FLOAT32\n};\nconst typedArrayIndexFormats = [Uint8Array, Uint16Array, Uint32Array];\nconst typedArrayIndexFormatsByteSize = [1, 2, 4];\nconst semanticToLocation = {};\nsemanticToLocation[SEMANTIC_POSITION] = 0;\nsemanticToLocation[SEMANTIC_NORMAL] = 1;\nsemanticToLocation[SEMANTIC_BLENDWEIGHT] = 2;\nsemanticToLocation[SEMANTIC_BLENDINDICES] = 3;\nsemanticToLocation[SEMANTIC_COLOR] = 4;\nsemanticToLocation[SEMANTIC_TEXCOORD0] = 5;\nsemanticToLocation[SEMANTIC_TEXCOORD1] = 6;\nsemanticToLocation[SEMANTIC_TEXCOORD2] = 7;\nsemanticToLocation[SEMANTIC_TEXCOORD3] = 8;\nsemanticToLocation[SEMANTIC_TEXCOORD4] = 9;\nsemanticToLocation[SEMANTIC_TEXCOORD5] = 10;\nsemanticToLocation[SEMANTIC_TEXCOORD6] = 11;\nsemanticToLocation[SEMANTIC_TEXCOORD7] = 12;\nsemanticToLocation[SEMANTIC_TANGENT] = 13;\nsemanticToLocation[SEMANTIC_ATTR0] = 0;\nsemanticToLocation[SEMANTIC_ATTR1] = 1;\nsemanticToLocation[SEMANTIC_ATTR2] = 2;\nsemanticToLocation[SEMANTIC_ATTR3] = 3;\nsemanticToLocation[SEMANTIC_ATTR4] = 4;\nsemanticToLocation[SEMANTIC_ATTR5] = 5;\nsemanticToLocation[SEMANTIC_ATTR6] = 6;\nsemanticToLocation[SEMANTIC_ATTR7] = 7;\nsemanticToLocation[SEMANTIC_ATTR8] = 8;\nsemanticToLocation[SEMANTIC_ATTR9] = 9;\nsemanticToLocation[SEMANTIC_ATTR10] = 10;\nsemanticToLocation[SEMANTIC_ATTR11] = 11;\nsemanticToLocation[SEMANTIC_ATTR12] = 12;\nsemanticToLocation[SEMANTIC_ATTR13] = 13;\nsemanticToLocation[SEMANTIC_ATTR14] = 14;\nsemanticToLocation[SEMANTIC_ATTR15] = 15;\nconst CHUNKAPI_1_51 = '1.51';\nconst CHUNKAPI_1_55 = '1.55';\nconst CHUNKAPI_1_56 = '1.56';\nconst CHUNKAPI_1_57 = '1.57';\nconst CHUNKAPI_1_58 = '1.58';\nconst CHUNKAPI_1_60 = '1.60';\nconst CHUNKAPI_1_62 = '1.62';\nconst CHUNKAPI_1_65 = '1.65';\nconst CHUNKAPI_1_70 = '1.70';\n\nexport { ADDRESS_CLAMP_TO_EDGE, ADDRESS_MIRRORED_REPEAT, ADDRESS_REPEAT, BINDGROUP_MESH, BINDGROUP_VIEW, BLENDEQUATION_ADD, BLENDEQUATION_MAX, BLENDEQUATION_MIN, BLENDEQUATION_REVERSE_SUBTRACT, BLENDEQUATION_SUBTRACT, BLENDMODE_CONSTANT, BLENDMODE_DST_ALPHA, BLENDMODE_DST_COLOR, BLENDMODE_ONE, BLENDMODE_ONE_MINUS_CONSTANT, BLENDMODE_ONE_MINUS_DST_ALPHA, BLENDMODE_ONE_MINUS_DST_COLOR, BLENDMODE_ONE_MINUS_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_COLOR, BLENDMODE_SRC_ALPHA, BLENDMODE_SRC_ALPHA_SATURATE, BLENDMODE_SRC_COLOR, BLENDMODE_ZERO, BUFFERUSAGE_COPY_DST, BUFFERUSAGE_COPY_SRC, BUFFERUSAGE_INDEX, BUFFERUSAGE_INDIRECT, BUFFERUSAGE_READ, BUFFERUSAGE_STORAGE, BUFFERUSAGE_UNIFORM, BUFFERUSAGE_VERTEX, BUFFERUSAGE_WRITE, BUFFER_DYNAMIC, BUFFER_GPUDYNAMIC, BUFFER_STATIC, BUFFER_STREAM, CHUNKAPI_1_51, CHUNKAPI_1_55, CHUNKAPI_1_56, CHUNKAPI_1_57, CHUNKAPI_1_58, CHUNKAPI_1_60, CHUNKAPI_1_62, CHUNKAPI_1_65, CHUNKAPI_1_70, CLEARFLAG_COLOR, CLEARFLAG_DEPTH, CLEARFLAG_STENCIL, CUBEFACE_NEGX, CUBEFACE_NEGY, CUBEFACE_NEGZ, CUBEFACE_POSX, CUBEFACE_POSY, CUBEFACE_POSZ, CULLFACE_BACK, CULLFACE_FRONT, CULLFACE_FRONTANDBACK, CULLFACE_NONE, DEVICETYPE_NULL, DEVICETYPE_WEBGL1, DEVICETYPE_WEBGL2, DEVICETYPE_WEBGPU, FILTER_LINEAR, FILTER_LINEAR_MIPMAP_LINEAR, FILTER_LINEAR_MIPMAP_NEAREST, FILTER_NEAREST, FILTER_NEAREST_MIPMAP_LINEAR, FILTER_NEAREST_MIPMAP_NEAREST, FUNC_ALWAYS, FUNC_EQUAL, FUNC_GREATER, FUNC_GREATEREQUAL, FUNC_LESS, FUNC_LESSEQUAL, FUNC_NEVER, FUNC_NOTEQUAL, INDEXFORMAT_UINT16, INDEXFORMAT_UINT32, INDEXFORMAT_UINT8, PIXELFORMAT_111110F, PIXELFORMAT_A8, PIXELFORMAT_ASTC_4x4, PIXELFORMAT_ATC_RGB, PIXELFORMAT_ATC_RGBA, PIXELFORMAT_BGRA8, PIXELFORMAT_DEPTH, PIXELFORMAT_DEPTHSTENCIL, PIXELFORMAT_DXT1, PIXELFORMAT_DXT3, PIXELFORMAT_DXT5, PIXELFORMAT_ETC1, PIXELFORMAT_ETC2_RGB, PIXELFORMAT_ETC2_RGBA, PIXELFORMAT_L8, PIXELFORMAT_LA8, PIXELFORMAT_PVRTC_2BPP_RGBA_1, PIXELFORMAT_PVRTC_2BPP_RGB_1, PIXELFORMAT_PVRTC_4BPP_RGBA_1, PIXELFORMAT_PVRTC_4BPP_RGB_1, PIXELFORMAT_R16F, PIXELFORMAT_R16I, PIXELFORMAT_R16U, PIXELFORMAT_R32F, PIXELFORMAT_R32I, PIXELFORMAT_R32U, PIXELFORMAT_R8I, PIXELFORMAT_R8U, PIXELFORMAT_RG16F, PIXELFORMAT_RG16I, PIXELFORMAT_RG16U, PIXELFORMAT_RG32I, PIXELFORMAT_RG32U, PIXELFORMAT_RG8I, PIXELFORMAT_RG8U, PIXELFORMAT_RGB16F, PIXELFORMAT_RGB32F, PIXELFORMAT_RGB565, PIXELFORMAT_RGB8, PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA16I, PIXELFORMAT_RGBA16U, PIXELFORMAT_RGBA32F, PIXELFORMAT_RGBA32I, PIXELFORMAT_RGBA32U, PIXELFORMAT_RGBA4, PIXELFORMAT_RGBA5551, PIXELFORMAT_RGBA8, PIXELFORMAT_RGBA8I, PIXELFORMAT_RGBA8U, PIXELFORMAT_SRGB, PIXELFORMAT_SRGBA, PRIMITIVE_LINELOOP, PRIMITIVE_LINES, PRIMITIVE_LINESTRIP, PRIMITIVE_POINTS, PRIMITIVE_TRIANGLES, PRIMITIVE_TRIFAN, PRIMITIVE_TRISTRIP, SAMPLETYPE_DEPTH, SAMPLETYPE_FLOAT, SAMPLETYPE_INT, SAMPLETYPE_UINT, SAMPLETYPE_UNFILTERABLE_FLOAT, SEMANTIC_ATTR, SEMANTIC_ATTR0, SEMANTIC_ATTR1, SEMANTIC_ATTR10, SEMANTIC_ATTR11, SEMANTIC_ATTR12, SEMANTIC_ATTR13, SEMANTIC_ATTR14, SEMANTIC_ATTR15, SEMANTIC_ATTR2, SEMANTIC_ATTR3, SEMANTIC_ATTR4, SEMANTIC_ATTR5, SEMANTIC_ATTR6, SEMANTIC_ATTR7, SEMANTIC_ATTR8, SEMANTIC_ATTR9, SEMANTIC_BLENDINDICES, SEMANTIC_BLENDWEIGHT, SEMANTIC_COLOR, SEMANTIC_NORMAL, SEMANTIC_POSITION, SEMANTIC_TANGENT, SEMANTIC_TEXCOORD, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1, SEMANTIC_TEXCOORD2, SEMANTIC_TEXCOORD3, SEMANTIC_TEXCOORD4, SEMANTIC_TEXCOORD5, SEMANTIC_TEXCOORD6, SEMANTIC_TEXCOORD7, SHADERLANGUAGE_GLSL, SHADERLANGUAGE_WGSL, SHADERSTAGE_COMPUTE, SHADERSTAGE_FRAGMENT, SHADERSTAGE_VERTEX, SHADERTAG_MATERIAL, STENCILOP_DECREMENT, STENCILOP_DECREMENTWRAP, STENCILOP_INCREMENT, STENCILOP_INCREMENTWRAP, STENCILOP_INVERT, STENCILOP_KEEP, STENCILOP_REPLACE, STENCILOP_ZERO, TEXHINT_ASSET, TEXHINT_LIGHTMAP, TEXHINT_NONE, TEXHINT_SHADOWMAP, TEXTUREDIMENSION_1D, TEXTUREDIMENSION_2D, TEXTUREDIMENSION_2D_ARRAY, TEXTUREDIMENSION_3D, TEXTUREDIMENSION_CUBE, TEXTUREDIMENSION_CUBE_ARRAY, TEXTURELOCK_NONE, TEXTURELOCK_READ, TEXTURELOCK_WRITE, TEXTUREPROJECTION_CUBE, TEXTUREPROJECTION_EQUIRECT, TEXTUREPROJECTION_NONE, TEXTUREPROJECTION_OCTAHEDRAL, TEXTURETYPE_DEFAULT, TEXTURETYPE_RGBE, TEXTURETYPE_RGBM, TEXTURETYPE_RGBP, TEXTURETYPE_SWIZZLEGGGR, TYPE_FLOAT16, TYPE_FLOAT32, TYPE_INT16, TYPE_INT32, TYPE_INT8, TYPE_UINT16, TYPE_UINT32, TYPE_UINT8, UNIFORMTYPE_BOOL, UNIFORMTYPE_BOOLARRAY, UNIFORMTYPE_BVEC2, UNIFORMTYPE_BVEC2ARRAY, UNIFORMTYPE_BVEC3, UNIFORMTYPE_BVEC3ARRAY, UNIFORMTYPE_BVEC4, UNIFORMTYPE_BVEC4ARRAY, UNIFORMTYPE_FLOAT, UNIFORMTYPE_FLOATARRAY, UNIFORMTYPE_INT, UNIFORMTYPE_INTARRAY, UNIFORMTYPE_ITEXTURE2D, UNIFORMTYPE_ITEXTURE2D_ARRAY, UNIFORMTYPE_ITEXTURE3D, UNIFORMTYPE_ITEXTURECUBE, UNIFORMTYPE_IVEC2, UNIFORMTYPE_IVEC2ARRAY, UNIFORMTYPE_IVEC3, UNIFORMTYPE_IVEC3ARRAY, UNIFORMTYPE_IVEC4, UNIFORMTYPE_IVEC4ARRAY, UNIFORMTYPE_MAT2, UNIFORMTYPE_MAT3, UNIFORMTYPE_MAT4, UNIFORMTYPE_MAT4ARRAY, UNIFORMTYPE_TEXTURE2D, UNIFORMTYPE_TEXTURE2D_ARRAY, UNIFORMTYPE_TEXTURE2D_SHADOW, UNIFORMTYPE_TEXTURE3D, UNIFORMTYPE_TEXTURECUBE, UNIFORMTYPE_TEXTURECUBE_SHADOW, UNIFORMTYPE_UINT, UNIFORMTYPE_UINTARRAY, UNIFORMTYPE_UTEXTURE2D, UNIFORMTYPE_UTEXTURE2D_ARRAY, UNIFORMTYPE_UTEXTURE3D, UNIFORMTYPE_UTEXTURECUBE, UNIFORMTYPE_UVEC2, UNIFORMTYPE_UVEC2ARRAY, UNIFORMTYPE_UVEC3, UNIFORMTYPE_UVEC3ARRAY, UNIFORMTYPE_UVEC4, UNIFORMTYPE_UVEC4ARRAY, UNIFORMTYPE_VEC2, UNIFORMTYPE_VEC2ARRAY, UNIFORMTYPE_VEC3, UNIFORMTYPE_VEC3ARRAY, UNIFORMTYPE_VEC4, UNIFORMTYPE_VEC4ARRAY, UNIFORM_BUFFER_DEFAULT_SLOT_NAME, bindGroupNames, getPixelFormatArrayType, isCompressedPixelFormat, isIntegerPixelFormat, pixelFormatInfo, semanticToLocation, typedArrayIndexFormats, typedArrayIndexFormatsByteSize, typedArrayToType, typedArrayTypes, typedArrayTypesByteSize, uniformTypeToName, uniformTypeToStorage, vertexTypesNames };\n","import { BitPacking } from '../../core/math/bit-packing.js';\nimport { StringIds } from '../../core/string-ids.js';\nimport { FUNC_LESSEQUAL, FUNC_ALWAYS } from './constants.js';\n\nvar _DepthState;\nconst stringIds = new StringIds();\nconst funcMask = 0b111;\nconst funcShift = 0;\nconst writeShift = 3;\nclass DepthState {\n\tconstructor(func = FUNC_LESSEQUAL, write = true) {\n\t\tthis.data = 0;\n\t\tthis._depthBias = 0;\n\t\tthis._depthBiasSlope = 0;\n\t\tthis.key = 0;\n\t\tthis.func = func;\n\t\tthis.write = write;\n\t}\n\tset test(value) {\n\t\tthis.func = value ? FUNC_LESSEQUAL : FUNC_ALWAYS;\n\t\tthis.updateKey();\n\t}\n\tget test() {\n\t\treturn this.func !== FUNC_ALWAYS;\n\t}\n\tset write(value) {\n\t\tthis.data = BitPacking.set(this.data, value ? 1 : 0, writeShift);\n\t\tthis.updateKey();\n\t}\n\tget write() {\n\t\treturn BitPacking.all(this.data, writeShift);\n\t}\n\tset func(value) {\n\t\tthis.data = BitPacking.set(this.data, value, funcShift, funcMask);\n\t\tthis.updateKey();\n\t}\n\tget func() {\n\t\treturn BitPacking.get(this.data, funcShift, funcMask);\n\t}\n\tset depthBias(value) {\n\t\tthis._depthBias = value;\n\t\tthis.updateKey();\n\t}\n\tget depthBias() {\n\t\treturn this._depthBias;\n\t}\n\tset depthBiasSlope(value) {\n\t\tthis._depthBiasSlope = value;\n\t\tthis.updateKey();\n\t}\n\tget depthBiasSlope() {\n\t\treturn this._depthBiasSlope;\n\t}\n\tcopy(rhs) {\n\t\tthis.data = rhs.data;\n\t\tthis._depthBias = rhs._depthBias;\n\t\tthis._depthBiasSlope = rhs._depthBiasSlope;\n\t\tthis.key = rhs.key;\n\t\treturn this;\n\t}\n\tclone() {\n\t\tconst clone = new this.constructor();\n\t\treturn clone.copy(this);\n\t}\n\tupdateKey() {\n\t\tconst {\n\t\t\tdata,\n\t\t\t_depthBias,\n\t\t\t_depthBiasSlope\n\t\t} = this;\n\t\tconst key = `${data}-${_depthBias}-${_depthBiasSlope}`;\n\t\tthis.key = stringIds.get(key);\n\t}\n\tequals(rhs) {\n\t\treturn this.key === rhs.key;\n\t}\n}\n_DepthState = DepthState;\nDepthState.DEFAULT = Object.freeze(new _DepthState());\nDepthState.NODEPTH = Object.freeze(new _DepthState(FUNC_ALWAYS, false));\nDepthState.WRITEDEPTH = Object.freeze(new _DepthState(FUNC_ALWAYS, true));\n\nexport { DepthState };\n","class DeviceCache {\n\tconstructor() {\n\t\tthis._cache = new Map();\n\t}\n\tget(device, onCreate) {\n\t\tif (!this._cache.has(device)) {\n\t\t\tthis._cache.set(device, onCreate());\n\t\t\tdevice.on('destroy', () => {\n\t\t\t\tthis.remove(device);\n\t\t\t});\n\t\t\tdevice.on('devicelost', () => {\n\t\t\t\tvar _this$_cache$get;\n\t\t\t\t(_this$_cache$get = this._cache.get(device)) == null || _this$_cache$get.loseContext == null || _this$_cache$get.loseContext(device);\n\t\t\t});\n\t\t}\n\t\treturn this._cache.get(device);\n\t}\n\tremove(device) {\n\t\tvar _this$_cache$get2;\n\t\t(_this$_cache$get2 = this._cache.get(device)) == null || _this$_cache$get2.destroy == null || _this$_cache$get2.destroy(device);\n\t\tthis._cache.delete(device);\n\t}\n}\n\nexport { DeviceCache };\n","import { math } from '../../core/math/math.js';\n\nclass DynamicBuffer {\n\tconstructor(device) {\n\t\tthis.device = void 0;\n\t\tthis.device = device;\n\t}\n}\nclass UsedBuffer {\n\tconstructor() {\n\t\tthis.gpuBuffer = void 0;\n\t\tthis.stagingBuffer = void 0;\n\t\tthis.offset = void 0;\n\t\tthis.size = void 0;\n\t}\n}\nclass DynamicBufferAllocation {\n\tconstructor() {\n\t\tthis.storage = void 0;\n\t\tthis.gpuBuffer = void 0;\n\t\tthis.offset = void 0;\n\t}\n}\nclass DynamicBuffers {\n\tconstructor(device, bufferSize, bufferAlignment) {\n\t\tthis.bufferSize = void 0;\n\t\tthis.gpuBuffers = [];\n\t\tthis.stagingBuffers = [];\n\t\tthis.usedBuffers = [];\n\t\tthis.activeBuffer = null;\n\t\tthis.device = device;\n\t\tthis.bufferSize = bufferSize;\n\t\tthis.bufferAlignment = bufferAlignment;\n\t}\n\tdestroy() {\n\t\tthis.gpuBuffers.forEach(gpuBuffer => {\n\t\t\tgpuBuffer.destroy(this.device);\n\t\t});\n\t\tthis.gpuBuffers = null;\n\t\tthis.stagingBuffers.forEach(stagingBuffer => {\n\t\t\tstagingBuffer.destroy(this.device);\n\t\t});\n\t\tthis.stagingBuffers = null;\n\t\tthis.usedBuffers = null;\n\t\tthis.activeBuffer = null;\n\t}\n\talloc(allocation, size) {\n\t\tif (this.activeBuffer) {\n\t\t\tconst _alignedStart = math.roundUp(this.activeBuffer.size, this.bufferAlignment);\n\t\t\tconst space = this.bufferSize - _alignedStart;\n\t\t\tif (space < size) {\n\t\t\t\tthis.scheduleSubmit();\n\t\t\t}\n\t\t}\n\t\tif (!this.activeBuffer) {\n\t\t\tlet gpuBuffer = this.gpuBuffers.pop();\n\t\t\tif (!gpuBuffer) {\n\t\t\t\tgpuBuffer = this.createBuffer(this.device, this.bufferSize, false);\n\t\t\t}\n\t\t\tlet stagingBuffer = this.stagingBuffers.pop();\n\t\t\tif (!stagingBuffer) {\n\t\t\t\tstagingBuffer = this.createBuffer(this.device, this.bufferSize, true);\n\t\t\t}\n\t\t\tthis.activeBuffer = new UsedBuffer();\n\t\t\tthis.activeBuffer.stagingBuffer = stagingBuffer;\n\t\t\tthis.activeBuffer.gpuBuffer = gpuBuffer;\n\t\t\tthis.activeBuffer.offset = 0;\n\t\t\tthis.activeBuffer.size = 0;\n\t\t}\n\t\tconst activeBuffer = this.activeBuffer;\n\t\tconst alignedStart = math.roundUp(activeBuffer.size, this.bufferAlignment);\n\t\tallocation.gpuBuffer = activeBuffer.gpuBuffer;\n\t\tallocation.offset = alignedStart;\n\t\tallocation.storage = activeBuffer.stagingBuffer.alloc(alignedStart, size);\n\t\tactiveBuffer.size = alignedStart + size;\n\t}\n\tscheduleSubmit() {\n\t\tif (this.activeBuffer) {\n\t\t\tthis.usedBuffers.push(this.activeBuffer);\n\t\t\tthis.activeBuffer = null;\n\t\t}\n\t}\n\tsubmit() {\n\t\tthis.scheduleSubmit();\n\t}\n}\n\nexport { DynamicBuffer, DynamicBufferAllocation, DynamicBuffers };\n","import { TRACEID_GPU_TIMINGS } from '../../core/constants.js';\nimport { Tracing } from '../../core/tracing.js';\n\nclass GpuProfiler {\n\tconstructor() {\n\t\tthis.frameAllocations = [];\n\t\tthis.pastFrameAllocations = new Map();\n\t\tthis._enabled = false;\n\t\tthis._enableRequest = false;\n\t\tthis._frameTime = 0;\n\t}\n\tloseContext() {\n\t\tthis.pastFrameAllocations.clear();\n\t}\n\tset enabled(value) {\n\t\tthis._enableRequest = value;\n\t}\n\tget enabled() {\n\t\treturn this._enableRequest;\n\t}\n\tprocessEnableRequest() {\n\t\tif (this._enableRequest !== this._enabled) {\n\t\t\tthis._enabled = this._enableRequest;\n\t\t\tif (!this._enabled) {\n\t\t\t\tthis._frameTime = 0;\n\t\t\t}\n\t\t}\n\t}\n\trequest(renderVersion) {\n\t\tthis.pastFrameAllocations.set(renderVersion, this.frameAllocations);\n\t\tthis.frameAllocations = [];\n\t}\n\treport(renderVersion, timings) {\n\t\tif (timings) {\n\t\t\tconst allocations = this.pastFrameAllocations.get(renderVersion);\n\t\t\tif (timings.length > 0) {\n\t\t\t\tthis._frameTime = timings[0];\n\t\t\t}\n\t\t\tif (Tracing.get(TRACEID_GPU_TIMINGS)) {\n\t\t\t\tfor (let i = 0; i < allocations.length; ++i) {\n\t\t\t\t\tallocations[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.pastFrameAllocations.delete(renderVersion);\n\t}\n\tgetSlot(name) {\n\t\tconst slot = this.frameAllocations.length;\n\t\tthis.frameAllocations.push(name);\n\t\treturn slot;\n\t}\n\tget slotCount() {\n\t\treturn this.frameAllocations.length;\n\t}\n}\n\nexport { GpuProfiler };\n","import { extends as _extends } from '../../../_virtual/_rollupPluginBabelHelpers.js';\nimport { EventHandler } from '../../core/event-handler.js';\nimport { platform } from '../../core/platform.js';\nimport { Vec2 } from '../../core/math/vec2.js';\nimport { Color } from '../../core/math/color.js';\nimport { CLEARFLAG_COLOR, CLEARFLAG_DEPTH, PRIMITIVE_TRIFAN, SEMANTIC_POSITION, TYPE_FLOAT32, CULLFACE_BACK, PIXELFORMAT_RGBA32F, PIXELFORMAT_RGBA16F, PIXELFORMAT_111110F, PRIMITIVE_POINTS } from './constants.js';\nimport { BlendState } from './blend-state.js';\nimport { DepthState } from './depth-state.js';\nimport { ScopeSpace } from './scope-space.js';\nimport { VertexBuffer } from './vertex-buffer.js';\nimport { VertexFormat } from './vertex-format.js';\nimport { StencilParameters } from './stencil-parameters.js';\n\nclass GraphicsDevice extends EventHandler {\n\tconstructor(canvas, options) {\n\t\tvar _this$initOptions, _this$initOptions$dep, _this$initOptions2, _this$initOptions2$st, _this$initOptions3, _this$initOptions3$an, _this$initOptions4, _this$initOptions4$po;\n\t\tsuper();\n\t\tthis.canvas = void 0;\n\t\tthis.backBuffer = null;\n\t\tthis.backBufferSize = new Vec2();\n\t\tthis.backBufferFormat = void 0;\n\t\tthis.backBufferAntialias = false;\n\t\tthis.isWebGPU = false;\n\t\tthis.isWebGL1 = false;\n\t\tthis.isWebGL2 = false;\n\t\tthis.scope = void 0;\n\t\tthis.boneLimit = void 0;\n\t\tthis.maxAnisotropy = void 0;\n\t\tthis.maxCubeMapSize = void 0;\n\t\tthis.maxTextureSize = void 0;\n\t\tthis.maxVolumeSize = void 0;\n\t\tthis.maxColorAttachments = 1;\n\t\tthis.precision = void 0;\n\t\tthis.samples = void 0;\n\t\tthis.supportsStencil = void 0;\n\t\tthis.supportsMrt = false;\n\t\tthis.supportsVolumeTextures = false;\n\t\tthis.supportsCompute = false;\n\t\tthis.supportsStorageTextureRead = false;\n\t\tthis.renderTarget = null;\n\t\tthis.shaders = [];\n\t\tthis.textures = [];\n\t\tthis.targets = new Set();\n\t\tthis.renderVersion = 0;\n\t\tthis.renderPassIndex = void 0;\n\t\tthis.insideRenderPass = false;\n\t\tthis.supportsInstancing = void 0;\n\t\tthis.supportsUniformBuffers = false;\n\t\tthis.textureFloatRenderable = void 0;\n\t\tthis.textureHalfFloatRenderable = void 0;\n\t\tthis.textureFloatFilterable = false;\n\t\tthis.textureHalfFloatFilterable = false;\n\t\tthis.quadVertexBuffer = void 0;\n\t\tthis.blendState = new BlendState();\n\t\tthis.depthState = new DepthState();\n\t\tthis.stencilEnabled = false;\n\t\tthis.stencilFront = new StencilParameters();\n\t\tthis.stencilBack = new StencilParameters();\n\t\tthis.dynamicBuffers = void 0;\n\t\tthis.gpuProfiler = void 0;\n\t\tthis.defaultClearOptions = {\n\t\t\tcolor: [0, 0, 0, 1],\n\t\t\tdepth: 1,\n\t\t\tstencil: 0,\n\t\t\tflags: CLEARFLAG_COLOR | CLEARFLAG_DEPTH\n\t\t};\n\t\tthis.clientRect = {\n\t\t\twidth: 0,\n\t\t\theight: 0\n\t\t};\n\t\tthis.canvas = canvas;\n\t\tthis.initOptions = _extends({}, options);\n\t\t(_this$initOptions$dep = (_this$initOptions = this.initOptions).depth) != null ? _this$initOptions$dep : _this$initOptions.depth = true;\n\t\t(_this$initOptions2$st = (_this$initOptions2 = this.initOptions).stencil) != null ? _this$initOptions2$st : _this$initOptions2.stencil = true;\n\t\t(_this$initOptions3$an = (_this$initOptions3 = this.initOptions).antialias) != null ? _this$initOptions3$an : _this$initOptions3.antialias = true;\n\t\t(_this$initOptions4$po = (_this$initOptions4 = this.initOptions).powerPreference) != null ? _this$initOptions4$po : _this$initOptions4.powerPreference = 'high-performance';\n\t\tthis._maxPixelRatio = platform.browser ? Math.min(1, window.devicePixelRatio) : 1;\n\t\tthis.buffers = [];\n\t\tthis._vram = {\n\t\t\ttex: 0,\n\t\t\tvb: 0,\n\t\t\tib: 0,\n\t\t\tub: 0,\n\t\t\tsb: 0\n\t\t};\n\t\tthis._shaderStats = {\n\t\t\tvsCompiled: 0,\n\t\t\tfsCompiled: 0,\n\t\t\tlinked: 0,\n\t\t\tmaterialShaders: 0,\n\t\t\tcompileTime: 0\n\t\t};\n\t\tthis.initializeContextCaches();\n\t\tthis._drawCallsPerFrame = 0;\n\t\tthis._shaderSwitchesPerFrame = 0;\n\t\tthis._primsPerFrame = [];\n\t\tfor (let i = PRIMITIVE_POINTS; i <= PRIMITIVE_TRIFAN; i++) {\n\t\t\tthis._primsPerFrame[i] = 0;\n\t\t}\n\t\tthis._renderTargetCreationTime = 0;\n\t\tthis.scope = new ScopeSpace('Device');\n\t\tthis.textureBias = this.scope.resolve('textureBias');\n\t\tthis.textureBias.setValue(0.0);\n\t}\n\tpostInit() {\n\t\tconst vertexFormat = new VertexFormat(this, [{\n\t\t\tsemantic: SEMANTIC_POSITION,\n\t\t\tcomponents: 2,\n\t\t\ttype: TYPE_FLOAT32\n\t\t}]);\n\t\tconst positions = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);\n\t\tthis.quadVertexBuffer = new VertexBuffer(this, vertexFormat, 4, {\n\t\t\tdata: positions\n\t\t});\n\t}\n\tdestroy() {\n\t\tvar _this$quadVertexBuffe, _this$dynamicBuffers, _this$gpuProfiler;\n\t\tthis.fire('destroy');\n\t\t(_this$quadVertexBuffe = this.quadVertexBuffer) == null || _this$quadVertexBuffe.destroy();\n\t\tthis.quadVertexBuffer = null;\n\t\t(_this$dynamicBuffers = this.dynamicBuffers) == null || _this$dynamicBuffers.destroy();\n\t\tthis.dynamicBuffers = null;\n\t\t(_this$gpuProfiler = this.gpuProfiler) == null || _this$gpuProfiler.destroy();\n\t\tthis.gpuProfiler = null;\n\t}\n\tonDestroyShader(shader) {\n\t\tthis.fire('destroy:shader', shader);\n\t\tconst idx = this.shaders.indexOf(shader);\n\t\tif (idx !== -1) {\n\t\t\tthis.shaders.splice(idx, 1);\n\t\t}\n\t}\n\tpostDestroy() {\n\t\tthis.scope = null;\n\t\tthis.canvas = null;\n\t}\n\tloseContext() {\n\t\tvar _this$gpuProfiler2;\n\t\tthis.contextLost = true;\n\t\tthis.backBufferSize.set(-1, -1);\n\t\tfor (const texture of this.textures) {\n\t\t\ttexture.loseContext();\n\t\t}\n\t\tfor (const buffer of this.buffers) {\n\t\t\tbuffer.loseContext();\n\t\t}\n\t\tfor (const target of this.targets) {\n\t\t\ttarget.loseContext();\n\t\t}\n\t\t(_this$gpuProfiler2 = this.gpuProfiler) == null || _this$gpuProfiler2.loseContext();\n\t}\n\trestoreContext() {\n\t\tvar _this$gpuProfiler3;\n\t\tthis.contextLost = false;\n\t\tthis.initializeRenderState();\n\t\tthis.initializeContextCaches();\n\t\tfor (const buffer of this.buffers) {\n\t\t\tbuffer.unlock();\n\t\t}\n\t\t(_this$gpuProfiler3 = this.gpuProfiler) == null || _this$gpuProfiler3.restoreContext == null || _this$gpuProfiler3.restoreContext();\n\t}\n\ttoJSON(key) {\n\t\treturn undefined;\n\t}\n\tinitializeContextCaches() {\n\t\tthis.indexBuffer = null;\n\t\tthis.vertexBuffers = [];\n\t\tthis.shader = null;\n\t\tthis.shaderValid = undefined;\n\t\tthis.shaderAsyncCompile = false;\n\t\tthis.renderTarget = null;\n\t}\n\tinitializeRenderState() {\n\t\tthis.blendState = new BlendState();\n\t\tthis.depthState = new DepthState();\n\t\tthis.cullMode = CULLFACE_BACK;\n\t\tthis.vx = this.vy = this.vw = this.vh = 0;\n\t\tthis.sx = this.sy = this.sw = this.sh = 0;\n\t\tthis.blendColor = new Color(0, 0, 0, 0);\n\t}\n\tsetStencilState(stencilFront, stencilBack) {}\n\tsetBlendState(blendState) {}\n\tsetBlendColor(r, g, b, a) {}\n\tsetDepthState(depthState) {}\n\tsetCullMode(cullMode) {}\n\tsetRenderTarget(renderTarget) {\n\t\tthis.renderTarget = renderTarget;\n\t}\n\tsetIndexBuffer(indexBuffer) {\n\t\tthis.indexBuffer = indexBuffer;\n\t}\n\tsetVertexBuffer(vertexBuffer) {\n\t\tif (vertexBuffer) {\n\t\t\tthis.vertexBuffers.push(vertexBuffer);\n\t\t}\n\t}\n\tclearVertexBuffer() {\n\t\tthis.vertexBuffers.length = 0;\n\t}\n\tgetRenderTarget() {\n\t\treturn this.renderTarget;\n\t}\n\tinitRenderTarget(target) {\n\t\tif (target.initialized) return;\n\t\ttarget.init();\n\t\tthis.targets.add(target);\n\t}\n\t_isBrowserInterface(texture) {\n\t\treturn this._isImageBrowserInterface(texture) || this._isImageCanvasInterface(texture) || this._isImageVideoInterface(texture);\n\t}\n\t_isImageBrowserInterface(texture) {\n\t\treturn typeof ImageBitmap !== 'undefined' && texture instanceof ImageBitmap || typeof HTMLImageElement !== 'undefined' && texture instanceof HTMLImageElement;\n\t}\n\t_isImageCanvasInterface(texture) {\n\t\treturn typeof HTMLCanvasElement !== 'undefined' && texture instanceof HTMLCanvasElement;\n\t}\n\t_isImageVideoInterface(texture) {\n\t\treturn typeof HTMLVideoElement !== 'undefined' && texture instanceof HTMLVideoElement;\n\t}\n\tresizeCanvas(width, height) {\n\t\tconst pixelRatio = Math.min(this._maxPixelRatio, platform.browser ? window.devicePixelRatio : 1);\n\t\tconst w = Math.floor(width * pixelRatio);\n\t\tconst h = Math.floor(height * pixelRatio);\n\t\tif (w !== this.canvas.width || h !== this.canvas.height) {\n\t\t\tthis.setResolution(w, h);\n\t\t}\n\t}\n\tsetResolution(width, height) {\n\t\tthis.canvas.width = width;\n\t\tthis.canvas.height = height;\n\t\tthis.fire(GraphicsDevice.EVENT_RESIZE, width, height);\n\t}\n\tupdateClientRect() {\n\t\tif (platform.worker) {\n\t\t\tthis.clientRect.width = this.canvas.width;\n\t\t\tthis.clientRect.height = this.canvas.height;\n\t\t} else {\n\t\t\tconst rect = this.canvas.getBoundingClientRect();\n\t\t\tthis.clientRect.width = rect.width;\n\t\t\tthis.clientRect.height = rect.height;\n\t\t}\n\t}\n\tget width() {\n\t\treturn this.canvas.width;\n\t}\n\tget height() {\n\t\treturn this.canvas.height;\n\t}\n\tset fullscreen(fullscreen) {}\n\tget fullscreen() {\n\t\treturn false;\n\t}\n\tset maxPixelRatio(ratio) {\n\t\tthis._maxPixelRatio = ratio;\n\t}\n\tget maxPixelRatio() {\n\t\treturn this._maxPixelRatio;\n\t}\n\tget deviceType() {\n\t\treturn this._deviceType;\n\t}\n\tgetBoneLimit() {\n\t\treturn this.boneLimit;\n\t}\n\tsetBoneLimit(maxBones) {\n\t\tthis.boneLimit = maxBones;\n\t}\n\tstartRenderPass(renderPass) {}\n\tendRenderPass(renderPass) {}\n\tstartComputePass() {}\n\tendComputePass() {}\n\tframeStart() {\n\t\tthis.renderPassIndex = 0;\n\t\tthis.renderVersion++;\n\t}\n\tframeEnd() {}\n\tcomputeDispatch(computes) {}\n\tgetRenderableHdrFormat(formats = [PIXELFORMAT_111110F, PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F], filterable = true) {\n\t\tfor (let i = 0; i < formats.length; i++) {\n\t\t\tconst format = formats[i];\n\t\t\tswitch (format) {\n\t\t\t\tcase PIXELFORMAT_111110F:\n\t\t\t\t\t{\n\t\t\t\t\t\tif (this.textureRG11B10Renderable) {\n\t\t\t\t\t\t\treturn format;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tcase PIXELFORMAT_RGBA16F:\n\t\t\t\t\tif (this.textureHalfFloatRenderable && (!filterable || this.textureHalfFloatFilterable)) {\n\t\t\t\t\t\treturn format;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase PIXELFORMAT_RGBA32F:\n\t\t\t\t\tif (this.textureFloatRenderable && (!filterable || this.textureFloatFilterable)) {\n\t\t\t\t\t\treturn format;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n}\nGraphicsDevice.EVENT_RESIZE = 'resizecanvas';\n\nexport { GraphicsDevice };\n","import { typedArrayIndexFormatsByteSize, BUFFER_STATIC, INDEXFORMAT_UINT32, INDEXFORMAT_UINT16 } from './constants.js';\n\nlet id = 0;\nclass IndexBuffer {\n\tconstructor(graphicsDevice, format, numIndices, usage = BUFFER_STATIC, initialData, options) {\n\t\tthis.device = graphicsDevice;\n\t\tthis.format = format;\n\t\tthis.numIndices = numIndices;\n\t\tthis.usage = usage;\n\t\tthis.id = id++;\n\t\tthis.impl = graphicsDevice.createIndexBufferImpl(this, options);\n\t\tconst bytesPerIndex = typedArrayIndexFormatsByteSize[format];\n\t\tthis.bytesPerIndex = bytesPerIndex;\n\t\tthis.numBytes = this.numIndices * bytesPerIndex;\n\t\tif (initialData) {\n\t\t\tthis.setData(initialData);\n\t\t} else {\n\t\t\tthis.storage = new ArrayBuffer(this.numBytes);\n\t\t}\n\t\tthis.adjustVramSizeTracking(graphicsDevice._vram, this.numBytes);\n\t\tthis.device.buffers.push(this);\n\t}\n\tdestroy() {\n\t\tconst device = this.device;\n\t\tconst idx = device.buffers.indexOf(this);\n\t\tif (idx !== -1) {\n\t\t\tdevice.buffers.splice(idx, 1);\n\t\t}\n\t\tif (this.device.indexBuffer === this) {\n\t\t\tthis.device.indexBuffer = null;\n\t\t}\n\t\tif (this.impl.initialized) {\n\t\t\tthis.impl.destroy(device);\n\t\t\tthis.adjustVramSizeTracking(device._vram, -this.storage.byteLength);\n\t\t}\n\t}\n\tadjustVramSizeTracking(vram, size) {\n\t\tvram.ib += size;\n\t}\n\tloseContext() {\n\t\tthis.impl.loseContext();\n\t}\n\tgetFormat() {\n\t\treturn this.format;\n\t}\n\tgetNumIndices() {\n\t\treturn this.numIndices;\n\t}\n\tlock() {\n\t\treturn this.storage;\n\t}\n\tunlock() {\n\t\tthis.impl.unlock(this);\n\t}\n\tsetData(data) {\n\t\tif (data.byteLength !== this.numBytes) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.storage = data;\n\t\tthis.unlock();\n\t\treturn true;\n\t}\n\t_lockTypedArray() {\n\t\tconst lock = this.lock();\n\t\tconst indices = this.format === INDEXFORMAT_UINT32 ? new Uint32Array(lock) : this.format === INDEXFORMAT_UINT16 ? new Uint16Array(lock) : new Uint8Array(lock);\n\t\treturn indices;\n\t}\n\twriteData(data, count) {\n\t\tconst indices = this._lockTypedArray();\n\t\tif (data.length > count) {\n\t\t\tif (ArrayBuffer.isView(data)) {\n\t\t\t\tdata = data.subarray(0, count);\n\t\t\t\tindices.set(data);\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\t\tindices[i] = data[i];\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tindices.set(data);\n\t\t}\n\t\tthis.unlock();\n\t}\n\treadData(data) {\n\t\tconst indices = this._lockTypedArray();\n\t\tconst count = this.numIndices;\n\t\tif (ArrayBuffer.isView(data)) {\n\t\t\tdata.set(indices);\n\t\t} else {\n\t\t\tdata.length = 0;\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tdata[i] = indices[i];\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n\nexport { IndexBuffer };\n","import { Color } from '../../core/math/color.js';\n\nclass ColorAttachmentOps {\n\tconstructor() {\n\t\tthis.clearValue = new Color(0, 0, 0, 1);\n\t\tthis.clear = false;\n\t\tthis.store = false;\n\t\tthis.resolve = true;\n\t\tthis.mipmaps = false;\n\t}\n}\nclass DepthStencilAttachmentOps {\n\tconstructor() {\n\t\tthis.clearDepthValue = 1;\n\t\tthis.clearStencilValue = 0;\n\t\tthis.clearDepth = false;\n\t\tthis.clearStencil = false;\n\t\tthis.storeDepth = false;\n\t\tthis.storeStencil = false;\n\t}\n}\nclass RenderPass {\n\tget colorOps() {\n\t\treturn this.colorArrayOps[0];\n\t}\n\tconstructor(graphicsDevice) {\n\t\tthis._name = void 0;\n\t\tthis.device = void 0;\n\t\tthis._enabled = true;\n\t\tthis.executeEnabled = true;\n\t\tthis.renderTarget = void 0;\n\t\tthis._options = void 0;\n\t\tthis.samples = 0;\n\t\tthis.colorArrayOps = [];\n\t\tthis.depthStencilOps = void 0;\n\t\tthis.requiresCubemaps = true;\n\t\tthis.fullSizeClearRect = true;\n\t\tthis.beforePasses = [];\n\t\tthis.afterPasses = [];\n\t\tthis.device = graphicsDevice;\n\t}\n\tset name(value) {\n\t\tthis._name = value;\n\t}\n\tget name() {\n\t\tif (!this._name) {\n\t\t\tthis._name = this.constructor.name;\n\t\t}\n\t\treturn this._name;\n\t}\n\tset options(value) {\n\t\tthis._options = value;\n\t\tif (value) {\n\t\t\tvar _this$_options$scaleX, _this$_options$scaleY;\n\t\t\tthis._options.scaleX = (_this$_options$scaleX = this._options.scaleX) != null ? _this$_options$scaleX : 1;\n\t\t\tthis._options.scaleY = (_this$_options$scaleY = this._options.scaleY) != null ? _this$_options$scaleY : 1;\n\t\t}\n\t}\n\tget options() {\n\t\treturn this._options;\n\t}\n\tinit(renderTarget = null, options = null) {\n\t\tvar _renderTarget$_colorB;\n\t\tthis.options = options;\n\t\tthis.renderTarget = renderTarget;\n\t\tthis.samples = Math.max(this.renderTarget ? this.renderTarget.samples : this.device.samples, 1);\n\t\tthis.depthStencilOps = new DepthStencilAttachmentOps();\n\t\tconst numColorOps = renderTarget ? (_renderTarget$_colorB = renderTarget._colorBuffers) == null ? void 0 : _renderTarget$_colorB.length : 1;\n\t\tthis.colorArrayOps.length = 0;\n\t\tfor (let i = 0; i < numColorOps; i++) {\n\t\t\tvar _this$renderTarget;\n\t\t\tconst colorOps = new ColorAttachmentOps();\n\t\t\tthis.colorArrayOps[i] = colorOps;\n\t\t\tif (this.samples === 1) {\n\t\t\t\tcolorOps.store = true;\n\t\t\t\tcolorOps.resolve = false;\n\t\t\t}\n\t\t\tif ((_this$renderTarget = this.renderTarget) != null && (_this$renderTarget = _this$renderTarget._colorBuffers) != null && _this$renderTarget[i].mipmaps) {\n\t\t\t\tcolorOps.mipmaps = true;\n\t\t\t}\n\t\t}\n\t\tthis.postInit();\n\t}\n\tdestroy() {}\n\tpostInit() {}\n\tframeUpdate() {\n\t\tif (this._options && this.renderTarget) {\n\t\t\tvar _this$_options$resize;\n\t\t\tconst resizeSource = (_this$_options$resize = this._options.resizeSource) != null ? _this$_options$resize : this.device.backBuffer;\n\t\t\tconst width = Math.floor(resizeSource.width * this._options.scaleX);\n\t\t\tconst height = Math.floor(resizeSource.height * this._options.scaleY);\n\t\t\tthis.renderTarget.resize(width, height);\n\t\t}\n\t}\n\tbefore() {}\n\texecute() {}\n\tafter() {}\n\tonEnable() {}\n\tonDisable() {}\n\tset enabled(value) {\n\t\tif (this._enabled !== value) {\n\t\t\tthis._enabled = value;\n\t\t\tif (value) {\n\t\t\t\tthis.onEnable();\n\t\t\t} else {\n\t\t\t\tthis.onDisable();\n\t\t\t}\n\t\t}\n\t}\n\tget enabled() {\n\t\treturn this._enabled;\n\t}\n\tsetClearColor(color) {\n\t\tconst count = this.colorArrayOps.length;\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst colorOps = this.colorArrayOps[i];\n\t\t\tif (color) {\n\t\t\t\tcolorOps.clearValue.copy(color);\n\t\t\t}\n\t\t\tcolorOps.clear = !!color;\n\t\t}\n\t}\n\tsetClearDepth(depthValue) {\n\t\tif (depthValue) {\n\t\t\tthis.depthStencilOps.clearDepthValue = depthValue;\n\t\t}\n\t\tthis.depthStencilOps.clearDepth = depthValue !== undefined;\n\t}\n\tsetClearStencil(stencilValue) {\n\t\tif (stencilValue) {\n\t\t\tthis.depthStencilOps.clearStencilValue = stencilValue;\n\t\t}\n\t\tthis.depthStencilOps.clearStencil = stencilValue !== undefined;\n\t}\n\trender() {\n\t\tif (this.enabled) {\n\t\t\tconst device = this.device;\n\t\t\tconst realPass = this.renderTarget !== undefined;\n\t\t\tthis.before();\n\t\t\tif (this.executeEnabled) {\n\t\t\t\tif (realPass) {\n\t\t\t\t\tdevice.startRenderPass(this);\n\t\t\t\t}\n\t\t\t\tthis.execute();\n\t\t\t\tif (realPass) {\n\t\t\t\t\tdevice.endRenderPass(this);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.after();\n\t\t\tdevice.renderPassIndex++;\n\t\t}\n\t}\n}\n\nexport { ColorAttachmentOps, DepthStencilAttachmentOps, RenderPass };\n","import { PIXELFORMAT_DEPTH, PIXELFORMAT_DEPTHSTENCIL } from './constants.js';\nimport { GraphicsDevice } from './graphics-device.js';\n\nlet id = 0;\nclass RenderTarget {\n\tconstructor(options = {}) {\n\t\tvar _options$face, _this$_colorBuffer, _this$_depthBuffer, _options$samples, _options$autoResolve, _options$flipY;\n\t\tthis.name = void 0;\n\t\tthis._device = void 0;\n\t\tthis._colorBuffer = void 0;\n\t\tthis._colorBuffers = void 0;\n\t\tthis._depthBuffer = void 0;\n\t\tthis._depth = void 0;\n\t\tthis._stencil = void 0;\n\t\tthis._samples = void 0;\n\t\tthis.autoResolve = void 0;\n\t\tthis._face = void 0;\n\t\tthis.flipY = void 0;\n\t\tthis.id = id++;\n\t\tconst _arg2 = arguments[1];\n\t\tconst _arg3 = arguments[2];\n\t\tif (options instanceof GraphicsDevice) {\n\t\t\tthis._colorBuffer = _arg2;\n\t\t\toptions = _arg3;\n\t\t} else {\n\t\t\tthis._colorBuffer = options.colorBuffer;\n\t\t}\n\t\tif (this._colorBuffer) {\n\t\t\tthis._colorBuffers = [this._colorBuffer];\n\t\t}\n\t\tthis._depthBuffer = options.depthBuffer;\n\t\tthis._face = (_options$face = options.face) != null ? _options$face : 0;\n\t\tif (this._depthBuffer) {\n\t\t\tconst format = this._depthBuffer._format;\n\t\t\tif (format === PIXELFORMAT_DEPTH) {\n\t\t\t\tthis._depth = true;\n\t\t\t\tthis._stencil = false;\n\t\t\t} else if (format === PIXELFORMAT_DEPTHSTENCIL) {\n\t\t\t\tthis._depth = true;\n\t\t\t\tthis._stencil = true;\n\t\t\t} else {\n\t\t\t\tthis._depth = false;\n\t\t\t\tthis._stencil = false;\n\t\t\t}\n\t\t} else {\n\t\t\tvar _options$depth, _options$stencil;\n\t\t\tthis._depth = (_options$depth = options.depth) != null ? _options$depth : true;\n\t\t\tthis._stencil = (_options$stencil = options.stencil) != null ? _options$stencil : false;\n\t\t}\n\t\tif (options.colorBuffers) {\n\t\t\tif (!this._colorBuffers) {\n\t\t\t\tthis._colorBuffers = [...options.colorBuffers];\n\t\t\t\tthis._colorBuffer = options.colorBuffers[0];\n\t\t\t}\n\t\t}\n\t\tconst device = ((_this$_colorBuffer = this._colorBuffer) == null ? void 0 : _this$_colorBuffer.device) || ((_this$_depthBuffer = this._depthBuffer) == null ? void 0 : _this$_depthBuffer.device) || options.graphicsDevice;\n\t\tthis._device = device;\n\t\tconst {\n\t\t\tmaxSamples\n\t\t} = this._device;\n\t\tthis._samples = Math.min((_options$samples = options.samples) != null ? _options$samples : 1, maxSamples);\n\t\tif (device.isWebGPU) {\n\t\t\tthis._samples = this._samples > 1 ? maxSamples : 1;\n\t\t}\n\t\tthis.autoResolve = (_options$autoResolve = options.autoResolve) != null ? _options$autoResolve : true;\n\t\tthis.name = options.name;\n\t\tif (!this.name) {\n\t\t\tvar _this$_colorBuffer2;\n\t\t\tthis.name = (_this$_colorBuffer2 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer2.name;\n\t\t}\n\t\tif (!this.name) {\n\t\t\tvar _this$_depthBuffer2;\n\t\t\tthis.name = (_this$_depthBuffer2 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer2.name;\n\t\t}\n\t\tif (!this.name) {\n\t\t\tthis.name = 'Untitled';\n\t\t}\n\t\tthis.flipY = (_options$flipY = options.flipY) != null ? _options$flipY : false;\n\t\tthis.validateMrt();\n\t\tthis.impl = device.createRenderTargetImpl(this);\n\t}\n\tdestroy() {\n\t\tconst device = this._device;\n\t\tif (device) {\n\t\t\tdevice.targets.delete(this);\n\t\t\tif (device.renderTarget === this) {\n\t\t\t\tdevice.setRenderTarget(null);\n\t\t\t}\n\t\t\tthis.destroyFrameBuffers();\n\t\t}\n\t}\n\tdestroyFrameBuffers() {\n\t\tconst device = this._device;\n\t\tif (device) {\n\t\t\tthis.impl.destroy(device);\n\t\t}\n\t}\n\tdestroyTextureBuffers() {\n\t\tvar _this$_depthBuffer3, _this$_colorBuffers;\n\t\t(_this$_depthBuffer3 = this._depthBuffer) == null || _this$_depthBuffer3.destroy();\n\t\tthis._depthBuffer = null;\n\t\t(_this$_colorBuffers = this._colorBuffers) == null || _this$_colorBuffers.forEach(colorBuffer => {\n\t\t\tcolorBuffer.destroy();\n\t\t});\n\t\tthis._colorBuffers = null;\n\t\tthis._colorBuffer = null;\n\t}\n\tresize(width, height) {\n\t\tif (this.width !== width || this.height !== height) {\n\t\t\tvar _this$_depthBuffer4, _this$_colorBuffers2;\n\t\t\tconst device = this._device;\n\t\t\tthis.destroyFrameBuffers();\n\t\t\tif (device.renderTarget === this) {\n\t\t\t\tdevice.setRenderTarget(null);\n\t\t\t}\n\t\t\t(_this$_depthBuffer4 = this._depthBuffer) == null || _this$_depthBuffer4.resize(width, height);\n\t\t\t(_this$_colorBuffers2 = this._colorBuffers) == null || _this$_colorBuffers2.forEach(colorBuffer => {\n\t\t\t\tcolorBuffer.resize(width, height);\n\t\t\t});\n\t\t\tthis.validateMrt();\n\t\t\tthis.impl = device.createRenderTargetImpl(this);\n\t\t}\n\t}\n\tvalidateMrt() {}\n\tinit() {\n\t\tthis.impl.init(this._device, this);\n\t}\n\tget initialized() {\n\t\treturn this.impl.initialized;\n\t}\n\tget device() {\n\t\treturn this._device;\n\t}\n\tloseContext() {\n\t\tthis.impl.loseContext();\n\t}\n\tresolve(color = true, depth = !!this._depthBuffer) {\n\t\tif (this._device && this._samples > 1) {\n\t\t\tthis.impl.resolve(this._device, this, color, depth);\n\t\t}\n\t}\n\tcopy(source, color, depth) {\n\t\tif (!this._device) {\n\t\t\tif (source._device) {\n\t\t\t\tthis._device = source._device;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tconst success = this._device.copyRenderTarget(source, this, color, depth);\n\t\treturn success;\n\t}\n\tget samples() {\n\t\treturn this._samples;\n\t}\n\tget depth() {\n\t\treturn this._depth;\n\t}\n\tget stencil() {\n\t\treturn this._stencil;\n\t}\n\tget colorBuffer() {\n\t\treturn this._colorBuffer;\n\t}\n\tgetColorBuffer(index) {\n\t\tvar _this$_colorBuffers3;\n\t\treturn (_this$_colorBuffers3 = this._colorBuffers) == null ? void 0 : _this$_colorBuffers3[index];\n\t}\n\tget depthBuffer() {\n\t\treturn this._depthBuffer;\n\t}\n\tget face() {\n\t\treturn this._face;\n\t}\n\tget width() {\n\t\tvar _this$_colorBuffer3, _this$_depthBuffer5;\n\t\treturn ((_this$_colorBuffer3 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer3.width) || ((_this$_depthBuffer5 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer5.width) || this._device.width;\n\t}\n\tget height() {\n\t\tvar _this$_colorBuffer4, _this$_depthBuffer6;\n\t\treturn ((_this$_colorBuffer4 = this._colorBuffer) == null ? void 0 : _this$_colorBuffer4.height) || ((_this$_depthBuffer6 = this._depthBuffer) == null ? void 0 : _this$_depthBuffer6.height) || this._device.height;\n\t}\n}\n\nexport { RenderTarget };\n","import { VersionedObject } from './versioned-object.js';\n\nclass ScopeId {\n\tconstructor(name) {\n\t\tthis.name = name;\n\t\tthis.value = null;\n\t\tthis.versionObject = new VersionedObject();\n\t}\n\ttoJSON(key) {\n\t\treturn undefined;\n\t}\n\tsetValue(value) {\n\t\tthis.value = value;\n\t\tthis.versionObject.increment();\n\t}\n\tgetValue() {\n\t\treturn this.value;\n\t}\n}\n\nexport { ScopeId };\n","import { ScopeId } from './scope-id.js';\n\nclass ScopeSpace {\n\tconstructor(name) {\n\t\tthis.name = name;\n\t\tthis.variables = new Map();\n\t}\n\tresolve(name) {\n\t\tif (!this.variables.has(name)) {\n\t\t\tthis.variables.set(name, new ScopeId(name));\n\t\t}\n\t\treturn this.variables.get(name);\n\t}\n\tremoveValue(value) {\n\t\tfor (const uniformName in this.variables) {\n\t\t\tconst uniform = this.variables[uniformName];\n\t\t\tif (uniform.value === value) {\n\t\t\t\tuniform.value = null;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { ScopeSpace };\n","var gles2PS = `\n#define pcFragColor0 gl_FragData[0]\n#if COLOR_ATTACHMENT_1\n#define pcFragColor1 gl_FragData[1]\n#endif\n#if COLOR_ATTACHMENT_2\n#define pcFragColor2 gl_FragData[2]\n#endif\n#if COLOR_ATTACHMENT_3\n#define pcFragColor3 gl_FragData[3]\n#endif\n#if COLOR_ATTACHMENT_4\n#define pcFragColor4 gl_FragData[4]\n#endif\n#if COLOR_ATTACHMENT_5\n#define pcFragColor5 gl_FragData[5]\n#endif\n#if COLOR_ATTACHMENT_6\n#define pcFragColor6 gl_FragData[6]\n#endif\n#if COLOR_ATTACHMENT_7\n#define pcFragColor7 gl_FragData[7]\n#endif\n#define texture2DBias texture2D\n#define itexture2D texture2D\n#define utexture2D texture2D\n#define SHADOWMAP_PASS(name) name\n#define SHADOWMAP_ACCEPT(name) sampler2D name\n#define TEXTURE_PASS(name) name\n#define TEXTURE_ACCEPT(name) sampler2D name\n#define TEXTURE_ACCEPT_HIGHP(name) highp sampler2D name\n#ifndef SUPPORTS_TEXLOD\n\t#define texture2DLodEXT texture2D\n\t#define texture2DProjLodEXT textureProj\n\t#define textureCubeLodEXT textureCube\n\t#define textureShadow texture2D\n#else\n\t#define textureShadow(res, uv) texture2DGradEXT(res, uv, vec2(1, 1), vec2(1, 1))\n#endif\n#ifdef SUPPORTS_MRT\n\t#define gl_FragColor pcFragColor0\n#endif\n`;\n\nexport { gles2PS as default };\n","var gles3PS = `\n#ifndef outType_0\n#define outType_0 vec4\n#endif\nlayout(location = 0) out highp outType_0 pc_fragColor;\n#ifndef REMOVE_COLOR_ATTACHMENT_1\n#if COLOR_ATTACHMENT_1\nlayout(location = 1) out highp outType_1 pc_fragColor1;\n#endif\n#endif\n#ifndef REMOVE_COLOR_ATTACHMENT_2\n#if COLOR_ATTACHMENT_2\nlayout(location = 2) out highp outType_2 pc_fragColor2;\n#endif\n#endif\n#ifndef REMOVE_COLOR_ATTACHMENT_3\n#if COLOR_ATTACHMENT_3\nlayout(location = 3) out highp outType_3 pc_fragColor3;\n#endif\n#endif\n#ifndef REMOVE_COLOR_ATTACHMENT_4\n#if COLOR_ATTACHMENT_4\nlayout(location = 4) out highp outType_4 pc_fragColor4;\n#endif\n#endif\n#ifndef REMOVE_COLOR_ATTACHMENT_5\n#if COLOR_ATTACHMENT_5\nlayout(location = 5) out highp outType_5 pc_fragColor5;\n#endif\n#endif\n#ifndef REMOVE_COLOR_ATTACHMENT_6\n#if COLOR_ATTACHMENT_6\nlayout(location = 6) out highp outType_6 pc_fragColor6;\n#endif\n#endif\n#ifndef REMOVE_COLOR_ATTACHMENT_7\n#if COLOR_ATTACHMENT_7\nlayout(location = 7) out highp outType_7 pc_fragColor7;\n#endif\n#endif\n#define gl_FragColor pc_fragColor\n#define pcFragColor0 pc_fragColor\n#define pcFragColor1 pc_fragColor1\n#define pcFragColor2 pc_fragColor2\n#define pcFragColor3 pc_fragColor3\n#define pcFragColor4 pc_fragColor4\n#define pcFragColor5 pc_fragColor5\n#define pcFragColor6 pc_fragColor6\n#define pcFragColor7 pc_fragColor7\n#define varying in\n#define texture2D texture\n#define texture2DBias texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad\n#define utexture2D texture\n#define itexture2D texture\n#define textureShadow(res, uv) textureGrad(res, uv, vec2(1, 1), vec2(1, 1))\n#define SHADOWMAP_PASS(name) name\n#define SHADOWMAP_ACCEPT(name) sampler2DShadow name\n#define TEXTURE_PASS(name) name\n#define TEXTURE_ACCEPT(name) sampler2D name\n#define TEXTURE_ACCEPT_HIGHP(name) highp sampler2D name\n#define GL2\n#define SUPPORTS_TEXLOD\n#define SUPPORTS_MRT\n`;\n\nexport { gles3PS as default };\n","var sharedFS = `\nvec2 getGrabScreenPos(vec4 clipPos) {\n\tvec2 uv = (clipPos.xy / clipPos.w) * 0.5 + 0.5;\n\t#ifdef WEBGPU\n\t\tuv.y = 1.0 - uv.y;\n\t#endif\n\treturn uv;\n}\nvec2 getImageEffectUV(vec2 uv) {\n\t#ifdef WEBGPU\n\t\tuv.y = 1.0 - uv.y;\n\t#endif\n\treturn uv;\n}\n`;\n\nexport { sharedFS as default };\n","var webgpuPS = `\n#extension GL_EXT_samplerless_texture_functions : require\n#ifndef outType_0\n#define outType_0 vec4\n#endif\n#ifndef outType_1\n#define outType_1 vec4\n#endif\n#ifndef outType_2\n#define outType_2 vec4\n#endif\n#ifndef outType_3\n#define outType_3 vec4\n#endif\n#ifndef outType_4\n#define outType_4 vec4\n#endif\n#ifndef outType_5\n#define outType_5 vec4\n#endif\n#ifndef outType_6\n#define outType_6 vec4\n#endif\n#ifndef outType_7\n#define outType_7 vec4\n#endif\nlayout(location = 0) out highp outType_0 pc_fragColor;\nlayout(location = 1) out highp outType_1 pc_fragColor1;\nlayout(location = 2) out highp outType_2 pc_fragColor2;\nlayout(location = 3) out highp outType_3 pc_fragColor3;\nlayout(location = 4) out highp outType_4 pc_fragColor4;\nlayout(location = 5) out highp outType_5 pc_fragColor5;\nlayout(location = 6) out highp outType_6 pc_fragColor6;\nlayout(location = 7) out highp outType_7 pc_fragColor7;\n#define gl_FragColor pc_fragColor\n#define pcFragColor0 pc_fragColor\n#define pcFragColor1 pc_fragColor1\n#define pcFragColor2 pc_fragColor2\n#define pcFragColor3 pc_fragColor3\n#define pcFragColor4 pc_fragColor4\n#define pcFragColor5 pc_fragColor5\n#define pcFragColor6 pc_fragColor6\n#define pcFragColor7 pc_fragColor7\n#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)\n#define texture2DBias(res, uv, bias) texture(sampler2D(res, res ## _sampler), uv, bias)\n#define texture2DLodEXT(res, uv, lod) textureLod(sampler2D(res, res ## _sampler), uv, lod)\n#define textureCube(res, uv) texture(samplerCube(res, res ## _sampler), uv)\n#define textureCubeLodEXT(res, uv, lod) textureLod(samplerCube(res, res ## _sampler), uv, lod)\n#define textureShadow(res, uv) textureLod(sampler2DShadow(res, res ## _sampler), uv, 0.0)\n#define itexture2D(res, uv) texture(isampler2D(res, res ## _sampler), uv)\n#define utexture2D(res, uv) texture(usampler2D(res, res ## _sampler), uv)\n#define SHADOWMAP_PASS(name) name, name ## _sampler\n#define SHADOWMAP_ACCEPT(name) texture2D name, sampler name ## _sampler\n#define TEXTURE_PASS(name) name, name ## _sampler\n#define TEXTURE_ACCEPT(name) texture2D name, sampler name ## _sampler\n#define TEXTURE_ACCEPT_HIGHP TEXTURE_ACCEPT\n#define GL2\n#define WEBGPU\n#define SUPPORTS_TEXLOD\n#define SUPPORTS_MRT\n`;\n\nexport { webgpuPS as default };\n","var gles2VS = `\n#define TEXTURE_PASS(name) name\n#define TEXTURE_ACCEPT(name) sampler2D name\n#define TEXTURE_ACCEPT_HIGHP(name) highp sampler2D name\n`;\n\nexport { gles2VS as default };\n","var gles3VS = `\n#define attribute in\n#define varying out\n#define texture2D texture\n#define utexture2D texture\n#define itexture2D texture\n#define GL2\n#define VERTEXSHADER\n#define TEXTURE_PASS(name) name\n#define TEXTURE_ACCEPT(name) sampler2D name\n#define TEXTURE_ACCEPT_HIGHP(name) highp sampler2D name\n`;\n\nexport { gles3VS as default };\n","var webgpuVS = `\n#extension GL_EXT_samplerless_texture_functions : require\n#define texture2D(res, uv) texture(sampler2D(res, res ## _sampler), uv)\n#define itexture2D(res, uv) texture(isampler2D(res, res ## _sampler), uv)\n#define utexture2D(res, uv) texture(usampler2D(res, res ## _sampler), uv)\n#define TEXTURE_PASS(name) name, name ## _sampler\n#define TEXTURE_ACCEPT(name) texture2D name, sampler name ## _sampler\n#define TEXTURE_ACCEPT_HIGHP TEXTURE_ACCEPT\n#define GL2\n#define WEBGPU\n#define VERTEXSHADER\n#define gl_VertexID gl_VertexIndex\n`;\n\nexport { webgpuVS as default };\n","import { BINDGROUP_VIEW } from './constants.js';\n\nclass ShaderProcessorOptions {\n\tconstructor(viewUniformFormat, viewBindGroupFormat, vertexFormat) {\n\t\tthis.uniformFormats = [];\n\t\tthis.bindGroupFormats = [];\n\t\tthis.vertexFormat = void 0;\n\t\tthis.uniformFormats[BINDGROUP_VIEW] = viewUniformFormat;\n\t\tthis.bindGroupFormats[BINDGROUP_VIEW] = viewBindGroupFormat;\n\t\tthis.vertexFormat = vertexFormat;\n\t}\n\thasUniform(name) {\n\t\tfor (let i = 0; i < this.uniformFormats.length; i++) {\n\t\t\tconst uniformFormat = this.uniformFormats[i];\n\t\t\tif (uniformFormat != null && uniformFormat.get(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\thasTexture(name) {\n\t\tfor (let i = 0; i < this.bindGroupFormats.length; i++) {\n\t\t\tconst groupFormat = this.bindGroupFormats[i];\n\t\t\tif (groupFormat != null && groupFormat.getTexture(name)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tgetVertexElement(semantic) {\n\t\tvar _this$vertexFormat;\n\t\treturn (_this$vertexFormat = this.vertexFormat) == null ? void 0 : _this$vertexFormat.elements.find(element => element.name === semantic);\n\t}\n\tgenerateKey(device) {\n\t\tlet key = JSON.stringify(this.uniformFormats) + JSON.stringify(this.bindGroupFormats);\n\t\tif (device.isWebGPU) {\n\t\t\tvar _this$vertexFormat2;\n\t\t\tkey += (_this$vertexFormat2 = this.vertexFormat) == null ? void 0 : _this$vertexFormat2.shaderProcessingHashString;\n\t\t}\n\t\treturn key;\n\t}\n}\n\nexport { ShaderProcessorOptions };\n","import { SEMANTIC_POSITION, SEMANTIC_NORMAL, SEMANTIC_TANGENT, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1, SEMANTIC_TEXCOORD2, SEMANTIC_TEXCOORD3, SEMANTIC_TEXCOORD4, SEMANTIC_TEXCOORD5, SEMANTIC_TEXCOORD6, SEMANTIC_TEXCOORD7, SEMANTIC_COLOR, SEMANTIC_BLENDINDICES, SEMANTIC_BLENDWEIGHT } from './constants.js';\nimport gles2PS from './shader-chunks/frag/gles2.js';\nimport gles2VS from './shader-chunks/vert/gles2.js';\nimport gles3PS from './shader-chunks/frag/gles3.js';\nimport gles3VS from './shader-chunks/vert/gles3.js';\nimport webgpuPS from './shader-chunks/frag/webgpu.js';\nimport webgpuVS from './shader-chunks/vert/webgpu.js';\nimport sharedFS from './shader-chunks/frag/shared.js';\n\nconst _attrib2Semantic = {\n\tvertex_position: SEMANTIC_POSITION,\n\tvertex_normal: SEMANTIC_NORMAL,\n\tvertex_tangent: SEMANTIC_TANGENT,\n\tvertex_texCoord0: SEMANTIC_TEXCOORD0,\n\tvertex_texCoord1: SEMANTIC_TEXCOORD1,\n\tvertex_texCoord2: SEMANTIC_TEXCOORD2,\n\tvertex_texCoord3: SEMANTIC_TEXCOORD3,\n\tvertex_texCoord4: SEMANTIC_TEXCOORD4,\n\tvertex_texCoord5: SEMANTIC_TEXCOORD5,\n\tvertex_texCoord6: SEMANTIC_TEXCOORD6,\n\tvertex_texCoord7: SEMANTIC_TEXCOORD7,\n\tvertex_color: SEMANTIC_COLOR,\n\tvertex_boneIndices: SEMANTIC_BLENDINDICES,\n\tvertex_boneWeights: SEMANTIC_BLENDWEIGHT\n};\nclass ShaderUtils {\n\tstatic createDefinition(device, options) {\n\t\tvar _options$name, _options$attributes;\n\t\tconst getDefines = (gpu, gl2, gl1, isVertex, options) => {\n\t\t\tconst deviceIntro = device.isWebGPU ? gpu : device.isWebGL2 ? gl2 : ShaderUtils.gl1Extensions(device, options) + gl1;\n\t\t\tlet attachmentsDefine = '';\n\t\t\tif (!isVertex) {\n\t\t\t\tvar _options$fragmentOutp;\n\t\t\t\tlet fragmentOutputTypes = (_options$fragmentOutp = options.fragmentOutputTypes) != null ? _options$fragmentOutp : 'vec4';\n\t\t\t\tif (!Array.isArray(fragmentOutputTypes)) {\n\t\t\t\t\tfragmentOutputTypes = [fragmentOutputTypes];\n\t\t\t\t}\n\t\t\t\tfor (let i = 0; i < device.maxColorAttachments; i++) {\n\t\t\t\t\tvar _fragmentOutputTypes$;\n\t\t\t\t\tattachmentsDefine += `#define COLOR_ATTACHMENT_${i}\\n`;\n\t\t\t\t\tconst outType = (_fragmentOutputTypes$ = fragmentOutputTypes[i]) != null ? _fragmentOutputTypes$ : 'vec4';\n\t\t\t\t\tattachmentsDefine += `#define outType_${i} ${outType}\\n`;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn attachmentsDefine + deviceIntro;\n\t\t};\n\t\tconst name = (_options$name = options.name) != null ? _options$name : 'Untitled';\n\t\tconst vertCode = ShaderUtils.versionCode(device) + getDefines(webgpuVS, gles3VS, gles2VS, true, options) + ShaderUtils.getDefinesCode(options.vertexDefines) + sharedFS + ShaderUtils.getShaderNameCode(name) + options.vertexCode;\n\t\tconst fragCode = `${(options.fragmentPreamble || '') + ShaderUtils.versionCode(device) + getDefines(webgpuPS, gles3PS, gles2PS, false, options) + ShaderUtils.getDefinesCode(options.fragmentDefines) + ShaderUtils.precisionCode(device)}\\n${sharedFS}${ShaderUtils.getShaderNameCode(name)}${options.fragmentCode || ShaderUtils.dummyFragmentCode()}`;\n\t\tconst attribs = (_options$attributes = options.attributes) != null ? _options$attributes : ShaderUtils.collectAttributes(options.vertexCode);\n\t\treturn {\n\t\t\tname: name,\n\t\t\tattributes: attribs,\n\t\t\tvshader: vertCode,\n\t\t\tvincludes: options.vertexIncludes,\n\t\t\tfincludes: options.fragmentIncludes,\n\t\t\tfshader: fragCode,\n\t\t\tuseTransformFeedback: options.useTransformFeedback\n\t\t};\n\t}\n\tstatic getDefinesCode(defines) {\n\t\tlet code = '';\n\t\tdefines == null || defines.forEach((value, key) => {\n\t\t\tcode += `#define ${key} ${value}\\n`;\n\t\t});\n\t\treturn code;\n\t}\n\tstatic getShaderNameCode(name) {\n\t\treturn `#define SHADER_NAME ${name}\\n`;\n\t}\n\tstatic gl1Extensions(device, options, isVertex) {\n\t\tlet code;\n\t\tif (isVertex) {\n\t\t\tcode = options.vertexExtensions ? `${options.vertexExtensions}\\n` : '';\n\t\t} else {\n\t\t\tcode = options.fragmentExtensions ? `${options.fragmentExtensions}\\n` : '';\n\t\t\tif (device.extStandardDerivatives) {\n\t\t\t\tcode += '#extension GL_OES_standard_derivatives : enable\\n';\n\t\t\t}\n\t\t\tif (device.extTextureLod) {\n\t\t\t\tcode += '#extension GL_EXT_shader_texture_lod : enable\\n';\n\t\t\t\tcode += '#define SUPPORTS_TEXLOD\\n';\n\t\t\t}\n\t\t\tif (device.extDrawBuffers) {\n\t\t\t\tcode += '#extension GL_EXT_draw_buffers : require\\n';\n\t\t\t\tcode += '#define SUPPORTS_MRT\\n';\n\t\t\t}\n\t\t}\n\t\treturn code;\n\t}\n\tstatic dummyFragmentCode() {\n\t\treturn 'void main(void) {gl_FragColor = vec4(0.0);}';\n\t}\n\tstatic versionCode(device) {\n\t\tif (device.isWebGPU) {\n\t\t\treturn '#version 450\\n';\n\t\t}\n\t\treturn device.isWebGL2 ? '#version 300 es\\n' : '';\n\t}\n\tstatic precisionCode(device, forcePrecision) {\n\t\tlet code = '';\n\t\tif (forcePrecision && forcePrecision !== 'highp' && forcePrecision !== 'mediump' && forcePrecision !== 'lowp') {\n\t\t\tforcePrecision = null;\n\t\t}\n\t\tif (forcePrecision) {\n\t\t\tif (forcePrecision === 'highp' && device.maxPrecision !== 'highp') {\n\t\t\t\tforcePrecision = 'mediump';\n\t\t\t}\n\t\t\tif (forcePrecision === 'mediump' && device.maxPrecision === 'lowp') {\n\t\t\t\tforcePrecision = 'lowp';\n\t\t\t}\n\t\t}\n\t\tconst precision = forcePrecision ? forcePrecision : device.precision;\n\t\tif (!device.isWebGPU) {\n\t\t\tcode = `precision ${precision} float;\\nprecision ${precision} int;`;\n\t\t\tif (device.isWebGL2) {\n\t\t\t\tcode += `precision ${precision} sampler2DShadow;\\n`;\n\t\t\t}\n\t\t} else {\n\t\t\tcode = `precision ${precision} float;\\nprecision ${precision} int;\\n`;\n\t\t}\n\t\treturn code;\n\t}\n\tstatic collectAttributes(vsCode) {\n\t\tconst attribs = {};\n\t\tlet attrs = 0;\n\t\tlet found = vsCode.indexOf('attribute');\n\t\twhile (found >= 0) {\n\t\t\tif (found > 0 && vsCode[found - 1] === '/') break;\n\t\t\tconst endOfLine = vsCode.indexOf(';', found);\n\t\t\tconst startOfAttribName = vsCode.lastIndexOf(' ', endOfLine);\n\t\t\tconst attribName = vsCode.substring(startOfAttribName + 1, endOfLine);\n\t\t\tif (attribs[attribName]) ; else {\n\t\t\t\tconst semantic = _attrib2Semantic[attribName];\n\t\t\t\tif (semantic !== undefined) {\n\t\t\t\t\tattribs[attribName] = semantic;\n\t\t\t\t} else {\n\t\t\t\t\tattribs[attribName] = `ATTR${attrs}`;\n\t\t\t\t\tattrs++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfound = vsCode.indexOf('attribute', found + 1);\n\t\t}\n\t\treturn attribs;\n\t}\n}\n\nexport { ShaderUtils };\n","import { platform } from '../../core/platform.js';\nimport { Preprocessor } from '../../core/preprocessor.js';\n\nlet id = 0;\nclass Shader {\n\tconstructor(graphicsDevice, definition) {\n\t\tthis.meshUniformBufferFormat = void 0;\n\t\tthis.meshBindGroupFormat = void 0;\n\t\tthis.id = id++;\n\t\tthis.device = graphicsDevice;\n\t\tthis.definition = definition;\n\t\tthis.name = definition.name || 'Untitled';\n\t\tthis.init();\n\t\tif (definition.cshader) ; else {\n\t\t\tdefinition.vshader = Preprocessor.run(definition.vshader, definition.vincludes);\n\t\t\tconst stripUnusedColorAttachments = graphicsDevice.isWebGL2 && (platform.name === 'osx' || platform.name === 'ios');\n\t\t\tdefinition.fshader = Preprocessor.run(definition.fshader, definition.fincludes, stripUnusedColorAttachments);\n\t\t}\n\t\tthis.impl = graphicsDevice.createShaderImpl(this);\n\t}\n\tinit() {\n\t\tthis.ready = false;\n\t\tthis.failed = false;\n\t}\n\tget label() {\n\t\treturn `Shader Id ${this.id} ${this.name}`;\n\t}\n\tdestroy() {\n\t\tthis.device.onDestroyShader(this);\n\t\tthis.impl.destroy(this);\n\t}\n\tloseContext() {\n\t\tthis.init();\n\t\tthis.impl.loseContext();\n\t}\n\trestoreContext() {\n\t\tthis.impl.restoreContext(this.device, this);\n\t}\n}\n\nexport { Shader };\n","import { FUNC_ALWAYS, STENCILOP_KEEP } from './constants.js';\nimport { StringIds } from '../../core/string-ids.js';\n\nvar _StencilParameters;\nconst stringIds = new StringIds();\nclass StencilParameters {\n\tset func(value) {\n\t\tthis._func = value;\n\t\tthis._dirty = true;\n\t}\n\tget func() {\n\t\treturn this._func;\n\t}\n\tset ref(value) {\n\t\tthis._ref = value;\n\t\tthis._dirty = true;\n\t}\n\tget ref() {\n\t\treturn this._ref;\n\t}\n\tset fail(value) {\n\t\tthis._fail = value;\n\t\tthis._dirty = true;\n\t}\n\tget fail() {\n\t\treturn this._fail;\n\t}\n\tset zfail(value) {\n\t\tthis._zfail = value;\n\t\tthis._dirty = true;\n\t}\n\tget zfail() {\n\t\treturn this._zfail;\n\t}\n\tset zpass(value) {\n\t\tthis._zpass = value;\n\t\tthis._dirty = true;\n\t}\n\tget zpass() {\n\t\treturn this._zpass;\n\t}\n\tset readMask(value) {\n\t\tthis._readMask = value;\n\t\tthis._dirty = true;\n\t}\n\tget readMask() {\n\t\treturn this._readMask;\n\t}\n\tset writeMask(value) {\n\t\tthis._writeMask = value;\n\t\tthis._dirty = true;\n\t}\n\tget writeMask() {\n\t\treturn this._writeMask;\n\t}\n\tconstructor(options = {}) {\n\t\tvar _options$func, _options$ref, _options$readMask, _options$writeMask, _options$fail, _options$zfail, _options$zpass;\n\t\tthis._func = void 0;\n\t\tthis._ref = void 0;\n\t\tthis._fail = void 0;\n\t\tthis._zfail = void 0;\n\t\tthis._zpass = void 0;\n\t\tthis._readMask = void 0;\n\t\tthis._writeMask = void 0;\n\t\tthis._dirty = true;\n\t\tthis._key = void 0;\n\t\tthis._func = (_options$func = options.func) != null ? _options$func : FUNC_ALWAYS;\n\t\tthis._ref = (_options$ref = options.ref) != null ? _options$ref : 0;\n\t\tthis._readMask = (_options$readMask = options.readMask) != null ? _options$readMask : 0xFF;\n\t\tthis._writeMask = (_options$writeMask = options.writeMask) != null ? _options$writeMask : 0xFF;\n\t\tthis._fail = (_options$fail = options.fail) != null ? _options$fail : STENCILOP_KEEP;\n\t\tthis._zfail = (_options$zfail = options.zfail) != null ? _options$zfail : STENCILOP_KEEP;\n\t\tthis._zpass = (_options$zpass = options.zpass) != null ? _options$zpass : STENCILOP_KEEP;\n\t\tthis._evalKey();\n\t}\n\t_evalKey() {\n\t\tconst {\n\t\t\t_func,\n\t\t\t_ref,\n\t\t\t_fail,\n\t\t\t_zfail,\n\t\t\t_zpass,\n\t\t\t_readMask,\n\t\t\t_writeMask\n\t\t} = this;\n\t\tconst key = `${_func},${_ref},${_fail},${_zfail},${_zpass},${_readMask},${_writeMask}`;\n\t\tthis._key = stringIds.get(key);\n\t\tthis._dirty = false;\n\t}\n\tget key() {\n\t\tif (this._dirty) {\n\t\t\tthis._evalKey();\n\t\t}\n\t\treturn this._key;\n\t}\n\tcopy(rhs) {\n\t\tthis._func = rhs._func;\n\t\tthis._ref = rhs._ref;\n\t\tthis._readMask = rhs._readMask;\n\t\tthis._writeMask = rhs._writeMask;\n\t\tthis._fail = rhs._fail;\n\t\tthis._zfail = rhs._zfail;\n\t\tthis._zpass = rhs._zpass;\n\t\tthis._dirty = rhs._dirty;\n\t\tthis._key = rhs._key;\n\t\treturn this;\n\t}\n\tclone() {\n\t\tconst clone = new this.constructor();\n\t\treturn clone.copy(this);\n\t}\n}\n_StencilParameters = StencilParameters;\nStencilParameters.DEFAULT = Object.freeze(new _StencilParameters());\n\nexport { StencilParameters };\n","import { pixelFormatInfo, PIXELFORMAT_PVRTC_2BPP_RGB_1, PIXELFORMAT_PVRTC_2BPP_RGBA_1 } from './constants.js';\n\nclass TextureUtils {\n\tstatic calcLevelDimension(dimension, mipLevel) {\n\t\treturn Math.max(dimension >> mipLevel, 1);\n\t}\n\tstatic calcMipLevelsCount(width, height, depth = 1) {\n\t\treturn 1 + Math.floor(Math.log2(Math.max(width, height, depth)));\n\t}\n\tstatic calcLevelGpuSize(width, height, depth, format) {\n\t\tvar _pixelFormatInfo$get$, _pixelFormatInfo$get, _formatInfo$blockSize;\n\t\tconst formatInfo = pixelFormatInfo.get(format);\n\t\tconst pixelSize = (_pixelFormatInfo$get$ = (_pixelFormatInfo$get = pixelFormatInfo.get(format)) == null ? void 0 : _pixelFormatInfo$get.size) != null ? _pixelFormatInfo$get$ : 0;\n\t\tif (pixelSize > 0) {\n\t\t\treturn width * height * depth * pixelSize;\n\t\t}\n\t\tconst blockSize = (_formatInfo$blockSize = formatInfo.blockSize) != null ? _formatInfo$blockSize : 0;\n\t\tlet blockWidth = Math.floor((width + 3) / 4);\n\t\tconst blockHeight = Math.floor((height + 3) / 4);\n\t\tconst blockDepth = Math.floor((depth + 3) / 4);\n\t\tif (format === PIXELFORMAT_PVRTC_2BPP_RGB_1 || format === PIXELFORMAT_PVRTC_2BPP_RGBA_1) {\n\t\t\tblockWidth = Math.max(Math.floor(blockWidth / 2), 1);\n\t\t}\n\t\treturn blockWidth * blockHeight * blockDepth * blockSize;\n\t}\n\tstatic calcGpuSize(width, height, depth, format, mipmaps, cubemap) {\n\t\tlet result = 0;\n\t\twhile (1) {\n\t\t\tresult += TextureUtils.calcLevelGpuSize(width, height, depth, format);\n\t\t\tif (!mipmaps || width === 1 && height === 1 && depth === 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\twidth = Math.max(width >> 1, 1);\n\t\t\theight = Math.max(height >> 1, 1);\n\t\t\tdepth = Math.max(depth >> 1, 1);\n\t\t}\n\t\treturn result * (cubemap ? 6 : 1);\n\t}\n}\n\nexport { TextureUtils };\n","import { math } from '../../core/math/math.js';\nimport { RenderTarget } from './render-target.js';\nimport { TextureUtils } from './texture-utils.js';\nimport { TEXTURELOCK_NONE, PIXELFORMAT_RGBA8, isCompressedPixelFormat, isIntegerPixelFormat, FILTER_NEAREST, FILTER_LINEAR_MIPMAP_LINEAR, FILTER_LINEAR, ADDRESS_REPEAT, FUNC_LESS, TEXTURETYPE_DEFAULT, TEXTURETYPE_RGBM, TEXTURETYPE_SWIZZLEGGGR, TEXTUREPROJECTION_NONE, TEXTUREPROJECTION_CUBE, PIXELFORMAT_RGB16F, PIXELFORMAT_RGB32F, PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F, TEXTURETYPE_RGBP, TEXTURETYPE_RGBE, TEXTURELOCK_WRITE, getPixelFormatArrayType } from './constants.js';\n\nlet id = 0;\nclass Texture {\n\tconstructor(graphicsDevice, options = {}) {\n\t\tvar _options$name, _options$width, _options$height, _options$format, _options$storage, _options$cubemap, _options$fixCubemapSe, _options$flipY, _options$premultiplyA, _ref, _options$mipmaps, _options$minFilter, _options$magFilter, _options$anisotropy, _options$addressU, _options$addressV, _options$addressW, _options$compareOnRea, _options$compareFunc;\n\t\tthis.name = void 0;\n\t\tthis._gpuSize = 0;\n\t\tthis.id = id++;\n\t\tthis._invalid = false;\n\t\tthis._lockedLevel = -1;\n\t\tthis._lockedMode = TEXTURELOCK_NONE;\n\t\tthis.renderVersionDirty = 0;\n\t\tthis._storage = false;\n\t\tthis.device = graphicsDevice;\n\t\tthis.name = (_options$name = options.name) != null ? _options$name : '';\n\t\tthis._width = Math.floor((_options$width = options.width) != null ? _options$width : 4);\n\t\tthis._height = Math.floor((_options$height = options.height) != null ? _options$height : 4);\n\t\tthis._format = (_options$format = options.format) != null ? _options$format : PIXELFORMAT_RGBA8;\n\t\tthis._compressed = isCompressedPixelFormat(this._format);\n\t\tthis._integerFormat = isIntegerPixelFormat(this._format);\n\t\tif (this._integerFormat) {\n\t\t\toptions.mipmaps = false;\n\t\t\toptions.minFilter = FILTER_NEAREST;\n\t\t\toptions.magFilter = FILTER_NEAREST;\n\t\t}\n\t\tif (graphicsDevice.supportsVolumeTextures) {\n\t\t\tvar _options$volume, _options$depth, _options$arrayLength;\n\t\t\tthis._volume = (_options$volume = options.volume) != null ? _options$volume : false;\n\t\t\tthis._depth = Math.floor((_options$depth = options.depth) != null ? _options$depth : 1);\n\t\t\tthis._arrayLength = Math.floor((_options$arrayLength = options.arrayLength) != null ? _options$arrayLength : 0);\n\t\t} else {\n\t\t\tthis._volume = false;\n\t\t\tthis._depth = 1;\n\t\t\tthis._arrayLength = 0;\n\t\t}\n\t\tthis._storage = (_options$storage = options.storage) != null ? _options$storage : false;\n\t\tthis._cubemap = (_options$cubemap = options.cubemap) != null ? _options$cubemap : false;\n\t\tthis.fixCubemapSeams = (_options$fixCubemapSe = options.fixCubemapSeams) != null ? _options$fixCubemapSe : false;\n\t\tthis._flipY = (_options$flipY = options.flipY) != null ? _options$flipY : false;\n\t\tthis._premultiplyAlpha = (_options$premultiplyA = options.premultiplyAlpha) != null ? _options$premultiplyA : false;\n\t\tthis._mipmaps = (_ref = (_options$mipmaps = options.mipmaps) != null ? _options$mipmaps : options.autoMipmap) != null ? _ref : true;\n\t\tthis._minFilter = (_options$minFilter = options.minFilter) != null ? _options$minFilter : FILTER_LINEAR_MIPMAP_LINEAR;\n\t\tthis._magFilter = (_options$magFilter = options.magFilter) != null ? _options$magFilter : FILTER_LINEAR;\n\t\tthis._anisotropy = (_options$anisotropy = options.anisotropy) != null ? _options$anisotropy : 1;\n\t\tthis._addressU = (_options$addressU = options.addressU) != null ? _options$addressU : ADDRESS_REPEAT;\n\t\tthis._addressV = (_options$addressV = options.addressV) != null ? _options$addressV : ADDRESS_REPEAT;\n\t\tthis._addressW = (_options$addressW = options.addressW) != null ? _options$addressW : ADDRESS_REPEAT;\n\t\tthis._compareOnRead = (_options$compareOnRea = options.compareOnRead) != null ? _options$compareOnRea : false;\n\t\tthis._compareFunc = (_options$compareFunc = options.compareFunc) != null ? _options$compareFunc : FUNC_LESS;\n\t\tthis.type = TEXTURETYPE_DEFAULT;\n\t\tif (options.hasOwnProperty('type')) {\n\t\t\tthis.type = options.type;\n\t\t} else if (options.hasOwnProperty('rgbm')) {\n\t\t\tthis.type = options.rgbm ? TEXTURETYPE_RGBM : TEXTURETYPE_DEFAULT;\n\t\t} else if (options.hasOwnProperty('swizzleGGGR')) {\n\t\t\tthis.type = options.swizzleGGGR ? TEXTURETYPE_SWIZZLEGGGR : TEXTURETYPE_DEFAULT;\n\t\t}\n\t\tthis.projection = TEXTUREPROJECTION_NONE;\n\t\tif (this._cubemap) {\n\t\t\tthis.projection = TEXTUREPROJECTION_CUBE;\n\t\t} else if (options.projection && options.projection !== TEXTUREPROJECTION_CUBE) {\n\t\t\tthis.projection = options.projection;\n\t\t}\n\t\tthis.impl = graphicsDevice.createTextureImpl(this);\n\t\tthis.dirtyAll();\n\t\tthis._levels = options.levels;\n\t\tif (this._levels) {\n\t\t\tthis.upload();\n\t\t} else {\n\t\t\tthis._levels = this._cubemap ? [[null, null, null, null, null, null]] : [null];\n\t\t}\n\t\tgraphicsDevice.textures.push(this);\n\t}\n\tdestroy() {\n\t\tconst device = this.device;\n\t\tif (device) {\n\t\t\tconst idx = device.textures.indexOf(this);\n\t\t\tif (idx !== -1) {\n\t\t\t\tdevice.textures.splice(idx, 1);\n\t\t\t}\n\t\t\tdevice.scope.removeValue(this);\n\t\t\tthis.impl.destroy(device);\n\t\t\tthis.adjustVramSizeTracking(device._vram, -this._gpuSize);\n\t\t\tthis._levels = null;\n\t\t\tthis.device = null;\n\t\t}\n\t}\n\tresize(width, height, depth = 1) {\n\t\tconst device = this.device;\n\t\tthis.adjustVramSizeTracking(device._vram, -this._gpuSize);\n\t\tthis.impl.destroy(device);\n\t\tthis._width = Math.floor(width);\n\t\tthis._height = Math.floor(height);\n\t\tthis._depth = Math.floor(depth);\n\t\tthis.impl = device.createTextureImpl(this);\n\t\tthis.dirtyAll();\n\t}\n\tloseContext() {\n\t\tthis.impl.loseContext();\n\t\tthis.dirtyAll();\n\t}\n\tadjustVramSizeTracking(vram, size) {\n\t\tvram.tex += size;\n\t}\n\tpropertyChanged(flag) {\n\t\tthis.impl.propertyChanged(flag);\n\t\tthis.renderVersionDirty = this.device.renderVersion;\n\t}\n\tget requiredMipLevels() {\n\t\treturn this.mipmaps ? TextureUtils.calcMipLevelsCount(this.width, this.height) : 1;\n\t}\n\tget lockedMode() {\n\t\treturn this._lockedMode;\n\t}\n\tset minFilter(v) {\n\t\tif (this._minFilter !== v) {\n\t\t\tif (isIntegerPixelFormat(this._format)) ; else {\n\t\t\t\tthis._minFilter = v;\n\t\t\t\tthis.propertyChanged(1);\n\t\t\t}\n\t\t}\n\t}\n\tget minFilter() {\n\t\treturn this._minFilter;\n\t}\n\tset magFilter(v) {\n\t\tif (this._magFilter !== v) {\n\t\t\tif (isIntegerPixelFormat(this._format)) ; else {\n\t\t\t\tthis._magFilter = v;\n\t\t\t\tthis.propertyChanged(2);\n\t\t\t}\n\t\t}\n\t}\n\tget magFilter() {\n\t\treturn this._magFilter;\n\t}\n\tset addressU(v) {\n\t\tif (this._addressU !== v) {\n\t\t\tthis._addressU = v;\n\t\t\tthis.propertyChanged(4);\n\t\t}\n\t}\n\tget addressU() {\n\t\treturn this._addressU;\n\t}\n\tset addressV(v) {\n\t\tif (this._addressV !== v) {\n\t\t\tthis._addressV = v;\n\t\t\tthis.propertyChanged(8);\n\t\t}\n\t}\n\tget addressV() {\n\t\treturn this._addressV;\n\t}\n\tset addressW(addressW) {\n\t\tif (!this.device.supportsVolumeTextures) return;\n\t\tif (!this._volume) {\n\t\t\treturn;\n\t\t}\n\t\tif (addressW !== this._addressW) {\n\t\t\tthis._addressW = addressW;\n\t\t\tthis.propertyChanged(16);\n\t\t}\n\t}\n\tget addressW() {\n\t\treturn this._addressW;\n\t}\n\tset compareOnRead(v) {\n\t\tif (this._compareOnRead !== v) {\n\t\t\tthis._compareOnRead = v;\n\t\t\tthis.propertyChanged(32);\n\t\t}\n\t}\n\tget compareOnRead() {\n\t\treturn this._compareOnRead;\n\t}\n\tset compareFunc(v) {\n\t\tif (this._compareFunc !== v) {\n\t\t\tthis._compareFunc = v;\n\t\t\tthis.propertyChanged(64);\n\t\t}\n\t}\n\tget compareFunc() {\n\t\treturn this._compareFunc;\n\t}\n\tset anisotropy(v) {\n\t\tif (this._anisotropy !== v) {\n\t\t\tthis._anisotropy = v;\n\t\t\tthis.propertyChanged(128);\n\t\t}\n\t}\n\tget anisotropy() {\n\t\treturn this._anisotropy;\n\t}\n\tset mipmaps(v) {\n\t\tif (this._mipmaps !== v) {\n\t\t\tif (this.device.isWebGPU) ; else if (isIntegerPixelFormat(this._format)) ; else {\n\t\t\t\tthis._mipmaps = v;\n\t\t\t}\n\t\t\tif (v) this._needsMipmapsUpload = true;\n\t\t}\n\t}\n\tget mipmaps() {\n\t\treturn this._mipmaps;\n\t}\n\tget storage() {\n\t\treturn this._storage;\n\t}\n\tget width() {\n\t\treturn this._width;\n\t}\n\tget height() {\n\t\treturn this._height;\n\t}\n\tget depth() {\n\t\treturn this._depth;\n\t}\n\tget format() {\n\t\treturn this._format;\n\t}\n\tget cubemap() {\n\t\treturn this._cubemap;\n\t}\n\tget gpuSize() {\n\t\tconst mips = this.pot && this._mipmaps && !(this._compressed && this._levels.length === 1);\n\t\treturn TextureUtils.calcGpuSize(this._width, this._height, this._depth, this._format, mips, this._cubemap);\n\t}\n\tget array() {\n\t\treturn this._arrayLength > 0;\n\t}\n\tget arrayLength() {\n\t\treturn this._arrayLength;\n\t}\n\tget volume() {\n\t\treturn this._volume;\n\t}\n\tset flipY(flipY) {\n\t\tif (this._flipY !== flipY) {\n\t\t\tthis._flipY = flipY;\n\t\t\tthis._needsUpload = true;\n\t\t}\n\t}\n\tget flipY() {\n\t\treturn this._flipY;\n\t}\n\tset premultiplyAlpha(premultiplyAlpha) {\n\t\tif (this._premultiplyAlpha !== premultiplyAlpha) {\n\t\t\tthis._premultiplyAlpha = premultiplyAlpha;\n\t\t\tthis._needsUpload = true;\n\t\t}\n\t}\n\tget premultiplyAlpha() {\n\t\treturn this._premultiplyAlpha;\n\t}\n\tget pot() {\n\t\treturn math.powerOfTwo(this._width) && math.powerOfTwo(this._height);\n\t}\n\tget encoding() {\n\t\tswitch (this.type) {\n\t\t\tcase TEXTURETYPE_RGBM:\n\t\t\t\treturn 'rgbm';\n\t\t\tcase TEXTURETYPE_RGBE:\n\t\t\t\treturn 'rgbe';\n\t\t\tcase TEXTURETYPE_RGBP:\n\t\t\t\treturn 'rgbp';\n\t\t\tdefault:\n\t\t\t\treturn this.format === PIXELFORMAT_RGB16F || this.format === PIXELFORMAT_RGB32F || this.format === PIXELFORMAT_RGBA16F || this.format === PIXELFORMAT_RGBA32F || isIntegerPixelFormat(this.format) ? 'linear' : 'srgb';\n\t\t}\n\t}\n\tdirtyAll() {\n\t\tthis._levelsUpdated = this._cubemap ? [[true, true, true, true, true, true]] : [true];\n\t\tthis._needsUpload = true;\n\t\tthis._needsMipmapsUpload = this._mipmaps;\n\t\tthis._mipmapsUploaded = false;\n\t\tthis.propertyChanged(255);\n\t}\n\tlock(options = {}) {\n\t\tvar _options$level, _options$face, _options$mode;\n\t\t(_options$level = options.level) != null ? _options$level : options.level = 0;\n\t\t(_options$face = options.face) != null ? _options$face : options.face = 0;\n\t\t(_options$mode = options.mode) != null ? _options$mode : options.mode = TEXTURELOCK_WRITE;\n\t\tthis._lockedMode = options.mode;\n\t\tthis._lockedLevel = options.level;\n\t\tconst levels = this.cubemap ? this._levels[options.face] : this._levels;\n\t\tif (levels[options.level] === null) {\n\t\t\tconst width = Math.max(1, this._width >> options.level);\n\t\t\tconst height = Math.max(1, this._height >> options.level);\n\t\t\tconst depth = Math.max(1, this._depth >> options.level);\n\t\t\tconst data = new ArrayBuffer(TextureUtils.calcLevelGpuSize(width, height, depth, this._format));\n\t\t\tlevels[options.level] = new (getPixelFormatArrayType(this._format))(data);\n\t\t}\n\t\treturn levels[options.level];\n\t}\n\tsetSource(source, mipLevel = 0) {\n\t\tlet invalid = false;\n\t\tlet width, height;\n\t\tif (this._cubemap) {\n\t\t\tif (source[0]) {\n\t\t\t\twidth = source[0].width || 0;\n\t\t\t\theight = source[0].height || 0;\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\tconst face = source[i];\n\t\t\t\t\tif (!face || face.width !== width || face.height !== height || !this.device._isBrowserInterface(face)) {\n\t\t\t\t\t\tinvalid = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tinvalid = true;\n\t\t\t}\n\t\t\tif (!invalid) {\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\tif (this._levels[mipLevel][i] !== source[i]) {\n\t\t\t\t\t\tthis._levelsUpdated[mipLevel][i] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!this.device._isBrowserInterface(source)) {\n\t\t\t\tinvalid = true;\n\t\t\t}\n\t\t\tif (!invalid) {\n\t\t\t\tif (source !== this._levels[mipLevel]) {\n\t\t\t\t\tthis._levelsUpdated[mipLevel] = true;\n\t\t\t\t}\n\t\t\t\twidth = source.width;\n\t\t\t\theight = source.height;\n\t\t\t}\n\t\t}\n\t\tif (invalid) {\n\t\t\tthis._width = 4;\n\t\t\tthis._height = 4;\n\t\t\tif (this._cubemap) {\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\tthis._levels[mipLevel][i] = null;\n\t\t\t\t\tthis._levelsUpdated[mipLevel][i] = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._levels[mipLevel] = null;\n\t\t\t\tthis._levelsUpdated[mipLevel] = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (mipLevel === 0) {\n\t\t\t\tthis._width = width;\n\t\t\t\tthis._height = height;\n\t\t\t}\n\t\t\tthis._levels[mipLevel] = source;\n\t\t}\n\t\tif (this._invalid !== invalid || !invalid) {\n\t\t\tthis._invalid = invalid;\n\t\t\tthis.upload();\n\t\t}\n\t}\n\tgetSource(mipLevel = 0) {\n\t\treturn this._levels[mipLevel];\n\t}\n\tunlock() {\n\t\tif (this._lockedMode === TEXTURELOCK_NONE) ;\n\t\tif (this._lockedMode === TEXTURELOCK_WRITE) {\n\t\t\tthis.upload();\n\t\t}\n\t\tthis._lockedLevel = -1;\n\t\tthis._lockedMode = TEXTURELOCK_NONE;\n\t}\n\tupload() {\n\t\tvar _this$impl$uploadImme, _this$impl;\n\t\tthis._needsUpload = true;\n\t\tthis._needsMipmapsUpload = this._mipmaps;\n\t\t(_this$impl$uploadImme = (_this$impl = this.impl).uploadImmediate) == null || _this$impl$uploadImme.call(_this$impl, this.device, this);\n\t}\n\tasync downloadAsync() {\n\t\tconst promises = [];\n\t\tfor (let i = 0; i < (this.cubemap ? 6 : 1); i++) {\n\t\t\tvar _this$device$readPixe, _this$device;\n\t\t\tconst renderTarget = new RenderTarget({\n\t\t\t\tcolorBuffer: this,\n\t\t\t\tdepth: false,\n\t\t\t\tface: i\n\t\t\t});\n\t\t\tthis.device.setRenderTarget(renderTarget);\n\t\t\tthis.device.initRenderTarget(renderTarget);\n\t\t\tconst levels = this.cubemap ? this._levels[i] : this._levels;\n\t\t\tlet level = levels[0];\n\t\t\tif (levels[0] && this.device._isBrowserInterface(levels[0])) {\n\t\t\t\tlevels[0] = null;\n\t\t\t}\n\t\t\tlevel = this.lock({\n\t\t\t\tface: i\n\t\t\t});\n\t\t\tconst promise = (_this$device$readPixe = (_this$device = this.device).readPixelsAsync) == null ? void 0 : _this$device$readPixe.call(_this$device, 0, 0, this.width, this.height, level).then(() => renderTarget.destroy());\n\t\t\tpromises.push(promise);\n\t\t}\n\t\tawait Promise.all(promises);\n\t}\n}\n\nexport { Texture };\n","import { math } from '../../core/math/math.js';\nimport { UNIFORMTYPE_MAT4, UNIFORMTYPE_MAT4ARRAY, UNIFORMTYPE_BVEC4, UNIFORMTYPE_BVEC4ARRAY, UNIFORMTYPE_UVEC4, UNIFORMTYPE_UVEC4ARRAY, UNIFORMTYPE_IVEC4, UNIFORMTYPE_IVEC4ARRAY, UNIFORMTYPE_VEC4, UNIFORMTYPE_VEC4ARRAY, UNIFORMTYPE_BVEC3, UNIFORMTYPE_BVEC3ARRAY, UNIFORMTYPE_UVEC3, UNIFORMTYPE_UVEC3ARRAY, UNIFORMTYPE_IVEC3, UNIFORMTYPE_IVEC3ARRAY, UNIFORMTYPE_VEC3, UNIFORMTYPE_VEC3ARRAY, UNIFORMTYPE_BVEC2, UNIFORMTYPE_BVEC2ARRAY, UNIFORMTYPE_UVEC2, UNIFORMTYPE_UVEC2ARRAY, UNIFORMTYPE_IVEC2, UNIFORMTYPE_IVEC2ARRAY, UNIFORMTYPE_VEC2, UNIFORMTYPE_VEC2ARRAY, UNIFORMTYPE_BOOL, UNIFORMTYPE_BOOLARRAY, UNIFORMTYPE_UINT, UNIFORMTYPE_UINTARRAY, UNIFORMTYPE_INT, UNIFORMTYPE_INTARRAY, UNIFORMTYPE_FLOAT, UNIFORMTYPE_FLOATARRAY, bindGroupNames, uniformTypeToName, UNIFORMTYPE_MAT2, UNIFORMTYPE_MAT3 } from './constants.js';\n\nconst uniformTypeToNumComponents = [];\nuniformTypeToNumComponents[UNIFORMTYPE_FLOAT] = 1;\nuniformTypeToNumComponents[UNIFORMTYPE_VEC2] = 2;\nuniformTypeToNumComponents[UNIFORMTYPE_VEC3] = 3;\nuniformTypeToNumComponents[UNIFORMTYPE_VEC4] = 4;\nuniformTypeToNumComponents[UNIFORMTYPE_INT] = 1;\nuniformTypeToNumComponents[UNIFORMTYPE_IVEC2] = 2;\nuniformTypeToNumComponents[UNIFORMTYPE_IVEC3] = 3;\nuniformTypeToNumComponents[UNIFORMTYPE_IVEC4] = 4;\nuniformTypeToNumComponents[UNIFORMTYPE_BOOL] = 1;\nuniformTypeToNumComponents[UNIFORMTYPE_BVEC2] = 2;\nuniformTypeToNumComponents[UNIFORMTYPE_BVEC3] = 3;\nuniformTypeToNumComponents[UNIFORMTYPE_BVEC4] = 4;\nuniformTypeToNumComponents[UNIFORMTYPE_MAT2] = 8;\nuniformTypeToNumComponents[UNIFORMTYPE_MAT3] = 12;\nuniformTypeToNumComponents[UNIFORMTYPE_MAT4] = 16;\nuniformTypeToNumComponents[UNIFORMTYPE_UINT] = 1;\nuniformTypeToNumComponents[UNIFORMTYPE_UVEC2] = 2;\nuniformTypeToNumComponents[UNIFORMTYPE_UVEC3] = 3;\nuniformTypeToNumComponents[UNIFORMTYPE_UVEC4] = 4;\nclass UniformFormat {\n\tget isArrayType() {\n\t\treturn this.count > 0;\n\t}\n\tconstructor(name, type, count = 0) {\n\t\tthis.name = void 0;\n\t\tthis.type = void 0;\n\t\tthis.byteSize = void 0;\n\t\tthis.offset = void 0;\n\t\tthis.scopeId = void 0;\n\t\tthis.count = void 0;\n\t\tthis.numComponents = void 0;\n\t\tthis.shortName = name;\n\t\tthis.name = count ? `${name}[0]` : name;\n\t\tthis.type = type;\n\t\tthis.numComponents = uniformTypeToNumComponents[type];\n\t\tthis.updateType = type;\n\t\tif (count > 0) {\n\t\t\tswitch (type) {\n\t\t\t\tcase UNIFORMTYPE_FLOAT:\n\t\t\t\t\tthis.updateType = UNIFORMTYPE_FLOATARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_INT:\n\t\t\t\t\tthis.updateType = UNIFORMTYPE_INTARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_UINT:\n\t\t\t\t\tthis.updateType = UNIFORMTYPE_UINTARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_BOOL:\n\t\t\t\t\tthis.updateType = UNIFORMTYPE_BOOLARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_VEC2:\n\t\t\t\t\tthis.updateType = UNIFORMTYPE_VEC2ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_IVEC2:\n\t\t\t\t\tthis.updateType = UNIFORMTYPE_IVEC2ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_UVEC2:\n\t\t\t\t\tthis.updateType = UNIFORMTYPE_UVEC2ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_BVEC2:\n\t\t\t\t\tthis.updateType = UNIFORMTYPE_BVEC2ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_VEC3:\n\t\t\t\t\tthis.updateType = UNIFORMTYPE_VEC3ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_IVEC3:\n\t\t\t\t\tthis.updateType = UNIFORMTYPE_IVEC3ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_UVEC3:\n\t\t\t\t\tthis.updateType = UNIFORMTYPE_UVEC3ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_BVEC3:\n\t\t\t\t\tthis.updateType = UNIFORMTYPE_BVEC3ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_VEC4:\n\t\t\t\t\tthis.updateType = UNIFORMTYPE_VEC4ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_IVEC4:\n\t\t\t\t\tthis.updateType = UNIFORMTYPE_IVEC4ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_UVEC4:\n\t\t\t\t\tthis.updateType = UNIFORMTYPE_UVEC4ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_BVEC4:\n\t\t\t\t\tthis.updateType = UNIFORMTYPE_BVEC4ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_MAT4:\n\t\t\t\t\tthis.updateType = UNIFORMTYPE_MAT4ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.count = count;\n\t\tlet componentSize = this.numComponents;\n\t\tif (count) {\n\t\t\tcomponentSize = math.roundUp(componentSize, 4);\n\t\t}\n\t\tthis.byteSize = componentSize * 4;\n\t\tif (count) {\n\t\t\tthis.byteSize *= count;\n\t\t}\n\t}\n\tcalculateOffset(offset) {\n\t\tlet alignment = this.byteSize <= 8 ? this.byteSize : 16;\n\t\tif (this.count) {\n\t\t\talignment = 16;\n\t\t}\n\t\toffset = math.roundUp(offset, alignment);\n\t\tthis.offset = offset / 4;\n\t}\n}\nclass UniformBufferFormat {\n\tconstructor(graphicsDevice, uniforms) {\n\t\tthis.byteSize = 0;\n\t\tthis.map = new Map();\n\t\tthis.scope = graphicsDevice.scope;\n\t\tthis.uniforms = uniforms;\n\t\tlet offset = 0;\n\t\tfor (let i = 0; i < uniforms.length; i++) {\n\t\t\tconst uniform = uniforms[i];\n\t\t\tuniform.calculateOffset(offset);\n\t\t\toffset = uniform.offset * 4 + uniform.byteSize;\n\t\t\tuniform.scopeId = this.scope.resolve(uniform.name);\n\t\t\tthis.map.set(uniform.name, uniform);\n\t\t}\n\t\tthis.byteSize = math.roundUp(offset, 16);\n\t}\n\tget(name) {\n\t\treturn this.map.get(name);\n\t}\n\tgetShaderDeclaration(bindGroup, bindIndex) {\n\t\tconst name = bindGroupNames[bindGroup];\n\t\tlet code = `layout(set = ${bindGroup}, binding = ${bindIndex}, std140) uniform ub_${name} {\\n`;\n\t\tthis.uniforms.forEach(uniform => {\n\t\t\tconst typeString = uniformTypeToName[uniform.type];\n\t\t\tcode += `    ${typeString} ${uniform.shortName}${uniform.count ? `[${uniform.count}]` : ''};\\n`;\n\t\t});\n\t\treturn `${code}};\\n`;\n\t}\n}\n\nexport { UniformBufferFormat, UniformFormat };\n","import { UNIFORMTYPE_FLOAT, UNIFORMTYPE_VEC2, UNIFORMTYPE_VEC3, UNIFORMTYPE_VEC4, UNIFORMTYPE_INT, UNIFORMTYPE_IVEC2, UNIFORMTYPE_IVEC3, UNIFORMTYPE_IVEC4, UNIFORMTYPE_MAT2, UNIFORMTYPE_MAT3, UNIFORMTYPE_FLOATARRAY, UNIFORMTYPE_VEC2ARRAY, UNIFORMTYPE_VEC3ARRAY, UNIFORMTYPE_UINT, UNIFORMTYPE_UVEC2, UNIFORMTYPE_UVEC3, UNIFORMTYPE_UVEC4, UNIFORMTYPE_INTARRAY, UNIFORMTYPE_BOOLARRAY, UNIFORMTYPE_UINTARRAY, UNIFORMTYPE_IVEC2ARRAY, UNIFORMTYPE_BVEC2ARRAY, UNIFORMTYPE_UVEC2ARRAY, UNIFORMTYPE_IVEC3ARRAY, UNIFORMTYPE_BVEC3ARRAY, UNIFORMTYPE_UVEC3ARRAY } from './constants.js';\nimport { DynamicBufferAllocation } from './dynamic-buffers.js';\n\nconst _updateFunctions = [];\n_updateFunctions[UNIFORMTYPE_FLOAT] = function (uniformBuffer, value, offset) {\n\tconst dst = uniformBuffer.storageFloat32;\n\tdst[offset] = value;\n};\n_updateFunctions[UNIFORMTYPE_VEC2] = (uniformBuffer, value, offset) => {\n\tconst dst = uniformBuffer.storageFloat32;\n\tdst[offset] = value[0];\n\tdst[offset + 1] = value[1];\n};\n_updateFunctions[UNIFORMTYPE_VEC3] = (uniformBuffer, value, offset) => {\n\tconst dst = uniformBuffer.storageFloat32;\n\tdst[offset] = value[0];\n\tdst[offset + 1] = value[1];\n\tdst[offset + 2] = value[2];\n};\n_updateFunctions[UNIFORMTYPE_VEC4] = (uniformBuffer, value, offset) => {\n\tconst dst = uniformBuffer.storageFloat32;\n\tdst[offset] = value[0];\n\tdst[offset + 1] = value[1];\n\tdst[offset + 2] = value[2];\n\tdst[offset + 3] = value[3];\n};\n_updateFunctions[UNIFORMTYPE_INT] = function (uniformBuffer, value, offset) {\n\tconst dst = uniformBuffer.storageInt32;\n\tdst[offset] = value;\n};\n_updateFunctions[UNIFORMTYPE_IVEC2] = function (uniformBuffer, value, offset) {\n\tconst dst = uniformBuffer.storageInt32;\n\tdst[offset] = value[0];\n\tdst[offset + 1] = value[1];\n};\n_updateFunctions[UNIFORMTYPE_IVEC3] = function (uniformBuffer, value, offset) {\n\tconst dst = uniformBuffer.storageInt32;\n\tdst[offset] = value[0];\n\tdst[offset + 1] = value[1];\n\tdst[offset + 2] = value[2];\n};\n_updateFunctions[UNIFORMTYPE_IVEC4] = function (uniformBuffer, value, offset) {\n\tconst dst = uniformBuffer.storageInt32;\n\tdst[offset] = value[0];\n\tdst[offset + 1] = value[1];\n\tdst[offset + 2] = value[2];\n\tdst[offset + 3] = value[3];\n};\n_updateFunctions[UNIFORMTYPE_MAT2] = (uniformBuffer, value, offset) => {\n\tconst dst = uniformBuffer.storageFloat32;\n\tdst[offset] = value[0];\n\tdst[offset + 1] = value[1];\n\tdst[offset + 4] = value[2];\n\tdst[offset + 5] = value[3];\n\tdst[offset + 8] = value[4];\n\tdst[offset + 9] = value[5];\n};\n_updateFunctions[UNIFORMTYPE_MAT3] = (uniformBuffer, value, offset) => {\n\tconst dst = uniformBuffer.storageFloat32;\n\tdst[offset] = value[0];\n\tdst[offset + 1] = value[1];\n\tdst[offset + 2] = value[2];\n\tdst[offset + 4] = value[3];\n\tdst[offset + 5] = value[4];\n\tdst[offset + 6] = value[5];\n\tdst[offset + 8] = value[6];\n\tdst[offset + 9] = value[7];\n\tdst[offset + 10] = value[8];\n};\n_updateFunctions[UNIFORMTYPE_FLOATARRAY] = function (uniformBuffer, value, offset, count) {\n\tconst dst = uniformBuffer.storageFloat32;\n\tfor (let i = 0; i < count; i++) {\n\t\tdst[offset + i * 4] = value[i];\n\t}\n};\n_updateFunctions[UNIFORMTYPE_VEC2ARRAY] = (uniformBuffer, value, offset, count) => {\n\tconst dst = uniformBuffer.storageFloat32;\n\tfor (let i = 0; i < count; i++) {\n\t\tdst[offset + i * 4] = value[i * 2];\n\t\tdst[offset + i * 4 + 1] = value[i * 2 + 1];\n\t}\n};\n_updateFunctions[UNIFORMTYPE_VEC3ARRAY] = (uniformBuffer, value, offset, count) => {\n\tconst dst = uniformBuffer.storageFloat32;\n\tfor (let i = 0; i < count; i++) {\n\t\tdst[offset + i * 4] = value[i * 3];\n\t\tdst[offset + i * 4 + 1] = value[i * 3 + 1];\n\t\tdst[offset + i * 4 + 2] = value[i * 3 + 2];\n\t}\n};\n_updateFunctions[UNIFORMTYPE_UINT] = (uniformBuffer, value, offset, count) => {\n\tconst dst = uniformBuffer.storageUint32;\n\tdst[offset] = value;\n};\n_updateFunctions[UNIFORMTYPE_UVEC2] = (uniformBuffer, value, offset, count) => {\n\tconst dst = uniformBuffer.storageUint32;\n\tdst[offset] = value[0];\n\tdst[offset + 1] = value[1];\n};\n_updateFunctions[UNIFORMTYPE_UVEC3] = (uniformBuffer, value, offset, count) => {\n\tconst dst = uniformBuffer.storageUint32;\n\tdst[offset] = value[0];\n\tdst[offset + 1] = value[1];\n\tdst[offset + 2] = value[2];\n};\n_updateFunctions[UNIFORMTYPE_UVEC4] = (uniformBuffer, value, offset, count) => {\n\tconst dst = uniformBuffer.storageUint32;\n\tdst[offset] = value[0];\n\tdst[offset + 1] = value[1];\n\tdst[offset + 2] = value[2];\n\tdst[offset + 3] = value[3];\n};\n_updateFunctions[UNIFORMTYPE_INTARRAY] = function (uniformBuffer, value, offset, count) {\n\tconst dst = uniformBuffer.storageInt32;\n\tfor (let i = 0; i < count; i++) {\n\t\tdst[offset + i * 4] = value[i];\n\t}\n};\n_updateFunctions[UNIFORMTYPE_BOOLARRAY] = _updateFunctions[UNIFORMTYPE_INTARRAY];\n_updateFunctions[UNIFORMTYPE_UINTARRAY] = function (uniformBuffer, value, offset, count) {\n\tconst dst = uniformBuffer.storageUint32;\n\tfor (let i = 0; i < count; i++) {\n\t\tdst[offset + i * 4] = value[i];\n\t}\n};\n_updateFunctions[UNIFORMTYPE_IVEC2ARRAY] = (uniformBuffer, value, offset, count) => {\n\tconst dst = uniformBuffer.storageInt32;\n\tfor (let i = 0; i < count; i++) {\n\t\tdst[offset + i * 4] = value[i * 2];\n\t\tdst[offset + i * 4 + 1] = value[i * 2 + 1];\n\t}\n};\n_updateFunctions[UNIFORMTYPE_BVEC2ARRAY] = _updateFunctions[UNIFORMTYPE_IVEC2ARRAY];\n_updateFunctions[UNIFORMTYPE_UVEC2ARRAY] = (uniformBuffer, value, offset, count) => {\n\tconst dst = uniformBuffer.storageUint32;\n\tfor (let i = 0; i < count; i++) {\n\t\tdst[offset + i * 4] = value[i * 2];\n\t\tdst[offset + i * 4 + 1] = value[i * 2 + 1];\n\t}\n};\n_updateFunctions[UNIFORMTYPE_IVEC3ARRAY] = (uniformBuffer, value, offset, count) => {\n\tconst dst = uniformBuffer.storageInt32;\n\tfor (let i = 0; i < count; i++) {\n\t\tdst[offset + i * 4] = value[i * 3];\n\t\tdst[offset + i * 4 + 1] = value[i * 3 + 1];\n\t\tdst[offset + i * 4 + 2] = value[i * 3 + 2];\n\t}\n};\n_updateFunctions[UNIFORMTYPE_BVEC3ARRAY] = _updateFunctions[UNIFORMTYPE_IVEC3ARRAY];\n_updateFunctions[UNIFORMTYPE_UVEC3ARRAY] = (uniformBuffer, value, offset, count) => {\n\tconst dst = uniformBuffer.storageUint32;\n\tfor (let i = 0; i < count; i++) {\n\t\tdst[offset + i * 4] = value[i * 3];\n\t\tdst[offset + i * 4 + 1] = value[i * 3 + 1];\n\t\tdst[offset + i * 4 + 2] = value[i * 3 + 2];\n\t}\n};\nclass UniformBuffer {\n\tconstructor(graphicsDevice, format, persistent = true) {\n\t\tthis.device = void 0;\n\t\tthis.persistent = void 0;\n\t\tthis.allocation = void 0;\n\t\tthis.storageFloat32 = void 0;\n\t\tthis.storageInt32 = void 0;\n\t\tthis.storageUint32 = void 0;\n\t\tthis.renderVersionDirty = 0;\n\t\tthis.device = graphicsDevice;\n\t\tthis.format = format;\n\t\tthis.persistent = persistent;\n\t\tif (persistent) {\n\t\t\tthis.impl = graphicsDevice.createUniformBufferImpl(this);\n\t\t\tconst storage = new ArrayBuffer(format.byteSize);\n\t\t\tthis.assignStorage(new Int32Array(storage));\n\t\t\tgraphicsDevice._vram.ub += this.format.byteSize;\n\t\t} else {\n\t\t\tthis.allocation = new DynamicBufferAllocation();\n\t\t}\n\t}\n\tdestroy() {\n\t\tif (this.persistent) {\n\t\t\tconst device = this.device;\n\t\t\tthis.impl.destroy(device);\n\t\t\tdevice._vram.ub -= this.format.byteSize;\n\t\t}\n\t}\n\tget offset() {\n\t\treturn this.persistent ? 0 : this.allocation.offset;\n\t}\n\tassignStorage(storage) {\n\t\tthis.storageInt32 = storage;\n\t\tthis.storageUint32 = new Uint32Array(storage.buffer, storage.byteOffset, storage.byteLength / 4);\n\t\tthis.storageFloat32 = new Float32Array(storage.buffer, storage.byteOffset, storage.byteLength / 4);\n\t}\n\tloseContext() {\n\t\tvar _this$impl;\n\t\t(_this$impl = this.impl) == null || _this$impl.loseContext();\n\t}\n\tsetUniform(uniformFormat) {\n\t\tconst offset = uniformFormat.offset;\n\t\tconst value = uniformFormat.scopeId.value;\n\t\tif (value !== null && value !== undefined) {\n\t\t\tconst updateFunction = _updateFunctions[uniformFormat.updateType];\n\t\t\tif (updateFunction) {\n\t\t\t\tupdateFunction(this, value, offset, uniformFormat.count);\n\t\t\t} else {\n\t\t\t\tthis.storageFloat32.set(value, offset);\n\t\t\t}\n\t\t}\n\t}\n\tset(name) {\n\t\tconst uniformFormat = this.format.map.get(name);\n\t\tif (uniformFormat) {\n\t\t\tthis.setUniform(uniformFormat);\n\t\t}\n\t}\n\tupdate() {\n\t\tconst persistent = this.persistent;\n\t\tif (!persistent) {\n\t\t\tconst allocation = this.allocation;\n\t\t\tconst oldGpuBuffer = allocation.gpuBuffer;\n\t\t\tthis.device.dynamicBuffers.alloc(allocation, this.format.byteSize);\n\t\t\tthis.assignStorage(allocation.storage);\n\t\t\tif (oldGpuBuffer !== allocation.gpuBuffer) {\n\t\t\t\tthis.renderVersionDirty = this.device.renderVersion;\n\t\t\t}\n\t\t}\n\t\tconst uniforms = this.format.uniforms;\n\t\tfor (let i = 0; i < uniforms.length; i++) {\n\t\t\tthis.setUniform(uniforms[i]);\n\t\t}\n\t\tif (persistent) {\n\t\t\tthis.impl.unlock(this);\n\t\t} else {\n\t\t\tthis.storageFloat32 = null;\n\t\t\tthis.storageInt32 = null;\n\t\t}\n\t}\n}\n\nexport { UniformBuffer };\n","class Version {\n\tconstructor() {\n\t\tthis.globalId = 0;\n\t\tthis.revision = 0;\n\t}\n\tequals(other) {\n\t\treturn this.globalId === other.globalId && this.revision === other.revision;\n\t}\n\tcopy(other) {\n\t\tthis.globalId = other.globalId;\n\t\tthis.revision = other.revision;\n\t}\n\treset() {\n\t\tthis.globalId = 0;\n\t\tthis.revision = 0;\n\t}\n}\n\nexport { Version };\n","import { Version } from './version.js';\n\nlet idCounter = 0;\nclass VersionedObject {\n\tconstructor() {\n\t\tidCounter++;\n\t\tthis.version = new Version();\n\t\tthis.version.globalId = idCounter;\n\t}\n\tincrement() {\n\t\tthis.version.revision++;\n\t}\n}\n\nexport { VersionedObject };\n","import { BUFFER_STATIC } from './constants.js';\n\nlet id = 0;\nclass VertexBuffer {\n\tconstructor(graphicsDevice, format, numVertices, options) {\n\t\tthis.usage = BUFFER_STATIC;\n\t\tlet initialData;\n\t\tif (typeof options === 'object') {\n\t\t\tvar _options$usage;\n\t\t\tthis.usage = (_options$usage = options.usage) != null ? _options$usage : BUFFER_STATIC;\n\t\t\tinitialData = options.data;\n\t\t} else if (arguments.length > 3) {\n\t\t\tvar _arguments$;\n\t\t\tthis.usage = (_arguments$ = arguments[3]) != null ? _arguments$ : BUFFER_STATIC;\n\t\t\tinitialData = arguments[4];\n\t\t}\n\t\tthis.device = graphicsDevice;\n\t\tthis.format = format;\n\t\tthis.numVertices = numVertices;\n\t\tthis.id = id++;\n\t\tthis.impl = graphicsDevice.createVertexBufferImpl(this, format, options);\n\t\tthis.numBytes = format.verticesByteSize ? format.verticesByteSize : format.size * numVertices;\n\t\tthis.adjustVramSizeTracking(graphicsDevice._vram, this.numBytes);\n\t\tif (initialData) {\n\t\t\tthis.setData(initialData);\n\t\t} else {\n\t\t\tthis.storage = new ArrayBuffer(this.numBytes);\n\t\t}\n\t\tthis.device.buffers.push(this);\n\t}\n\tdestroy() {\n\t\tconst device = this.device;\n\t\tconst idx = device.buffers.indexOf(this);\n\t\tif (idx !== -1) {\n\t\t\tdevice.buffers.splice(idx, 1);\n\t\t}\n\t\tif (this.impl.initialized) {\n\t\t\tthis.impl.destroy(device);\n\t\t\tthis.adjustVramSizeTracking(device._vram, -this.storage.byteLength);\n\t\t}\n\t}\n\tadjustVramSizeTracking(vram, size) {\n\t\tvram.vb += size;\n\t}\n\tloseContext() {\n\t\tthis.impl.loseContext();\n\t}\n\tgetFormat() {\n\t\treturn this.format;\n\t}\n\tgetUsage() {\n\t\treturn this.usage;\n\t}\n\tgetNumVertices() {\n\t\treturn this.numVertices;\n\t}\n\tlock() {\n\t\treturn this.storage;\n\t}\n\tunlock() {\n\t\tthis.impl.unlock(this);\n\t}\n\tsetData(data) {\n\t\tif (data.byteLength !== this.numBytes) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.storage = data;\n\t\tthis.unlock();\n\t\treturn true;\n\t}\n}\n\nexport { VertexBuffer };\n","import { hashCode } from '../../core/hash.js';\nimport { math } from '../../core/math/math.js';\nimport { StringIds } from '../../core/string-ids.js';\nimport { typedArrayTypesByteSize, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1, SEMANTIC_COLOR, SEMANTIC_TANGENT, SEMANTIC_ATTR12, TYPE_FLOAT32, SEMANTIC_ATTR13, SEMANTIC_ATTR14, SEMANTIC_ATTR15 } from './constants.js';\nimport { DeviceCache } from './device-cache.js';\n\nconst stringIds = new StringIds();\nconst webgpuValidElementSizes = [2, 4, 8, 12, 16];\nconst deviceCache = new DeviceCache();\nclass VertexFormat {\n\tconstructor(graphicsDevice, description, vertexCount) {\n\t\tthis.device = graphicsDevice;\n\t\tthis._elements = [];\n\t\tthis.hasUv0 = false;\n\t\tthis.hasUv1 = false;\n\t\tthis.hasColor = false;\n\t\tthis.hasTangents = false;\n\t\tthis.verticesByteSize = 0;\n\t\tthis.vertexCount = vertexCount;\n\t\tthis.interleaved = vertexCount === undefined;\n\t\tthis.instancing = false;\n\t\tthis.size = description.reduce((total, desc) => {\n\t\t\treturn total + Math.ceil(desc.components * typedArrayTypesByteSize[desc.type] / 4) * 4;\n\t\t}, 0);\n\t\tlet offset = 0,\n\t\t\telementSize;\n\t\tfor (let i = 0, len = description.length; i < len; i++) {\n\t\t\tvar _elementDesc$asInt, _elementDesc$normaliz;\n\t\t\tconst elementDesc = description[i];\n\t\t\telementSize = elementDesc.components * typedArrayTypesByteSize[elementDesc.type];\n\t\t\tif (vertexCount) {\n\t\t\t\toffset = math.roundUp(offset, elementSize);\n\t\t\t}\n\t\t\tconst asInt = (_elementDesc$asInt = elementDesc.asInt) != null ? _elementDesc$asInt : false;\n\t\t\tconst normalize = asInt ? false : (_elementDesc$normaliz = elementDesc.normalize) != null ? _elementDesc$normaliz : false;\n\t\t\tconst element = {\n\t\t\t\tname: elementDesc.semantic,\n\t\t\t\toffset: vertexCount ? offset : elementDesc.hasOwnProperty('offset') ? elementDesc.offset : offset,\n\t\t\t\tstride: vertexCount ? elementSize : elementDesc.hasOwnProperty('stride') ? elementDesc.stride : this.size,\n\t\t\t\tdataType: elementDesc.type,\n\t\t\t\tnumComponents: elementDesc.components,\n\t\t\t\tnormalize: normalize,\n\t\t\t\tsize: elementSize,\n\t\t\t\tasInt: asInt\n\t\t\t};\n\t\t\tthis._elements.push(element);\n\t\t\tif (vertexCount) {\n\t\t\t\toffset += elementSize * vertexCount;\n\t\t\t} else {\n\t\t\t\toffset += Math.ceil(elementSize / 4) * 4;\n\t\t\t}\n\t\t\tif (elementDesc.semantic === SEMANTIC_TEXCOORD0) {\n\t\t\t\tthis.hasUv0 = true;\n\t\t\t} else if (elementDesc.semantic === SEMANTIC_TEXCOORD1) {\n\t\t\t\tthis.hasUv1 = true;\n\t\t\t} else if (elementDesc.semantic === SEMANTIC_COLOR) {\n\t\t\t\tthis.hasColor = true;\n\t\t\t} else if (elementDesc.semantic === SEMANTIC_TANGENT) {\n\t\t\t\tthis.hasTangents = true;\n\t\t\t}\n\t\t}\n\t\tif (vertexCount) {\n\t\t\tthis.verticesByteSize = offset;\n\t\t}\n\t\tthis._evaluateHash();\n\t}\n\tget elements() {\n\t\treturn this._elements;\n\t}\n\tstatic getDefaultInstancingFormat(graphicsDevice) {\n\t\treturn deviceCache.get(graphicsDevice, () => {\n\t\t\treturn new VertexFormat(graphicsDevice, [{\n\t\t\t\tsemantic: SEMANTIC_ATTR12,\n\t\t\t\tcomponents: 4,\n\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t}, {\n\t\t\t\tsemantic: SEMANTIC_ATTR13,\n\t\t\t\tcomponents: 4,\n\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t}, {\n\t\t\t\tsemantic: SEMANTIC_ATTR14,\n\t\t\t\tcomponents: 4,\n\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t}, {\n\t\t\t\tsemantic: SEMANTIC_ATTR15,\n\t\t\t\tcomponents: 4,\n\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t}]);\n\t\t});\n\t}\n\tstatic isElementValid(graphicsDevice, elementDesc) {\n\t\tconst elementSize = elementDesc.components * typedArrayTypesByteSize[elementDesc.type];\n\t\tif (graphicsDevice.isWebGPU && !webgpuValidElementSizes.includes(elementSize)) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tupdate() {\n\t\tthis._evaluateHash();\n\t}\n\t_evaluateHash() {\n\t\tconst stringElementsBatch = [];\n\t\tconst stringElementsRender = [];\n\t\tconst len = this._elements.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst {\n\t\t\t\tname,\n\t\t\t\tdataType,\n\t\t\t\tnumComponents,\n\t\t\t\tnormalize,\n\t\t\t\toffset,\n\t\t\t\tstride,\n\t\t\t\tsize,\n\t\t\t\tasInt\n\t\t\t} = this._elements[i];\n\t\t\tconst stringElementBatch = name + dataType + numComponents + normalize + asInt;\n\t\t\tstringElementsBatch.push(stringElementBatch);\n\t\t\tconst stringElementRender = stringElementBatch + offset + stride + size;\n\t\t\tstringElementsRender.push(stringElementRender);\n\t\t}\n\t\tstringElementsBatch.sort();\n\t\tconst batchingString = stringElementsBatch.join();\n\t\tthis.batchingHash = hashCode(batchingString);\n\t\tthis.shaderProcessingHashString = batchingString;\n\t\tthis.renderingHashString = stringElementsRender.join('_');\n\t\tthis.renderingHash = stringIds.get(this.renderingHashString);\n\t}\n}\n\nexport { VertexFormat };\n","import { typedArrayTypes } from './constants.js';\n\nfunction set1(a) {\n\tthis.array[this.index] = a;\n}\nfunction set2(a, b) {\n\tthis.array[this.index] = a;\n\tthis.array[this.index + 1] = b;\n}\nfunction set3(a, b, c) {\n\tthis.array[this.index] = a;\n\tthis.array[this.index + 1] = b;\n\tthis.array[this.index + 2] = c;\n}\nfunction set4(a, b, c, d) {\n\tthis.array[this.index] = a;\n\tthis.array[this.index + 1] = b;\n\tthis.array[this.index + 2] = c;\n\tthis.array[this.index + 3] = d;\n}\nfunction arraySet1(index, inputArray, inputIndex) {\n\tthis.array[index] = inputArray[inputIndex];\n}\nfunction arraySet2(index, inputArray, inputIndex) {\n\tthis.array[index] = inputArray[inputIndex];\n\tthis.array[index + 1] = inputArray[inputIndex + 1];\n}\nfunction arraySet3(index, inputArray, inputIndex) {\n\tthis.array[index] = inputArray[inputIndex];\n\tthis.array[index + 1] = inputArray[inputIndex + 1];\n\tthis.array[index + 2] = inputArray[inputIndex + 2];\n}\nfunction arraySet4(index, inputArray, inputIndex) {\n\tthis.array[index] = inputArray[inputIndex];\n\tthis.array[index + 1] = inputArray[inputIndex + 1];\n\tthis.array[index + 2] = inputArray[inputIndex + 2];\n\tthis.array[index + 3] = inputArray[inputIndex + 3];\n}\nfunction arrayGet1(offset, outputArray, outputIndex) {\n\toutputArray[outputIndex] = this.array[offset];\n}\nfunction arrayGet2(offset, outputArray, outputIndex) {\n\toutputArray[outputIndex] = this.array[offset];\n\toutputArray[outputIndex + 1] = this.array[offset + 1];\n}\nfunction arrayGet3(offset, outputArray, outputIndex) {\n\toutputArray[outputIndex] = this.array[offset];\n\toutputArray[outputIndex + 1] = this.array[offset + 1];\n\toutputArray[outputIndex + 2] = this.array[offset + 2];\n}\nfunction arrayGet4(offset, outputArray, outputIndex) {\n\toutputArray[outputIndex] = this.array[offset];\n\toutputArray[outputIndex + 1] = this.array[offset + 1];\n\toutputArray[outputIndex + 2] = this.array[offset + 2];\n\toutputArray[outputIndex + 3] = this.array[offset + 3];\n}\nclass VertexIteratorAccessor {\n\tconstructor(buffer, vertexElement, vertexFormat) {\n\t\tthis.index = 0;\n\t\tthis.numComponents = vertexElement.numComponents;\n\t\tif (vertexFormat.interleaved) {\n\t\t\tthis.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset);\n\t\t} else {\n\t\t\tthis.array = new typedArrayTypes[vertexElement.dataType](buffer, vertexElement.offset, vertexFormat.vertexCount * vertexElement.numComponents);\n\t\t}\n\t\tthis.stride = vertexElement.stride / this.array.constructor.BYTES_PER_ELEMENT;\n\t\tswitch (vertexElement.numComponents) {\n\t\t\tcase 1:\n\t\t\t\tthis.set = set1;\n\t\t\t\tthis.getToArray = arrayGet1;\n\t\t\t\tthis.setFromArray = arraySet1;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tthis.set = set2;\n\t\t\t\tthis.getToArray = arrayGet2;\n\t\t\t\tthis.setFromArray = arraySet2;\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\tthis.set = set3;\n\t\t\t\tthis.getToArray = arrayGet3;\n\t\t\t\tthis.setFromArray = arraySet3;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\tthis.set = set4;\n\t\t\t\tthis.getToArray = arrayGet4;\n\t\t\t\tthis.setFromArray = arraySet4;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tget(offset) {\n\t\treturn this.array[this.index + offset];\n\t}\n\tset(a, b, c, d) {}\n\tgetToArray(offset, outputArray, outputIndex) {}\n\tsetFromArray(index, inputArray, inputIndex) {}\n}\nclass VertexIterator {\n\tconstructor(vertexBuffer) {\n\t\tthis.vertexBuffer = vertexBuffer;\n\t\tthis.vertexFormatSize = vertexBuffer.getFormat().size;\n\t\tthis.buffer = this.vertexBuffer.lock();\n\t\tthis.accessors = [];\n\t\tthis.element = {};\n\t\tconst vertexFormat = this.vertexBuffer.getFormat();\n\t\tfor (let i = 0; i < vertexFormat.elements.length; i++) {\n\t\t\tconst vertexElement = vertexFormat.elements[i];\n\t\t\tthis.accessors[i] = new VertexIteratorAccessor(this.buffer, vertexElement, vertexFormat);\n\t\t\tthis.element[vertexElement.name] = this.accessors[i];\n\t\t}\n\t}\n\tnext(count = 1) {\n\t\tlet i = 0;\n\t\tconst accessors = this.accessors;\n\t\tconst numAccessors = this.accessors.length;\n\t\twhile (i < numAccessors) {\n\t\t\tconst accessor = accessors[i++];\n\t\t\taccessor.index += count * accessor.stride;\n\t\t}\n\t}\n\tend() {\n\t\tthis.vertexBuffer.unlock();\n\t}\n\twriteData(semantic, data, numVertices) {\n\t\tconst element = this.element[semantic];\n\t\tif (element) {\n\t\t\tif (numVertices > this.vertexBuffer.numVertices) {\n\t\t\t\tnumVertices = this.vertexBuffer.numVertices;\n\t\t\t}\n\t\t\tconst numComponents = element.numComponents;\n\t\t\tif (this.vertexBuffer.getFormat().interleaved) {\n\t\t\t\tlet index = 0;\n\t\t\t\tfor (let i = 0; i < numVertices; i++) {\n\t\t\t\t\telement.setFromArray(index, data, i * numComponents);\n\t\t\t\t\tindex += element.stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (data.length > numVertices * numComponents) {\n\t\t\t\t\tconst copyCount = numVertices * numComponents;\n\t\t\t\t\tif (ArrayBuffer.isView(data)) {\n\t\t\t\t\t\tdata = data.subarray(0, copyCount);\n\t\t\t\t\t\telement.array.set(data);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let i = 0; i < copyCount; i++) {\n\t\t\t\t\t\t\telement.array[i] = data[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\telement.array.set(data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treadData(semantic, data) {\n\t\tconst element = this.element[semantic];\n\t\tlet count = 0;\n\t\tif (element) {\n\t\t\tcount = this.vertexBuffer.numVertices;\n\t\t\tlet i;\n\t\t\tconst numComponents = element.numComponents;\n\t\t\tif (this.vertexBuffer.getFormat().interleaved) {\n\t\t\t\tif (Array.isArray(data)) {\n\t\t\t\t\tdata.length = 0;\n\t\t\t\t}\n\t\t\t\telement.index = 0;\n\t\t\t\tlet offset = 0;\n\t\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\t\telement.getToArray(offset, data, i * numComponents);\n\t\t\t\t\toffset += element.stride;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ArrayBuffer.isView(data)) {\n\t\t\t\t\tdata.set(element.array);\n\t\t\t\t} else {\n\t\t\t\t\tdata.length = 0;\n\t\t\t\t\tconst copyCount = count * numComponents;\n\t\t\t\t\tfor (i = 0; i < copyCount; i++) {\n\t\t\t\t\t\tdata[i] = element.array[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n}\n\nexport { VertexIterator, VertexIteratorAccessor };\n","import { BUFFER_GPUDYNAMIC, BUFFER_STREAM, BUFFER_DYNAMIC, BUFFER_STATIC } from '../constants.js';\n\nclass WebglBuffer {\n\tconstructor() {\n\t\tthis.bufferId = null;\n\t}\n\tdestroy(device) {\n\t\tif (this.bufferId) {\n\t\t\tdevice.gl.deleteBuffer(this.bufferId);\n\t\t\tthis.bufferId = null;\n\t\t}\n\t}\n\tget initialized() {\n\t\treturn !!this.bufferId;\n\t}\n\tloseContext() {\n\t\tthis.bufferId = null;\n\t}\n\tunlock(device, usage, target, storage) {\n\t\tconst gl = device.gl;\n\t\tif (!this.bufferId) {\n\t\t\tlet glUsage;\n\t\t\tswitch (usage) {\n\t\t\t\tcase BUFFER_STATIC:\n\t\t\t\t\tglUsage = gl.STATIC_DRAW;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUFFER_DYNAMIC:\n\t\t\t\t\tglUsage = gl.DYNAMIC_DRAW;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUFFER_STREAM:\n\t\t\t\t\tglUsage = gl.STREAM_DRAW;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BUFFER_GPUDYNAMIC:\n\t\t\t\t\tglUsage = device.isWebGL2 ? gl.DYNAMIC_COPY : gl.STATIC_DRAW;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tthis.bufferId = gl.createBuffer();\n\t\t\tgl.bindBuffer(target, this.bufferId);\n\t\t\tgl.bufferData(target, storage, glUsage);\n\t\t} else {\n\t\t\tgl.bindBuffer(target, this.bufferId);\n\t\t\tgl.bufferSubData(target, 0, storage);\n\t\t}\n\t}\n}\n\nexport { WebglBuffer };\n","import { GpuProfiler } from '../gpu-profiler.js';\n\nclass FrameQueriesInfo {\n\tconstructor() {\n\t\tthis.renderVersion = void 0;\n\t\tthis.queries = [];\n\t}\n\tdestroy(gl) {\n\t\tthis.queries.forEach(query => gl.deleteQuery(query));\n\t\tthis.queries = null;\n\t}\n}\nclass WebglGpuProfiler extends GpuProfiler {\n\tconstructor(device) {\n\t\tsuper();\n\t\tthis.device = void 0;\n\t\tthis.freeQueries = [];\n\t\tthis.frameQueries = [];\n\t\tthis.previousFrameQueries = [];\n\t\tthis.timings = [];\n\t\tthis.device = device;\n\t\tthis.ext = device.extDisjointTimerQuery;\n\t}\n\tdestroy() {\n\t\tthis.freeQueries.forEach(query => this.device.gl.deleteQuery(query));\n\t\tthis.frameQueries.forEach(query => this.device.gl.deleteQuery(query));\n\t\tthis.previousFrameQueries.forEach(frameQueriesInfo => frameQueriesInfo.destroy(this.device.gl));\n\t\tthis.freeQueries = null;\n\t\tthis.frameQueries = null;\n\t\tthis.previousFrameQueries = null;\n\t}\n\tloseContext() {\n\t\tsuper.loseContext();\n\t\tthis.freeQueries = [];\n\t\tthis.frameQueries = [];\n\t\tthis.previousFrameQueries = [];\n\t}\n\trestoreContext() {\n\t\tthis.ext = this.device.extDisjointTimerQuery;\n\t}\n\tgetQuery() {\n\t\tvar _this$freeQueries$pop;\n\t\treturn (_this$freeQueries$pop = this.freeQueries.pop()) != null ? _this$freeQueries$pop : this.device.gl.createQuery();\n\t}\n\tstart(name) {\n\t\tif (this.ext) {\n\t\t\tconst slot = this.getSlot(name);\n\t\t\tconst query = this.getQuery();\n\t\t\tthis.frameQueries[slot] = query;\n\t\t\tthis.device.gl.beginQuery(this.ext.TIME_ELAPSED_EXT, query);\n\t\t\treturn slot;\n\t\t}\n\t\treturn undefined;\n\t}\n\tend(slot) {\n\t\tif (slot !== undefined) {\n\t\t\tthis.device.gl.endQuery(this.ext.TIME_ELAPSED_EXT);\n\t\t}\n\t}\n\tframeStart() {\n\t\tthis.processEnableRequest();\n\t\tif (this._enabled) {\n\t\t\tthis.frameGPUMarkerSlot = this.start('GpuFrame');\n\t\t}\n\t}\n\tframeEnd() {\n\t\tif (this._enabled) {\n\t\t\tthis.end(this.frameGPUMarkerSlot);\n\t\t}\n\t}\n\trequest() {\n\t\tif (this._enabled) {\n\t\t\tconst ext = this.ext;\n\t\t\tconst gl = this.device.gl;\n\t\t\tconst renderVersion = this.device.renderVersion;\n\t\t\tconst frameQueries = this.frameQueries;\n\t\t\tif (frameQueries.length > 0) {\n\t\t\t\tthis.frameQueries = [];\n\t\t\t\tconst frameQueriesInfo = new FrameQueriesInfo();\n\t\t\t\tframeQueriesInfo.queries = frameQueries;\n\t\t\t\tframeQueriesInfo.renderVersion = renderVersion;\n\t\t\t\tthis.previousFrameQueries.push(frameQueriesInfo);\n\t\t\t}\n\t\t\tif (this.previousFrameQueries.length > 0) {\n\t\t\t\tconst previousQueriesInfo = this.previousFrameQueries[0];\n\t\t\t\tconst previousQueries = previousQueriesInfo.queries;\n\t\t\t\tconst lastQuery = previousQueries[previousQueries.length - 1];\n\t\t\t\tconst available = gl.getQueryParameter(lastQuery, gl.QUERY_RESULT_AVAILABLE);\n\t\t\t\tconst disjoint = gl.getParameter(ext.GPU_DISJOINT_EXT);\n\t\t\t\tif (available && !disjoint) {\n\t\t\t\t\tthis.previousFrameQueries.shift();\n\t\t\t\t\tconst timings = this.timings;\n\t\t\t\t\ttimings.length = 0;\n\t\t\t\t\tfor (let i = 0; i < previousQueries.length; i++) {\n\t\t\t\t\t\tconst query = previousQueries[i];\n\t\t\t\t\t\tconst duration = gl.getQueryParameter(query, gl.QUERY_RESULT);\n\t\t\t\t\t\ttimings[i] = duration * 0.000001;\n\t\t\t\t\t\tthis.freeQueries.push(query);\n\t\t\t\t\t}\n\t\t\t\t\tthis.report(previousQueriesInfo.renderVersion, timings);\n\t\t\t\t}\n\t\t\t\tif (disjoint) {\n\t\t\t\t\tthis.previousFrameQueries.forEach(frameQueriesInfo => {\n\t\t\t\t\t\tthis.report(frameQueriesInfo.renderVersion, null);\n\t\t\t\t\t\tframeQueriesInfo.destroy(gl);\n\t\t\t\t\t});\n\t\t\t\t\tthis.previousFrameQueries.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsuper.request(renderVersion);\n\t\t}\n\t}\n}\n\nexport { WebglGpuProfiler };\n","import { math } from '../../../core/math/math.js';\nimport { platform } from '../../../core/platform.js';\nimport { Color } from '../../../core/math/color.js';\nimport { DEVICETYPE_WEBGL2, DEVICETYPE_WEBGL1, UNIFORMTYPE_BOOL, UNIFORMTYPE_INT, UNIFORMTYPE_FLOAT, UNIFORMTYPE_VEC2, UNIFORMTYPE_VEC3, UNIFORMTYPE_VEC4, UNIFORMTYPE_IVEC2, UNIFORMTYPE_IVEC3, UNIFORMTYPE_IVEC4, UNIFORMTYPE_BVEC2, UNIFORMTYPE_BVEC3, UNIFORMTYPE_BVEC4, UNIFORMTYPE_MAT2, UNIFORMTYPE_MAT3, UNIFORMTYPE_MAT4, UNIFORMTYPE_TEXTURE2D, UNIFORMTYPE_TEXTURECUBE, UNIFORMTYPE_UINT, UNIFORMTYPE_UVEC2, UNIFORMTYPE_UVEC3, UNIFORMTYPE_UVEC4, UNIFORMTYPE_TEXTURE2D_SHADOW, UNIFORMTYPE_TEXTURECUBE_SHADOW, UNIFORMTYPE_TEXTURE2D_ARRAY, UNIFORMTYPE_TEXTURE3D, UNIFORMTYPE_ITEXTURE2D, UNIFORMTYPE_UTEXTURE2D, UNIFORMTYPE_ITEXTURECUBE, UNIFORMTYPE_UTEXTURECUBE, UNIFORMTYPE_ITEXTURE3D, UNIFORMTYPE_UTEXTURE3D, UNIFORMTYPE_ITEXTURE2D_ARRAY, UNIFORMTYPE_UTEXTURE2D_ARRAY, UNIFORMTYPE_FLOATARRAY, UNIFORMTYPE_VEC2ARRAY, UNIFORMTYPE_VEC3ARRAY, UNIFORMTYPE_VEC4ARRAY, UNIFORMTYPE_INTARRAY, UNIFORMTYPE_UINTARRAY, UNIFORMTYPE_BOOLARRAY, UNIFORMTYPE_IVEC2ARRAY, UNIFORMTYPE_UVEC2ARRAY, UNIFORMTYPE_BVEC2ARRAY, UNIFORMTYPE_IVEC3ARRAY, UNIFORMTYPE_UVEC3ARRAY, UNIFORMTYPE_BVEC3ARRAY, UNIFORMTYPE_IVEC4ARRAY, UNIFORMTYPE_UVEC4ARRAY, UNIFORMTYPE_BVEC4ARRAY, UNIFORMTYPE_MAT4ARRAY, PIXELFORMAT_RGBA8, PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F, PIXELFORMAT_RGB8, FUNC_ALWAYS, STENCILOP_KEEP, ADDRESS_CLAMP_TO_EDGE, semanticToLocation, CLEARFLAG_COLOR, CLEARFLAG_DEPTH, CLEARFLAG_STENCIL, CULLFACE_NONE, PRIMITIVE_TRISTRIP, FILTER_NEAREST_MIPMAP_NEAREST, FILTER_NEAREST_MIPMAP_LINEAR, FILTER_NEAREST, FILTER_LINEAR_MIPMAP_NEAREST, FILTER_LINEAR_MIPMAP_LINEAR, FILTER_LINEAR } from '../constants.js';\nimport { GraphicsDevice } from '../graphics-device.js';\nimport { RenderTarget } from '../render-target.js';\nimport { Texture } from '../texture.js';\nimport { WebglVertexBuffer } from './webgl-vertex-buffer.js';\nimport { WebglIndexBuffer } from './webgl-index-buffer.js';\nimport { WebglShader } from './webgl-shader.js';\nimport { WebglTexture } from './webgl-texture.js';\nimport { WebglRenderTarget } from './webgl-render-target.js';\nimport { ShaderUtils } from '../shader-utils.js';\nimport { Shader } from '../shader.js';\nimport { BlendState } from '../blend-state.js';\nimport { DepthState } from '../depth-state.js';\nimport { StencilParameters } from '../stencil-parameters.js';\nimport { WebglGpuProfiler } from './webgl-gpu-profiler.js';\n\nconst invalidateAttachments = [];\nconst _fullScreenQuadVS = `\nattribute vec2 vertex_position;\nvarying vec2 vUv0;\nvoid main(void)\n{\n\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\tvUv0 = vertex_position.xy*0.5+0.5;\n}\n`;\nconst _precisionTest1PS = `\nvoid main(void) { \n\tgl_FragColor = vec4(2147483648.0);\n}\n`;\nconst _precisionTest2PS = `\nuniform sampler2D source;\nvec4 packFloat(float depth) {\n\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n\tconst vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\nvoid main(void) {\n\tfloat c = texture2D(source, vec2(0.0)).r;\n\tfloat diff = abs(c - 2147483648.0) / 2147483648.0;\n\tgl_FragColor = packFloat(diff);\n}\n`;\nconst _outputTexture2D = `\nvarying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n\tgl_FragColor = texture2D(source, vUv0);\n}\n`;\nfunction quadWithShader(device, target, shader) {\n\tconst oldRt = device.renderTarget;\n\tdevice.setRenderTarget(target);\n\tdevice.updateBegin();\n\tdevice.setCullMode(CULLFACE_NONE);\n\tdevice.setBlendState(BlendState.NOBLEND);\n\tdevice.setDepthState(DepthState.NODEPTH);\n\tdevice.setStencilState(null, null);\n\tdevice.setVertexBuffer(device.quadVertexBuffer, 0);\n\tdevice.setShader(shader);\n\tdevice.draw({\n\t\ttype: PRIMITIVE_TRISTRIP,\n\t\tbase: 0,\n\t\tcount: 4,\n\t\tindexed: false\n\t});\n\tdevice.updateEnd();\n\tdevice.setRenderTarget(oldRt);\n\tdevice.updateBegin();\n}\nfunction testRenderable(gl, pixelFormat) {\n\tlet result = true;\n\tconst texture = gl.createTexture();\n\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, pixelFormat, null);\n\tconst framebuffer = gl.createFramebuffer();\n\tgl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n\tif (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {\n\t\tresult = false;\n\t}\n\tgl.bindTexture(gl.TEXTURE_2D, null);\n\tgl.deleteTexture(texture);\n\tgl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\tgl.deleteFramebuffer(framebuffer);\n\treturn result;\n}\nfunction testTextureHalfFloatUpdatable(gl, pixelFormat) {\n\tlet result = true;\n\tconst texture = gl.createTexture();\n\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\tconst data = new Uint16Array(4 * 2 * 2);\n\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 2, 2, 0, gl.RGBA, pixelFormat, data);\n\tif (gl.getError() !== gl.NO_ERROR) {\n\t\tresult = false;\n\t\tconsole.log('Above error related to HALF_FLOAT_OES can be ignored, it was triggered by testing half float texture support');\n\t}\n\tgl.bindTexture(gl.TEXTURE_2D, null);\n\tgl.deleteTexture(texture);\n\treturn result;\n}\nfunction testTextureFloatHighPrecision(device) {\n\tif (!device.textureFloatRenderable) {\n\t\treturn false;\n\t}\n\tconst shader1 = new Shader(device, ShaderUtils.createDefinition(device, {\n\t\tname: 'ptest1',\n\t\tvertexCode: _fullScreenQuadVS,\n\t\tfragmentCode: _precisionTest1PS\n\t}));\n\tconst shader2 = new Shader(device, ShaderUtils.createDefinition(device, {\n\t\tname: 'ptest2',\n\t\tvertexCode: _fullScreenQuadVS,\n\t\tfragmentCode: _precisionTest2PS\n\t}));\n\tconst textureOptions = {\n\t\tformat: PIXELFORMAT_RGBA32F,\n\t\twidth: 1,\n\t\theight: 1,\n\t\tmipmaps: false,\n\t\tminFilter: FILTER_NEAREST,\n\t\tmagFilter: FILTER_NEAREST,\n\t\tname: 'testFHP'\n\t};\n\tconst tex1 = new Texture(device, textureOptions);\n\tconst targ1 = new RenderTarget({\n\t\tcolorBuffer: tex1,\n\t\tdepth: false\n\t});\n\tquadWithShader(device, targ1, shader1);\n\ttextureOptions.format = PIXELFORMAT_RGBA8;\n\tconst tex2 = new Texture(device, textureOptions);\n\tconst targ2 = new RenderTarget({\n\t\tcolorBuffer: tex2,\n\t\tdepth: false\n\t});\n\tdevice.constantTexSource.setValue(tex1);\n\tquadWithShader(device, targ2, shader2);\n\tconst prevFramebuffer = device.activeFramebuffer;\n\tdevice.setFramebuffer(targ2.impl._glFrameBuffer);\n\tconst pixels = new Uint8Array(4);\n\tdevice.readPixels(0, 0, 1, 1, pixels);\n\tdevice.setFramebuffer(prevFramebuffer);\n\tconst x = pixels[0] / 255;\n\tconst y = pixels[1] / 255;\n\tconst z = pixels[2] / 255;\n\tconst w = pixels[3] / 255;\n\tconst f = x / (256 * 256 * 256) + y / (256 * 256) + z / 256 + w;\n\ttex1.destroy();\n\ttarg1.destroy();\n\ttex2.destroy();\n\ttarg2.destroy();\n\tshader1.destroy();\n\tshader2.destroy();\n\treturn f === 0;\n}\nclass WebglGraphicsDevice extends GraphicsDevice {\n\tconstructor(canvas, options = {}) {\n\t\tvar _options$antialias;\n\t\tsuper(canvas, options);\n\t\tthis.gl = void 0;\n\t\tthis._defaultFramebuffer = null;\n\t\tthis._defaultFramebufferChanged = false;\n\t\toptions = this.initOptions;\n\t\tthis.updateClientRect();\n\t\tthis.initTextureUnits();\n\t\tthis.contextLost = false;\n\t\tthis._contextLostHandler = event => {\n\t\t\tevent.preventDefault();\n\t\t\tthis.loseContext();\n\t\t\tthis.fire('devicelost');\n\t\t};\n\t\tthis._contextRestoredHandler = () => {\n\t\t\tthis.restoreContext();\n\t\t\tthis.fire('devicerestored');\n\t\t};\n\t\tconst ua = typeof navigator !== 'undefined' && navigator.userAgent;\n\t\tthis.forceDisableMultisampling = ua && ua.includes('AppleWebKit') && (ua.includes('15.4') || ua.includes('15_4'));\n\t\tif (this.forceDisableMultisampling) {\n\t\t\toptions.antialias = false;\n\t\t}\n\t\tif (platform.browserName === 'firefox') {\n\t\t\tconst _ua = typeof navigator !== 'undefined' ? navigator.userAgent : '';\n\t\t\tconst match = _ua.match(/Firefox\\/(\\d+(\\.\\d+)*)/);\n\t\t\tconst firefoxVersion = match ? match[1] : null;\n\t\t\tif (firefoxVersion) {\n\t\t\t\tconst version = parseFloat(firefoxVersion);\n\t\t\t\tconst disableAntialias = platform.name === 'windows' && (version >= 120 || version === 115) || platform.name === 'android' && version >= 132;\n\t\t\t\tif (disableAntialias) {\n\t\t\t\t\toptions.antialias = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet gl = null;\n\t\tthis.backBufferAntialias = (_options$antialias = options.antialias) != null ? _options$antialias : false;\n\t\toptions.antialias = false;\n\t\tif (options.gl) {\n\t\t\tgl = options.gl;\n\t\t} else {\n\t\t\tconst preferWebGl2 = options.preferWebGl2 !== undefined ? options.preferWebGl2 : true;\n\t\t\tconst names = preferWebGl2 ? ['webgl2', 'webgl', 'experimental-webgl'] : ['webgl', 'experimental-webgl'];\n\t\t\tfor (let i = 0; i < names.length; i++) {\n\t\t\t\tgl = canvas.getContext(names[i], options);\n\t\t\t\tif (gl) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!gl) {\n\t\t\tthrow new Error('WebGL not supported');\n\t\t}\n\t\tthis.gl = gl;\n\t\tthis.isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;\n\t\tthis.isWebGL1 = !this.isWebGL2;\n\t\tthis._deviceType = this.isWebGL2 ? DEVICETYPE_WEBGL2 : DEVICETYPE_WEBGL1;\n\t\tthis.updateBackbufferFormat(null);\n\t\tconst isChrome = platform.browserName === 'chrome';\n\t\tconst isSafari = platform.browserName === 'safari';\n\t\tconst isMac = platform.browser && navigator.appVersion.indexOf('Mac') !== -1;\n\t\tthis._tempEnableSafariTextureUnitWorkaround = isSafari;\n\t\tthis._tempMacChromeBlitFramebufferWorkaround = isMac && isChrome && !options.alpha;\n\t\tcanvas.addEventListener('webglcontextlost', this._contextLostHandler, false);\n\t\tcanvas.addEventListener('webglcontextrestored', this._contextRestoredHandler, false);\n\t\tthis.initializeExtensions();\n\t\tthis.initializeCapabilities();\n\t\tthis.initializeRenderState();\n\t\tthis.initializeContextCaches();\n\t\tthis.createBackbuffer(null);\n\t\tthis.supportsImageBitmap = !isSafari && typeof ImageBitmap !== 'undefined';\n\t\tthis._samplerTypes = new Set([...[gl.SAMPLER_2D, gl.SAMPLER_CUBE], ...(this.isWebGL2 ? [gl.UNSIGNED_INT_SAMPLER_2D, gl.INT_SAMPLER_2D, gl.SAMPLER_2D_SHADOW, gl.SAMPLER_CUBE_SHADOW, gl.SAMPLER_3D, gl.INT_SAMPLER_3D, gl.UNSIGNED_INT_SAMPLER_3D, gl.SAMPLER_2D_ARRAY, gl.INT_SAMPLER_2D_ARRAY, gl.UNSIGNED_INT_SAMPLER_2D_ARRAY] : [])]);\n\t\tthis.glAddress = [gl.REPEAT, gl.CLAMP_TO_EDGE, gl.MIRRORED_REPEAT];\n\t\tthis.glBlendEquation = [gl.FUNC_ADD, gl.FUNC_SUBTRACT, gl.FUNC_REVERSE_SUBTRACT, this.isWebGL2 ? gl.MIN : this.extBlendMinmax ? this.extBlendMinmax.MIN_EXT : gl.FUNC_ADD, this.isWebGL2 ? gl.MAX : this.extBlendMinmax ? this.extBlendMinmax.MAX_EXT : gl.FUNC_ADD];\n\t\tthis.glBlendFunctionColor = [gl.ZERO, gl.ONE, gl.SRC_COLOR, gl.ONE_MINUS_SRC_COLOR, gl.DST_COLOR, gl.ONE_MINUS_DST_COLOR, gl.SRC_ALPHA, gl.SRC_ALPHA_SATURATE, gl.ONE_MINUS_SRC_ALPHA, gl.DST_ALPHA, gl.ONE_MINUS_DST_ALPHA, gl.CONSTANT_COLOR, gl.ONE_MINUS_CONSTANT_COLOR];\n\t\tthis.glBlendFunctionAlpha = [gl.ZERO, gl.ONE, gl.SRC_COLOR, gl.ONE_MINUS_SRC_COLOR, gl.DST_COLOR, gl.ONE_MINUS_DST_COLOR, gl.SRC_ALPHA, gl.SRC_ALPHA_SATURATE, gl.ONE_MINUS_SRC_ALPHA, gl.DST_ALPHA, gl.ONE_MINUS_DST_ALPHA, gl.CONSTANT_ALPHA, gl.ONE_MINUS_CONSTANT_ALPHA];\n\t\tthis.glComparison = [gl.NEVER, gl.LESS, gl.EQUAL, gl.LEQUAL, gl.GREATER, gl.NOTEQUAL, gl.GEQUAL, gl.ALWAYS];\n\t\tthis.glStencilOp = [gl.KEEP, gl.ZERO, gl.REPLACE, gl.INCR, gl.INCR_WRAP, gl.DECR, gl.DECR_WRAP, gl.INVERT];\n\t\tthis.glClearFlag = [0, gl.COLOR_BUFFER_BIT, gl.DEPTH_BUFFER_BIT, gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.DEPTH_BUFFER_BIT, gl.STENCIL_BUFFER_BIT | gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT];\n\t\tthis.glCull = [0, gl.BACK, gl.FRONT, gl.FRONT_AND_BACK];\n\t\tthis.glFilter = [gl.NEAREST, gl.LINEAR, gl.NEAREST_MIPMAP_NEAREST, gl.NEAREST_MIPMAP_LINEAR, gl.LINEAR_MIPMAP_NEAREST, gl.LINEAR_MIPMAP_LINEAR];\n\t\tthis.glPrimitive = [gl.POINTS, gl.LINES, gl.LINE_LOOP, gl.LINE_STRIP, gl.TRIANGLES, gl.TRIANGLE_STRIP, gl.TRIANGLE_FAN];\n\t\tthis.glType = [gl.BYTE, gl.UNSIGNED_BYTE, gl.SHORT, gl.UNSIGNED_SHORT, gl.INT, gl.UNSIGNED_INT, gl.FLOAT, gl.HALF_FLOAT];\n\t\tthis.pcUniformType = {};\n\t\tthis.pcUniformType[gl.BOOL] = UNIFORMTYPE_BOOL;\n\t\tthis.pcUniformType[gl.INT] = UNIFORMTYPE_INT;\n\t\tthis.pcUniformType[gl.FLOAT] = UNIFORMTYPE_FLOAT;\n\t\tthis.pcUniformType[gl.FLOAT_VEC2] = UNIFORMTYPE_VEC2;\n\t\tthis.pcUniformType[gl.FLOAT_VEC3] = UNIFORMTYPE_VEC3;\n\t\tthis.pcUniformType[gl.FLOAT_VEC4] = UNIFORMTYPE_VEC4;\n\t\tthis.pcUniformType[gl.INT_VEC2] = UNIFORMTYPE_IVEC2;\n\t\tthis.pcUniformType[gl.INT_VEC3] = UNIFORMTYPE_IVEC3;\n\t\tthis.pcUniformType[gl.INT_VEC4] = UNIFORMTYPE_IVEC4;\n\t\tthis.pcUniformType[gl.BOOL_VEC2] = UNIFORMTYPE_BVEC2;\n\t\tthis.pcUniformType[gl.BOOL_VEC3] = UNIFORMTYPE_BVEC3;\n\t\tthis.pcUniformType[gl.BOOL_VEC4] = UNIFORMTYPE_BVEC4;\n\t\tthis.pcUniformType[gl.FLOAT_MAT2] = UNIFORMTYPE_MAT2;\n\t\tthis.pcUniformType[gl.FLOAT_MAT3] = UNIFORMTYPE_MAT3;\n\t\tthis.pcUniformType[gl.FLOAT_MAT4] = UNIFORMTYPE_MAT4;\n\t\tthis.pcUniformType[gl.SAMPLER_2D] = UNIFORMTYPE_TEXTURE2D;\n\t\tthis.pcUniformType[gl.SAMPLER_CUBE] = UNIFORMTYPE_TEXTURECUBE;\n\t\tthis.pcUniformType[gl.UNSIGNED_INT] = UNIFORMTYPE_UINT;\n\t\tthis.pcUniformType[gl.UNSIGNED_INT_VEC2] = UNIFORMTYPE_UVEC2;\n\t\tthis.pcUniformType[gl.UNSIGNED_INT_VEC3] = UNIFORMTYPE_UVEC3;\n\t\tthis.pcUniformType[gl.UNSIGNED_INT_VEC4] = UNIFORMTYPE_UVEC4;\n\t\tif (this.isWebGL2) {\n\t\t\tthis.pcUniformType[gl.SAMPLER_2D_SHADOW] = UNIFORMTYPE_TEXTURE2D_SHADOW;\n\t\t\tthis.pcUniformType[gl.SAMPLER_CUBE_SHADOW] = UNIFORMTYPE_TEXTURECUBE_SHADOW;\n\t\t\tthis.pcUniformType[gl.SAMPLER_2D_ARRAY] = UNIFORMTYPE_TEXTURE2D_ARRAY;\n\t\t\tthis.pcUniformType[gl.SAMPLER_3D] = UNIFORMTYPE_TEXTURE3D;\n\t\t\tthis.pcUniformType[gl.INT_SAMPLER_2D] = UNIFORMTYPE_ITEXTURE2D;\n\t\t\tthis.pcUniformType[gl.UNSIGNED_INT_SAMPLER_2D] = UNIFORMTYPE_UTEXTURE2D;\n\t\t\tthis.pcUniformType[gl.INT_SAMPLER_CUBE] = UNIFORMTYPE_ITEXTURECUBE;\n\t\t\tthis.pcUniformType[gl.UNSIGNED_INT_SAMPLER_2D] = UNIFORMTYPE_UTEXTURECUBE;\n\t\t\tthis.pcUniformType[gl.INT_SAMPLER_3D] = UNIFORMTYPE_ITEXTURE3D;\n\t\t\tthis.pcUniformType[gl.UNSIGNED_INT_SAMPLER_3D] = UNIFORMTYPE_UTEXTURE3D;\n\t\t\tthis.pcUniformType[gl.INT_SAMPLER_2D_ARRAY] = UNIFORMTYPE_ITEXTURE2D_ARRAY;\n\t\t\tthis.pcUniformType[gl.UNSIGNED_INT_SAMPLER_2D_ARRAY] = UNIFORMTYPE_UTEXTURE2D_ARRAY;\n\t\t}\n\t\tthis.targetToSlot = {};\n\t\tthis.targetToSlot[gl.TEXTURE_2D] = 0;\n\t\tthis.targetToSlot[gl.TEXTURE_CUBE_MAP] = 1;\n\t\tthis.targetToSlot[gl.TEXTURE_3D] = 2;\n\t\tlet scopeX, scopeY, scopeZ, scopeW;\n\t\tlet uniformValue;\n\t\tthis.commitFunction = [];\n\t\tthis.commitFunction[UNIFORMTYPE_BOOL] = function (uniform, value) {\n\t\t\tif (uniform.value !== value) {\n\t\t\t\tgl.uniform1i(uniform.locationId, value);\n\t\t\t\tuniform.value = value;\n\t\t\t}\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_INT] = this.commitFunction[UNIFORMTYPE_BOOL];\n\t\tthis.commitFunction[UNIFORMTYPE_FLOAT] = function (uniform, value) {\n\t\t\tif (uniform.value !== value) {\n\t\t\t\tgl.uniform1f(uniform.locationId, value);\n\t\t\t\tuniform.value = value;\n\t\t\t}\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_VEC2] = function (uniform, value) {\n\t\t\tuniformValue = uniform.value;\n\t\t\tscopeX = value[0];\n\t\t\tscopeY = value[1];\n\t\t\tif (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {\n\t\t\t\tgl.uniform2fv(uniform.locationId, value);\n\t\t\t\tuniformValue[0] = scopeX;\n\t\t\t\tuniformValue[1] = scopeY;\n\t\t\t}\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_VEC3] = function (uniform, value) {\n\t\t\tuniformValue = uniform.value;\n\t\t\tscopeX = value[0];\n\t\t\tscopeY = value[1];\n\t\t\tscopeZ = value[2];\n\t\t\tif (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {\n\t\t\t\tgl.uniform3fv(uniform.locationId, value);\n\t\t\t\tuniformValue[0] = scopeX;\n\t\t\t\tuniformValue[1] = scopeY;\n\t\t\t\tuniformValue[2] = scopeZ;\n\t\t\t}\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_VEC4] = function (uniform, value) {\n\t\t\tuniformValue = uniform.value;\n\t\t\tscopeX = value[0];\n\t\t\tscopeY = value[1];\n\t\t\tscopeZ = value[2];\n\t\t\tscopeW = value[3];\n\t\t\tif (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {\n\t\t\t\tgl.uniform4fv(uniform.locationId, value);\n\t\t\t\tuniformValue[0] = scopeX;\n\t\t\t\tuniformValue[1] = scopeY;\n\t\t\t\tuniformValue[2] = scopeZ;\n\t\t\t\tuniformValue[3] = scopeW;\n\t\t\t}\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_IVEC2] = function (uniform, value) {\n\t\t\tuniformValue = uniform.value;\n\t\t\tscopeX = value[0];\n\t\t\tscopeY = value[1];\n\t\t\tif (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {\n\t\t\t\tgl.uniform2iv(uniform.locationId, value);\n\t\t\t\tuniformValue[0] = scopeX;\n\t\t\t\tuniformValue[1] = scopeY;\n\t\t\t}\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_BVEC2] = this.commitFunction[UNIFORMTYPE_IVEC2];\n\t\tthis.commitFunction[UNIFORMTYPE_IVEC3] = function (uniform, value) {\n\t\t\tuniformValue = uniform.value;\n\t\t\tscopeX = value[0];\n\t\t\tscopeY = value[1];\n\t\t\tscopeZ = value[2];\n\t\t\tif (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {\n\t\t\t\tgl.uniform3iv(uniform.locationId, value);\n\t\t\t\tuniformValue[0] = scopeX;\n\t\t\t\tuniformValue[1] = scopeY;\n\t\t\t\tuniformValue[2] = scopeZ;\n\t\t\t}\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_BVEC3] = this.commitFunction[UNIFORMTYPE_IVEC3];\n\t\tthis.commitFunction[UNIFORMTYPE_IVEC4] = function (uniform, value) {\n\t\t\tuniformValue = uniform.value;\n\t\t\tscopeX = value[0];\n\t\t\tscopeY = value[1];\n\t\t\tscopeZ = value[2];\n\t\t\tscopeW = value[3];\n\t\t\tif (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {\n\t\t\t\tgl.uniform4iv(uniform.locationId, value);\n\t\t\t\tuniformValue[0] = scopeX;\n\t\t\t\tuniformValue[1] = scopeY;\n\t\t\t\tuniformValue[2] = scopeZ;\n\t\t\t\tuniformValue[3] = scopeW;\n\t\t\t}\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_BVEC4] = this.commitFunction[UNIFORMTYPE_IVEC4];\n\t\tthis.commitFunction[UNIFORMTYPE_MAT2] = function (uniform, value) {\n\t\t\tgl.uniformMatrix2fv(uniform.locationId, false, value);\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_MAT3] = function (uniform, value) {\n\t\t\tgl.uniformMatrix3fv(uniform.locationId, false, value);\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_MAT4] = function (uniform, value) {\n\t\t\tgl.uniformMatrix4fv(uniform.locationId, false, value);\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_FLOATARRAY] = function (uniform, value) {\n\t\t\tgl.uniform1fv(uniform.locationId, value);\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_VEC2ARRAY] = function (uniform, value) {\n\t\t\tgl.uniform2fv(uniform.locationId, value);\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_VEC3ARRAY] = function (uniform, value) {\n\t\t\tgl.uniform3fv(uniform.locationId, value);\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_VEC4ARRAY] = function (uniform, value) {\n\t\t\tgl.uniform4fv(uniform.locationId, value);\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_UINT] = function (uniform, value) {\n\t\t\tif (uniform.value !== value) {\n\t\t\t\tgl.uniform1ui(uniform.locationId, value);\n\t\t\t\tuniform.value = value;\n\t\t\t}\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_UVEC2] = function (uniform, value) {\n\t\t\tuniformValue = uniform.value;\n\t\t\tscopeX = value[0];\n\t\t\tscopeY = value[1];\n\t\t\tif (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY) {\n\t\t\t\tgl.uniform2uiv(uniform.locationId, value);\n\t\t\t\tuniformValue[0] = scopeX;\n\t\t\t\tuniformValue[1] = scopeY;\n\t\t\t}\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_UVEC3] = function (uniform, value) {\n\t\t\tuniformValue = uniform.value;\n\t\t\tscopeX = value[0];\n\t\t\tscopeY = value[1];\n\t\t\tscopeZ = value[2];\n\t\t\tif (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ) {\n\t\t\t\tgl.uniform3uiv(uniform.locationId, value);\n\t\t\t\tuniformValue[0] = scopeX;\n\t\t\t\tuniformValue[1] = scopeY;\n\t\t\t\tuniformValue[2] = scopeZ;\n\t\t\t}\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_UVEC4] = function (uniform, value) {\n\t\t\tuniformValue = uniform.value;\n\t\t\tscopeX = value[0];\n\t\t\tscopeY = value[1];\n\t\t\tscopeZ = value[2];\n\t\t\tscopeW = value[3];\n\t\t\tif (uniformValue[0] !== scopeX || uniformValue[1] !== scopeY || uniformValue[2] !== scopeZ || uniformValue[3] !== scopeW) {\n\t\t\t\tgl.uniform4uiv(uniform.locationId, value);\n\t\t\t\tuniformValue[0] = scopeX;\n\t\t\t\tuniformValue[1] = scopeY;\n\t\t\t\tuniformValue[2] = scopeZ;\n\t\t\t\tuniformValue[3] = scopeW;\n\t\t\t}\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_INTARRAY] = function (uniform, value) {\n\t\t\tgl.uniform1iv(uniform.locationId, value);\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_UINTARRAY] = function (uniform, value) {\n\t\t\tgl.uniform1uiv(uniform.locationId, value);\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_BOOLARRAY] = this.commitFunction[UNIFORMTYPE_INTARRAY];\n\t\tthis.commitFunction[UNIFORMTYPE_IVEC2ARRAY] = function (uniform, value) {\n\t\t\tgl.uniform2iv(uniform.locationId, value);\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_UVEC2ARRAY] = function (uniform, value) {\n\t\t\tgl.uniform2uiv(uniform.locationId, value);\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_BVEC2ARRAY] = this.commitFunction[UNIFORMTYPE_IVEC2ARRAY];\n\t\tthis.commitFunction[UNIFORMTYPE_IVEC3ARRAY] = function (uniform, value) {\n\t\t\tgl.uniform3iv(uniform.locationId, value);\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_UVEC3ARRAY] = function (uniform, value) {\n\t\t\tgl.uniform3uiv(uniform.locationId, value);\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_BVEC3ARRAY] = this.commitFunction[UNIFORMTYPE_IVEC3ARRAY];\n\t\tthis.commitFunction[UNIFORMTYPE_IVEC4ARRAY] = function (uniform, value) {\n\t\t\tgl.uniform4iv(uniform.locationId, value);\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_UVEC4ARRAY] = function (uniform, value) {\n\t\t\tgl.uniform4uiv(uniform.locationId, value);\n\t\t};\n\t\tthis.commitFunction[UNIFORMTYPE_BVEC4ARRAY] = this.commitFunction[UNIFORMTYPE_IVEC4ARRAY];\n\t\tthis.commitFunction[UNIFORMTYPE_MAT4ARRAY] = function (uniform, value) {\n\t\t\tgl.uniformMatrix4fv(uniform.locationId, false, value);\n\t\t};\n\t\tthis.supportsBoneTextures = this.extTextureFloat && this.maxVertexTextures > 0;\n\t\tlet numUniforms = this.vertexUniformsCount;\n\t\tnumUniforms -= 4 * 4;\n\t\tnumUniforms -= 8;\n\t\tnumUniforms -= 1;\n\t\tnumUniforms -= 4 * 4;\n\t\tthis.boneLimit = Math.floor(numUniforms / 3);\n\t\tthis.boneLimit = Math.min(this.boneLimit, 128);\n\t\tthis.constantTexSource = this.scope.resolve('source');\n\t\tif (this.extTextureFloat) {\n\t\t\tif (this.isWebGL2) {\n\t\t\t\tthis.textureFloatRenderable = !!this.extColorBufferFloat;\n\t\t\t} else {\n\t\t\t\tthis.textureFloatRenderable = testRenderable(gl, gl.FLOAT);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.textureFloatRenderable = false;\n\t\t}\n\t\tif (this.extColorBufferHalfFloat) {\n\t\t\tthis.textureHalfFloatRenderable = !!this.extColorBufferHalfFloat;\n\t\t} else if (this.extTextureHalfFloat) {\n\t\t\tif (this.isWebGL2) {\n\t\t\t\tthis.textureHalfFloatRenderable = !!this.extColorBufferFloat;\n\t\t\t} else {\n\t\t\t\tthis.textureHalfFloatRenderable = testRenderable(gl, this.extTextureHalfFloat.HALF_FLOAT_OES);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.textureHalfFloatRenderable = false;\n\t\t}\n\t\tthis.supportsMorphTargetTexturesCore = this.maxPrecision === 'highp' && this.maxVertexTextures >= 2;\n\t\tthis.supportsDepthShadow = this.isWebGL2;\n\t\tthis._textureFloatHighPrecision = undefined;\n\t\tthis._textureHalfFloatUpdatable = undefined;\n\t\tthis.areaLightLutFormat = PIXELFORMAT_RGBA8;\n\t\tif (this.extTextureHalfFloat && this.textureHalfFloatUpdatable && this.extTextureHalfFloatLinear) {\n\t\t\tthis.areaLightLutFormat = PIXELFORMAT_RGBA16F;\n\t\t} else if (this.extTextureFloat && this.extTextureFloatLinear) {\n\t\t\tthis.areaLightLutFormat = PIXELFORMAT_RGBA32F;\n\t\t}\n\t\tthis.postInit();\n\t}\n\tpostInit() {\n\t\tsuper.postInit();\n\t\tthis.gpuProfiler = new WebglGpuProfiler(this);\n\t}\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tconst gl = this.gl;\n\t\tif (this.isWebGL2 && this.feedback) {\n\t\t\tgl.deleteTransformFeedback(this.feedback);\n\t\t}\n\t\tthis.clearVertexArrayObjectCache();\n\t\tthis.canvas.removeEventListener('webglcontextlost', this._contextLostHandler, false);\n\t\tthis.canvas.removeEventListener('webglcontextrestored', this._contextRestoredHandler, false);\n\t\tthis._contextLostHandler = null;\n\t\tthis._contextRestoredHandler = null;\n\t\tthis.gl = null;\n\t\tsuper.postDestroy();\n\t}\n\tcreateBackbuffer(frameBuffer) {\n\t\tthis.supportsStencil = this.initOptions.stencil;\n\t\tthis.backBuffer = new RenderTarget({\n\t\t\tname: 'WebglFramebuffer',\n\t\t\tgraphicsDevice: this,\n\t\t\tdepth: this.initOptions.depth,\n\t\t\tstencil: this.supportsStencil,\n\t\t\tsamples: this.samples\n\t\t});\n\t\tthis.backBuffer.impl.suppliedColorFramebuffer = frameBuffer;\n\t}\n\tupdateBackbufferFormat(framebuffer) {\n\t\tconst gl = this.gl;\n\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\n\t\tconst alphaBits = this.gl.getParameter(this.gl.ALPHA_BITS);\n\t\tthis.backBufferFormat = alphaBits ? PIXELFORMAT_RGBA8 : PIXELFORMAT_RGB8;\n\t}\n\tupdateBackbuffer() {\n\t\tconst resolutionChanged = this.canvas.width !== this.backBufferSize.x || this.canvas.height !== this.backBufferSize.y;\n\t\tif (this._defaultFramebufferChanged || resolutionChanged) {\n\t\t\tif (this._defaultFramebufferChanged) {\n\t\t\t\tthis.updateBackbufferFormat(this._defaultFramebuffer);\n\t\t\t}\n\t\t\tthis._defaultFramebufferChanged = false;\n\t\t\tthis.backBufferSize.set(this.canvas.width, this.canvas.height);\n\t\t\tthis.backBuffer.destroy();\n\t\t\tthis.createBackbuffer(this._defaultFramebuffer);\n\t\t}\n\t}\n\tcreateVertexBufferImpl(vertexBuffer, format) {\n\t\treturn new WebglVertexBuffer();\n\t}\n\tcreateIndexBufferImpl(indexBuffer) {\n\t\treturn new WebglIndexBuffer(indexBuffer);\n\t}\n\tcreateShaderImpl(shader) {\n\t\treturn new WebglShader(shader);\n\t}\n\tcreateTextureImpl(texture) {\n\t\treturn new WebglTexture();\n\t}\n\tcreateRenderTargetImpl(renderTarget) {\n\t\treturn new WebglRenderTarget();\n\t}\n\tgetPrecision() {\n\t\tconst gl = this.gl;\n\t\tlet precision = 'highp';\n\t\tif (gl.getShaderPrecisionFormat) {\n\t\t\tconst vertexShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT);\n\t\t\tconst vertexShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT);\n\t\t\tconst fragmentShaderPrecisionHighpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n\t\t\tconst fragmentShaderPrecisionMediumpFloat = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT);\n\t\t\tif (vertexShaderPrecisionHighpFloat && vertexShaderPrecisionMediumpFloat && fragmentShaderPrecisionHighpFloat && fragmentShaderPrecisionMediumpFloat) {\n\t\t\t\tconst highpAvailable = vertexShaderPrecisionHighpFloat.precision > 0 && fragmentShaderPrecisionHighpFloat.precision > 0;\n\t\t\t\tconst mediumpAvailable = vertexShaderPrecisionMediumpFloat.precision > 0 && fragmentShaderPrecisionMediumpFloat.precision > 0;\n\t\t\t\tif (!highpAvailable) {\n\t\t\t\t\tif (mediumpAvailable) {\n\t\t\t\t\t\tprecision = 'mediump';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tprecision = 'lowp';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn precision;\n\t}\n\tgetExtension() {\n\t\tfor (let i = 0; i < arguments.length; i++) {\n\t\t\tif (this.supportedExtensions.indexOf(arguments[i]) !== -1) {\n\t\t\t\treturn this.gl.getExtension(arguments[i]);\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\tget extDisjointTimerQuery() {\n\t\tif (!this._extDisjointTimerQuery) {\n\t\t\tif (this.isWebGL2) {\n\t\t\t\tthis._extDisjointTimerQuery = this.getExtension('EXT_disjoint_timer_query_webgl2', 'EXT_disjoint_timer_query');\n\t\t\t}\n\t\t}\n\t\treturn this._extDisjointTimerQuery;\n\t}\n\tinitializeExtensions() {\n\t\tvar _gl$getSupportedExten;\n\t\tconst gl = this.gl;\n\t\tthis.supportedExtensions = (_gl$getSupportedExten = gl.getSupportedExtensions()) != null ? _gl$getSupportedExten : [];\n\t\tthis._extDisjointTimerQuery = null;\n\t\tif (this.isWebGL2) {\n\t\t\tthis.extBlendMinmax = true;\n\t\t\tthis.extDrawBuffers = true;\n\t\t\tthis.drawBuffers = gl.drawBuffers.bind(gl);\n\t\t\tthis.extInstancing = true;\n\t\t\tthis.extStandardDerivatives = true;\n\t\t\tthis.extTextureFloat = true;\n\t\t\tthis.extTextureHalfFloat = true;\n\t\t\tthis.textureHalfFloatFilterable = true;\n\t\t\tthis.extTextureLod = true;\n\t\t\tthis.extUintElement = true;\n\t\t\tthis.extVertexArrayObject = true;\n\t\t\tthis.extColorBufferFloat = this.getExtension('EXT_color_buffer_float');\n\t\t\tthis.extDepthTexture = true;\n\t\t\tthis.textureRG11B10Renderable = true;\n\t\t} else {\n\t\t\tvar _this$extDrawBuffers;\n\t\t\tthis.extBlendMinmax = this.getExtension('EXT_blend_minmax');\n\t\t\tthis.extDrawBuffers = this.getExtension('WEBGL_draw_buffers');\n\t\t\tthis.extInstancing = this.getExtension('ANGLE_instanced_arrays');\n\t\t\tthis.drawBuffers = (_this$extDrawBuffers = this.extDrawBuffers) == null ? void 0 : _this$extDrawBuffers.drawBuffersWEBGL.bind(this.extDrawBuffers);\n\t\t\tif (this.extInstancing) {\n\t\t\t\tconst ext = this.extInstancing;\n\t\t\t\tgl.drawArraysInstanced = ext.drawArraysInstancedANGLE.bind(ext);\n\t\t\t\tgl.drawElementsInstanced = ext.drawElementsInstancedANGLE.bind(ext);\n\t\t\t\tgl.vertexAttribDivisor = ext.vertexAttribDivisorANGLE.bind(ext);\n\t\t\t}\n\t\t\tthis.extStandardDerivatives = this.getExtension('OES_standard_derivatives');\n\t\t\tthis.extTextureFloat = this.getExtension('OES_texture_float');\n\t\t\tthis.extTextureLod = this.getExtension('EXT_shader_texture_lod');\n\t\t\tthis.extUintElement = this.getExtension('OES_element_index_uint');\n\t\t\tthis.extVertexArrayObject = this.getExtension('OES_vertex_array_object');\n\t\t\tif (this.extVertexArrayObject) {\n\t\t\t\tconst ext = this.extVertexArrayObject;\n\t\t\t\tgl.createVertexArray = ext.createVertexArrayOES.bind(ext);\n\t\t\t\tgl.deleteVertexArray = ext.deleteVertexArrayOES.bind(ext);\n\t\t\t\tgl.isVertexArray = ext.isVertexArrayOES.bind(ext);\n\t\t\t\tgl.bindVertexArray = ext.bindVertexArrayOES.bind(ext);\n\t\t\t}\n\t\t\tthis.extColorBufferFloat = null;\n\t\t\tthis.extDepthTexture = gl.getExtension('WEBGL_depth_texture');\n\t\t\tthis.extTextureHalfFloat = this.getExtension('OES_texture_half_float');\n\t\t\tthis.extTextureHalfFloatLinear = this.getExtension('OES_texture_half_float_linear');\n\t\t\tthis.textureHalfFloatFilterable = !!this.extTextureHalfFloatLinear;\n\t\t}\n\t\tthis.extDebugRendererInfo = this.getExtension('WEBGL_debug_renderer_info');\n\t\tthis.extTextureFloatLinear = this.getExtension('OES_texture_float_linear');\n\t\tthis.textureFloatFilterable = !!this.extTextureFloatLinear;\n\t\tthis.extFloatBlend = this.getExtension('EXT_float_blend');\n\t\tthis.extTextureFilterAnisotropic = this.getExtension('EXT_texture_filter_anisotropic', 'WEBKIT_EXT_texture_filter_anisotropic');\n\t\tthis.extCompressedTextureETC1 = this.getExtension('WEBGL_compressed_texture_etc1');\n\t\tthis.extCompressedTextureETC = this.getExtension('WEBGL_compressed_texture_etc');\n\t\tthis.extCompressedTexturePVRTC = this.getExtension('WEBGL_compressed_texture_pvrtc', 'WEBKIT_WEBGL_compressed_texture_pvrtc');\n\t\tthis.extCompressedTextureS3TC = this.getExtension('WEBGL_compressed_texture_s3tc', 'WEBKIT_WEBGL_compressed_texture_s3tc');\n\t\tthis.extCompressedTextureATC = this.getExtension('WEBGL_compressed_texture_atc');\n\t\tthis.extCompressedTextureASTC = this.getExtension('WEBGL_compressed_texture_astc');\n\t\tthis.extParallelShaderCompile = this.getExtension('KHR_parallel_shader_compile');\n\t\tthis.extColorBufferHalfFloat = this.getExtension('EXT_color_buffer_half_float');\n\t}\n\tinitializeCapabilities() {\n\t\tvar _contextAttribs$antia, _contextAttribs$stenc;\n\t\tconst gl = this.gl;\n\t\tlet ext;\n\t\tconst userAgent = typeof navigator !== 'undefined' ? navigator.userAgent : '';\n\t\tthis.maxPrecision = this.precision = this.getPrecision();\n\t\tconst contextAttribs = gl.getContextAttributes();\n\t\tthis.supportsMsaa = (_contextAttribs$antia = contextAttribs == null ? void 0 : contextAttribs.antialias) != null ? _contextAttribs$antia : false;\n\t\tthis.supportsStencil = (_contextAttribs$stenc = contextAttribs == null ? void 0 : contextAttribs.stencil) != null ? _contextAttribs$stenc : false;\n\t\tthis.supportsInstancing = !!this.extInstancing;\n\t\tthis.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n\t\tthis.maxCubeMapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);\n\t\tthis.maxRenderBufferSize = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);\n\t\tthis.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n\t\tthis.maxCombinedTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n\t\tthis.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);\n\t\tthis.vertexUniformsCount = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n\t\tthis.fragmentUniformsCount = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);\n\t\tif (this.isWebGL2) {\n\t\t\tthis.maxDrawBuffers = gl.getParameter(gl.MAX_DRAW_BUFFERS);\n\t\t\tthis.maxColorAttachments = gl.getParameter(gl.MAX_COLOR_ATTACHMENTS);\n\t\t\tthis.maxVolumeSize = gl.getParameter(gl.MAX_3D_TEXTURE_SIZE);\n\t\t\tthis.supportsMrt = true;\n\t\t\tthis.supportsVolumeTextures = true;\n\t\t} else {\n\t\t\text = this.extDrawBuffers;\n\t\t\tthis.supportsMrt = !!ext;\n\t\t\tthis.maxDrawBuffers = ext ? gl.getParameter(ext.MAX_DRAW_BUFFERS_WEBGL) : 1;\n\t\t\tthis.maxColorAttachments = ext ? gl.getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 1;\n\t\t\tthis.maxVolumeSize = 1;\n\t\t}\n\t\text = this.extDebugRendererInfo;\n\t\tthis.unmaskedRenderer = ext ? gl.getParameter(ext.UNMASKED_RENDERER_WEBGL) : '';\n\t\tthis.unmaskedVendor = ext ? gl.getParameter(ext.UNMASKED_VENDOR_WEBGL) : '';\n\t\tconst maliRendererRegex = /\\bMali-G52+/;\n\t\tconst samsungModelRegex = /SM-[a-zA-Z0-9]+/;\n\t\tthis.supportsGpuParticles = !(this.unmaskedVendor === 'ARM' && userAgent.match(samsungModelRegex)) && !this.unmaskedRenderer.match(maliRendererRegex);\n\t\text = this.extTextureFilterAnisotropic;\n\t\tthis.maxAnisotropy = ext ? gl.getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1;\n\t\tconst antialiasSupported = this.isWebGL2 && !this.forceDisableMultisampling;\n\t\tthis.maxSamples = antialiasSupported ? gl.getParameter(gl.MAX_SAMPLES) : 1;\n\t\tthis.maxSamples = Math.min(this.maxSamples, 4);\n\t\tthis.samples = antialiasSupported && this.backBufferAntialias ? this.maxSamples : 1;\n\t\tthis.supportsAreaLights = this.isWebGL2 || !platform.android;\n\t\tthis.supportsTextureFetch = this.isWebGL2;\n\t\tif (this.maxTextures <= 8) {\n\t\t\tthis.supportsAreaLights = false;\n\t\t}\n\t}\n\tinitializeRenderState() {\n\t\tsuper.initializeRenderState();\n\t\tconst gl = this.gl;\n\t\tgl.disable(gl.BLEND);\n\t\tgl.blendFunc(gl.ONE, gl.ZERO);\n\t\tgl.blendEquation(gl.FUNC_ADD);\n\t\tgl.colorMask(true, true, true, true);\n\t\tgl.blendColor(0, 0, 0, 0);\n\t\tgl.enable(gl.CULL_FACE);\n\t\tthis.cullFace = gl.BACK;\n\t\tgl.cullFace(gl.BACK);\n\t\tgl.enable(gl.DEPTH_TEST);\n\t\tgl.depthFunc(gl.LEQUAL);\n\t\tgl.depthMask(true);\n\t\tthis.stencil = false;\n\t\tgl.disable(gl.STENCIL_TEST);\n\t\tthis.stencilFuncFront = this.stencilFuncBack = FUNC_ALWAYS;\n\t\tthis.stencilRefFront = this.stencilRefBack = 0;\n\t\tthis.stencilMaskFront = this.stencilMaskBack = 0xFF;\n\t\tgl.stencilFunc(gl.ALWAYS, 0, 0xFF);\n\t\tthis.stencilFailFront = this.stencilFailBack = STENCILOP_KEEP;\n\t\tthis.stencilZfailFront = this.stencilZfailBack = STENCILOP_KEEP;\n\t\tthis.stencilZpassFront = this.stencilZpassBack = STENCILOP_KEEP;\n\t\tthis.stencilWriteMaskFront = 0xFF;\n\t\tthis.stencilWriteMaskBack = 0xFF;\n\t\tgl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);\n\t\tgl.stencilMask(0xFF);\n\t\tthis.alphaToCoverage = false;\n\t\tthis.raster = true;\n\t\tif (this.isWebGL2) {\n\t\t\tgl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);\n\t\t\tgl.disable(gl.RASTERIZER_DISCARD);\n\t\t}\n\t\tthis.depthBiasEnabled = false;\n\t\tgl.disable(gl.POLYGON_OFFSET_FILL);\n\t\tthis.clearDepth = 1;\n\t\tgl.clearDepth(1);\n\t\tthis.clearColor = new Color(0, 0, 0, 0);\n\t\tgl.clearColor(0, 0, 0, 0);\n\t\tthis.clearStencil = 0;\n\t\tgl.clearStencil(0);\n\t\tif (this.isWebGL2) {\n\t\t\tgl.hint(gl.FRAGMENT_SHADER_DERIVATIVE_HINT, gl.NICEST);\n\t\t} else {\n\t\t\tif (this.extStandardDerivatives) {\n\t\t\t\tgl.hint(this.extStandardDerivatives.FRAGMENT_SHADER_DERIVATIVE_HINT_OES, gl.NICEST);\n\t\t\t}\n\t\t}\n\t\tgl.enable(gl.SCISSOR_TEST);\n\t\tgl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);\n\t\tthis.unpackFlipY = false;\n\t\tgl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);\n\t\tthis.unpackPremultiplyAlpha = false;\n\t\tgl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n\t\tgl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n\t}\n\tinitTextureUnits(count = 16) {\n\t\tthis.textureUnits = [];\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tthis.textureUnits.push([null, null, null]);\n\t\t}\n\t}\n\tinitializeContextCaches() {\n\t\tsuper.initializeContextCaches();\n\t\tthis._vaoMap = new Map();\n\t\tthis.boundVao = null;\n\t\tthis.activeFramebuffer = null;\n\t\tthis.feedback = null;\n\t\tthis.transformFeedbackBuffer = null;\n\t\tthis.textureUnit = 0;\n\t\tthis.initTextureUnits(this.maxCombinedTextures);\n\t}\n\tloseContext() {\n\t\tsuper.loseContext();\n\t\tfor (const shader of this.shaders) {\n\t\t\tshader.loseContext();\n\t\t}\n\t}\n\trestoreContext() {\n\t\tthis.initializeExtensions();\n\t\tthis.initializeCapabilities();\n\t\tsuper.restoreContext();\n\t\tfor (const shader of this.shaders) {\n\t\t\tshader.restoreContext();\n\t\t}\n\t}\n\tsetViewport(x, y, w, h) {\n\t\tif (this.vx !== x || this.vy !== y || this.vw !== w || this.vh !== h) {\n\t\t\tthis.gl.viewport(x, y, w, h);\n\t\t\tthis.vx = x;\n\t\t\tthis.vy = y;\n\t\t\tthis.vw = w;\n\t\t\tthis.vh = h;\n\t\t}\n\t}\n\tsetScissor(x, y, w, h) {\n\t\tif (this.sx !== x || this.sy !== y || this.sw !== w || this.sh !== h) {\n\t\t\tthis.gl.scissor(x, y, w, h);\n\t\t\tthis.sx = x;\n\t\t\tthis.sy = y;\n\t\t\tthis.sw = w;\n\t\t\tthis.sh = h;\n\t\t}\n\t}\n\tsetFramebuffer(fb) {\n\t\tif (this.activeFramebuffer !== fb) {\n\t\t\tconst gl = this.gl;\n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n\t\t\tthis.activeFramebuffer = fb;\n\t\t}\n\t}\n\tcopyRenderTarget(source, dest, color, depth) {\n\t\tconst gl = this.gl;\n\t\tif (source === this.backBuffer) {\n\t\t\tsource = null;\n\t\t}\n\t\tif (!this.isWebGL2 && depth) {\n\t\t\treturn false;\n\t\t}\n\t\tif (color) {\n\t\t\tif (!dest) {\n\t\t\t\tif (!source._colorBuffer) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t} else if (source) {\n\t\t\t\tif (!source._colorBuffer || !dest._colorBuffer) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (source._colorBuffer._format !== dest._colorBuffer._format) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (depth && source) {\n\t\t\tif (!source._depth) {\n\t\t\t\tif (!source._depthBuffer || !dest._depthBuffer) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tif (source._depthBuffer._format !== dest._depthBuffer._format) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.isWebGL2) {\n\t\t\tvar _this$backBuffer, _this$backBuffer2;\n\t\t\tconst prevRt = this.renderTarget;\n\t\t\tthis.renderTarget = dest;\n\t\t\tthis.updateBegin();\n\t\t\tconst src = source ? source.impl._glFrameBuffer : (_this$backBuffer = this.backBuffer) == null ? void 0 : _this$backBuffer.impl._glFrameBuffer;\n\t\t\tconst dst = dest ? dest.impl._glFrameBuffer : (_this$backBuffer2 = this.backBuffer) == null ? void 0 : _this$backBuffer2.impl._glFrameBuffer;\n\t\t\tgl.bindFramebuffer(gl.READ_FRAMEBUFFER, src);\n\t\t\tgl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dst);\n\t\t\tconst w = source ? source.width : dest ? dest.width : this.width;\n\t\t\tconst h = source ? source.height : dest ? dest.height : this.height;\n\t\t\tgl.blitFramebuffer(0, 0, w, h, 0, 0, w, h, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0), gl.NEAREST);\n\t\t\tthis.renderTarget = prevRt;\n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, prevRt ? prevRt.impl._glFrameBuffer : null);\n\t\t} else {\n\t\t\tconst shader = this.getCopyShader();\n\t\t\tthis.constantTexSource.setValue(source._colorBuffer);\n\t\t\tquadWithShader(this, dest, shader);\n\t\t}\n\t\treturn true;\n\t}\n\tgetCopyShader() {\n\t\tif (!this._copyShader) {\n\t\t\tthis._copyShader = new Shader(this, ShaderUtils.createDefinition(this, {\n\t\t\t\tname: 'outputTex2D',\n\t\t\t\tvertexCode: _fullScreenQuadVS,\n\t\t\t\tfragmentCode: _outputTexture2D\n\t\t\t}));\n\t\t}\n\t\treturn this._copyShader;\n\t}\n\tframeStart() {\n\t\tsuper.frameStart();\n\t\tthis.updateBackbuffer();\n\t\tthis.gpuProfiler.frameStart();\n\t}\n\tframeEnd() {\n\t\tsuper.frameEnd();\n\t\tthis.gpuProfiler.frameEnd();\n\t\tthis.gpuProfiler.request();\n\t}\n\tstartRenderPass(renderPass) {\n\t\tvar _renderPass$renderTar;\n\t\tconst rt = (_renderPass$renderTar = renderPass.renderTarget) != null ? _renderPass$renderTar : this.backBuffer;\n\t\tthis.renderTarget = rt;\n\t\tthis.updateBegin();\n\t\tconst {\n\t\t\twidth,\n\t\t\theight\n\t\t} = rt;\n\t\tthis.setViewport(0, 0, width, height);\n\t\tthis.setScissor(0, 0, width, height);\n\t\tconst colorOps = renderPass.colorOps;\n\t\tconst depthStencilOps = renderPass.depthStencilOps;\n\t\tif (colorOps != null && colorOps.clear || depthStencilOps.clearDepth || depthStencilOps.clearStencil) {\n\t\t\tlet clearFlags = 0;\n\t\t\tconst clearOptions = {};\n\t\t\tif (colorOps != null && colorOps.clear) {\n\t\t\t\tclearFlags |= CLEARFLAG_COLOR;\n\t\t\t\tclearOptions.color = [colorOps.clearValue.r, colorOps.clearValue.g, colorOps.clearValue.b, colorOps.clearValue.a];\n\t\t\t}\n\t\t\tif (depthStencilOps.clearDepth) {\n\t\t\t\tclearFlags |= CLEARFLAG_DEPTH;\n\t\t\t\tclearOptions.depth = depthStencilOps.clearDepthValue;\n\t\t\t}\n\t\t\tif (depthStencilOps.clearStencil) {\n\t\t\t\tclearFlags |= CLEARFLAG_STENCIL;\n\t\t\t\tclearOptions.stencil = depthStencilOps.clearStencilValue;\n\t\t\t}\n\t\t\tclearOptions.flags = clearFlags;\n\t\t\tthis.clear(clearOptions);\n\t\t}\n\t\tthis.insideRenderPass = true;\n\t}\n\tendRenderPass(renderPass) {\n\t\tthis.unbindVertexArray();\n\t\tconst target = this.renderTarget;\n\t\tconst colorBufferCount = renderPass.colorArrayOps.length;\n\t\tif (target) {\n\t\t\tvar _renderPass$colorOps;\n\t\t\tif (this.isWebGL2) {\n\t\t\t\tinvalidateAttachments.length = 0;\n\t\t\t\tconst gl = this.gl;\n\t\t\t\tfor (let i = 0; i < colorBufferCount; i++) {\n\t\t\t\t\tconst colorOps = renderPass.colorArrayOps[i];\n\t\t\t\t\tif (!(colorOps.store || colorOps.resolve)) {\n\t\t\t\t\t\tinvalidateAttachments.push(gl.COLOR_ATTACHMENT0 + i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (target !== this.backBuffer) {\n\t\t\t\t\tif (!renderPass.depthStencilOps.storeDepth) {\n\t\t\t\t\t\tinvalidateAttachments.push(gl.DEPTH_ATTACHMENT);\n\t\t\t\t\t}\n\t\t\t\t\tif (!renderPass.depthStencilOps.storeStencil) {\n\t\t\t\t\t\tinvalidateAttachments.push(gl.STENCIL_ATTACHMENT);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (invalidateAttachments.length > 0) {\n\t\t\t\t\tif (renderPass.fullSizeClearRect) {\n\t\t\t\t\t\tgl.invalidateFramebuffer(gl.DRAW_FRAMEBUFFER, invalidateAttachments);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((_renderPass$colorOps = renderPass.colorOps) != null && _renderPass$colorOps.resolve) {\n\t\t\t\tif (this.isWebGL2 && renderPass.samples > 1 && target.autoResolve) {\n\t\t\t\t\ttarget.resolve(true, false);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i = 0; i < colorBufferCount; i++) {\n\t\t\t\tconst colorOps = renderPass.colorArrayOps[i];\n\t\t\t\tif (colorOps.mipmaps) {\n\t\t\t\t\tconst colorBuffer = target._colorBuffers[i];\n\t\t\t\t\tif (colorBuffer && colorBuffer.impl._glTexture && colorBuffer.mipmaps && (colorBuffer.pot || this.isWebGL2)) {\n\t\t\t\t\t\tthis.activeTexture(this.maxCombinedTextures - 1);\n\t\t\t\t\t\tthis.bindTexture(colorBuffer);\n\t\t\t\t\t\tthis.gl.generateMipmap(colorBuffer.impl._glTarget);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.insideRenderPass = false;\n\t}\n\tset defaultFramebuffer(value) {\n\t\tif (this._defaultFramebuffer !== value) {\n\t\t\tthis._defaultFramebuffer = value;\n\t\t\tthis._defaultFramebufferChanged = true;\n\t\t}\n\t}\n\tget defaultFramebuffer() {\n\t\treturn this._defaultFramebuffer;\n\t}\n\tupdateBegin() {\n\t\tvar _this$renderTarget;\n\t\tthis.boundVao = null;\n\t\tif (this._tempEnableSafariTextureUnitWorkaround) {\n\t\t\tfor (let unit = 0; unit < this.textureUnits.length; ++unit) {\n\t\t\t\tfor (let slot = 0; slot < 3; ++slot) {\n\t\t\t\t\tthis.textureUnits[unit][slot] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst target = (_this$renderTarget = this.renderTarget) != null ? _this$renderTarget : this.backBuffer;\n\t\tconst targetImpl = target.impl;\n\t\tif (!targetImpl.initialized) {\n\t\t\tthis.initRenderTarget(target);\n\t\t}\n\t\tthis.setFramebuffer(targetImpl._glFrameBuffer);\n\t}\n\tupdateEnd() {\n\t\tthis.unbindVertexArray();\n\t\tconst target = this.renderTarget;\n\t\tif (target && target !== this.backBuffer) {\n\t\t\tif (this.isWebGL2 && target._samples > 1 && target.autoResolve) {\n\t\t\t\ttarget.resolve();\n\t\t\t}\n\t\t\tconst colorBuffer = target._colorBuffer;\n\t\t\tif (colorBuffer && colorBuffer.impl._glTexture && colorBuffer.mipmaps && (colorBuffer.pot || this.isWebGL2)) {\n\t\t\t\tthis.activeTexture(this.maxCombinedTextures - 1);\n\t\t\t\tthis.bindTexture(colorBuffer);\n\t\t\t\tthis.gl.generateMipmap(colorBuffer.impl._glTarget);\n\t\t\t}\n\t\t}\n\t}\n\tsetUnpackFlipY(flipY) {\n\t\tif (this.unpackFlipY !== flipY) {\n\t\t\tthis.unpackFlipY = flipY;\n\t\t\tconst gl = this.gl;\n\t\t\tgl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, flipY);\n\t\t}\n\t}\n\tsetUnpackPremultiplyAlpha(premultiplyAlpha) {\n\t\tif (this.unpackPremultiplyAlpha !== premultiplyAlpha) {\n\t\t\tthis.unpackPremultiplyAlpha = premultiplyAlpha;\n\t\t\tconst gl = this.gl;\n\t\t\tgl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiplyAlpha);\n\t\t}\n\t}\n\tactiveTexture(textureUnit) {\n\t\tif (this.textureUnit !== textureUnit) {\n\t\t\tthis.gl.activeTexture(this.gl.TEXTURE0 + textureUnit);\n\t\t\tthis.textureUnit = textureUnit;\n\t\t}\n\t}\n\tbindTexture(texture) {\n\t\tconst impl = texture.impl;\n\t\tconst textureTarget = impl._glTarget;\n\t\tconst textureObject = impl._glTexture;\n\t\tconst textureUnit = this.textureUnit;\n\t\tconst slot = this.targetToSlot[textureTarget];\n\t\tif (this.textureUnits[textureUnit][slot] !== textureObject) {\n\t\t\tthis.gl.bindTexture(textureTarget, textureObject);\n\t\t\tthis.textureUnits[textureUnit][slot] = textureObject;\n\t\t}\n\t}\n\tbindTextureOnUnit(texture, textureUnit) {\n\t\tconst impl = texture.impl;\n\t\tconst textureTarget = impl._glTarget;\n\t\tconst textureObject = impl._glTexture;\n\t\tconst slot = this.targetToSlot[textureTarget];\n\t\tif (this.textureUnits[textureUnit][slot] !== textureObject) {\n\t\t\tthis.activeTexture(textureUnit);\n\t\t\tthis.gl.bindTexture(textureTarget, textureObject);\n\t\t\tthis.textureUnits[textureUnit][slot] = textureObject;\n\t\t}\n\t}\n\tsetTextureParameters(texture) {\n\t\tconst gl = this.gl;\n\t\tconst flags = texture.impl.dirtyParameterFlags;\n\t\tconst target = texture.impl._glTarget;\n\t\tif (flags & 1) {\n\t\t\tlet filter = texture._minFilter;\n\t\t\tif (!texture.pot && !this.isWebGL2 || !texture._mipmaps || texture._compressed && texture._levels.length === 1) {\n\t\t\t\tif (filter === FILTER_NEAREST_MIPMAP_NEAREST || filter === FILTER_NEAREST_MIPMAP_LINEAR) {\n\t\t\t\t\tfilter = FILTER_NEAREST;\n\t\t\t\t} else if (filter === FILTER_LINEAR_MIPMAP_NEAREST || filter === FILTER_LINEAR_MIPMAP_LINEAR) {\n\t\t\t\t\tfilter = FILTER_LINEAR;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgl.texParameteri(target, gl.TEXTURE_MIN_FILTER, this.glFilter[filter]);\n\t\t}\n\t\tif (flags & 2) {\n\t\t\tgl.texParameteri(target, gl.TEXTURE_MAG_FILTER, this.glFilter[texture._magFilter]);\n\t\t}\n\t\tif (flags & 4) {\n\t\t\tif (this.isWebGL2) {\n\t\t\t\tgl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture._addressU]);\n\t\t\t} else {\n\t\t\t\tgl.texParameteri(target, gl.TEXTURE_WRAP_S, this.glAddress[texture.pot ? texture._addressU : ADDRESS_CLAMP_TO_EDGE]);\n\t\t\t}\n\t\t}\n\t\tif (flags & 8) {\n\t\t\tif (this.isWebGL2) {\n\t\t\t\tgl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture._addressV]);\n\t\t\t} else {\n\t\t\t\tgl.texParameteri(target, gl.TEXTURE_WRAP_T, this.glAddress[texture.pot ? texture._addressV : ADDRESS_CLAMP_TO_EDGE]);\n\t\t\t}\n\t\t}\n\t\tif (flags & 16) {\n\t\t\tif (this.isWebGL2) {\n\t\t\t\tgl.texParameteri(target, gl.TEXTURE_WRAP_R, this.glAddress[texture._addressW]);\n\t\t\t}\n\t\t}\n\t\tif (flags & 32) {\n\t\t\tif (this.isWebGL2) {\n\t\t\t\tgl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, texture._compareOnRead ? gl.COMPARE_REF_TO_TEXTURE : gl.NONE);\n\t\t\t}\n\t\t}\n\t\tif (flags & 64) {\n\t\t\tif (this.isWebGL2) {\n\t\t\t\tgl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, this.glComparison[texture._compareFunc]);\n\t\t\t}\n\t\t}\n\t\tif (flags & 128) {\n\t\t\tconst ext = this.extTextureFilterAnisotropic;\n\t\t\tif (ext) {\n\t\t\t\tgl.texParameterf(target, ext.TEXTURE_MAX_ANISOTROPY_EXT, math.clamp(Math.round(texture._anisotropy), 1, this.maxAnisotropy));\n\t\t\t}\n\t\t}\n\t}\n\tsetTexture(texture, textureUnit) {\n\t\tconst impl = texture.impl;\n\t\tif (!impl._glTexture) {\n\t\t\timpl.initialize(this, texture);\n\t\t}\n\t\tif (impl.dirtyParameterFlags > 0 || texture._needsUpload || texture._needsMipmapsUpload) {\n\t\t\tthis.activeTexture(textureUnit);\n\t\t\tthis.bindTexture(texture);\n\t\t\tif (impl.dirtyParameterFlags) {\n\t\t\t\tthis.setTextureParameters(texture);\n\t\t\t\timpl.dirtyParameterFlags = 0;\n\t\t\t}\n\t\t\tif (texture._needsUpload || texture._needsMipmapsUpload) {\n\t\t\t\timpl.upload(this, texture);\n\t\t\t\ttexture._needsUpload = false;\n\t\t\t\ttexture._needsMipmapsUpload = false;\n\t\t\t}\n\t\t} else {\n\t\t\tthis.bindTextureOnUnit(texture, textureUnit);\n\t\t}\n\t}\n\tcreateVertexArray(vertexBuffers) {\n\t\tlet key, vao;\n\t\tconst useCache = vertexBuffers.length > 1;\n\t\tif (useCache) {\n\t\t\tkey = '';\n\t\t\tfor (let i = 0; i < vertexBuffers.length; i++) {\n\t\t\t\tconst vertexBuffer = vertexBuffers[i];\n\t\t\t\tkey += vertexBuffer.id + vertexBuffer.format.renderingHash;\n\t\t\t}\n\t\t\tvao = this._vaoMap.get(key);\n\t\t}\n\t\tif (!vao) {\n\t\t\tconst gl = this.gl;\n\t\t\tvao = gl.createVertexArray();\n\t\t\tgl.bindVertexArray(vao);\n\t\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n\t\t\tfor (let i = 0; i < vertexBuffers.length; i++) {\n\t\t\t\tconst vertexBuffer = vertexBuffers[i];\n\t\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer.impl.bufferId);\n\t\t\t\tconst elements = vertexBuffer.format.elements;\n\t\t\t\tfor (let j = 0; j < elements.length; j++) {\n\t\t\t\t\tconst e = elements[j];\n\t\t\t\t\tconst loc = semanticToLocation[e.name];\n\t\t\t\t\tif (e.asInt) {\n\t\t\t\t\t\tgl.vertexAttribIPointer(loc, e.numComponents, this.glType[e.dataType], e.stride, e.offset);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgl.vertexAttribPointer(loc, e.numComponents, this.glType[e.dataType], e.normalize, e.stride, e.offset);\n\t\t\t\t\t}\n\t\t\t\t\tgl.enableVertexAttribArray(loc);\n\t\t\t\t\tif (vertexBuffer.format.instancing) {\n\t\t\t\t\t\tgl.vertexAttribDivisor(loc, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgl.bindVertexArray(null);\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, null);\n\t\t\tif (useCache) {\n\t\t\t\tthis._vaoMap.set(key, vao);\n\t\t\t}\n\t\t}\n\t\treturn vao;\n\t}\n\tunbindVertexArray() {\n\t\tif (this.boundVao) {\n\t\t\tthis.boundVao = null;\n\t\t\tthis.gl.bindVertexArray(null);\n\t\t}\n\t}\n\tsetBuffers() {\n\t\tconst gl = this.gl;\n\t\tlet vao;\n\t\tif (this.vertexBuffers.length === 1) {\n\t\t\tconst vertexBuffer = this.vertexBuffers[0];\n\t\t\tif (!vertexBuffer.impl.vao) {\n\t\t\t\tvertexBuffer.impl.vao = this.createVertexArray(this.vertexBuffers);\n\t\t\t}\n\t\t\tvao = vertexBuffer.impl.vao;\n\t\t} else {\n\t\t\tvao = this.createVertexArray(this.vertexBuffers);\n\t\t}\n\t\tif (this.boundVao !== vao) {\n\t\t\tthis.boundVao = vao;\n\t\t\tgl.bindVertexArray(vao);\n\t\t}\n\t\tthis.clearVertexBuffer();\n\t\tconst bufferId = this.indexBuffer ? this.indexBuffer.impl.bufferId : null;\n\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferId);\n\t}\n\tdraw(primitive, numInstances, keepBuffers) {\n\t\tconst gl = this.gl;\n\t\tthis.activateShader(this);\n\t\tif (!this.shaderValid) {\n\t\t\treturn;\n\t\t}\n\t\tlet sampler, samplerValue, texture, numTextures;\n\t\tlet uniform, scopeId, uniformVersion, programVersion;\n\t\tconst shader = this.shader;\n\t\tif (!shader) {\n\t\t\treturn;\n\t\t}\n\t\tconst samplers = shader.impl.samplers;\n\t\tconst uniforms = shader.impl.uniforms;\n\t\tif (!keepBuffers) {\n\t\t\tthis.setBuffers();\n\t\t}\n\t\tlet textureUnit = 0;\n\t\tfor (let i = 0, len = samplers.length; i < len; i++) {\n\t\t\tsampler = samplers[i];\n\t\t\tsamplerValue = sampler.scopeId.value;\n\t\t\tif (!samplerValue) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (samplerValue instanceof Texture) {\n\t\t\t\ttexture = samplerValue;\n\t\t\t\tthis.setTexture(texture, textureUnit);\n\t\t\t\tif (sampler.slot !== textureUnit) {\n\t\t\t\t\tgl.uniform1i(sampler.locationId, textureUnit);\n\t\t\t\t\tsampler.slot = textureUnit;\n\t\t\t\t}\n\t\t\t\ttextureUnit++;\n\t\t\t} else {\n\t\t\t\tsampler.array.length = 0;\n\t\t\t\tnumTextures = samplerValue.length;\n\t\t\t\tfor (let j = 0; j < numTextures; j++) {\n\t\t\t\t\ttexture = samplerValue[j];\n\t\t\t\t\tthis.setTexture(texture, textureUnit);\n\t\t\t\t\tsampler.array[j] = textureUnit;\n\t\t\t\t\ttextureUnit++;\n\t\t\t\t}\n\t\t\t\tgl.uniform1iv(sampler.locationId, sampler.array);\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0, len = uniforms.length; i < len; i++) {\n\t\t\tuniform = uniforms[i];\n\t\t\tscopeId = uniform.scopeId;\n\t\t\tuniformVersion = uniform.version;\n\t\t\tprogramVersion = scopeId.versionObject.version;\n\t\t\tif (uniformVersion.globalId !== programVersion.globalId || uniformVersion.revision !== programVersion.revision) {\n\t\t\t\tuniformVersion.globalId = programVersion.globalId;\n\t\t\t\tuniformVersion.revision = programVersion.revision;\n\t\t\t\tif (scopeId.value !== null) {\n\t\t\t\t\tthis.commitFunction[uniform.dataType](uniform, scopeId.value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.isWebGL2 && this.transformFeedbackBuffer) {\n\t\t\tgl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, this.transformFeedbackBuffer.impl.bufferId);\n\t\t\tgl.beginTransformFeedback(gl.POINTS);\n\t\t}\n\t\tconst mode = this.glPrimitive[primitive.type];\n\t\tconst count = primitive.count;\n\t\tif (primitive.indexed) {\n\t\t\tconst indexBuffer = this.indexBuffer;\n\t\t\tconst format = indexBuffer.impl.glFormat;\n\t\t\tconst offset = primitive.base * indexBuffer.bytesPerIndex;\n\t\t\tif (numInstances > 0) {\n\t\t\t\tgl.drawElementsInstanced(mode, count, format, offset, numInstances);\n\t\t\t} else {\n\t\t\t\tgl.drawElements(mode, count, format, offset);\n\t\t\t}\n\t\t} else {\n\t\t\tconst first = primitive.base;\n\t\t\tif (numInstances > 0) {\n\t\t\t\tgl.drawArraysInstanced(mode, first, count, numInstances);\n\t\t\t} else {\n\t\t\t\tgl.drawArrays(mode, first, count);\n\t\t\t}\n\t\t}\n\t\tif (this.isWebGL2 && this.transformFeedbackBuffer) {\n\t\t\tgl.endTransformFeedback();\n\t\t\tgl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, 0, null);\n\t\t}\n\t\tthis._drawCallsPerFrame++;\n\t}\n\tclear(options) {\n\t\tvar _options$flags;\n\t\tconst defaultOptions = this.defaultClearOptions;\n\t\toptions = options || defaultOptions;\n\t\tconst flags = (_options$flags = options.flags) != null ? _options$flags : defaultOptions.flags;\n\t\tif (flags !== 0) {\n\t\t\tconst gl = this.gl;\n\t\t\tif (flags & CLEARFLAG_COLOR) {\n\t\t\t\tvar _options$color;\n\t\t\t\tconst color = (_options$color = options.color) != null ? _options$color : defaultOptions.color;\n\t\t\t\tconst r = color[0];\n\t\t\t\tconst g = color[1];\n\t\t\t\tconst b = color[2];\n\t\t\t\tconst a = color[3];\n\t\t\t\tconst c = this.clearColor;\n\t\t\t\tif (r !== c.r || g !== c.g || b !== c.b || a !== c.a) {\n\t\t\t\t\tthis.gl.clearColor(r, g, b, a);\n\t\t\t\t\tthis.clearColor.set(r, g, b, a);\n\t\t\t\t}\n\t\t\t\tthis.setBlendState(BlendState.NOBLEND);\n\t\t\t}\n\t\t\tif (flags & CLEARFLAG_DEPTH) {\n\t\t\t\tvar _options$depth;\n\t\t\t\tconst depth = (_options$depth = options.depth) != null ? _options$depth : defaultOptions.depth;\n\t\t\t\tif (depth !== this.clearDepth) {\n\t\t\t\t\tthis.gl.clearDepth(depth);\n\t\t\t\t\tthis.clearDepth = depth;\n\t\t\t\t}\n\t\t\t\tthis.setDepthState(DepthState.WRITEDEPTH);\n\t\t\t}\n\t\t\tif (flags & CLEARFLAG_STENCIL) {\n\t\t\t\tvar _options$stencil;\n\t\t\t\tconst stencil = (_options$stencil = options.stencil) != null ? _options$stencil : defaultOptions.stencil;\n\t\t\t\tif (stencil !== this.clearStencil) {\n\t\t\t\t\tthis.gl.clearStencil(stencil);\n\t\t\t\t\tthis.clearStencil = stencil;\n\t\t\t\t}\n\t\t\t\tgl.stencilMask(0xFF);\n\t\t\t\tthis.stencilWriteMaskFront = 0xFF;\n\t\t\t\tthis.stencilWriteMaskBack = 0xFF;\n\t\t\t}\n\t\t\tgl.clear(this.glClearFlag[flags]);\n\t\t}\n\t}\n\tsubmit() {\n\t\tthis.gl.flush();\n\t}\n\treadPixels(x, y, w, h, pixels) {\n\t\tconst gl = this.gl;\n\t\tgl.readPixels(x, y, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n\t}\n\tasync readPixelsAsync(x, y, w, h, pixels) {\n\t\tvar _this$renderTarget$co, _impl$_glFormat, _impl$_glPixelType;\n\t\tconst gl = this.gl;\n\t\tif (!this.isWebGL2) {\n\t\t\tthis.readPixels(x, y, w, h, pixels);\n\t\t\treturn;\n\t\t}\n\t\tconst clientWaitAsync = (flags, interval_ms) => {\n\t\t\tconst sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);\n\t\t\tthis.submit();\n\t\t\treturn new Promise((resolve, reject) => {\n\t\t\t\tfunction test() {\n\t\t\t\t\tconst res = gl.clientWaitSync(sync, flags, 0);\n\t\t\t\t\tif (res === gl.WAIT_FAILED) {\n\t\t\t\t\t\tgl.deleteSync(sync);\n\t\t\t\t\t\treject(new Error('webgl clientWaitSync sync failed'));\n\t\t\t\t\t} else if (res === gl.TIMEOUT_EXPIRED) {\n\t\t\t\t\t\tsetTimeout(test, interval_ms);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgl.deleteSync(sync);\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttest();\n\t\t\t});\n\t\t};\n\t\tconst impl = (_this$renderTarget$co = this.renderTarget.colorBuffer) == null ? void 0 : _this$renderTarget$co.impl;\n\t\tconst format = (_impl$_glFormat = impl == null ? void 0 : impl._glFormat) != null ? _impl$_glFormat : gl.RGBA;\n\t\tconst pixelType = (_impl$_glPixelType = impl == null ? void 0 : impl._glPixelType) != null ? _impl$_glPixelType : gl.UNSIGNED_BYTE;\n\t\tconst buf = gl.createBuffer();\n\t\tgl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);\n\t\tgl.bufferData(gl.PIXEL_PACK_BUFFER, pixels.byteLength, gl.STREAM_READ);\n\t\tgl.readPixels(x, y, w, h, format, pixelType, 0);\n\t\tgl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n\t\tawait clientWaitAsync(0, 20);\n\t\tgl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);\n\t\tgl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, pixels);\n\t\tgl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);\n\t\tgl.deleteBuffer(buf);\n\t}\n\tsetAlphaToCoverage(state) {\n\t\tif (this.isWebGL1) return;\n\t\tif (this.alphaToCoverage === state) return;\n\t\tthis.alphaToCoverage = state;\n\t\tif (state) {\n\t\t\tthis.gl.enable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);\n\t\t} else {\n\t\t\tthis.gl.disable(this.gl.SAMPLE_ALPHA_TO_COVERAGE);\n\t\t}\n\t}\n\tsetTransformFeedbackBuffer(tf) {\n\t\tif (this.transformFeedbackBuffer === tf) {\n\t\t\treturn;\n\t\t}\n\t\tthis.transformFeedbackBuffer = tf;\n\t\tif (this.isWebGL2) {\n\t\t\tconst gl = this.gl;\n\t\t\tif (tf) {\n\t\t\t\tif (!this.feedback) {\n\t\t\t\t\tthis.feedback = gl.createTransformFeedback();\n\t\t\t\t}\n\t\t\t\tgl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, this.feedback);\n\t\t\t} else {\n\t\t\t\tgl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);\n\t\t\t}\n\t\t}\n\t}\n\tsetRaster(on) {\n\t\tif (this.raster === on) return;\n\t\tthis.raster = on;\n\t\tif (this.isWebGL2) {\n\t\t\tif (on) {\n\t\t\t\tthis.gl.disable(this.gl.RASTERIZER_DISCARD);\n\t\t\t} else {\n\t\t\t\tthis.gl.enable(this.gl.RASTERIZER_DISCARD);\n\t\t\t}\n\t\t}\n\t}\n\tsetStencilTest(enable) {\n\t\tif (this.stencil !== enable) {\n\t\t\tconst gl = this.gl;\n\t\t\tif (enable) {\n\t\t\t\tgl.enable(gl.STENCIL_TEST);\n\t\t\t} else {\n\t\t\t\tgl.disable(gl.STENCIL_TEST);\n\t\t\t}\n\t\t\tthis.stencil = enable;\n\t\t}\n\t}\n\tsetStencilFunc(func, ref, mask) {\n\t\tif (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask || this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {\n\t\t\tthis.gl.stencilFunc(this.glComparison[func], ref, mask);\n\t\t\tthis.stencilFuncFront = this.stencilFuncBack = func;\n\t\t\tthis.stencilRefFront = this.stencilRefBack = ref;\n\t\t\tthis.stencilMaskFront = this.stencilMaskBack = mask;\n\t\t}\n\t}\n\tsetStencilFuncFront(func, ref, mask) {\n\t\tif (this.stencilFuncFront !== func || this.stencilRefFront !== ref || this.stencilMaskFront !== mask) {\n\t\t\tconst gl = this.gl;\n\t\t\tgl.stencilFuncSeparate(gl.FRONT, this.glComparison[func], ref, mask);\n\t\t\tthis.stencilFuncFront = func;\n\t\t\tthis.stencilRefFront = ref;\n\t\t\tthis.stencilMaskFront = mask;\n\t\t}\n\t}\n\tsetStencilFuncBack(func, ref, mask) {\n\t\tif (this.stencilFuncBack !== func || this.stencilRefBack !== ref || this.stencilMaskBack !== mask) {\n\t\t\tconst gl = this.gl;\n\t\t\tgl.stencilFuncSeparate(gl.BACK, this.glComparison[func], ref, mask);\n\t\t\tthis.stencilFuncBack = func;\n\t\t\tthis.stencilRefBack = ref;\n\t\t\tthis.stencilMaskBack = mask;\n\t\t}\n\t}\n\tsetStencilOperation(fail, zfail, zpass, writeMask) {\n\t\tif (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass || this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {\n\t\t\tthis.gl.stencilOp(this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);\n\t\t\tthis.stencilFailFront = this.stencilFailBack = fail;\n\t\t\tthis.stencilZfailFront = this.stencilZfailBack = zfail;\n\t\t\tthis.stencilZpassFront = this.stencilZpassBack = zpass;\n\t\t}\n\t\tif (this.stencilWriteMaskFront !== writeMask || this.stencilWriteMaskBack !== writeMask) {\n\t\t\tthis.gl.stencilMask(writeMask);\n\t\t\tthis.stencilWriteMaskFront = writeMask;\n\t\t\tthis.stencilWriteMaskBack = writeMask;\n\t\t}\n\t}\n\tsetStencilOperationFront(fail, zfail, zpass, writeMask) {\n\t\tif (this.stencilFailFront !== fail || this.stencilZfailFront !== zfail || this.stencilZpassFront !== zpass) {\n\t\t\tthis.gl.stencilOpSeparate(this.gl.FRONT, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);\n\t\t\tthis.stencilFailFront = fail;\n\t\t\tthis.stencilZfailFront = zfail;\n\t\t\tthis.stencilZpassFront = zpass;\n\t\t}\n\t\tif (this.stencilWriteMaskFront !== writeMask) {\n\t\t\tthis.gl.stencilMaskSeparate(this.gl.FRONT, writeMask);\n\t\t\tthis.stencilWriteMaskFront = writeMask;\n\t\t}\n\t}\n\tsetStencilOperationBack(fail, zfail, zpass, writeMask) {\n\t\tif (this.stencilFailBack !== fail || this.stencilZfailBack !== zfail || this.stencilZpassBack !== zpass) {\n\t\t\tthis.gl.stencilOpSeparate(this.gl.BACK, this.glStencilOp[fail], this.glStencilOp[zfail], this.glStencilOp[zpass]);\n\t\t\tthis.stencilFailBack = fail;\n\t\t\tthis.stencilZfailBack = zfail;\n\t\t\tthis.stencilZpassBack = zpass;\n\t\t}\n\t\tif (this.stencilWriteMaskBack !== writeMask) {\n\t\t\tthis.gl.stencilMaskSeparate(this.gl.BACK, writeMask);\n\t\t\tthis.stencilWriteMaskBack = writeMask;\n\t\t}\n\t}\n\tsetBlendState(blendState) {\n\t\tconst currentBlendState = this.blendState;\n\t\tif (!currentBlendState.equals(blendState)) {\n\t\t\tconst gl = this.gl;\n\t\t\tconst {\n\t\t\t\tblend,\n\t\t\t\tcolorOp,\n\t\t\t\talphaOp,\n\t\t\t\tcolorSrcFactor,\n\t\t\t\tcolorDstFactor,\n\t\t\t\talphaSrcFactor,\n\t\t\t\talphaDstFactor\n\t\t\t} = blendState;\n\t\t\tif (currentBlendState.blend !== blend) {\n\t\t\t\tif (blend) {\n\t\t\t\t\tgl.enable(gl.BLEND);\n\t\t\t\t} else {\n\t\t\t\t\tgl.disable(gl.BLEND);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (currentBlendState.colorOp !== colorOp || currentBlendState.alphaOp !== alphaOp) {\n\t\t\t\tconst glBlendEquation = this.glBlendEquation;\n\t\t\t\tgl.blendEquationSeparate(glBlendEquation[colorOp], glBlendEquation[alphaOp]);\n\t\t\t}\n\t\t\tif (currentBlendState.colorSrcFactor !== colorSrcFactor || currentBlendState.colorDstFactor !== colorDstFactor || currentBlendState.alphaSrcFactor !== alphaSrcFactor || currentBlendState.alphaDstFactor !== alphaDstFactor) {\n\t\t\t\tgl.blendFuncSeparate(this.glBlendFunctionColor[colorSrcFactor], this.glBlendFunctionColor[colorDstFactor], this.glBlendFunctionAlpha[alphaSrcFactor], this.glBlendFunctionAlpha[alphaDstFactor]);\n\t\t\t}\n\t\t\tif (currentBlendState.allWrite !== blendState.allWrite) {\n\t\t\t\tthis.gl.colorMask(blendState.redWrite, blendState.greenWrite, blendState.blueWrite, blendState.alphaWrite);\n\t\t\t}\n\t\t\tcurrentBlendState.copy(blendState);\n\t\t}\n\t}\n\tsetBlendColor(r, g, b, a) {\n\t\tconst c = this.blendColor;\n\t\tif (r !== c.r || g !== c.g || b !== c.b || a !== c.a) {\n\t\t\tthis.gl.blendColor(r, g, b, a);\n\t\t\tc.set(r, g, b, a);\n\t\t}\n\t}\n\tsetStencilState(stencilFront, stencilBack) {\n\t\tif (stencilFront || stencilBack) {\n\t\t\tthis.setStencilTest(true);\n\t\t\tif (stencilFront === stencilBack) {\n\t\t\t\tthis.setStencilFunc(stencilFront.func, stencilFront.ref, stencilFront.readMask);\n\t\t\t\tthis.setStencilOperation(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);\n\t\t\t} else {\n\t\t\t\tvar _stencilFront, _stencilBack;\n\t\t\t\t(_stencilFront = stencilFront) != null ? _stencilFront : stencilFront = StencilParameters.DEFAULT;\n\t\t\t\tthis.setStencilFuncFront(stencilFront.func, stencilFront.ref, stencilFront.readMask);\n\t\t\t\tthis.setStencilOperationFront(stencilFront.fail, stencilFront.zfail, stencilFront.zpass, stencilFront.writeMask);\n\t\t\t\t(_stencilBack = stencilBack) != null ? _stencilBack : stencilBack = StencilParameters.DEFAULT;\n\t\t\t\tthis.setStencilFuncBack(stencilBack.func, stencilBack.ref, stencilBack.readMask);\n\t\t\t\tthis.setStencilOperationBack(stencilBack.fail, stencilBack.zfail, stencilBack.zpass, stencilBack.writeMask);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.setStencilTest(false);\n\t\t}\n\t}\n\tsetDepthState(depthState) {\n\t\tconst currentDepthState = this.depthState;\n\t\tif (!currentDepthState.equals(depthState)) {\n\t\t\tconst gl = this.gl;\n\t\t\tconst write = depthState.write;\n\t\t\tif (currentDepthState.write !== write) {\n\t\t\t\tgl.depthMask(write);\n\t\t\t}\n\t\t\tlet {\n\t\t\t\tfunc,\n\t\t\t\ttest\n\t\t\t} = depthState;\n\t\t\tif (!test && write) {\n\t\t\t\ttest = true;\n\t\t\t\tfunc = FUNC_ALWAYS;\n\t\t\t}\n\t\t\tif (currentDepthState.func !== func) {\n\t\t\t\tgl.depthFunc(this.glComparison[func]);\n\t\t\t}\n\t\t\tif (currentDepthState.test !== test) {\n\t\t\t\tif (test) {\n\t\t\t\t\tgl.enable(gl.DEPTH_TEST);\n\t\t\t\t} else {\n\t\t\t\t\tgl.disable(gl.DEPTH_TEST);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst {\n\t\t\t\tdepthBias,\n\t\t\t\tdepthBiasSlope\n\t\t\t} = depthState;\n\t\t\tif (depthBias || depthBiasSlope) {\n\t\t\t\tif (!this.depthBiasEnabled) {\n\t\t\t\t\tthis.depthBiasEnabled = true;\n\t\t\t\t\tthis.gl.enable(this.gl.POLYGON_OFFSET_FILL);\n\t\t\t\t}\n\t\t\t\tgl.polygonOffset(depthBiasSlope, depthBias);\n\t\t\t} else {\n\t\t\t\tif (this.depthBiasEnabled) {\n\t\t\t\t\tthis.depthBiasEnabled = false;\n\t\t\t\t\tthis.gl.disable(this.gl.POLYGON_OFFSET_FILL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcurrentDepthState.copy(depthState);\n\t\t}\n\t}\n\tsetCullMode(cullMode) {\n\t\tif (this.cullMode !== cullMode) {\n\t\t\tif (cullMode === CULLFACE_NONE) {\n\t\t\t\tthis.gl.disable(this.gl.CULL_FACE);\n\t\t\t} else {\n\t\t\t\tif (this.cullMode === CULLFACE_NONE) {\n\t\t\t\t\tthis.gl.enable(this.gl.CULL_FACE);\n\t\t\t\t}\n\t\t\t\tconst mode = this.glCull[cullMode];\n\t\t\t\tif (this.cullFace !== mode) {\n\t\t\t\t\tthis.gl.cullFace(mode);\n\t\t\t\t\tthis.cullFace = mode;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.cullMode = cullMode;\n\t\t}\n\t}\n\tsetShader(shader, asyncCompile = false) {\n\t\tif (shader !== this.shader) {\n\t\t\tthis.shader = shader;\n\t\t\tthis.shaderAsyncCompile = asyncCompile;\n\t\t\tthis.shaderValid = undefined;\n\t\t}\n\t}\n\tactivateShader(device) {\n\t\tconst {\n\t\t\tshader\n\t\t} = this;\n\t\tconst {\n\t\t\timpl\n\t\t} = shader;\n\t\tif (this.shaderValid === undefined) {\n\t\t\tif (shader.failed) {\n\t\t\t\tthis.shaderValid = false;\n\t\t\t} else if (!shader.ready) {\n\t\t\t\tif (this.shaderAsyncCompile) {\n\t\t\t\t\tif (impl.isLinked(device)) {\n\t\t\t\t\t\tif (!impl.finalize(this, shader)) {\n\t\t\t\t\t\t\tshader.failed = true;\n\t\t\t\t\t\t\tthis.shaderValid = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.shaderValid = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!impl.finalize(this, shader)) {\n\t\t\t\t\t\tshader.failed = true;\n\t\t\t\t\t\tthis.shaderValid = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.shaderValid === undefined) {\n\t\t\tthis.gl.useProgram(impl.glProgram);\n\t\t\tthis.shaderValid = true;\n\t\t}\n\t}\n\tclearVertexArrayObjectCache() {\n\t\tconst gl = this.gl;\n\t\tthis._vaoMap.forEach((item, key, mapObj) => {\n\t\t\tgl.deleteVertexArray(item);\n\t\t});\n\t\tthis._vaoMap.clear();\n\t}\n\tset fullscreen(fullscreen) {\n\t\tif (fullscreen) {\n\t\t\tconst canvas = this.gl.canvas;\n\t\t\tcanvas.requestFullscreen();\n\t\t} else {\n\t\t\tdocument.exitFullscreen();\n\t\t}\n\t}\n\tget fullscreen() {\n\t\treturn !!document.fullscreenElement;\n\t}\n\tget textureFloatHighPrecision() {\n\t\tif (this._textureFloatHighPrecision === undefined) {\n\t\t\tthis._textureFloatHighPrecision = testTextureFloatHighPrecision(this);\n\t\t}\n\t\treturn this._textureFloatHighPrecision;\n\t}\n\tget textureHalfFloatUpdatable() {\n\t\tif (this._textureHalfFloatUpdatable === undefined) {\n\t\t\tif (this.isWebGL2) {\n\t\t\t\tthis._textureHalfFloatUpdatable = true;\n\t\t\t} else {\n\t\t\t\tthis._textureHalfFloatUpdatable = testTextureHalfFloatUpdatable(this.gl, this.extTextureHalfFloat.HALF_FLOAT_OES);\n\t\t\t}\n\t\t}\n\t\treturn this._textureHalfFloatUpdatable;\n\t}\n}\n\nexport { WebglGraphicsDevice };\n","import { INDEXFORMAT_UINT8, INDEXFORMAT_UINT16, INDEXFORMAT_UINT32 } from '../constants.js';\nimport { WebglBuffer } from './webgl-buffer.js';\n\nclass WebglIndexBuffer extends WebglBuffer {\n\tconstructor(indexBuffer) {\n\t\tsuper();\n\t\tconst gl = indexBuffer.device.gl;\n\t\tconst format = indexBuffer.format;\n\t\tif (format === INDEXFORMAT_UINT8) {\n\t\t\tthis.glFormat = gl.UNSIGNED_BYTE;\n\t\t} else if (format === INDEXFORMAT_UINT16) {\n\t\t\tthis.glFormat = gl.UNSIGNED_SHORT;\n\t\t} else if (format === INDEXFORMAT_UINT32) {\n\t\t\tthis.glFormat = gl.UNSIGNED_INT;\n\t\t}\n\t}\n\tunlock(indexBuffer) {\n\t\tconst device = indexBuffer.device;\n\t\tsuper.unlock(device, indexBuffer.usage, device.gl.ELEMENT_ARRAY_BUFFER, indexBuffer.storage);\n\t}\n}\n\nexport { WebglIndexBuffer };\n","import { PIXELFORMAT_RGBA8 } from '../constants.js';\n\nclass FramebufferPair {\n\tconstructor(msaaFB, resolveFB) {\n\t\tthis.msaaFB = void 0;\n\t\tthis.resolveFB = void 0;\n\t\tthis.msaaFB = msaaFB;\n\t\tthis.resolveFB = resolveFB;\n\t}\n\tdestroy(gl) {\n\t\tif (this.msaaFB) {\n\t\t\tgl.deleteRenderbuffer(this.msaaFB);\n\t\t\tthis.msaaFB = null;\n\t\t}\n\t\tif (this.resolveFB) {\n\t\t\tgl.deleteRenderbuffer(this.resolveFB);\n\t\t\tthis.resolveFB = null;\n\t\t}\n\t}\n}\nclass WebglRenderTarget {\n\tconstructor() {\n\t\tthis._glFrameBuffer = null;\n\t\tthis._glDepthBuffer = null;\n\t\tthis._glResolveFrameBuffer = null;\n\t\tthis.colorMrtFramebuffers = null;\n\t\tthis._glMsaaColorBuffers = [];\n\t\tthis._glMsaaDepthBuffer = null;\n\t\tthis.suppliedColorFramebuffer = void 0;\n\t\tthis._isInitialized = false;\n\t}\n\tdestroy(device) {\n\t\tvar _this$colorMrtFramebu;\n\t\tconst gl = device.gl;\n\t\tthis._isInitialized = false;\n\t\tif (this._glFrameBuffer) {\n\t\t\tif (this._glFrameBuffer !== this.suppliedColorFramebuffer) {\n\t\t\t\tgl.deleteFramebuffer(this._glFrameBuffer);\n\t\t\t}\n\t\t\tthis._glFrameBuffer = null;\n\t\t}\n\t\tif (this._glDepthBuffer) {\n\t\t\tgl.deleteRenderbuffer(this._glDepthBuffer);\n\t\t\tthis._glDepthBuffer = null;\n\t\t}\n\t\tif (this._glResolveFrameBuffer) {\n\t\t\tif (this._glResolveFrameBuffer !== this.suppliedColorFramebuffer) {\n\t\t\t\tgl.deleteFramebuffer(this._glResolveFrameBuffer);\n\t\t\t}\n\t\t\tthis._glResolveFrameBuffer = null;\n\t\t}\n\t\tthis._glMsaaColorBuffers.forEach(buffer => {\n\t\t\tgl.deleteRenderbuffer(buffer);\n\t\t});\n\t\tthis._glMsaaColorBuffers.length = 0;\n\t\t(_this$colorMrtFramebu = this.colorMrtFramebuffers) == null || _this$colorMrtFramebu.forEach(framebuffer => {\n\t\t\tframebuffer.destroy(gl);\n\t\t});\n\t\tthis.colorMrtFramebuffers = null;\n\t\tif (this._glMsaaDepthBuffer) {\n\t\t\tgl.deleteRenderbuffer(this._glMsaaDepthBuffer);\n\t\t\tthis._glMsaaDepthBuffer = null;\n\t\t}\n\t\tthis.suppliedColorFramebuffer = undefined;\n\t}\n\tget initialized() {\n\t\treturn this._isInitialized;\n\t}\n\tinit(device, target) {\n\t\tconst gl = device.gl;\n\t\tthis._isInitialized = true;\n\t\tconst buffers = [];\n\t\tif (this.suppliedColorFramebuffer !== undefined) {\n\t\t\tthis._glFrameBuffer = this.suppliedColorFramebuffer;\n\t\t} else {\n\t\t\tvar _target$_colorBuffers, _target$_colorBuffers2, _device$extDrawBuffer, _device$extDrawBuffer2;\n\t\t\tthis._glFrameBuffer = gl.createFramebuffer();\n\t\t\tdevice.setFramebuffer(this._glFrameBuffer);\n\t\t\tconst colorBufferCount = (_target$_colorBuffers = (_target$_colorBuffers2 = target._colorBuffers) == null ? void 0 : _target$_colorBuffers2.length) != null ? _target$_colorBuffers : 0;\n\t\t\tconst attachmentBaseConstant = device.isWebGL2 ? gl.COLOR_ATTACHMENT0 : (_device$extDrawBuffer = (_device$extDrawBuffer2 = device.extDrawBuffers) == null ? void 0 : _device$extDrawBuffer2.COLOR_ATTACHMENT0_WEBGL) != null ? _device$extDrawBuffer : gl.COLOR_ATTACHMENT0;\n\t\t\tfor (let i = 0; i < colorBufferCount; ++i) {\n\t\t\t\tconst colorBuffer = target.getColorBuffer(i);\n\t\t\t\tif (colorBuffer) {\n\t\t\t\t\tif (!colorBuffer.impl._glTexture) {\n\t\t\t\t\t\tcolorBuffer._width = Math.min(colorBuffer.width, device.maxRenderBufferSize);\n\t\t\t\t\t\tcolorBuffer._height = Math.min(colorBuffer.height, device.maxRenderBufferSize);\n\t\t\t\t\t\tdevice.setTexture(colorBuffer, 0);\n\t\t\t\t\t}\n\t\t\t\t\tgl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentBaseConstant + i, colorBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, colorBuffer.impl._glTexture, 0);\n\t\t\t\t\tbuffers.push(attachmentBaseConstant + i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (device.drawBuffers) {\n\t\t\t\tdevice.drawBuffers(buffers);\n\t\t\t}\n\t\t\tconst depthBuffer = target._depthBuffer;\n\t\t\tif (depthBuffer) {\n\t\t\t\tif (!depthBuffer.impl._glTexture) {\n\t\t\t\t\tdepthBuffer._width = Math.min(depthBuffer.width, device.maxRenderBufferSize);\n\t\t\t\t\tdepthBuffer._height = Math.min(depthBuffer.height, device.maxRenderBufferSize);\n\t\t\t\t\tdevice.setTexture(depthBuffer, 0);\n\t\t\t\t}\n\t\t\t\tif (target._stencil) {\n\t\t\t\t\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer.impl._glTexture, 0);\n\t\t\t\t} else {\n\t\t\t\t\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, depthBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, target._depthBuffer.impl._glTexture, 0);\n\t\t\t\t}\n\t\t\t} else if (target._depth) {\n\t\t\t\tconst willRenderMsaa = target._samples > 1 && device.isWebGL2;\n\t\t\t\tif (!willRenderMsaa) {\n\t\t\t\t\tif (!this._glDepthBuffer) {\n\t\t\t\t\t\tthis._glDepthBuffer = gl.createRenderbuffer();\n\t\t\t\t\t}\n\t\t\t\t\tgl.bindRenderbuffer(gl.RENDERBUFFER, this._glDepthBuffer);\n\t\t\t\t\tif (target._stencil) {\n\t\t\t\t\t\tgl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, target.width, target.height);\n\t\t\t\t\t\tgl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._glDepthBuffer);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconst depthFormat = device.isWebGL2 ? gl.DEPTH_COMPONENT32F : gl.DEPTH_COMPONENT16;\n\t\t\t\t\t\tgl.renderbufferStorage(gl.RENDERBUFFER, depthFormat, target.width, target.height);\n\t\t\t\t\t\tgl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._glDepthBuffer);\n\t\t\t\t\t}\n\t\t\t\t\tgl.bindRenderbuffer(gl.RENDERBUFFER, null);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (device.isWebGL2 && target._samples > 1) {\n\t\t\tvar _target$_colorBuffers3, _target$_colorBuffers4;\n\t\t\tthis._glResolveFrameBuffer = this._glFrameBuffer;\n\t\t\tthis._glFrameBuffer = gl.createFramebuffer();\n\t\t\tdevice.setFramebuffer(this._glFrameBuffer);\n\t\t\tconst colorBufferCount = (_target$_colorBuffers3 = (_target$_colorBuffers4 = target._colorBuffers) == null ? void 0 : _target$_colorBuffers4.length) != null ? _target$_colorBuffers3 : 0;\n\t\t\tif (this.suppliedColorFramebuffer !== undefined) {\n\t\t\t\tconst buffer = gl.createRenderbuffer();\n\t\t\t\tthis._glMsaaColorBuffers.push(buffer);\n\t\t\t\tconst internalFormat = device.backBufferFormat === PIXELFORMAT_RGBA8 ? gl.RGBA8 : gl.RGB8;\n\t\t\t\tgl.bindRenderbuffer(gl.RENDERBUFFER, buffer);\n\t\t\t\tgl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, internalFormat, target.width, target.height);\n\t\t\t\tgl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, buffer);\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < colorBufferCount; ++i) {\n\t\t\t\t\tconst colorBuffer = target.getColorBuffer(i);\n\t\t\t\t\tif (colorBuffer) {\n\t\t\t\t\t\tconst buffer = gl.createRenderbuffer();\n\t\t\t\t\t\tthis._glMsaaColorBuffers.push(buffer);\n\t\t\t\t\t\tgl.bindRenderbuffer(gl.RENDERBUFFER, buffer);\n\t\t\t\t\t\tgl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, colorBuffer.impl._glInternalFormat, target.width, target.height);\n\t\t\t\t\t\tgl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + i, gl.RENDERBUFFER, buffer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (target._depth) {\n\t\t\t\tif (!this._glMsaaDepthBuffer) {\n\t\t\t\t\tthis._glMsaaDepthBuffer = gl.createRenderbuffer();\n\t\t\t\t}\n\t\t\t\tgl.bindRenderbuffer(gl.RENDERBUFFER, this._glMsaaDepthBuffer);\n\t\t\t\tif (target._stencil) {\n\t\t\t\t\tgl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH24_STENCIL8, target.width, target.height);\n\t\t\t\t\tgl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, this._glMsaaDepthBuffer);\n\t\t\t\t} else {\n\t\t\t\t\tgl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, gl.DEPTH_COMPONENT32F, target.width, target.height);\n\t\t\t\t\tgl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this._glMsaaDepthBuffer);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (colorBufferCount > 1) {\n\t\t\t\tthis._createMsaaMrtFramebuffers(device, target, colorBufferCount);\n\t\t\t\tdevice.setFramebuffer(this._glFrameBuffer);\n\t\t\t\tdevice.drawBuffers(buffers);\n\t\t\t}\n\t\t}\n\t}\n\t_createMsaaMrtFramebuffers(device, target, colorBufferCount) {\n\t\tconst gl = device.gl;\n\t\tthis.colorMrtFramebuffers = [];\n\t\tfor (let i = 0; i < colorBufferCount; ++i) {\n\t\t\tconst colorBuffer = target.getColorBuffer(i);\n\t\t\tconst srcFramebuffer = gl.createFramebuffer();\n\t\t\tdevice.setFramebuffer(srcFramebuffer);\n\t\t\tconst buffer = this._glMsaaColorBuffers[i];\n\t\t\tgl.bindRenderbuffer(gl.RENDERBUFFER, buffer);\n\t\t\tgl.renderbufferStorageMultisample(gl.RENDERBUFFER, target._samples, colorBuffer.impl._glInternalFormat, target.width, target.height);\n\t\t\tgl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.RENDERBUFFER, buffer);\n\t\t\tdevice.drawBuffers([gl.COLOR_ATTACHMENT0]);\n\t\t\tconst dstFramebuffer = gl.createFramebuffer();\n\t\t\tdevice.setFramebuffer(dstFramebuffer);\n\t\t\tgl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, colorBuffer._cubemap ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + target._face : gl.TEXTURE_2D, colorBuffer.impl._glTexture, 0);\n\t\t\tthis.colorMrtFramebuffers[i] = new FramebufferPair(srcFramebuffer, dstFramebuffer);\n\t\t}\n\t}\n\t_checkFbo(device, target, type = '') {\n\t\tconst gl = device.gl;\n\t\tconst status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n\t\tswitch (status) {\n\t\t\tcase gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:\n\t\t\t\tbreak;\n\t\t\tcase gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:\n\t\t\t\tbreak;\n\t\t\tcase gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:\n\t\t\t\tbreak;\n\t\t\tcase gl.FRAMEBUFFER_UNSUPPORTED:\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tloseContext() {\n\t\tthis._glFrameBuffer = null;\n\t\tthis._glDepthBuffer = null;\n\t\tthis._glResolveFrameBuffer = null;\n\t\tthis._glMsaaColorBuffers.length = 0;\n\t\tthis._glMsaaDepthBuffer = null;\n\t\tthis.colorMrtFramebuffers = null;\n\t\tthis.suppliedColorFramebuffer = undefined;\n\t\tthis._isInitialized = false;\n\t}\n\tinternalResolve(device, src, dst, target, mask) {\n\t\tdevice.setScissor(0, 0, target.width, target.height);\n\t\tconst gl = device.gl;\n\t\tgl.bindFramebuffer(gl.READ_FRAMEBUFFER, src);\n\t\tgl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dst);\n\t\tgl.blitFramebuffer(0, 0, target.width, target.height, 0, 0, target.width, target.height, mask, gl.NEAREST);\n\t}\n\tresolve(device, target, color, depth) {\n\t\tif (device.isWebGL2) {\n\t\t\tconst gl = device.gl;\n\t\t\tif (this.colorMrtFramebuffers) {\n\t\t\t\tif (color) {\n\t\t\t\t\tfor (let i = 0; i < this.colorMrtFramebuffers.length; i++) {\n\t\t\t\t\t\tconst fbPair = this.colorMrtFramebuffers[i];\n\t\t\t\t\t\tthis.internalResolve(device, fbPair.msaaFB, fbPair.resolveFB, target, gl.COLOR_BUFFER_BIT);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (depth) {\n\t\t\t\t\tthis.internalResolve(device, this._glFrameBuffer, this._glResolveFrameBuffer, target, gl.DEPTH_BUFFER_BIT);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.internalResolve(device, this._glFrameBuffer, this._glResolveFrameBuffer, target, (color ? gl.COLOR_BUFFER_BIT : 0) | (depth ? gl.DEPTH_BUFFER_BIT : 0));\n\t\t\t}\n\t\t\tgl.bindFramebuffer(gl.FRAMEBUFFER, this._glFrameBuffer);\n\t\t}\n\t}\n}\n\nexport { WebglRenderTarget };\n","import { UNIFORMTYPE_BVEC4, UNIFORMTYPE_BVEC4ARRAY, UNIFORMTYPE_UVEC4, UNIFORMTYPE_UVEC4ARRAY, UNIFORMTYPE_IVEC4, UNIFORMTYPE_IVEC4ARRAY, UNIFORMTYPE_VEC4, UNIFORMTYPE_VEC4ARRAY, UNIFORMTYPE_BVEC3, UNIFORMTYPE_BVEC3ARRAY, UNIFORMTYPE_UVEC3, UNIFORMTYPE_UVEC3ARRAY, UNIFORMTYPE_IVEC3, UNIFORMTYPE_IVEC3ARRAY, UNIFORMTYPE_VEC3, UNIFORMTYPE_VEC3ARRAY, UNIFORMTYPE_BVEC2, UNIFORMTYPE_BVEC2ARRAY, UNIFORMTYPE_UVEC2, UNIFORMTYPE_UVEC2ARRAY, UNIFORMTYPE_IVEC2, UNIFORMTYPE_IVEC2ARRAY, UNIFORMTYPE_VEC2, UNIFORMTYPE_VEC2ARRAY, UNIFORMTYPE_BOOL, UNIFORMTYPE_BOOLARRAY, UNIFORMTYPE_UINT, UNIFORMTYPE_UINTARRAY, UNIFORMTYPE_INT, UNIFORMTYPE_INTARRAY, UNIFORMTYPE_FLOAT, UNIFORMTYPE_FLOATARRAY } from '../constants.js';\nimport { Version } from '../version.js';\n\nclass WebglShaderInput {\n\tconstructor(graphicsDevice, name, type, locationId) {\n\t\tthis.locationId = locationId;\n\t\tthis.scopeId = graphicsDevice.scope.resolve(name);\n\t\tthis.version = new Version();\n\t\tif (name.substring(name.length - 3) === '[0]') {\n\t\t\tswitch (type) {\n\t\t\t\tcase UNIFORMTYPE_FLOAT:\n\t\t\t\t\ttype = UNIFORMTYPE_FLOATARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_INT:\n\t\t\t\t\ttype = UNIFORMTYPE_INTARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_UINT:\n\t\t\t\t\ttype = UNIFORMTYPE_UINTARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_BOOL:\n\t\t\t\t\ttype = UNIFORMTYPE_BOOLARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_VEC2:\n\t\t\t\t\ttype = UNIFORMTYPE_VEC2ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_IVEC2:\n\t\t\t\t\ttype = UNIFORMTYPE_IVEC2ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_UVEC2:\n\t\t\t\t\ttype = UNIFORMTYPE_UVEC2ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_BVEC2:\n\t\t\t\t\ttype = UNIFORMTYPE_BVEC2ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_VEC3:\n\t\t\t\t\ttype = UNIFORMTYPE_VEC3ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_IVEC3:\n\t\t\t\t\ttype = UNIFORMTYPE_IVEC3ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_UVEC3:\n\t\t\t\t\ttype = UNIFORMTYPE_UVEC3ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_BVEC3:\n\t\t\t\t\ttype = UNIFORMTYPE_BVEC3ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_VEC4:\n\t\t\t\t\ttype = UNIFORMTYPE_VEC4ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_IVEC4:\n\t\t\t\t\ttype = UNIFORMTYPE_IVEC4ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_UVEC4:\n\t\t\t\t\ttype = UNIFORMTYPE_UVEC4ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase UNIFORMTYPE_BVEC4:\n\t\t\t\t\ttype = UNIFORMTYPE_BVEC4ARRAY;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.dataType = type;\n\t\tthis.value = [null, null, null, null];\n\t\tthis.array = [];\n\t}\n}\n\nexport { WebglShaderInput };\n","import { WebglShaderInput } from './webgl-shader-input.js';\nimport { semanticToLocation } from '../constants.js';\nimport { DeviceCache } from '../device-cache.js';\n\nconst _vertexShaderBuiltins = new Set(['gl_VertexID', 'gl_InstanceID', 'gl_DrawID', 'gl_BaseVertex', 'gl_BaseInstance']);\nclass CompiledShaderCache {\n\tconstructor() {\n\t\tthis.map = new Map();\n\t}\n\tdestroy(device) {\n\t\tthis.map.forEach(shader => {\n\t\t\tdevice.gl.deleteShader(shader);\n\t\t});\n\t}\n\tloseContext(device) {\n\t\tthis.map.clear();\n\t}\n}\nconst _vertexShaderCache = new DeviceCache();\nconst _fragmentShaderCache = new DeviceCache();\nclass WebglShader {\n\tconstructor(shader) {\n\t\tthis.compileDuration = 0;\n\t\tthis.init();\n\t\tthis.compile(shader.device, shader);\n\t\tthis.link(shader.device, shader);\n\t\tshader.device.shaders.push(shader);\n\t}\n\tdestroy(shader) {\n\t\tif (this.glProgram) {\n\t\t\tshader.device.gl.deleteProgram(this.glProgram);\n\t\t\tthis.glProgram = null;\n\t\t}\n\t}\n\tinit() {\n\t\tthis.uniforms = [];\n\t\tthis.samplers = [];\n\t\tthis.attributes = [];\n\t\tthis.glProgram = null;\n\t\tthis.glVertexShader = null;\n\t\tthis.glFragmentShader = null;\n\t}\n\tloseContext() {\n\t\tthis.init();\n\t}\n\trestoreContext(device, shader) {\n\t\tthis.compile(device, shader);\n\t\tthis.link(device, shader);\n\t}\n\tcompile(device, shader) {\n\t\tconst definition = shader.definition;\n\t\tthis.glVertexShader = this._compileShaderSource(device, definition.vshader, true);\n\t\tthis.glFragmentShader = this._compileShaderSource(device, definition.fshader, false);\n\t}\n\tlink(device, shader) {\n\t\tif (this.glProgram) {\n\t\t\treturn;\n\t\t}\n\t\tconst gl = device.gl;\n\t\tif (gl.isContextLost()) {\n\t\t\treturn;\n\t\t}\n\t\tconst glProgram = gl.createProgram();\n\t\tthis.glProgram = glProgram;\n\t\tgl.attachShader(glProgram, this.glVertexShader);\n\t\tgl.attachShader(glProgram, this.glFragmentShader);\n\t\tconst definition = shader.definition;\n\t\tconst attrs = definition.attributes;\n\t\tif (device.isWebGL2 && definition.useTransformFeedback) {\n\t\t\tconst outNames = [];\n\t\t\tfor (const attr in attrs) {\n\t\t\t\tif (attrs.hasOwnProperty(attr)) {\n\t\t\t\t\toutNames.push(`out_${attr}`);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgl.transformFeedbackVaryings(glProgram, outNames, gl.INTERLEAVED_ATTRIBS);\n\t\t}\n\t\tfor (const attr in attrs) {\n\t\t\tif (attrs.hasOwnProperty(attr)) {\n\t\t\t\tconst semantic = attrs[attr];\n\t\t\t\tconst loc = semanticToLocation[semantic];\n\t\t\t\tgl.bindAttribLocation(glProgram, loc, attr);\n\t\t\t}\n\t\t}\n\t\tgl.linkProgram(glProgram);\n\t}\n\t_compileShaderSource(device, src, isVertexShader) {\n\t\tconst gl = device.gl;\n\t\tif (gl.isContextLost()) {\n\t\t\treturn null;\n\t\t}\n\t\tconst shaderDeviceCache = isVertexShader ? _vertexShaderCache : _fragmentShaderCache;\n\t\tconst shaderCache = shaderDeviceCache.get(device, () => {\n\t\t\treturn new CompiledShaderCache();\n\t\t});\n\t\tlet glShader = shaderCache.map.get(src);\n\t\tif (!glShader) {\n\t\t\tglShader = gl.createShader(isVertexShader ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);\n\t\t\tgl.shaderSource(glShader, src);\n\t\t\tgl.compileShader(glShader);\n\t\t\tshaderCache.map.set(src, glShader);\n\t\t}\n\t\treturn glShader;\n\t}\n\tfinalize(device, shader) {\n\t\tconst gl = device.gl;\n\t\tif (gl.isContextLost()) {\n\t\t\treturn true;\n\t\t}\n\t\tconst glProgram = this.glProgram;\n\t\tconst definition = shader.definition;\n\t\tconst linkStatus = gl.getProgramParameter(glProgram, gl.LINK_STATUS);\n\t\tif (!linkStatus) {\n\t\t\tif (!this._isCompiled(device, shader, this.glVertexShader, definition.vshader, 'vertex')) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!this._isCompiled(device, shader, this.glFragmentShader, definition.fshader, 'fragment')) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tconst message = `Failed to link shader program. Error: ${gl.getProgramInfoLog(glProgram)}`;\n\t\t\tconsole.error(message);\n\t\t\treturn false;\n\t\t}\n\t\tconst numAttributes = gl.getProgramParameter(glProgram, gl.ACTIVE_ATTRIBUTES);\n\t\tfor (let i = 0; i < numAttributes; i++) {\n\t\t\tconst info = gl.getActiveAttrib(glProgram, i);\n\t\t\tconst location = gl.getAttribLocation(glProgram, info.name);\n\t\t\tif (_vertexShaderBuiltins.has(info.name)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (definition.attributes[info.name] === undefined) {\n\t\t\t\tconsole.error(`Vertex shader attribute \"${info.name}\" is not mapped to a semantic in shader definition, shader [${shader.label}]`, shader);\n\t\t\t\tshader.failed = true;\n\t\t\t} else {\n\t\t\t\tconst shaderInput = new WebglShaderInput(device, definition.attributes[info.name], device.pcUniformType[info.type], location);\n\t\t\t\tthis.attributes.push(shaderInput);\n\t\t\t}\n\t\t}\n\t\tconst samplerTypes = device._samplerTypes;\n\t\tconst numUniforms = gl.getProgramParameter(glProgram, gl.ACTIVE_UNIFORMS);\n\t\tfor (let i = 0; i < numUniforms; i++) {\n\t\t\tconst info = gl.getActiveUniform(glProgram, i);\n\t\t\tconst location = gl.getUniformLocation(glProgram, info.name);\n\t\t\tconst shaderInput = new WebglShaderInput(device, info.name, device.pcUniformType[info.type], location);\n\t\t\tif (samplerTypes.has(info.type)) {\n\t\t\t\tthis.samplers.push(shaderInput);\n\t\t\t} else {\n\t\t\t\tthis.uniforms.push(shaderInput);\n\t\t\t}\n\t\t}\n\t\tshader.ready = true;\n\t\treturn true;\n\t}\n\t_isCompiled(device, shader, glShader, source, shaderType) {\n\t\tconst gl = device.gl;\n\t\tif (!gl.getShaderParameter(glShader, gl.COMPILE_STATUS)) {\n\t\t\tconst infoLog = gl.getShaderInfoLog(glShader);\n\t\t\tconst [code, error] = this._processError(source, infoLog);\n\t\t\tconst message = `Failed to compile ${shaderType} shader:\\n\\n${infoLog}\\n${code} while rendering ${void 0}`;\n\t\t\tconsole.error(message);\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tisLinked(device) {\n\t\tconst {\n\t\t\textParallelShaderCompile\n\t\t} = device;\n\t\tif (extParallelShaderCompile) {\n\t\t\treturn device.gl.getProgramParameter(this.glProgram, extParallelShaderCompile.COMPLETION_STATUS_KHR);\n\t\t}\n\t\treturn true;\n\t}\n\t_processError(src, infoLog) {\n\t\tconst error = {};\n\t\tlet code = '';\n\t\tif (src) {\n\t\t\tconst lines = src.split('\\n');\n\t\t\tlet from = 0;\n\t\t\tlet to = lines.length;\n\t\t\tif (infoLog && infoLog.startsWith('ERROR:')) {\n\t\t\t\tconst match = infoLog.match(/^ERROR:\\s(\\d+):(\\d+):\\s*(.+)/);\n\t\t\t\tif (match) {\n\t\t\t\t\terror.message = match[3];\n\t\t\t\t\terror.line = parseInt(match[2], 10);\n\t\t\t\t\tfrom = Math.max(0, error.line - 6);\n\t\t\t\t\tto = Math.min(lines.length, error.line + 5);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i = from; i < to; i++) {\n\t\t\t\tcode += `${i + 1}:\\t${lines[i]}\\n`;\n\t\t\t}\n\t\t\terror.source = src;\n\t\t}\n\t\treturn [code, error];\n\t}\n}\n\nexport { WebglShader };\n","import { PIXELFORMAT_RGBA32U, PIXELFORMAT_RGBA32I, PIXELFORMAT_RGBA16U, PIXELFORMAT_RGBA16I, PIXELFORMAT_RGBA8U, PIXELFORMAT_RGBA8I, PIXELFORMAT_RG32U, PIXELFORMAT_RG32I, PIXELFORMAT_RG16U, PIXELFORMAT_RG16I, PIXELFORMAT_RG8U, PIXELFORMAT_RG8I, PIXELFORMAT_R32U, PIXELFORMAT_R32I, PIXELFORMAT_R16U, PIXELFORMAT_R16I, PIXELFORMAT_R8U, PIXELFORMAT_R8I, PIXELFORMAT_SRGBA, PIXELFORMAT_SRGB, PIXELFORMAT_111110F, PIXELFORMAT_DEPTHSTENCIL, PIXELFORMAT_DEPTH, PIXELFORMAT_R32F, PIXELFORMAT_RGBA32F, PIXELFORMAT_RGB32F, PIXELFORMAT_RGBA16F, PIXELFORMAT_RGB16F, PIXELFORMAT_RG16F, PIXELFORMAT_R16F, PIXELFORMAT_ATC_RGBA, PIXELFORMAT_ATC_RGB, PIXELFORMAT_ASTC_4x4, PIXELFORMAT_ETC2_RGBA, PIXELFORMAT_ETC2_RGB, PIXELFORMAT_PVRTC_4BPP_RGBA_1, PIXELFORMAT_PVRTC_4BPP_RGB_1, PIXELFORMAT_PVRTC_2BPP_RGBA_1, PIXELFORMAT_PVRTC_2BPP_RGB_1, PIXELFORMAT_ETC1, PIXELFORMAT_DXT5, PIXELFORMAT_DXT3, PIXELFORMAT_DXT1, PIXELFORMAT_RGBA8, PIXELFORMAT_RGB8, PIXELFORMAT_RGBA4, PIXELFORMAT_RGBA5551, PIXELFORMAT_RGB565, PIXELFORMAT_LA8, PIXELFORMAT_L8, PIXELFORMAT_A8 } from '../constants.js';\n\nfunction downsampleImage(image, size) {\n\tconst srcW = image.width;\n\tconst srcH = image.height;\n\tif (srcW > size || srcH > size) {\n\t\tconst scale = size / Math.max(srcW, srcH);\n\t\tconst dstW = Math.floor(srcW * scale);\n\t\tconst dstH = Math.floor(srcH * scale);\n\t\tconst canvas = document.createElement('canvas');\n\t\tcanvas.width = dstW;\n\t\tcanvas.height = dstH;\n\t\tconst context = canvas.getContext('2d');\n\t\tcontext.drawImage(image, 0, 0, srcW, srcH, 0, 0, dstW, dstH);\n\t\treturn canvas;\n\t}\n\treturn image;\n}\nclass WebglTexture {\n\tconstructor() {\n\t\tthis._glTexture = null;\n\t\tthis._glTarget = void 0;\n\t\tthis._glFormat = void 0;\n\t\tthis._glInternalFormat = void 0;\n\t\tthis._glPixelType = void 0;\n\t\tthis._glCreated = void 0;\n\t\tthis.dirtyParameterFlags = 0;\n\t}\n\tdestroy(device) {\n\t\tif (this._glTexture) {\n\t\t\tfor (let i = 0; i < device.textureUnits.length; i++) {\n\t\t\t\tconst textureUnit = device.textureUnits[i];\n\t\t\t\tfor (let j = 0; j < textureUnit.length; j++) {\n\t\t\t\t\tif (textureUnit[j] === this._glTexture) {\n\t\t\t\t\t\ttextureUnit[j] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdevice.gl.deleteTexture(this._glTexture);\n\t\t\tthis._glTexture = null;\n\t\t}\n\t}\n\tloseContext() {\n\t\tthis._glTexture = null;\n\t}\n\tpropertyChanged(flag) {\n\t\tthis.dirtyParameterFlags |= flag;\n\t}\n\tinitialize(device, texture) {\n\t\tconst gl = device.gl;\n\t\tthis._glTexture = gl.createTexture();\n\t\tthis._glTarget = texture._cubemap ? gl.TEXTURE_CUBE_MAP : texture._volume ? gl.TEXTURE_3D : texture.array ? gl.TEXTURE_2D_ARRAY : gl.TEXTURE_2D;\n\t\tswitch (texture._format) {\n\t\t\tcase PIXELFORMAT_A8:\n\t\t\t\tthis._glFormat = gl.ALPHA;\n\t\t\t\tthis._glInternalFormat = gl.ALPHA;\n\t\t\t\tthis._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_L8:\n\t\t\t\tthis._glFormat = gl.LUMINANCE;\n\t\t\t\tthis._glInternalFormat = gl.LUMINANCE;\n\t\t\t\tthis._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_LA8:\n\t\t\t\tthis._glFormat = gl.LUMINANCE_ALPHA;\n\t\t\t\tthis._glInternalFormat = gl.LUMINANCE_ALPHA;\n\t\t\t\tthis._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_RGB565:\n\t\t\t\tthis._glFormat = gl.RGB;\n\t\t\t\tthis._glInternalFormat = gl.RGB;\n\t\t\t\tthis._glPixelType = gl.UNSIGNED_SHORT_5_6_5;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_RGBA5551:\n\t\t\t\tthis._glFormat = gl.RGBA;\n\t\t\t\tthis._glInternalFormat = gl.RGBA;\n\t\t\t\tthis._glPixelType = gl.UNSIGNED_SHORT_5_5_5_1;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_RGBA4:\n\t\t\t\tthis._glFormat = gl.RGBA;\n\t\t\t\tthis._glInternalFormat = gl.RGBA;\n\t\t\t\tthis._glPixelType = gl.UNSIGNED_SHORT_4_4_4_4;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_RGB8:\n\t\t\t\tthis._glFormat = gl.RGB;\n\t\t\t\tthis._glInternalFormat = device.isWebGL2 ? gl.RGB8 : gl.RGB;\n\t\t\t\tthis._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_RGBA8:\n\t\t\t\tthis._glFormat = gl.RGBA;\n\t\t\t\tthis._glInternalFormat = device.isWebGL2 ? gl.RGBA8 : gl.RGBA;\n\t\t\t\tthis._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_DXT1:\n\t\t\t\tthis._glFormat = gl.RGB;\n\t\t\t\tthis._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGB_S3TC_DXT1_EXT;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_DXT3:\n\t\t\t\tthis._glFormat = gl.RGBA;\n\t\t\t\tthis._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_DXT5:\n\t\t\t\tthis._glFormat = gl.RGBA;\n\t\t\t\tthis._glInternalFormat = device.extCompressedTextureS3TC.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_ETC1:\n\t\t\t\tthis._glFormat = gl.RGB;\n\t\t\t\tthis._glInternalFormat = device.extCompressedTextureETC1.COMPRESSED_RGB_ETC1_WEBGL;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_PVRTC_2BPP_RGB_1:\n\t\t\t\tthis._glFormat = gl.RGB;\n\t\t\t\tthis._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_PVRTC_2BPP_RGBA_1:\n\t\t\t\tthis._glFormat = gl.RGBA;\n\t\t\t\tthis._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_PVRTC_4BPP_RGB_1:\n\t\t\t\tthis._glFormat = gl.RGB;\n\t\t\t\tthis._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_PVRTC_4BPP_RGBA_1:\n\t\t\t\tthis._glFormat = gl.RGBA;\n\t\t\t\tthis._glInternalFormat = device.extCompressedTexturePVRTC.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_ETC2_RGB:\n\t\t\t\tthis._glFormat = gl.RGB;\n\t\t\t\tthis._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_RGB8_ETC2;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_ETC2_RGBA:\n\t\t\t\tthis._glFormat = gl.RGBA;\n\t\t\t\tthis._glInternalFormat = device.extCompressedTextureETC.COMPRESSED_RGBA8_ETC2_EAC;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_ASTC_4x4:\n\t\t\t\tthis._glFormat = gl.RGBA;\n\t\t\t\tthis._glInternalFormat = device.extCompressedTextureASTC.COMPRESSED_RGBA_ASTC_4x4_KHR;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_ATC_RGB:\n\t\t\t\tthis._glFormat = gl.RGB;\n\t\t\t\tthis._glInternalFormat = device.extCompressedTextureATC.COMPRESSED_RGB_ATC_WEBGL;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_ATC_RGBA:\n\t\t\t\tthis._glFormat = gl.RGBA;\n\t\t\t\tthis._glInternalFormat = device.extCompressedTextureATC.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_R16F:\n\t\t\t\tif (device.isWebGL2) {\n\t\t\t\t\tthis._glFormat = gl.RED;\n\t\t\t\t\tthis._glInternalFormat = gl.R16F;\n\t\t\t\t\tthis._glPixelType = gl.HALF_FLOAT;\n\t\t\t\t} else {\n\t\t\t\t\tthis._glFormat = gl.LUMINANCE;\n\t\t\t\t\tthis._glInternalFormat = gl.LUMINANCE;\n\t\t\t\t\tthis._glPixelType = device.extTextureHalfFloat.HALF_FLOAT_OES;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_RG16F:\n\t\t\t\tif (device.isWebGL2) {\n\t\t\t\t\tthis._glFormat = gl.RG;\n\t\t\t\t\tthis._glInternalFormat = gl.RG16F;\n\t\t\t\t\tthis._glPixelType = gl.HALF_FLOAT;\n\t\t\t\t} else {\n\t\t\t\t\tthis._glFormat = gl.RG;\n\t\t\t\t\tthis._glInternalFormat = gl.RG;\n\t\t\t\t\tthis._glPixelType = device.extTextureHalfFloat.HALF_FLOAT_OES;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_RGB16F:\n\t\t\t\tthis._glFormat = gl.RGB;\n\t\t\t\tif (device.isWebGL2) {\n\t\t\t\t\tthis._glInternalFormat = gl.RGB16F;\n\t\t\t\t\tthis._glPixelType = gl.HALF_FLOAT;\n\t\t\t\t} else {\n\t\t\t\t\tthis._glInternalFormat = gl.RGB;\n\t\t\t\t\tthis._glPixelType = device.extTextureHalfFloat.HALF_FLOAT_OES;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_RGBA16F:\n\t\t\t\tthis._glFormat = gl.RGBA;\n\t\t\t\tif (device.isWebGL2) {\n\t\t\t\t\tthis._glInternalFormat = gl.RGBA16F;\n\t\t\t\t\tthis._glPixelType = gl.HALF_FLOAT;\n\t\t\t\t} else {\n\t\t\t\t\tthis._glInternalFormat = gl.RGBA;\n\t\t\t\t\tthis._glPixelType = device.extTextureHalfFloat.HALF_FLOAT_OES;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_RGB32F:\n\t\t\t\tthis._glFormat = gl.RGB;\n\t\t\t\tif (device.isWebGL2) {\n\t\t\t\t\tthis._glInternalFormat = gl.RGB32F;\n\t\t\t\t} else {\n\t\t\t\t\tthis._glInternalFormat = gl.RGB;\n\t\t\t\t}\n\t\t\t\tthis._glPixelType = gl.FLOAT;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_RGBA32F:\n\t\t\t\tthis._glFormat = gl.RGBA;\n\t\t\t\tif (device.isWebGL2) {\n\t\t\t\t\tthis._glInternalFormat = gl.RGBA32F;\n\t\t\t\t} else {\n\t\t\t\t\tthis._glInternalFormat = gl.RGBA;\n\t\t\t\t}\n\t\t\t\tthis._glPixelType = gl.FLOAT;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_R32F:\n\t\t\t\tthis._glFormat = gl.RED;\n\t\t\t\tthis._glInternalFormat = gl.R32F;\n\t\t\t\tthis._glPixelType = gl.FLOAT;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_DEPTH:\n\t\t\t\tif (device.isWebGL2) {\n\t\t\t\t\tthis._glFormat = gl.DEPTH_COMPONENT;\n\t\t\t\t\tthis._glInternalFormat = gl.DEPTH_COMPONENT32F;\n\t\t\t\t\tthis._glPixelType = gl.FLOAT;\n\t\t\t\t} else {\n\t\t\t\t\tthis._glFormat = gl.DEPTH_COMPONENT;\n\t\t\t\t\tthis._glInternalFormat = gl.DEPTH_COMPONENT;\n\t\t\t\t\tthis._glPixelType = gl.UNSIGNED_SHORT;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_DEPTHSTENCIL:\n\t\t\t\tthis._glFormat = gl.DEPTH_STENCIL;\n\t\t\t\tif (device.isWebGL2) {\n\t\t\t\t\tthis._glInternalFormat = gl.DEPTH24_STENCIL8;\n\t\t\t\t\tthis._glPixelType = gl.UNSIGNED_INT_24_8;\n\t\t\t\t} else {\n\t\t\t\t\tthis._glInternalFormat = gl.DEPTH_STENCIL;\n\t\t\t\t\tthis._glPixelType = device.extDepthTexture.UNSIGNED_INT_24_8_WEBGL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_111110F:\n\t\t\t\tthis._glFormat = gl.RGB;\n\t\t\t\tthis._glInternalFormat = gl.R11F_G11F_B10F;\n\t\t\t\tthis._glPixelType = gl.UNSIGNED_INT_10F_11F_11F_REV;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_SRGB:\n\t\t\t\tthis._glFormat = gl.RGB;\n\t\t\t\tthis._glInternalFormat = gl.SRGB8;\n\t\t\t\tthis._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_SRGBA:\n\t\t\t\tthis._glFormat = gl.RGBA;\n\t\t\t\tthis._glInternalFormat = gl.SRGB8_ALPHA8;\n\t\t\t\tthis._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_R8I:\n\t\t\t\tthis._glFormat = gl.RED_INTEGER;\n\t\t\t\tthis._glInternalFormat = gl.R8I;\n\t\t\t\tthis._glPixelType = gl.BYTE;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_R8U:\n\t\t\t\tthis._glFormat = gl.RED_INTEGER;\n\t\t\t\tthis._glInternalFormat = gl.R8UI;\n\t\t\t\tthis._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_R16I:\n\t\t\t\tthis._glFormat = gl.RED_INTEGER;\n\t\t\t\tthis._glInternalFormat = gl.R16I;\n\t\t\t\tthis._glPixelType = gl.SHORT;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_R16U:\n\t\t\t\tthis._glFormat = gl.RED_INTEGER;\n\t\t\t\tthis._glInternalFormat = gl.R16UI;\n\t\t\t\tthis._glPixelType = gl.UNSIGNED_SHORT;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_R32I:\n\t\t\t\tthis._glFormat = gl.RED_INTEGER;\n\t\t\t\tthis._glInternalFormat = gl.R32I;\n\t\t\t\tthis._glPixelType = gl.INT;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_R32U:\n\t\t\t\tthis._glFormat = gl.RED_INTEGER;\n\t\t\t\tthis._glInternalFormat = gl.R32UI;\n\t\t\t\tthis._glPixelType = gl.UNSIGNED_INT;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_RG8I:\n\t\t\t\tthis._glFormat = gl.RG_INTEGER;\n\t\t\t\tthis._glInternalFormat = gl.RG8I;\n\t\t\t\tthis._glPixelType = gl.BYTE;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_RG8U:\n\t\t\t\tthis._glFormat = gl.RG_INTEGER;\n\t\t\t\tthis._glInternalFormat = gl.RG8UI;\n\t\t\t\tthis._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_RG16I:\n\t\t\t\tthis._glFormat = gl.RG_INTEGER;\n\t\t\t\tthis._glInternalFormat = gl.RG16I;\n\t\t\t\tthis._glPixelType = gl.SHORT;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_RG16U:\n\t\t\t\tthis._glFormat = gl.RG_INTEGER;\n\t\t\t\tthis._glInternalFormat = gl.RG16UI;\n\t\t\t\tthis._glPixelType = gl.UNSIGNED_SHORT;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_RG32I:\n\t\t\t\tthis._glFormat = gl.RG_INTEGER;\n\t\t\t\tthis._glInternalFormat = gl.RG32I;\n\t\t\t\tthis._glPixelType = gl.INT;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_RG32U:\n\t\t\t\tthis._glFormat = gl.RG_INTEGER;\n\t\t\t\tthis._glInternalFormat = gl.RG32UI;\n\t\t\t\tthis._glPixelType = gl.UNSIGNED_INT;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_RGBA8I:\n\t\t\t\tthis._glFormat = gl.RGBA_INTEGER;\n\t\t\t\tthis._glInternalFormat = gl.RGBA8I;\n\t\t\t\tthis._glPixelType = gl.BYTE;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_RGBA8U:\n\t\t\t\tthis._glFormat = gl.RGBA_INTEGER;\n\t\t\t\tthis._glInternalFormat = gl.RGBA8UI;\n\t\t\t\tthis._glPixelType = gl.UNSIGNED_BYTE;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_RGBA16I:\n\t\t\t\tthis._glFormat = gl.RGBA_INTEGER;\n\t\t\t\tthis._glInternalFormat = gl.RGBA16I;\n\t\t\t\tthis._glPixelType = gl.SHORT;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_RGBA16U:\n\t\t\t\tthis._glFormat = gl.RGBA_INTEGER;\n\t\t\t\tthis._glInternalFormat = gl.RGBA16UI;\n\t\t\t\tthis._glPixelType = gl.UNSIGNED_SHORT;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_RGBA32I:\n\t\t\t\tthis._glFormat = gl.RGBA_INTEGER;\n\t\t\t\tthis._glInternalFormat = gl.RGBA32I;\n\t\t\t\tthis._glPixelType = gl.INT;\n\t\t\t\tbreak;\n\t\t\tcase PIXELFORMAT_RGBA32U:\n\t\t\t\tthis._glFormat = gl.RGBA_INTEGER;\n\t\t\t\tthis._glInternalFormat = gl.RGBA32UI;\n\t\t\t\tthis._glPixelType = gl.UNSIGNED_INT;\n\t\t\t\tbreak;\n\t\t}\n\t\tthis._glCreated = false;\n\t}\n\tupload(device, texture) {\n\t\tconst gl = device.gl;\n\t\tif (!texture._needsUpload && (texture._needsMipmapsUpload && texture._mipmapsUploaded || !texture.pot)) {\n\t\t\treturn;\n\t\t}\n\t\tlet mipLevel = 0;\n\t\tlet mipObject;\n\t\tlet resMult;\n\t\tconst requiredMipLevels = texture.requiredMipLevels;\n\t\tif (texture.array) {\n\t\t\tgl.texStorage3D(gl.TEXTURE_2D_ARRAY, requiredMipLevels, this._glInternalFormat, texture._width, texture._height, texture._arrayLength);\n\t\t}\n\t\twhile (texture._levels[mipLevel] || mipLevel === 0) {\n\t\t\tif (!texture._needsUpload && mipLevel === 0) {\n\t\t\t\tmipLevel++;\n\t\t\t\tcontinue;\n\t\t\t} else if (mipLevel && (!texture._needsMipmapsUpload || !texture._mipmaps)) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmipObject = texture._levels[mipLevel];\n\t\t\tresMult = 1 / Math.pow(2, mipLevel);\n\t\t\tif (mipLevel === 1 && !texture._compressed && !texture._integerFormat && texture._levels.length < requiredMipLevels) {\n\t\t\t\tgl.generateMipmap(this._glTarget);\n\t\t\t\ttexture._mipmapsUploaded = true;\n\t\t\t}\n\t\t\tif (texture._cubemap) {\n\t\t\t\tlet face;\n\t\t\t\tif (device._isBrowserInterface(mipObject[0])) {\n\t\t\t\t\tfor (face = 0; face < 6; face++) {\n\t\t\t\t\t\tif (!texture._levelsUpdated[0][face]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet src = mipObject[face];\n\t\t\t\t\t\tif (device._isImageBrowserInterface(src)) {\n\t\t\t\t\t\t\tif (src.width > device.maxCubeMapSize || src.height > device.maxCubeMapSize) {\n\t\t\t\t\t\t\t\tsrc = downsampleImage(src, device.maxCubeMapSize);\n\t\t\t\t\t\t\t\tif (mipLevel === 0) {\n\t\t\t\t\t\t\t\t\ttexture._width = src.width;\n\t\t\t\t\t\t\t\t\ttexture._height = src.height;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdevice.setUnpackFlipY(false);\n\t\t\t\t\t\tdevice.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);\n\t\t\t\t\t\tif (this._glCreated) {\n\t\t\t\t\t\t\tgl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, 0, 0, this._glFormat, this._glPixelType, src);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, this._glFormat, this._glPixelType, src);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresMult = 1 / Math.pow(2, mipLevel);\n\t\t\t\t\tfor (face = 0; face < 6; face++) {\n\t\t\t\t\t\tif (!texture._levelsUpdated[0][face]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst texData = mipObject[face];\n\t\t\t\t\t\tif (texture._compressed) {\n\t\t\t\t\t\t\tif (this._glCreated && texData) {\n\t\t\t\t\t\t\t\tgl.compressedTexSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, 0, 0, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), this._glInternalFormat, texData);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, texData);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdevice.setUnpackFlipY(false);\n\t\t\t\t\t\t\tdevice.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);\n\t\t\t\t\t\t\tif (this._glCreated && texData) {\n\t\t\t\t\t\t\t\tgl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, 0, 0, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), this._glFormat, this._glPixelType, texData);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tgl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, this._glFormat, this._glPixelType, texData);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (texture._volume) {\n\t\t\t\tif (texture._compressed) {\n\t\t\t\t\tgl.compressedTexImage3D(gl.TEXTURE_3D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, mipObject);\n\t\t\t\t} else {\n\t\t\t\t\tdevice.setUnpackFlipY(false);\n\t\t\t\t\tdevice.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);\n\t\t\t\t\tgl.texImage3D(gl.TEXTURE_3D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), Math.max(texture._depth * resMult, 1), 0, this._glFormat, this._glPixelType, mipObject);\n\t\t\t\t}\n\t\t\t} else if (texture.array && typeof mipObject === 'object') {\n\t\t\t\tif (texture._arrayLength === mipObject.length) {\n\t\t\t\t\tif (texture._compressed) {\n\t\t\t\t\t\tfor (let index = 0; index < texture._arrayLength; index++) {\n\t\t\t\t\t\t\tgl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, mipLevel, 0, 0, index, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 1, this._glInternalFormat, mipObject[index]);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (let index = 0; index < texture._arrayLength; index++) {\n\t\t\t\t\t\t\tgl.texSubImage3D(gl.TEXTURE_2D_ARRAY, mipLevel, 0, 0, index, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 1, this._glFormat, this._glPixelType, mipObject[index]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (device._isBrowserInterface(mipObject)) {\n\t\t\t\t\tif (device._isImageBrowserInterface(mipObject)) {\n\t\t\t\t\t\tif (mipObject.width > device.maxTextureSize || mipObject.height > device.maxTextureSize) {\n\t\t\t\t\t\t\tmipObject = downsampleImage(mipObject, device.maxTextureSize);\n\t\t\t\t\t\t\tif (mipLevel === 0) {\n\t\t\t\t\t\t\t\ttexture._width = mipObject.width;\n\t\t\t\t\t\t\t\ttexture._height = mipObject.height;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tconst w = mipObject.width || mipObject.videoWidth;\n\t\t\t\t\tconst h = mipObject.height || mipObject.videoHeight;\n\t\t\t\t\tdevice.setUnpackFlipY(texture._flipY);\n\t\t\t\t\tdevice.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);\n\t\t\t\t\tif (this._glCreated && texture._width === w && texture._height === h && !device._isImageVideoInterface(mipObject)) {\n\t\t\t\t\t\tgl.texSubImage2D(gl.TEXTURE_2D, mipLevel, 0, 0, this._glFormat, this._glPixelType, mipObject);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgl.texImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, this._glFormat, this._glPixelType, mipObject);\n\t\t\t\t\t\tif (mipLevel === 0) {\n\t\t\t\t\t\t\ttexture._width = w;\n\t\t\t\t\t\t\ttexture._height = h;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tresMult = 1 / Math.pow(2, mipLevel);\n\t\t\t\t\tif (texture._compressed) {\n\t\t\t\t\t\tif (this._glCreated && mipObject) {\n\t\t\t\t\t\t\tgl.compressedTexSubImage2D(gl.TEXTURE_2D, mipLevel, 0, 0, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), this._glInternalFormat, mipObject);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgl.compressedTexImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, Math.max(Math.floor(texture._width * resMult), 1), Math.max(Math.floor(texture._height * resMult), 1), 0, mipObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdevice.setUnpackFlipY(false);\n\t\t\t\t\t\tdevice.setUnpackPremultiplyAlpha(texture._premultiplyAlpha);\n\t\t\t\t\t\tif (this._glCreated && mipObject) {\n\t\t\t\t\t\t\tgl.texSubImage2D(gl.TEXTURE_2D, mipLevel, 0, 0, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), this._glFormat, this._glPixelType, mipObject);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tgl.texImage2D(gl.TEXTURE_2D, mipLevel, this._glInternalFormat, Math.max(texture._width * resMult, 1), Math.max(texture._height * resMult, 1), 0, this._glFormat, this._glPixelType, mipObject);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mipLevel === 0) {\n\t\t\t\t\ttexture._mipmapsUploaded = false;\n\t\t\t\t} else {\n\t\t\t\t\ttexture._mipmapsUploaded = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmipLevel++;\n\t\t}\n\t\tif (texture._needsUpload) {\n\t\t\tif (texture._cubemap) {\n\t\t\t\tfor (let i = 0; i < 6; i++) {\n\t\t\t\t\ttexture._levelsUpdated[0][i] = false;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttexture._levelsUpdated[0] = false;\n\t\t\t}\n\t\t}\n\t\tif (!texture._compressed && !texture._integerFormat && texture._mipmaps && texture._needsMipmapsUpload && (texture.pot || device.isWebGL2) && texture._levels.length === 1) {\n\t\t\tgl.generateMipmap(this._glTarget);\n\t\t\ttexture._mipmapsUploaded = true;\n\t\t}\n\t\tif (texture._gpuSize) {\n\t\t\ttexture.adjustVramSizeTracking(device._vram, -texture._gpuSize);\n\t\t}\n\t\ttexture._gpuSize = texture.gpuSize;\n\t\ttexture.adjustVramSizeTracking(device._vram, texture._gpuSize);\n\t\tthis._glCreated = true;\n\t}\n}\n\nexport { WebglTexture };\n","import { WebglBuffer } from './webgl-buffer.js';\n\nclass WebglVertexBuffer extends WebglBuffer {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.vao = null;\n\t}\n\tdestroy(device) {\n\t\tsuper.destroy(device);\n\t\tdevice.unbindVertexArray();\n\t}\n\tloseContext() {\n\t\tsuper.loseContext();\n\t\tthis.vao = null;\n\t}\n\tunlock(vertexBuffer) {\n\t\tconst device = vertexBuffer.device;\n\t\tsuper.unlock(device, vertexBuffer.usage, device.gl.ARRAY_BUFFER, vertexBuffer.storage);\n\t}\n}\n\nexport { WebglVertexBuffer };\n","const ACTION_MOUSE = 'mouse';\nconst ACTION_KEYBOARD = 'keyboard';\nconst ACTION_GAMEPAD = 'gamepad';\nconst AXIS_MOUSE_X = 'mousex';\nconst AXIS_MOUSE_Y = 'mousey';\nconst AXIS_PAD_L_X = 'padlx';\nconst AXIS_PAD_L_Y = 'padly';\nconst AXIS_PAD_R_X = 'padrx';\nconst AXIS_PAD_R_Y = 'padry';\nconst AXIS_KEY = 'key';\nconst EVENT_KEYDOWN = 'keydown';\nconst EVENT_KEYUP = 'keyup';\nconst EVENT_MOUSEDOWN = 'mousedown';\nconst EVENT_MOUSEMOVE = 'mousemove';\nconst EVENT_MOUSEUP = 'mouseup';\nconst EVENT_MOUSEWHEEL = 'mousewheel';\nconst EVENT_TOUCHSTART = 'touchstart';\nconst EVENT_TOUCHEND = 'touchend';\nconst EVENT_TOUCHMOVE = 'touchmove';\nconst EVENT_TOUCHCANCEL = 'touchcancel';\nconst EVENT_SELECT = 'select';\nconst EVENT_SELECTSTART = 'selectstart';\nconst EVENT_SELECTEND = 'selectend';\nconst KEY_BACKSPACE = 8;\nconst KEY_TAB = 9;\nconst KEY_RETURN = 13;\nconst KEY_ENTER = 13;\nconst KEY_SHIFT = 16;\nconst KEY_CONTROL = 17;\nconst KEY_ALT = 18;\nconst KEY_PAUSE = 19;\nconst KEY_CAPS_LOCK = 20;\nconst KEY_ESCAPE = 27;\nconst KEY_SPACE = 32;\nconst KEY_PAGE_UP = 33;\nconst KEY_PAGE_DOWN = 34;\nconst KEY_END = 35;\nconst KEY_HOME = 36;\nconst KEY_LEFT = 37;\nconst KEY_UP = 38;\nconst KEY_RIGHT = 39;\nconst KEY_DOWN = 40;\nconst KEY_PRINT_SCREEN = 44;\nconst KEY_INSERT = 45;\nconst KEY_DELETE = 46;\nconst KEY_0 = 48;\nconst KEY_1 = 49;\nconst KEY_2 = 50;\nconst KEY_3 = 51;\nconst KEY_4 = 52;\nconst KEY_5 = 53;\nconst KEY_6 = 54;\nconst KEY_7 = 55;\nconst KEY_8 = 56;\nconst KEY_9 = 57;\nconst KEY_SEMICOLON = 59;\nconst KEY_EQUAL = 61;\nconst KEY_A = 65;\nconst KEY_B = 66;\nconst KEY_C = 67;\nconst KEY_D = 68;\nconst KEY_E = 69;\nconst KEY_F = 70;\nconst KEY_G = 71;\nconst KEY_H = 72;\nconst KEY_I = 73;\nconst KEY_J = 74;\nconst KEY_K = 75;\nconst KEY_L = 76;\nconst KEY_M = 77;\nconst KEY_N = 78;\nconst KEY_O = 79;\nconst KEY_P = 80;\nconst KEY_Q = 81;\nconst KEY_R = 82;\nconst KEY_S = 83;\nconst KEY_T = 84;\nconst KEY_U = 85;\nconst KEY_V = 86;\nconst KEY_W = 87;\nconst KEY_X = 88;\nconst KEY_Y = 89;\nconst KEY_Z = 90;\nconst KEY_WINDOWS = 91;\nconst KEY_CONTEXT_MENU = 93;\nconst KEY_NUMPAD_0 = 96;\nconst KEY_NUMPAD_1 = 97;\nconst KEY_NUMPAD_2 = 98;\nconst KEY_NUMPAD_3 = 99;\nconst KEY_NUMPAD_4 = 100;\nconst KEY_NUMPAD_5 = 101;\nconst KEY_NUMPAD_6 = 102;\nconst KEY_NUMPAD_7 = 103;\nconst KEY_NUMPAD_8 = 104;\nconst KEY_NUMPAD_9 = 105;\nconst KEY_MULTIPLY = 106;\nconst KEY_ADD = 107;\nconst KEY_SEPARATOR = 108;\nconst KEY_SUBTRACT = 109;\nconst KEY_DECIMAL = 110;\nconst KEY_DIVIDE = 111;\nconst KEY_F1 = 112;\nconst KEY_F2 = 113;\nconst KEY_F3 = 114;\nconst KEY_F4 = 115;\nconst KEY_F5 = 116;\nconst KEY_F6 = 117;\nconst KEY_F7 = 118;\nconst KEY_F8 = 119;\nconst KEY_F9 = 120;\nconst KEY_F10 = 121;\nconst KEY_F11 = 122;\nconst KEY_F12 = 123;\nconst KEY_COMMA = 188;\nconst KEY_PERIOD = 190;\nconst KEY_SLASH = 191;\nconst KEY_OPEN_BRACKET = 219;\nconst KEY_BACK_SLASH = 220;\nconst KEY_CLOSE_BRACKET = 221;\nconst KEY_META = 224;\nconst MOUSEBUTTON_NONE = -1;\nconst MOUSEBUTTON_LEFT = 0;\nconst MOUSEBUTTON_MIDDLE = 1;\nconst MOUSEBUTTON_RIGHT = 2;\nconst PAD_1 = 0;\nconst PAD_2 = 1;\nconst PAD_3 = 2;\nconst PAD_4 = 3;\nconst PAD_FACE_1 = 0;\nconst PAD_FACE_2 = 1;\nconst PAD_FACE_3 = 2;\nconst PAD_FACE_4 = 3;\nconst PAD_L_SHOULDER_1 = 4;\nconst PAD_R_SHOULDER_1 = 5;\nconst PAD_L_SHOULDER_2 = 6;\nconst PAD_R_SHOULDER_2 = 7;\nconst PAD_SELECT = 8;\nconst PAD_START = 9;\nconst PAD_L_STICK_BUTTON = 10;\nconst PAD_R_STICK_BUTTON = 11;\nconst PAD_UP = 12;\nconst PAD_DOWN = 13;\nconst PAD_LEFT = 14;\nconst PAD_RIGHT = 15;\nconst PAD_VENDOR = 16;\nconst PAD_L_STICK_X = 0;\nconst PAD_L_STICK_Y = 1;\nconst PAD_R_STICK_X = 2;\nconst PAD_R_STICK_Y = 3;\nconst EVENT_GAMEPADCONNECTED = 'gamepadconnected';\nconst EVENT_GAMEPADDISCONNECTED = 'gamepaddisconnected';\nconst XRPAD_TOUCHPAD_X = 0;\nconst XRPAD_TOUCHPAD_Y = 1;\nconst XRPAD_STICK_X = 2;\nconst XRPAD_STICK_Y = 3;\nconst XRPAD_TOUCHPAD_BUTTON = 2;\nconst XRPAD_TRIGGER = 0;\nconst XRPAD_SQUEEZE = 1;\nconst XRPAD_STICK_BUTTON = 3;\nconst XRPAD_A = 4;\nconst XRPAD_B = 5;\n\nexport { ACTION_GAMEPAD, ACTION_KEYBOARD, ACTION_MOUSE, AXIS_KEY, AXIS_MOUSE_X, AXIS_MOUSE_Y, AXIS_PAD_L_X, AXIS_PAD_L_Y, AXIS_PAD_R_X, AXIS_PAD_R_Y, EVENT_GAMEPADCONNECTED, EVENT_GAMEPADDISCONNECTED, EVENT_KEYDOWN, EVENT_KEYUP, EVENT_MOUSEDOWN, EVENT_MOUSEMOVE, EVENT_MOUSEUP, EVENT_MOUSEWHEEL, EVENT_SELECT, EVENT_SELECTEND, EVENT_SELECTSTART, EVENT_TOUCHCANCEL, EVENT_TOUCHEND, EVENT_TOUCHMOVE, EVENT_TOUCHSTART, KEY_0, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_A, KEY_ADD, KEY_ALT, KEY_B, KEY_BACKSPACE, KEY_BACK_SLASH, KEY_C, KEY_CAPS_LOCK, KEY_CLOSE_BRACKET, KEY_COMMA, KEY_CONTEXT_MENU, KEY_CONTROL, KEY_D, KEY_DECIMAL, KEY_DELETE, KEY_DIVIDE, KEY_DOWN, KEY_E, KEY_END, KEY_ENTER, KEY_EQUAL, KEY_ESCAPE, KEY_F, KEY_F1, KEY_F10, KEY_F11, KEY_F12, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6, KEY_F7, KEY_F8, KEY_F9, KEY_G, KEY_H, KEY_HOME, KEY_I, KEY_INSERT, KEY_J, KEY_K, KEY_L, KEY_LEFT, KEY_M, KEY_META, KEY_MULTIPLY, KEY_N, KEY_NUMPAD_0, KEY_NUMPAD_1, KEY_NUMPAD_2, KEY_NUMPAD_3, KEY_NUMPAD_4, KEY_NUMPAD_5, KEY_NUMPAD_6, KEY_NUMPAD_7, KEY_NUMPAD_8, KEY_NUMPAD_9, KEY_O, KEY_OPEN_BRACKET, KEY_P, KEY_PAGE_DOWN, KEY_PAGE_UP, KEY_PAUSE, KEY_PERIOD, KEY_PRINT_SCREEN, KEY_Q, KEY_R, KEY_RETURN, KEY_RIGHT, KEY_S, KEY_SEMICOLON, KEY_SEPARATOR, KEY_SHIFT, KEY_SLASH, KEY_SPACE, KEY_SUBTRACT, KEY_T, KEY_TAB, KEY_U, KEY_UP, KEY_V, KEY_W, KEY_WINDOWS, KEY_X, KEY_Y, KEY_Z, MOUSEBUTTON_LEFT, MOUSEBUTTON_MIDDLE, MOUSEBUTTON_NONE, MOUSEBUTTON_RIGHT, PAD_1, PAD_2, PAD_3, PAD_4, PAD_DOWN, PAD_FACE_1, PAD_FACE_2, PAD_FACE_3, PAD_FACE_4, PAD_LEFT, PAD_L_SHOULDER_1, PAD_L_SHOULDER_2, PAD_L_STICK_BUTTON, PAD_L_STICK_X, PAD_L_STICK_Y, PAD_RIGHT, PAD_R_SHOULDER_1, PAD_R_SHOULDER_2, PAD_R_STICK_BUTTON, PAD_R_STICK_X, PAD_R_STICK_Y, PAD_SELECT, PAD_START, PAD_UP, PAD_VENDOR, XRPAD_A, XRPAD_B, XRPAD_SQUEEZE, XRPAD_STICK_BUTTON, XRPAD_STICK_X, XRPAD_STICK_Y, XRPAD_TOUCHPAD_BUTTON, XRPAD_TOUCHPAD_X, XRPAD_TOUCHPAD_Y, XRPAD_TRIGGER };\n","import { extend } from '../../core/core.js';\nimport { now } from '../../core/time.js';\nimport { path } from '../../core/path.js';\nimport { URI } from '../../core/uri.js';\nimport { math } from '../../core/math/math.js';\n\nclass Http {\n\tget(url, options, callback) {\n\t\tif (typeof options === 'function') {\n\t\t\tcallback = options;\n\t\t\toptions = {};\n\t\t}\n\t\treturn this.request('GET', url, options, callback);\n\t}\n\tpost(url, data, options, callback) {\n\t\tif (typeof options === 'function') {\n\t\t\tcallback = options;\n\t\t\toptions = {};\n\t\t}\n\t\toptions.postdata = data;\n\t\treturn this.request('POST', url, options, callback);\n\t}\n\tput(url, data, options, callback) {\n\t\tif (typeof options === 'function') {\n\t\t\tcallback = options;\n\t\t\toptions = {};\n\t\t}\n\t\toptions.postdata = data;\n\t\treturn this.request('PUT', url, options, callback);\n\t}\n\tdel(url, options, callback) {\n\t\tif (typeof options === 'function') {\n\t\t\tcallback = options;\n\t\t\toptions = {};\n\t\t}\n\t\treturn this.request('DELETE', url, options, callback);\n\t}\n\trequest(method, url, options, callback) {\n\t\tlet uri, query, postdata;\n\t\tlet errored = false;\n\t\tif (typeof options === 'function') {\n\t\t\tcallback = options;\n\t\t\toptions = {};\n\t\t}\n\t\tif (options.retry) {\n\t\t\toptions = Object.assign({\n\t\t\t\tretries: 0,\n\t\t\t\tmaxRetries: 5\n\t\t\t}, options);\n\t\t}\n\t\toptions.callback = callback;\n\t\tif (options.async == null) {\n\t\t\toptions.async = true;\n\t\t}\n\t\tif (options.headers == null) {\n\t\t\toptions.headers = {};\n\t\t}\n\t\tif (options.postdata != null) {\n\t\t\tif (options.postdata instanceof Document) {\n\t\t\t\tpostdata = options.postdata;\n\t\t\t} else if (options.postdata instanceof FormData) {\n\t\t\t\tpostdata = options.postdata;\n\t\t\t} else if (options.postdata instanceof Object) {\n\t\t\t\tlet contentType = options.headers['Content-Type'];\n\t\t\t\tif (contentType === undefined) {\n\t\t\t\t\toptions.headers['Content-Type'] = Http.ContentType.FORM_URLENCODED;\n\t\t\t\t\tcontentType = options.headers['Content-Type'];\n\t\t\t\t}\n\t\t\t\tswitch (contentType) {\n\t\t\t\t\tcase Http.ContentType.FORM_URLENCODED:\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpostdata = '';\n\t\t\t\t\t\t\tlet bFirstItem = true;\n\t\t\t\t\t\t\tfor (const key in options.postdata) {\n\t\t\t\t\t\t\t\tif (options.postdata.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\t\tif (bFirstItem) {\n\t\t\t\t\t\t\t\t\t\tbFirstItem = false;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpostdata += '&';\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tconst encodedKey = encodeURIComponent(key);\n\t\t\t\t\t\t\t\t\tconst encodedValue = encodeURIComponent(options.postdata[key]);\n\t\t\t\t\t\t\t\t\tpostdata += `${encodedKey}=${encodedValue}`;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\tdefault:\n\t\t\t\t\tcase Http.ContentType.JSON:\n\t\t\t\t\t\tif (contentType == null) {\n\t\t\t\t\t\t\toptions.headers['Content-Type'] = Http.ContentType.JSON;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpostdata = JSON.stringify(options.postdata);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpostdata = options.postdata;\n\t\t\t}\n\t\t}\n\t\tif (options.cache === false) {\n\t\t\tconst timestamp = now();\n\t\t\turi = new URI(url);\n\t\t\tif (!uri.query) {\n\t\t\t\turi.query = `ts=${timestamp}`;\n\t\t\t} else {\n\t\t\t\turi.query = `${uri.query}&ts=${timestamp}`;\n\t\t\t}\n\t\t\turl = uri.toString();\n\t\t}\n\t\tif (options.query) {\n\t\t\turi = new URI(url);\n\t\t\tquery = extend(uri.getQuery(), options.query);\n\t\t\turi.setQuery(query);\n\t\t\turl = uri.toString();\n\t\t}\n\t\tconst xhr = new XMLHttpRequest();\n\t\txhr.open(method, url, options.async);\n\t\txhr.withCredentials = options.withCredentials !== undefined ? options.withCredentials : false;\n\t\txhr.responseType = options.responseType || this._guessResponseType(url);\n\t\tfor (const header in options.headers) {\n\t\t\tif (options.headers.hasOwnProperty(header)) {\n\t\t\t\txhr.setRequestHeader(header, options.headers[header]);\n\t\t\t}\n\t\t}\n\t\txhr.onreadystatechange = () => {\n\t\t\tthis._onReadyStateChange(method, url, options, xhr);\n\t\t};\n\t\txhr.onerror = () => {\n\t\t\tthis._onError(method, url, options, xhr);\n\t\t\terrored = true;\n\t\t};\n\t\ttry {\n\t\t\txhr.send(postdata);\n\t\t} catch (e) {\n\t\t\tif (!errored) {\n\t\t\t\toptions.error(xhr.status, xhr, e);\n\t\t\t}\n\t\t}\n\t\treturn xhr;\n\t}\n\t_guessResponseType(url) {\n\t\tconst uri = new URI(url);\n\t\tconst ext = path.getExtension(uri.path).toLowerCase();\n\t\tif (Http.binaryExtensions.indexOf(ext) >= 0) {\n\t\t\treturn Http.ResponseType.ARRAY_BUFFER;\n\t\t} else if (ext === '.json') {\n\t\t\treturn Http.ResponseType.JSON;\n\t\t} else if (ext === '.xml') {\n\t\t\treturn Http.ResponseType.DOCUMENT;\n\t\t}\n\t\treturn Http.ResponseType.TEXT;\n\t}\n\t_isBinaryContentType(contentType) {\n\t\tconst binTypes = [Http.ContentType.BASIS, Http.ContentType.BIN, Http.ContentType.DDS, Http.ContentType.GLB, Http.ContentType.MP3, Http.ContentType.MP4, Http.ContentType.OGG, Http.ContentType.OPUS, Http.ContentType.WAV];\n\t\tif (binTypes.indexOf(contentType) >= 0) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t_isBinaryResponseType(responseType) {\n\t\treturn responseType === Http.ResponseType.ARRAY_BUFFER || responseType === Http.ResponseType.BLOB || responseType === Http.ResponseType.JSON;\n\t}\n\t_onReadyStateChange(method, url, options, xhr) {\n\t\tif (xhr.readyState === 4) {\n\t\t\tswitch (xhr.status) {\n\t\t\t\tcase 0:\n\t\t\t\t\t{\n\t\t\t\t\t\tif (xhr.responseURL && xhr.responseURL.startsWith('file:///')) {\n\t\t\t\t\t\t\tthis._onSuccess(method, url, options, xhr);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis._onError(method, url, options, xhr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tcase 200:\n\t\t\t\tcase 201:\n\t\t\t\tcase 206:\n\t\t\t\tcase 304:\n\t\t\t\t\t{\n\t\t\t\t\t\tthis._onSuccess(method, url, options, xhr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\t{\n\t\t\t\t\t\tthis._onError(method, url, options, xhr);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t_onSuccess(method, url, options, xhr) {\n\t\tlet response;\n\t\tlet contentType;\n\t\tconst header = xhr.getResponseHeader('Content-Type');\n\t\tif (header) {\n\t\t\tconst parts = header.split(';');\n\t\t\tcontentType = parts[0].trim();\n\t\t}\n\t\ttry {\n\t\t\tif (this._isBinaryContentType(contentType) || this._isBinaryResponseType(xhr.responseType)) {\n\t\t\t\tresponse = xhr.response;\n\t\t\t} else if (contentType === Http.ContentType.JSON || url.split('?')[0].endsWith('.json')) {\n\t\t\t\tresponse = JSON.parse(xhr.responseText);\n\t\t\t} else if (xhr.responseType === Http.ResponseType.DOCUMENT || contentType === Http.ContentType.XML) {\n\t\t\t\tresponse = xhr.responseXML;\n\t\t\t} else {\n\t\t\t\tresponse = xhr.responseText;\n\t\t\t}\n\t\t\toptions.callback(null, response);\n\t\t} catch (err) {\n\t\t\toptions.callback(err);\n\t\t}\n\t}\n\t_onError(method, url, options, xhr) {\n\t\tif (options.retrying) {\n\t\t\treturn;\n\t\t}\n\t\tif (options.retry && options.retries < options.maxRetries) {\n\t\t\toptions.retries++;\n\t\t\toptions.retrying = true;\n\t\t\tconst retryDelay = math.clamp(Math.pow(2, options.retries) * Http.retryDelay, 0, options.maxRetryDelay || 5000);\n\t\t\tconsole.log(`${method}: ${url} - Error ${xhr.status}. Retrying in ${retryDelay} ms`);\n\t\t\tsetTimeout(() => {\n\t\t\t\toptions.retrying = false;\n\t\t\t\tthis.request(method, url, options, options.callback);\n\t\t\t}, retryDelay);\n\t\t} else {\n\t\t\toptions.callback(xhr.status === 0 ? 'Network error' : xhr.status, null);\n\t\t}\n\t}\n}\nHttp.ContentType = {\n\tAAC: 'audio/aac',\n\tBASIS: 'image/basis',\n\tBIN: 'application/octet-stream',\n\tDDS: 'image/dds',\n\tFORM_URLENCODED: 'application/x-www-form-urlencoded',\n\tGIF: 'image/gif',\n\tGLB: 'model/gltf-binary',\n\tJPEG: 'image/jpeg',\n\tJSON: 'application/json',\n\tMP3: 'audio/mpeg',\n\tMP4: 'audio/mp4',\n\tOGG: 'audio/ogg',\n\tOPUS: 'audio/ogg; codecs=\"opus\"',\n\tPNG: 'image/png',\n\tTEXT: 'text/plain',\n\tWAV: 'audio/x-wav',\n\tXML: 'application/xml'\n};\nHttp.ResponseType = {\n\tTEXT: 'text',\n\tARRAY_BUFFER: 'arraybuffer',\n\tBLOB: 'blob',\n\tDOCUMENT: 'document',\n\tJSON: 'json'\n};\nHttp.binaryExtensions = ['.model', '.wav', '.ogg', '.mp3', '.mp4', '.m4a', '.aac', '.dds', '.basis', '.glb', '.opus'];\nHttp.retryDelay = 100;\nconst http = new Http();\n\nexport { Http, http };\n","import { EventHandler } from '../../core/event-handler.js';\nimport { math } from '../../core/math/math.js';\nimport { hasAudioContext } from '../audio/capabilities.js';\n\nconst STATE_PLAYING = 0;\nconst STATE_PAUSED = 1;\nconst STATE_STOPPED = 2;\nfunction capTime(time, duration) {\n\treturn time % duration || 0;\n}\nclass SoundInstance extends EventHandler {\n\tconstructor(manager, sound, options) {\n\t\tsuper();\n\t\tthis.source = null;\n\t\tthis._manager = manager;\n\t\tthis._volume = options.volume !== undefined ? math.clamp(Number(options.volume) || 0, 0, 1) : 1;\n\t\tthis._pitch = options.pitch !== undefined ? Math.max(0.01, Number(options.pitch) || 0) : 1;\n\t\tthis._loop = !!(options.loop !== undefined ? options.loop : false);\n\t\tthis._sound = sound;\n\t\tthis._state = STATE_STOPPED;\n\t\tthis._suspended = false;\n\t\tthis._suspendEndEvent = 0;\n\t\tthis._suspendInstanceEvents = false;\n\t\tthis._playWhenLoaded = true;\n\t\tthis._startTime = Math.max(0, Number(options.startTime) || 0);\n\t\tthis._duration = Math.max(0, Number(options.duration) || 0);\n\t\tthis._startOffset = null;\n\t\tthis._onPlayCallback = options.onPlay;\n\t\tthis._onPauseCallback = options.onPause;\n\t\tthis._onResumeCallback = options.onResume;\n\t\tthis._onStopCallback = options.onStop;\n\t\tthis._onEndCallback = options.onEnd;\n\t\tif (hasAudioContext()) {\n\t\t\tthis._startedAt = 0;\n\t\t\tthis._currentTime = 0;\n\t\t\tthis._currentOffset = 0;\n\t\t\tthis._inputNode = null;\n\t\t\tthis._connectorNode = null;\n\t\t\tthis._firstNode = null;\n\t\t\tthis._lastNode = null;\n\t\t\tthis._waitingContextSuspension = false;\n\t\t\tthis._initializeNodes();\n\t\t\tthis._endedHandler = this._onEnded.bind(this);\n\t\t} else {\n\t\t\tthis._isReady = false;\n\t\t\tthis._loadedMetadataHandler = this._onLoadedMetadata.bind(this);\n\t\t\tthis._timeUpdateHandler = this._onTimeUpdate.bind(this);\n\t\t\tthis._endedHandler = this._onEnded.bind(this);\n\t\t\tthis._createSource();\n\t\t}\n\t}\n\tset currentTime(value) {\n\t\tif (value < 0) return;\n\t\tif (this._state === STATE_PLAYING) {\n\t\t\tconst suspend = this._suspendInstanceEvents;\n\t\t\tthis._suspendInstanceEvents = true;\n\t\t\tthis.stop();\n\t\t\tthis._startOffset = value;\n\t\t\tthis.play();\n\t\t\tthis._suspendInstanceEvents = suspend;\n\t\t} else {\n\t\t\tthis._startOffset = value;\n\t\t\tthis._currentTime = value;\n\t\t}\n\t}\n\tget currentTime() {\n\t\tif (this._startOffset !== null) {\n\t\t\treturn this._startOffset;\n\t\t}\n\t\tif (this._state === STATE_PAUSED) {\n\t\t\treturn this._currentTime;\n\t\t}\n\t\tif (this._state === STATE_STOPPED || !this.source) {\n\t\t\treturn 0;\n\t\t}\n\t\tthis._updateCurrentTime();\n\t\treturn this._currentTime;\n\t}\n\tset duration(value) {\n\t\tthis._duration = Math.max(0, Number(value) || 0);\n\t\tconst isPlaying = this._state === STATE_PLAYING;\n\t\tthis.stop();\n\t\tif (isPlaying) {\n\t\t\tthis.play();\n\t\t}\n\t}\n\tget duration() {\n\t\tif (!this._sound) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (this._duration) {\n\t\t\treturn capTime(this._duration, this._sound.duration);\n\t\t}\n\t\treturn this._sound.duration;\n\t}\n\tget isPaused() {\n\t\treturn this._state === STATE_PAUSED;\n\t}\n\tget isPlaying() {\n\t\treturn this._state === STATE_PLAYING;\n\t}\n\tget isStopped() {\n\t\treturn this._state === STATE_STOPPED;\n\t}\n\tget isSuspended() {\n\t\treturn this._suspended;\n\t}\n\tset loop(value) {\n\t\tthis._loop = !!value;\n\t\tif (this.source) {\n\t\t\tthis.source.loop = this._loop;\n\t\t}\n\t}\n\tget loop() {\n\t\treturn this._loop;\n\t}\n\tset pitch(pitch) {\n\t\tthis._currentOffset = this.currentTime;\n\t\tthis._startedAt = this._manager.context.currentTime;\n\t\tthis._pitch = Math.max(Number(pitch) || 0, 0.01);\n\t\tif (this.source) {\n\t\t\tthis.source.playbackRate.value = this._pitch;\n\t\t}\n\t}\n\tget pitch() {\n\t\treturn this._pitch;\n\t}\n\tset sound(value) {\n\t\tthis._sound = value;\n\t\tif (this._state !== STATE_STOPPED) {\n\t\t\tthis.stop();\n\t\t} else {\n\t\t\tthis._createSource();\n\t\t}\n\t}\n\tget sound() {\n\t\treturn this._sound;\n\t}\n\tset startTime(value) {\n\t\tthis._startTime = Math.max(0, Number(value) || 0);\n\t\tconst isPlaying = this._state === STATE_PLAYING;\n\t\tthis.stop();\n\t\tif (isPlaying) {\n\t\t\tthis.play();\n\t\t}\n\t}\n\tget startTime() {\n\t\treturn this._startTime;\n\t}\n\tset volume(volume) {\n\t\tvolume = math.clamp(volume, 0, 1);\n\t\tthis._volume = volume;\n\t\tif (this.gain) {\n\t\t\tthis.gain.gain.value = volume * this._manager.volume;\n\t\t}\n\t}\n\tget volume() {\n\t\treturn this._volume;\n\t}\n\t_onPlay() {\n\t\tthis.fire('play');\n\t\tif (this._onPlayCallback) {\n\t\t\tthis._onPlayCallback(this);\n\t\t}\n\t}\n\t_onPause() {\n\t\tthis.fire('pause');\n\t\tif (this._onPauseCallback) {\n\t\t\tthis._onPauseCallback(this);\n\t\t}\n\t}\n\t_onResume() {\n\t\tthis.fire('resume');\n\t\tif (this._onResumeCallback) {\n\t\t\tthis._onResumeCallback(this);\n\t\t}\n\t}\n\t_onStop() {\n\t\tthis.fire('stop');\n\t\tif (this._onStopCallback) {\n\t\t\tthis._onStopCallback(this);\n\t\t}\n\t}\n\t_onEnded() {\n\t\tif (this._suspendEndEvent > 0) {\n\t\t\tthis._suspendEndEvent--;\n\t\t\treturn;\n\t\t}\n\t\tthis.fire('end');\n\t\tif (this._onEndCallback) {\n\t\t\tthis._onEndCallback(this);\n\t\t}\n\t\tthis.stop();\n\t}\n\t_onManagerVolumeChange() {\n\t\tthis.volume = this._volume;\n\t}\n\t_onManagerSuspend() {\n\t\tif (this._state === STATE_PLAYING && !this._suspended) {\n\t\t\tthis._suspended = true;\n\t\t\tthis.pause();\n\t\t}\n\t}\n\t_onManagerResume() {\n\t\tif (this._suspended) {\n\t\t\tthis._suspended = false;\n\t\t\tthis.resume();\n\t\t}\n\t}\n\t_initializeNodes() {\n\t\tthis.gain = this._manager.context.createGain();\n\t\tthis._inputNode = this.gain;\n\t\tthis._connectorNode = this.gain;\n\t\tthis._connectorNode.connect(this._manager.context.destination);\n\t}\n\tplay() {\n\t\tif (this._state !== STATE_STOPPED) {\n\t\t\tthis.stop();\n\t\t}\n\t\tthis._state = STATE_PLAYING;\n\t\tthis._playWhenLoaded = false;\n\t\tif (this._waitingContextSuspension) {\n\t\t\treturn false;\n\t\t}\n\t\tif (this._manager.suspended) {\n\t\t\tthis._manager.once('resume', this._playAudioImmediate, this);\n\t\t\tthis._waitingContextSuspension = true;\n\t\t\treturn false;\n\t\t}\n\t\tthis._playAudioImmediate();\n\t\treturn true;\n\t}\n\t_playAudioImmediate() {\n\t\tthis._waitingContextSuspension = false;\n\t\tif (this._state !== STATE_PLAYING) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this.source) {\n\t\t\tthis._createSource();\n\t\t}\n\t\tlet offset = capTime(this._startOffset, this.duration);\n\t\toffset = capTime(this._startTime + offset, this._sound.duration);\n\t\tthis._startOffset = null;\n\t\tif (this._duration) {\n\t\t\tthis.source.start(0, offset, this._duration);\n\t\t} else {\n\t\t\tthis.source.start(0, offset);\n\t\t}\n\t\tthis._startedAt = this._manager.context.currentTime;\n\t\tthis._currentTime = 0;\n\t\tthis._currentOffset = offset;\n\t\tthis.volume = this._volume;\n\t\tthis.loop = this._loop;\n\t\tthis.pitch = this._pitch;\n\t\tthis._manager.on('volumechange', this._onManagerVolumeChange, this);\n\t\tthis._manager.on('suspend', this._onManagerSuspend, this);\n\t\tthis._manager.on('resume', this._onManagerResume, this);\n\t\tthis._manager.on('destroy', this._onManagerDestroy, this);\n\t\tif (!this._suspendInstanceEvents) {\n\t\t\tthis._onPlay();\n\t\t}\n\t}\n\tpause() {\n\t\tthis._playWhenLoaded = false;\n\t\tif (this._state !== STATE_PLAYING) {\n\t\t\treturn false;\n\t\t}\n\t\tthis._state = STATE_PAUSED;\n\t\tif (this._waitingContextSuspension) {\n\t\t\treturn true;\n\t\t}\n\t\tthis._updateCurrentTime();\n\t\tthis._suspendEndEvent++;\n\t\tthis.source.stop(0);\n\t\tthis.source = null;\n\t\tthis._startOffset = null;\n\t\tif (!this._suspendInstanceEvents) {\n\t\t\tthis._onPause();\n\t\t}\n\t\treturn true;\n\t}\n\tresume() {\n\t\tif (this._state !== STATE_PAUSED) {\n\t\t\treturn false;\n\t\t}\n\t\tlet offset = this.currentTime;\n\t\tthis._state = STATE_PLAYING;\n\t\tif (this._waitingContextSuspension) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!this.source) {\n\t\t\tthis._createSource();\n\t\t}\n\t\tif (this._startOffset !== null) {\n\t\t\toffset = capTime(this._startOffset, this.duration);\n\t\t\toffset = capTime(this._startTime + offset, this._sound.duration);\n\t\t\tthis._startOffset = null;\n\t\t}\n\t\tif (this._duration) {\n\t\t\tthis.source.start(0, offset, this._duration);\n\t\t} else {\n\t\t\tthis.source.start(0, offset);\n\t\t}\n\t\tthis._startedAt = this._manager.context.currentTime;\n\t\tthis._currentOffset = offset;\n\t\tthis.volume = this._volume;\n\t\tthis.loop = this._loop;\n\t\tthis.pitch = this._pitch;\n\t\tthis._playWhenLoaded = false;\n\t\tif (!this._suspendInstanceEvents) {\n\t\t\tthis._onResume();\n\t\t}\n\t\treturn true;\n\t}\n\tstop() {\n\t\tthis._playWhenLoaded = false;\n\t\tif (this._state === STATE_STOPPED) {\n\t\t\treturn false;\n\t\t}\n\t\tconst wasPlaying = this._state === STATE_PLAYING;\n\t\tthis._state = STATE_STOPPED;\n\t\tif (this._waitingContextSuspension) {\n\t\t\treturn true;\n\t\t}\n\t\tthis._manager.off('volumechange', this._onManagerVolumeChange, this);\n\t\tthis._manager.off('suspend', this._onManagerSuspend, this);\n\t\tthis._manager.off('resume', this._onManagerResume, this);\n\t\tthis._manager.off('destroy', this._onManagerDestroy, this);\n\t\tthis._startedAt = 0;\n\t\tthis._currentTime = 0;\n\t\tthis._currentOffset = 0;\n\t\tthis._startOffset = null;\n\t\tthis._suspendEndEvent++;\n\t\tif (wasPlaying && this.source) {\n\t\t\tthis.source.stop(0);\n\t\t}\n\t\tthis.source = null;\n\t\tif (!this._suspendInstanceEvents) {\n\t\t\tthis._onStop();\n\t\t}\n\t\treturn true;\n\t}\n\tsetExternalNodes(firstNode, lastNode) {\n\t\tif (!firstNode) {\n\t\t\tconsole.error('The firstNode must be a valid Audio Node');\n\t\t\treturn;\n\t\t}\n\t\tif (!lastNode) {\n\t\t\tlastNode = firstNode;\n\t\t}\n\t\tconst speakers = this._manager.context.destination;\n\t\tif (this._firstNode !== firstNode) {\n\t\t\tif (this._firstNode) {\n\t\t\t\tthis._connectorNode.disconnect(this._firstNode);\n\t\t\t} else {\n\t\t\t\tthis._connectorNode.disconnect(speakers);\n\t\t\t}\n\t\t\tthis._firstNode = firstNode;\n\t\t\tthis._connectorNode.connect(firstNode);\n\t\t}\n\t\tif (this._lastNode !== lastNode) {\n\t\t\tif (this._lastNode) {\n\t\t\t\tthis._lastNode.disconnect(speakers);\n\t\t\t}\n\t\t\tthis._lastNode = lastNode;\n\t\t\tthis._lastNode.connect(speakers);\n\t\t}\n\t}\n\tclearExternalNodes() {\n\t\tconst speakers = this._manager.context.destination;\n\t\tif (this._firstNode) {\n\t\t\tthis._connectorNode.disconnect(this._firstNode);\n\t\t\tthis._firstNode = null;\n\t\t}\n\t\tif (this._lastNode) {\n\t\t\tthis._lastNode.disconnect(speakers);\n\t\t\tthis._lastNode = null;\n\t\t}\n\t\tthis._connectorNode.connect(speakers);\n\t}\n\tgetExternalNodes() {\n\t\treturn [this._firstNode, this._lastNode];\n\t}\n\t_createSource() {\n\t\tif (!this._sound) {\n\t\t\treturn null;\n\t\t}\n\t\tconst context = this._manager.context;\n\t\tif (this._sound.buffer) {\n\t\t\tthis.source = context.createBufferSource();\n\t\t\tthis.source.buffer = this._sound.buffer;\n\t\t\tthis.source.connect(this._inputNode);\n\t\t\tthis.source.onended = this._endedHandler;\n\t\t\tthis.source.loopStart = capTime(this._startTime, this.source.buffer.duration);\n\t\t\tif (this._duration) {\n\t\t\t\tthis.source.loopEnd = Math.max(this.source.loopStart, capTime(this._startTime + this._duration, this.source.buffer.duration));\n\t\t\t}\n\t\t}\n\t\treturn this.source;\n\t}\n\t_updateCurrentTime() {\n\t\tthis._currentTime = capTime((this._manager.context.currentTime - this._startedAt) * this._pitch + this._currentOffset, this.duration);\n\t}\n\t_onManagerDestroy() {\n\t\tif (this.source && this._state === STATE_PLAYING) {\n\t\t\tthis.source.stop(0);\n\t\t\tthis.source = null;\n\t\t}\n\t}\n}\nSoundInstance.EVENT_PLAY = 'play';\nSoundInstance.EVENT_PAUSE = 'pause';\nSoundInstance.EVENT_RESUME = 'resume';\nSoundInstance.EVENT_STOP = 'stop';\nSoundInstance.EVENT_END = 'end';\nif (!hasAudioContext()) {\n\tObject.assign(SoundInstance.prototype, {\n\t\tplay: function () {\n\t\t\tif (this._state !== STATE_STOPPED) {\n\t\t\t\tthis.stop();\n\t\t\t}\n\t\t\tif (!this.source) {\n\t\t\t\tif (!this._createSource()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.volume = this._volume;\n\t\t\tthis.pitch = this._pitch;\n\t\t\tthis.loop = this._loop;\n\t\t\tthis.source.play();\n\t\t\tthis._state = STATE_PLAYING;\n\t\t\tthis._playWhenLoaded = false;\n\t\t\tthis._manager.on('volumechange', this._onManagerVolumeChange, this);\n\t\t\tthis._manager.on('suspend', this._onManagerSuspend, this);\n\t\t\tthis._manager.on('resume', this._onManagerResume, this);\n\t\t\tthis._manager.on('destroy', this._onManagerDestroy, this);\n\t\t\tif (this._manager.suspended) {\n\t\t\t\tthis._onManagerSuspend();\n\t\t\t}\n\t\t\tif (!this._suspendInstanceEvents) {\n\t\t\t\tthis._onPlay();\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\tpause: function () {\n\t\t\tif (!this.source || this._state !== STATE_PLAYING) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis._suspendEndEvent++;\n\t\t\tthis.source.pause();\n\t\t\tthis._playWhenLoaded = false;\n\t\t\tthis._state = STATE_PAUSED;\n\t\t\tthis._startOffset = null;\n\t\t\tif (!this._suspendInstanceEvents) {\n\t\t\t\tthis._onPause();\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\tresume: function () {\n\t\t\tif (!this.source || this._state !== STATE_PAUSED) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis._state = STATE_PLAYING;\n\t\t\tthis._playWhenLoaded = false;\n\t\t\tif (this.source.paused) {\n\t\t\t\tthis.source.play();\n\t\t\t\tif (!this._suspendInstanceEvents) {\n\t\t\t\t\tthis._onResume();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\tstop: function () {\n\t\t\tif (!this.source || this._state === STATE_STOPPED) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tthis._manager.off('volumechange', this._onManagerVolumeChange, this);\n\t\t\tthis._manager.off('suspend', this._onManagerSuspend, this);\n\t\t\tthis._manager.off('resume', this._onManagerResume, this);\n\t\t\tthis._manager.off('destroy', this._onManagerDestroy, this);\n\t\t\tthis._suspendEndEvent++;\n\t\t\tthis.source.pause();\n\t\t\tthis._playWhenLoaded = false;\n\t\t\tthis._state = STATE_STOPPED;\n\t\t\tthis._startOffset = null;\n\t\t\tif (!this._suspendInstanceEvents) {\n\t\t\t\tthis._onStop();\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\t\tsetExternalNodes: function () {},\n\t\tclearExternalNodes: function () {},\n\t\tgetExternalNodes: function () {\n\t\t\treturn [null, null];\n\t\t},\n\t\t_onLoadedMetadata: function () {\n\t\t\tthis.source.removeEventListener('loadedmetadata', this._loadedMetadataHandler);\n\t\t\tthis._isReady = true;\n\t\t\tlet offset = capTime(this._startOffset, this.duration);\n\t\t\toffset = capTime(this._startTime + offset, this._sound.duration);\n\t\t\tthis._startOffset = null;\n\t\t\tthis.source.currentTime = offset;\n\t\t},\n\t\t_createSource: function () {\n\t\t\tif (this._sound && this._sound.audio) {\n\t\t\t\tthis._isReady = false;\n\t\t\t\tthis.source = this._sound.audio.cloneNode(true);\n\t\t\t\tthis.source.addEventListener('loadedmetadata', this._loadedMetadataHandler);\n\t\t\t\tthis.source.addEventListener('timeupdate', this._timeUpdateHandler);\n\t\t\t\tthis.source.onended = this._endedHandler;\n\t\t\t}\n\t\t\treturn this.source;\n\t\t},\n\t\t_onTimeUpdate: function () {\n\t\t\tif (!this._duration) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.source.currentTime > capTime(this._startTime + this._duration, this.source.duration)) {\n\t\t\t\tif (this.loop) {\n\t\t\t\t\tthis.source.currentTime = capTime(this._startTime, this.source.duration);\n\t\t\t\t} else {\n\t\t\t\t\tthis.source.removeEventListener('timeupdate', this._timeUpdateHandler);\n\t\t\t\t\tthis.source.pause();\n\t\t\t\t\tthis._onEnded();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t_onManagerDestroy: function () {\n\t\t\tif (this.source) {\n\t\t\t\tthis.source.pause();\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance.prototype, 'volume', {\n\t\tget: function () {\n\t\t\treturn this._volume;\n\t\t},\n\t\tset: function (volume) {\n\t\t\tvolume = math.clamp(volume, 0, 1);\n\t\t\tthis._volume = volume;\n\t\t\tif (this.source) {\n\t\t\t\tthis.source.volume = volume * this._manager.volume;\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance.prototype, 'pitch', {\n\t\tget: function () {\n\t\t\treturn this._pitch;\n\t\t},\n\t\tset: function (pitch) {\n\t\t\tthis._pitch = Math.max(Number(pitch) || 0, 0.01);\n\t\t\tif (this.source) {\n\t\t\t\tthis.source.playbackRate = this._pitch;\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance.prototype, 'sound', {\n\t\tget: function () {\n\t\t\treturn this._sound;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis.stop();\n\t\t\tthis._sound = value;\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance.prototype, 'currentTime', {\n\t\tget: function () {\n\t\t\tif (this._startOffset !== null) {\n\t\t\t\treturn this._startOffset;\n\t\t\t}\n\t\t\tif (this._state === STATE_STOPPED || !this.source) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn this.source.currentTime - this._startTime;\n\t\t},\n\t\tset: function (value) {\n\t\t\tif (value < 0) return;\n\t\t\tthis._startOffset = value;\n\t\t\tif (this.source && this._isReady) {\n\t\t\t\tthis.source.currentTime = capTime(this._startTime + capTime(value, this.duration), this._sound.duration);\n\t\t\t\tthis._startOffset = null;\n\t\t\t}\n\t\t}\n\t});\n}\n\nexport { SoundInstance };\n","import { math } from '../../core/math/math.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { DISTANCE_LINEAR, DISTANCE_INVERSE, DISTANCE_EXPONENTIAL } from '../audio/constants.js';\nimport { hasAudioContext } from '../audio/capabilities.js';\nimport { SoundInstance } from './instance.js';\n\nconst MAX_DISTANCE = 10000;\nclass SoundInstance3d extends SoundInstance {\n\tconstructor(manager, sound, options = {}) {\n\t\tsuper(manager, sound, options);\n\t\tthis._position = new Vec3();\n\t\tthis._velocity = new Vec3();\n\t\tif (options.position) {\n\t\t\tthis.position = options.position;\n\t\t}\n\t\tthis.maxDistance = options.maxDistance !== undefined ? Number(options.maxDistance) : MAX_DISTANCE;\n\t\tthis.refDistance = options.refDistance !== undefined ? Number(options.refDistance) : 1;\n\t\tthis.rollOffFactor = options.rollOffFactor !== undefined ? Number(options.rollOffFactor) : 1;\n\t\tthis.distanceModel = options.distanceModel !== undefined ? options.distanceModel : DISTANCE_LINEAR;\n\t}\n\t_initializeNodes() {\n\t\tthis.gain = this._manager.context.createGain();\n\t\tthis.panner = this._manager.context.createPanner();\n\t\tthis.panner.connect(this.gain);\n\t\tthis._inputNode = this.panner;\n\t\tthis._connectorNode = this.gain;\n\t\tthis._connectorNode.connect(this._manager.context.destination);\n\t}\n\tset position(value) {\n\t\tthis._position.copy(value);\n\t\tconst panner = this.panner;\n\t\tif ('positionX' in panner) {\n\t\t\tpanner.positionX.value = value.x;\n\t\t\tpanner.positionY.value = value.y;\n\t\t\tpanner.positionZ.value = value.z;\n\t\t} else if (panner.setPosition) {\n\t\t\tpanner.setPosition(value.x, value.y, value.z);\n\t\t}\n\t}\n\tget position() {\n\t\treturn this._position;\n\t}\n\tset velocity(velocity) {\n\t\tthis._velocity.copy(velocity);\n\t}\n\tget velocity() {\n\t\treturn this._velocity;\n\t}\n\tset maxDistance(value) {\n\t\tthis.panner.maxDistance = value;\n\t}\n\tget maxDistance() {\n\t\treturn this.panner.maxDistance;\n\t}\n\tset refDistance(value) {\n\t\tthis.panner.refDistance = value;\n\t}\n\tget refDistance() {\n\t\treturn this.panner.refDistance;\n\t}\n\tset rollOffFactor(value) {\n\t\tthis.panner.rolloffFactor = value;\n\t}\n\tget rollOffFactor() {\n\t\treturn this.panner.rolloffFactor;\n\t}\n\tset distanceModel(value) {\n\t\tthis.panner.distanceModel = value;\n\t}\n\tget distanceModel() {\n\t\treturn this.panner.distanceModel;\n\t}\n}\nif (!hasAudioContext()) {\n\tlet offset = new Vec3();\n\tconst fallOff = function fallOff(posOne, posTwo, refDistance, maxDistance, rollOffFactor, distanceModel) {\n\t\toffset = offset.sub2(posOne, posTwo);\n\t\tconst distance = offset.length();\n\t\tif (distance < refDistance) {\n\t\t\treturn 1;\n\t\t} else if (distance > maxDistance) {\n\t\t\treturn 0;\n\t\t}\n\t\tlet result = 0;\n\t\tif (distanceModel === DISTANCE_LINEAR) {\n\t\t\tresult = 1 - rollOffFactor * (distance - refDistance) / (maxDistance - refDistance);\n\t\t} else if (distanceModel === DISTANCE_INVERSE) {\n\t\t\tresult = refDistance / (refDistance + rollOffFactor * (distance - refDistance));\n\t\t} else if (distanceModel === DISTANCE_EXPONENTIAL) {\n\t\t\tresult = Math.pow(distance / refDistance, -rollOffFactor);\n\t\t}\n\t\treturn math.clamp(result, 0, 1);\n\t};\n\tObject.defineProperty(SoundInstance3d.prototype, 'position', {\n\t\tget: function () {\n\t\t\treturn this._position;\n\t\t},\n\t\tset: function (position) {\n\t\t\tthis._position.copy(position);\n\t\t\tif (this.source) {\n\t\t\t\tconst listener = this._manager.listener;\n\t\t\t\tconst lpos = listener.getPosition();\n\t\t\t\tconst factor = fallOff(lpos, this._position, this.refDistance, this.maxDistance, this.rollOffFactor, this.distanceModel);\n\t\t\t\tconst v = this.volume;\n\t\t\t\tthis.source.volume = v * factor * this._manager.volume;\n\t\t\t}\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'maxDistance', {\n\t\tget: function () {\n\t\t\treturn this._maxDistance;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis._maxDistance = value;\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'refDistance', {\n\t\tget: function () {\n\t\t\treturn this._refDistance;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis._refDistance = value;\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'rollOffFactor', {\n\t\tget: function () {\n\t\t\treturn this._rollOffFactor;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis._rollOffFactor = value;\n\t\t}\n\t});\n\tObject.defineProperty(SoundInstance3d.prototype, 'distanceModel', {\n\t\tget: function () {\n\t\t\treturn this._distanceModel;\n\t\t},\n\t\tset: function (value) {\n\t\t\tthis._distanceModel = value;\n\t\t}\n\t});\n}\n\nexport { SoundInstance3d };\n","import { Mat4 } from '../../core/math/mat4.js';\nimport { Vec3 } from '../../core/math/vec3.js';\n\nclass Listener {\n\tconstructor(manager) {\n\t\tthis._manager = void 0;\n\t\tthis.position = new Vec3();\n\t\tthis.velocity = new Vec3();\n\t\tthis.orientation = new Mat4();\n\t\tthis._manager = manager;\n\t}\n\tgetPosition() {\n\t\treturn this.position;\n\t}\n\tsetPosition(position) {\n\t\tthis.position.copy(position);\n\t\tconst listener = this.listener;\n\t\tif (listener) {\n\t\t\tif ('positionX' in listener) {\n\t\t\t\tlistener.positionX.value = position.x;\n\t\t\t\tlistener.positionY.value = position.y;\n\t\t\t\tlistener.positionZ.value = position.z;\n\t\t\t} else if (listener.setPosition) {\n\t\t\t\tlistener.setPosition(position.x, position.y, position.z);\n\t\t\t}\n\t\t}\n\t}\n\tgetVelocity() {\n\t\treturn this.velocity;\n\t}\n\tsetVelocity(velocity) {}\n\tsetOrientation(orientation) {\n\t\tthis.orientation.copy(orientation);\n\t\tconst listener = this.listener;\n\t\tif (listener) {\n\t\t\tconst m = orientation.data;\n\t\t\tif ('forwardX' in listener) {\n\t\t\t\tlistener.forwardX.value = -m[8];\n\t\t\t\tlistener.forwardY.value = -m[9];\n\t\t\t\tlistener.forwardZ.value = -m[10];\n\t\t\t\tlistener.upX.value = m[4];\n\t\t\t\tlistener.upY.value = m[5];\n\t\t\t\tlistener.upZ.value = m[6];\n\t\t\t} else if (listener.setOrientation) {\n\t\t\t\tlistener.setOrientation(-m[8], -m[9], -m[10], m[4], m[5], m[6]);\n\t\t\t}\n\t\t}\n\t}\n\tgetOrientation() {\n\t\treturn this.orientation;\n\t}\n\tget listener() {\n\t\tconst context = this._manager.context;\n\t\treturn context ? context.listener : null;\n\t}\n}\n\nexport { Listener };\n","import { EventHandler } from '../../core/event-handler.js';\nimport { math } from '../../core/math/math.js';\nimport { Channel } from '../audio/channel.js';\nimport { Channel3d } from '../audio/channel3d.js';\nimport { Listener } from './listener.js';\n\nconst CONTEXT_STATE_RUNNING = 'running';\nconst USER_INPUT_EVENTS = ['click', 'touchstart', 'mousedown'];\nclass SoundManager extends EventHandler {\n\tconstructor() {\n\t\tsuper();\n\t\tthis._context = null;\n\t\tthis.AudioContext = typeof AudioContext !== 'undefined' && AudioContext || typeof webkitAudioContext !== 'undefined' && webkitAudioContext;\n\t\tif (!this.AudioContext) ;\n\t\tthis._unlockHandlerFunc = this._unlockHandler.bind(this);\n\t\tthis._userSuspended = false;\n\t\tthis.listener = new Listener(this);\n\t\tthis._volume = 1;\n\t}\n\tset volume(volume) {\n\t\tvolume = math.clamp(volume, 0, 1);\n\t\tthis._volume = volume;\n\t\tthis.fire('volumechange', volume);\n\t}\n\tget volume() {\n\t\treturn this._volume;\n\t}\n\tget suspended() {\n\t\treturn this._userSuspended;\n\t}\n\tget context() {\n\t\tif (!this._context && this.AudioContext) {\n\t\t\tthis._context = new this.AudioContext();\n\t\t\tif (this._context.state !== CONTEXT_STATE_RUNNING) {\n\t\t\t\tthis._registerUnlockListeners();\n\t\t\t}\n\t\t}\n\t\treturn this._context;\n\t}\n\tsuspend() {\n\t\tif (!this._userSuspended) {\n\t\t\tthis._userSuspended = true;\n\t\t\tif (this._context && this._context.state === CONTEXT_STATE_RUNNING) {\n\t\t\t\tthis._suspend();\n\t\t\t}\n\t\t}\n\t}\n\tresume() {\n\t\tif (this._userSuspended) {\n\t\t\tthis._userSuspended = false;\n\t\t\tif (this._context && this._context.state !== CONTEXT_STATE_RUNNING) {\n\t\t\t\tthis._resume();\n\t\t\t}\n\t\t}\n\t}\n\tdestroy() {\n\t\tthis.fire('destroy');\n\t\tif (this._context) {\n\t\t\tvar _this$_context;\n\t\t\tthis._removeUnlockListeners();\n\t\t\t(_this$_context = this._context) == null || _this$_context.close();\n\t\t\tthis._context = null;\n\t\t}\n\t}\n\tplaySound(sound, options = {}) {\n\t\tlet channel = null;\n\t\tif (Channel) {\n\t\t\tchannel = new Channel(this, sound, options);\n\t\t\tchannel.play();\n\t\t}\n\t\treturn channel;\n\t}\n\tplaySound3d(sound, position, options = {}) {\n\t\tlet channel = null;\n\t\tif (Channel3d) {\n\t\t\tchannel = new Channel3d(this, sound, options);\n\t\t\tchannel.setPosition(position);\n\t\t\tif (options.volume) {\n\t\t\t\tchannel.setVolume(options.volume);\n\t\t\t}\n\t\t\tif (options.loop) {\n\t\t\t\tchannel.setLoop(options.loop);\n\t\t\t}\n\t\t\tif (options.maxDistance) {\n\t\t\t\tchannel.setMaxDistance(options.maxDistance);\n\t\t\t}\n\t\t\tif (options.minDistance) {\n\t\t\t\tchannel.setMinDistance(options.minDistance);\n\t\t\t}\n\t\t\tif (options.rollOffFactor) {\n\t\t\t\tchannel.setRollOffFactor(options.rollOffFactor);\n\t\t\t}\n\t\t\tif (options.distanceModel) {\n\t\t\t\tchannel.setDistanceModel(options.distanceModel);\n\t\t\t}\n\t\t\tchannel.play();\n\t\t}\n\t\treturn channel;\n\t}\n\t_resume() {\n\t\tthis._context.resume().then(() => {\n\t\t\tconst source = this._context.createBufferSource();\n\t\t\tsource.buffer = this._context.createBuffer(1, 1, this._context.sampleRate);\n\t\t\tsource.connect(this._context.destination);\n\t\t\tsource.start(0);\n\t\t\tsource.onended = event => {\n\t\t\t\tsource.disconnect(0);\n\t\t\t\tthis.fire('resume');\n\t\t\t};\n\t\t}, e => {}).catch(e => {});\n\t}\n\t_suspend() {\n\t\tthis._context.suspend().then(() => {\n\t\t\tthis.fire('suspend');\n\t\t}, e => {}).catch(e => {});\n\t}\n\t_unlockHandler() {\n\t\tthis._removeUnlockListeners();\n\t\tif (!this._userSuspended && this._context.state !== CONTEXT_STATE_RUNNING) {\n\t\t\tthis._resume();\n\t\t}\n\t}\n\t_registerUnlockListeners() {\n\t\tUSER_INPUT_EVENTS.forEach(eventName => {\n\t\t\twindow.addEventListener(eventName, this._unlockHandlerFunc, false);\n\t\t});\n\t}\n\t_removeUnlockListeners() {\n\t\tUSER_INPUT_EVENTS.forEach(eventName => {\n\t\t\twindow.removeEventListener(eventName, this._unlockHandlerFunc, false);\n\t\t});\n\t}\n}\n\nexport { SoundManager };\n","class Sound {\n\tconstructor(resource) {\n\t\tthis.audio = void 0;\n\t\tthis.buffer = void 0;\n\t\tif (resource instanceof Audio) {\n\t\t\tthis.audio = resource;\n\t\t} else {\n\t\t\tthis.buffer = resource;\n\t\t}\n\t}\n\tget duration() {\n\t\tlet duration = 0;\n\t\tif (this.buffer) {\n\t\t\tduration = this.buffer.duration;\n\t\t} else if (this.audio) {\n\t\t\tduration = this.audio.duration;\n\t\t}\n\t\treturn duration || 0;\n\t}\n}\n\nexport { Sound };\n","class Key {\n\tconstructor(time, position, rotation, scale) {\n\t\tthis.time = time;\n\t\tthis.position = position;\n\t\tthis.rotation = rotation;\n\t\tthis.scale = scale;\n\t}\n}\nclass Node {\n\tconstructor() {\n\t\tthis._name = '';\n\t\tthis._keys = [];\n\t}\n}\nclass Animation {\n\tconstructor() {\n\t\tthis.name = '';\n\t\tthis.duration = 0;\n\t\tthis._nodes = [];\n\t\tthis._nodeDict = {};\n\t}\n\tgetNode(name) {\n\t\treturn this._nodeDict[name];\n\t}\n\taddNode(node) {\n\t\tthis._nodes.push(node);\n\t\tthis._nodeDict[node._name] = node;\n\t}\n\tget nodes() {\n\t\treturn this._nodes;\n\t}\n}\n\nexport { Animation, Key, Node };\n","import { Quat } from '../../core/math/quat.js';\nimport { Vec3 } from '../../core/math/vec3.js';\n\nclass InterpolatedKey {\n\tconstructor() {\n\t\tthis._written = false;\n\t\tthis._name = '';\n\t\tthis._keyFrames = [];\n\t\tthis._quat = new Quat();\n\t\tthis._pos = new Vec3();\n\t\tthis._scale = new Vec3();\n\t\tthis._targetNode = null;\n\t}\n\tgetTarget() {\n\t\treturn this._targetNode;\n\t}\n\tsetTarget(node) {\n\t\tthis._targetNode = node;\n\t}\n}\nclass Skeleton {\n\tconstructor(graph) {\n\t\tthis.looping = true;\n\t\tthis._animation = null;\n\t\tthis._time = 0;\n\t\tthis._interpolatedKeys = [];\n\t\tthis._interpolatedKeyDict = {};\n\t\tthis._currKeyIndices = {};\n\t\tthis.graph = null;\n\t\tconst addInterpolatedKeys = node => {\n\t\t\tconst interpKey = new InterpolatedKey();\n\t\t\tinterpKey._name = node.name;\n\t\t\tthis._interpolatedKeys.push(interpKey);\n\t\t\tthis._interpolatedKeyDict[node.name] = interpKey;\n\t\t\tthis._currKeyIndices[node.name] = 0;\n\t\t\tfor (let i = 0; i < node._children.length; i++) {\n\t\t\t\taddInterpolatedKeys(node._children[i]);\n\t\t\t}\n\t\t};\n\t\taddInterpolatedKeys(graph);\n\t}\n\tset animation(value) {\n\t\tthis._animation = value;\n\t\tthis.currentTime = 0;\n\t}\n\tget animation() {\n\t\treturn this._animation;\n\t}\n\tset currentTime(value) {\n\t\tthis._time = value;\n\t\tconst numNodes = this._interpolatedKeys.length;\n\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\tconst node = this._interpolatedKeys[i];\n\t\t\tconst nodeName = node._name;\n\t\t\tthis._currKeyIndices[nodeName] = 0;\n\t\t}\n\t\tthis.addTime(0);\n\t\tthis.updateGraph();\n\t}\n\tget currentTime() {\n\t\treturn this._time;\n\t}\n\tget numNodes() {\n\t\treturn this._interpolatedKeys.length;\n\t}\n\taddTime(delta) {\n\t\tif (this._animation !== null) {\n\t\t\tconst nodes = this._animation._nodes;\n\t\t\tconst duration = this._animation.duration;\n\t\t\tif (this._time === duration && !this.looping) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._time += delta;\n\t\t\tif (this._time > duration) {\n\t\t\t\tthis._time = this.looping ? 0.0 : duration;\n\t\t\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\t\t\tconst node = nodes[i];\n\t\t\t\t\tconst nodeName = node._name;\n\t\t\t\t\tthis._currKeyIndices[nodeName] = 0;\n\t\t\t\t}\n\t\t\t} else if (this._time < 0) {\n\t\t\t\tthis._time = this.looping ? duration : 0.0;\n\t\t\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\t\t\tconst node = nodes[i];\n\t\t\t\t\tconst nodeName = node._name;\n\t\t\t\t\tthis._currKeyIndices[nodeName] = node._keys.length - 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst offset = delta >= 0 ? 1 : -1;\n\t\t\tfor (let i = 0; i < nodes.length; i++) {\n\t\t\t\tconst node = nodes[i];\n\t\t\t\tconst nodeName = node._name;\n\t\t\t\tconst keys = node._keys;\n\t\t\t\tconst interpKey = this._interpolatedKeyDict[nodeName];\n\t\t\t\tif (interpKey === undefined) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlet foundKey = false;\n\t\t\t\tif (keys.length !== 1) {\n\t\t\t\t\tfor (let currKeyIndex = this._currKeyIndices[nodeName]; currKeyIndex < keys.length - 1 && currKeyIndex >= 0; currKeyIndex += offset) {\n\t\t\t\t\t\tconst k1 = keys[currKeyIndex];\n\t\t\t\t\t\tconst k2 = keys[currKeyIndex + 1];\n\t\t\t\t\t\tif (k1.time <= this._time && k2.time >= this._time) {\n\t\t\t\t\t\t\tconst alpha = (this._time - k1.time) / (k2.time - k1.time);\n\t\t\t\t\t\t\tinterpKey._pos.lerp(k1.position, k2.position, alpha);\n\t\t\t\t\t\t\tinterpKey._quat.slerp(k1.rotation, k2.rotation, alpha);\n\t\t\t\t\t\t\tinterpKey._scale.lerp(k1.scale, k2.scale, alpha);\n\t\t\t\t\t\t\tinterpKey._written = true;\n\t\t\t\t\t\t\tthis._currKeyIndices[nodeName] = currKeyIndex;\n\t\t\t\t\t\t\tfoundKey = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (keys.length === 1 || !foundKey && this._time === 0.0 && this.looping) {\n\t\t\t\t\tinterpKey._pos.copy(keys[0].position);\n\t\t\t\t\tinterpKey._quat.copy(keys[0].rotation);\n\t\t\t\t\tinterpKey._scale.copy(keys[0].scale);\n\t\t\t\t\tinterpKey._written = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tblend(skel1, skel2, alpha) {\n\t\tconst numNodes = this._interpolatedKeys.length;\n\t\tfor (let i = 0; i < numNodes; i++) {\n\t\t\tconst key1 = skel1._interpolatedKeys[i];\n\t\t\tconst key2 = skel2._interpolatedKeys[i];\n\t\t\tconst dstKey = this._interpolatedKeys[i];\n\t\t\tif (key1._written && key2._written) {\n\t\t\t\tdstKey._quat.slerp(key1._quat, skel2._interpolatedKeys[i]._quat, alpha);\n\t\t\t\tdstKey._pos.lerp(key1._pos, skel2._interpolatedKeys[i]._pos, alpha);\n\t\t\t\tdstKey._scale.lerp(key1._scale, key2._scale, alpha);\n\t\t\t\tdstKey._written = true;\n\t\t\t} else if (key1._written) {\n\t\t\t\tdstKey._quat.copy(key1._quat);\n\t\t\t\tdstKey._pos.copy(key1._pos);\n\t\t\t\tdstKey._scale.copy(key1._scale);\n\t\t\t\tdstKey._written = true;\n\t\t\t} else if (key2._written) {\n\t\t\t\tdstKey._quat.copy(key2._quat);\n\t\t\t\tdstKey._pos.copy(key2._pos);\n\t\t\t\tdstKey._scale.copy(key2._scale);\n\t\t\t\tdstKey._written = true;\n\t\t\t}\n\t\t}\n\t}\n\tsetGraph(graph) {\n\t\tthis.graph = graph;\n\t\tif (graph) {\n\t\t\tfor (let i = 0; i < this._interpolatedKeys.length; i++) {\n\t\t\t\tconst interpKey = this._interpolatedKeys[i];\n\t\t\t\tconst graphNode = graph.findByName(interpKey._name);\n\t\t\t\tthis._interpolatedKeys[i].setTarget(graphNode);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < this._interpolatedKeys.length; i++) {\n\t\t\t\tthis._interpolatedKeys[i].setTarget(null);\n\t\t\t}\n\t\t}\n\t}\n\tupdateGraph() {\n\t\tif (this.graph) {\n\t\t\tfor (let i = 0; i < this._interpolatedKeys.length; i++) {\n\t\t\t\tconst interpKey = this._interpolatedKeys[i];\n\t\t\t\tif (interpKey._written) {\n\t\t\t\t\tconst transform = interpKey.getTarget();\n\t\t\t\t\ttransform.localPosition.copy(interpKey._pos);\n\t\t\t\t\ttransform.localRotation.copy(interpKey._quat);\n\t\t\t\t\ttransform.localScale.copy(interpKey._scale);\n\t\t\t\t\tif (!transform._dirtyLocal) {\n\t\t\t\t\t\ttransform._dirtifyLocal();\n\t\t\t\t\t}\n\t\t\t\t\tinterpKey._written = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { Skeleton };\n","import { FloatPacking } from '../core/math/float-packing.js';\nimport { Texture } from '../platform/graphics/texture.js';\nimport { DeviceCache } from '../platform/graphics/device-cache.js';\nimport { ADDRESS_CLAMP_TO_EDGE, TEXTURETYPE_DEFAULT, FILTER_LINEAR, FILTER_NEAREST, PIXELFORMAT_RGBA32F, PIXELFORMAT_RGBA16F } from '../platform/graphics/constants.js';\n\nclass AreaLightCacheEntry {\n\tconstructor(texture0, texture1) {\n\t\tthis.texture0 = texture0;\n\t\tthis.texture1 = texture1;\n\t}\n\tdestroy() {\n\t\tvar _this$texture, _this$texture2;\n\t\t(_this$texture = this.texture0) == null || _this$texture.destroy();\n\t\t(_this$texture2 = this.texture1) == null || _this$texture2.destroy();\n\t}\n}\nconst deviceCache = new DeviceCache();\nclass AreaLightLuts {\n\tstatic createTexture(device, format, size, postfix = '') {\n\t\tconst tex = new Texture(device, {\n\t\t\tname: `AreaLightLUT${postfix}`,\n\t\t\twidth: size,\n\t\t\theight: size,\n\t\t\tformat: format,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\ttype: TEXTURETYPE_DEFAULT,\n\t\t\tmagFilter: FILTER_LINEAR,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tanisotropy: 1,\n\t\t\tmipmaps: false\n\t\t});\n\t\treturn tex;\n\t}\n\tstatic applyTextures(device, texture1, texture2) {\n\t\tdeviceCache.remove(device);\n\t\tdeviceCache.get(device, () => {\n\t\t\treturn new AreaLightCacheEntry(texture1, texture1 === texture2 ? null : texture2);\n\t\t});\n\t\tdevice.scope.resolve('areaLightsLutTex1').setValue(texture1);\n\t\tdevice.scope.resolve('areaLightsLutTex2').setValue(texture2);\n\t}\n\tstatic createPlaceholder(device) {\n\t\tconst texture = AreaLightLuts.createTexture(device, device.areaLightLutFormat, 2, 'placeholder');\n\t\tconst pixels = texture.lock();\n\t\tpixels.fill(0);\n\t\ttexture.unlock();\n\t\tAreaLightLuts.applyTextures(device, texture, texture);\n\t}\n\tstatic set(device, ltcMat1, ltcMat2) {\n\t\tfunction buildTexture(device, data, format) {\n\t\t\tconst texture = AreaLightLuts.createTexture(device, format, 64);\n\t\t\ttexture.lock().set(data);\n\t\t\ttexture.unlock();\n\t\t\treturn texture;\n\t\t}\n\t\tfunction offsetScale(data, offset, scale) {\n\t\t\tconst count = data.length;\n\t\t\tconst ret = new Float32Array(count);\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst n = i % 4;\n\t\t\t\tret[i] = (data[i] + offset[n]) * scale[n];\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tfunction convertToHalfFloat(data) {\n\t\t\tconst count = data.length;\n\t\t\tconst ret = new Uint16Array(count);\n\t\t\tconst float2Half = FloatPacking.float2Half;\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tret[i] = float2Half(data[i]);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tfunction convertToUint(data) {\n\t\t\tconst count = data.length;\n\t\t\tconst ret = new Uint8ClampedArray(count);\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tret[i] = data[i] * 255;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tconst srcData1 = ltcMat1;\n\t\tconst srcData2 = ltcMat2;\n\t\tlet data1, data2;\n\t\tconst format = device.areaLightLutFormat;\n\t\tif (format === PIXELFORMAT_RGBA32F) {\n\t\t\tdata1 = srcData1;\n\t\t\tdata2 = srcData2;\n\t\t} else if (format === PIXELFORMAT_RGBA16F) {\n\t\t\tdata1 = convertToHalfFloat(srcData1);\n\t\t\tdata2 = convertToHalfFloat(srcData2);\n\t\t} else {\n\t\t\tconst o1 = [0.0, 0.2976, 0.01381, 0.0];\n\t\t\tconst s1 = [0.999, 3.08737, 1.6546, 0.603249];\n\t\t\tconst o2 = [-0.306897, 0.0, 0.0, 0.0];\n\t\t\tconst s2 = [1.442787, 1.0, 1.0, 1.0];\n\t\t\tdata1 = convertToUint(offsetScale(srcData1, o1, s1));\n\t\t\tdata2 = convertToUint(offsetScale(srcData2, o2, s2));\n\t\t}\n\t\tconst tex1 = buildTexture(device, data1, format);\n\t\tconst tex2 = buildTexture(device, data2, format);\n\t\tAreaLightLuts.applyTextures(device, tex1, tex2);\n\t}\n}\n\nexport { AreaLightLuts };\n","import { LAYERID_WORLD } from '../constants.js';\n\nclass BatchGroup {\n\tconstructor(id, name, dynamic, maxAabbSize, layers = [LAYERID_WORLD]) {\n\t\tthis._ui = false;\n\t\tthis._sprite = false;\n\t\tthis._obj = {\n\t\t\tmodel: [],\n\t\t\telement: [],\n\t\t\tsprite: [],\n\t\t\trender: []\n\t\t};\n\t\tthis.id = void 0;\n\t\tthis.name = void 0;\n\t\tthis.dynamic = void 0;\n\t\tthis.maxAabbSize = void 0;\n\t\tthis.layers = void 0;\n\t\tthis.id = id;\n\t\tthis.name = name;\n\t\tthis.dynamic = dynamic;\n\t\tthis.maxAabbSize = maxAabbSize;\n\t\tthis.layers = layers;\n\t}\n}\nBatchGroup.MODEL = 'model';\nBatchGroup.ELEMENT = 'element';\nBatchGroup.SPRITE = 'sprite';\nBatchGroup.RENDER = 'render';\n\nexport { BatchGroup };\n","import { Mat3 } from '../../core/math/mat3.js';\nimport { BoundingBox } from '../../core/shape/bounding-box.js';\nimport { PRIMITIVE_TRIFAN, PRIMITIVE_TRISTRIP, SEMANTIC_BLENDINDICES, TYPE_FLOAT32, typedArrayTypes, typedArrayTypesByteSize, SEMANTIC_POSITION, SEMANTIC_NORMAL, SEMANTIC_TANGENT, typedArrayIndexFormats, PRIMITIVE_TRIANGLES } from '../../platform/graphics/constants.js';\nimport { SPRITE_RENDERMODE_SIMPLE } from '../constants.js';\nimport { Mesh } from '../mesh.js';\nimport { MeshInstance } from '../mesh-instance.js';\nimport { shaderChunks } from '../shader-lib/chunks/chunks.js';\nimport { Batch } from './batch.js';\nimport { BatchGroup } from './batch-group.js';\nimport { SkinBatchInstance } from './skin-batch-instance.js';\n\nfunction paramsIdentical(a, b) {\n\tif (a && !b) return false;\n\tif (!a && b) return false;\n\ta = a.data;\n\tb = b.data;\n\tif (a === b) return true;\n\tif (a instanceof Float32Array && b instanceof Float32Array) {\n\t\tif (a.length !== b.length) return false;\n\t\tfor (let i = 0; i < a.length; i++) {\n\t\t\tif (a[i] !== b[i]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\nfunction equalParamSets(params1, params2) {\n\tfor (const param in params1) {\n\t\tif (params1.hasOwnProperty(param) && !paramsIdentical(params1[param], params2[param])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tfor (const param in params2) {\n\t\tif (params2.hasOwnProperty(param) && !paramsIdentical(params2[param], params1[param])) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\nconst _triFanIndices = [0, 1, 3, 2, 3, 1];\nconst _triStripIndices = [0, 1, 3, 0, 3, 2];\nconst mat3 = new Mat3();\nfunction getScaleSign(mi) {\n\treturn mi.node.worldTransform.scaleSign;\n}\nclass BatchManager {\n\tconstructor(device, root, scene) {\n\t\tthis.device = device;\n\t\tthis.rootNode = root;\n\t\tthis.scene = scene;\n\t\tthis._init = false;\n\t\tthis._batchGroups = {};\n\t\tthis._batchGroupCounter = 0;\n\t\tthis._batchList = [];\n\t\tthis._dirtyGroups = [];\n\t}\n\tdestroy() {\n\t\tthis.device = null;\n\t\tthis.rootNode = null;\n\t\tthis.scene = null;\n\t\tthis._batchGroups = {};\n\t\tthis._batchList = [];\n\t\tthis._dirtyGroups = [];\n\t}\n\taddGroup(name, dynamic, maxAabbSize, id, layers) {\n\t\tif (id === undefined) {\n\t\t\tid = this._batchGroupCounter;\n\t\t\tthis._batchGroupCounter++;\n\t\t}\n\t\tif (this._batchGroups[id]) {\n\t\t\treturn undefined;\n\t\t}\n\t\tconst group = new BatchGroup(id, name, dynamic, maxAabbSize, layers);\n\t\tthis._batchGroups[id] = group;\n\t\treturn group;\n\t}\n\tremoveGroup(id) {\n\t\tif (!this._batchGroups[id]) {\n\t\t\treturn;\n\t\t}\n\t\tconst newBatchList = [];\n\t\tfor (let i = 0; i < this._batchList.length; i++) {\n\t\t\tif (this._batchList[i].batchGroupId === id) {\n\t\t\t\tthis.destroyBatch(this._batchList[i]);\n\t\t\t} else {\n\t\t\t\tnewBatchList.push(this._batchList[i]);\n\t\t\t}\n\t\t}\n\t\tthis._batchList = newBatchList;\n\t\tthis._removeModelsFromBatchGroup(this.rootNode, id);\n\t\tdelete this._batchGroups[id];\n\t}\n\tmarkGroupDirty(id) {\n\t\tif (this._dirtyGroups.indexOf(id) < 0) {\n\t\t\tthis._dirtyGroups.push(id);\n\t\t}\n\t}\n\tgetGroupByName(name) {\n\t\tconst groups = this._batchGroups;\n\t\tfor (const group in groups) {\n\t\t\tif (!groups.hasOwnProperty(group)) continue;\n\t\t\tif (groups[group].name === name) {\n\t\t\t\treturn groups[group];\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\tgetBatches(batchGroupId) {\n\t\tconst results = [];\n\t\tconst len = this._batchList.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst batch = this._batchList[i];\n\t\t\tif (batch.batchGroupId === batchGroupId) {\n\t\t\t\tresults.push(batch);\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\t_removeModelsFromBatchGroup(node, id) {\n\t\tif (!node.enabled) return;\n\t\tif (node.model && node.model.batchGroupId === id) {\n\t\t\tnode.model.batchGroupId = -1;\n\t\t}\n\t\tif (node.render && node.render.batchGroupId === id) {\n\t\t\tnode.render.batchGroupId = -1;\n\t\t}\n\t\tif (node.element && node.element.batchGroupId === id) {\n\t\t\tnode.element.batchGroupId = -1;\n\t\t}\n\t\tif (node.sprite && node.sprite.batchGroupId === id) {\n\t\t\tnode.sprite.batchGroupId = -1;\n\t\t}\n\t\tfor (let i = 0; i < node._children.length; i++) {\n\t\t\tthis._removeModelsFromBatchGroup(node._children[i], id);\n\t\t}\n\t}\n\tinsert(type, groupId, node) {\n\t\tconst group = this._batchGroups[groupId];\n\t\tif (group) {\n\t\t\tif (group._obj[type].indexOf(node) < 0) {\n\t\t\t\tgroup._obj[type].push(node);\n\t\t\t\tthis.markGroupDirty(groupId);\n\t\t\t}\n\t\t}\n\t}\n\tremove(type, groupId, node) {\n\t\tconst group = this._batchGroups[groupId];\n\t\tif (group) {\n\t\t\tconst idx = group._obj[type].indexOf(node);\n\t\t\tif (idx >= 0) {\n\t\t\t\tgroup._obj[type].splice(idx, 1);\n\t\t\t\tthis.markGroupDirty(groupId);\n\t\t\t}\n\t\t}\n\t}\n\t_extractRender(node, arr, group, groupMeshInstances) {\n\t\tif (node.render) {\n\t\t\tarr = groupMeshInstances[node.render.batchGroupId] = arr.concat(node.render.meshInstances);\n\t\t\tnode.render.removeFromLayers();\n\t\t}\n\t\treturn arr;\n\t}\n\t_extractModel(node, arr, group, groupMeshInstances) {\n\t\tif (node.model && node.model.model) {\n\t\t\tarr = groupMeshInstances[node.model.batchGroupId] = arr.concat(node.model.meshInstances);\n\t\t\tnode.model.removeModelFromLayers();\n\t\t}\n\t\treturn arr;\n\t}\n\t_extractElement(node, arr, group) {\n\t\tif (!node.element) return;\n\t\tlet valid = false;\n\t\tif (node.element._text && node.element._text._model.meshInstances.length > 0) {\n\t\t\tarr.push(node.element._text._model.meshInstances[0]);\n\t\t\tnode.element.removeModelFromLayers(node.element._text._model);\n\t\t\tvalid = true;\n\t\t} else if (node.element._image) {\n\t\t\tarr.push(node.element._image._renderable.meshInstance);\n\t\t\tnode.element.removeModelFromLayers(node.element._image._renderable.model);\n\t\t\tif (node.element._image._renderable.unmaskMeshInstance) {\n\t\t\t\tarr.push(node.element._image._renderable.unmaskMeshInstance);\n\t\t\t\tif (!node.element._image._renderable.unmaskMeshInstance.stencilFront || !node.element._image._renderable.unmaskMeshInstance.stencilBack) {\n\t\t\t\t\tnode.element._dirtifyMask();\n\t\t\t\t\tnode.element._onPrerender();\n\t\t\t\t}\n\t\t\t}\n\t\t\tvalid = true;\n\t\t}\n\t\tif (valid) {\n\t\t\tgroup._ui = true;\n\t\t}\n\t}\n\t_collectAndRemoveMeshInstances(groupMeshInstances, groupIds) {\n\t\tfor (let g = 0; g < groupIds.length; g++) {\n\t\t\tconst id = groupIds[g];\n\t\t\tconst group = this._batchGroups[id];\n\t\t\tif (!group) continue;\n\t\t\tlet arr = groupMeshInstances[id];\n\t\t\tif (!arr) arr = groupMeshInstances[id] = [];\n\t\t\tfor (let m = 0; m < group._obj.model.length; m++) {\n\t\t\t\tarr = this._extractModel(group._obj.model[m], arr, group, groupMeshInstances);\n\t\t\t}\n\t\t\tfor (let r = 0; r < group._obj.render.length; r++) {\n\t\t\t\tarr = this._extractRender(group._obj.render[r], arr, group, groupMeshInstances);\n\t\t\t}\n\t\t\tfor (let e = 0; e < group._obj.element.length; e++) {\n\t\t\t\tthis._extractElement(group._obj.element[e], arr, group);\n\t\t\t}\n\t\t\tfor (let s = 0; s < group._obj.sprite.length; s++) {\n\t\t\t\tconst node = group._obj.sprite[s];\n\t\t\t\tif (node.sprite && node.sprite._meshInstance && (group.dynamic || node.sprite.sprite._renderMode === SPRITE_RENDERMODE_SIMPLE)) {\n\t\t\t\t\tarr.push(node.sprite._meshInstance);\n\t\t\t\t\tnode.sprite.removeModelFromLayers();\n\t\t\t\t\tgroup._sprite = true;\n\t\t\t\t\tnode.sprite._batchGroup = group;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tgenerate(groupIds) {\n\t\tconst groupMeshInstances = {};\n\t\tif (!groupIds) {\n\t\t\tgroupIds = Object.keys(this._batchGroups);\n\t\t}\n\t\tconst newBatchList = [];\n\t\tfor (let i = 0; i < this._batchList.length; i++) {\n\t\t\tif (groupIds.indexOf(this._batchList[i].batchGroupId) < 0) {\n\t\t\t\tnewBatchList.push(this._batchList[i]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthis.destroyBatch(this._batchList[i]);\n\t\t}\n\t\tthis._batchList = newBatchList;\n\t\tthis._collectAndRemoveMeshInstances(groupMeshInstances, groupIds);\n\t\tif (groupIds === this._dirtyGroups) {\n\t\t\tthis._dirtyGroups.length = 0;\n\t\t} else {\n\t\t\tconst newDirtyGroups = [];\n\t\t\tfor (let i = 0; i < this._dirtyGroups.length; i++) {\n\t\t\t\tif (groupIds.indexOf(this._dirtyGroups[i]) < 0) newDirtyGroups.push(this._dirtyGroups[i]);\n\t\t\t}\n\t\t\tthis._dirtyGroups = newDirtyGroups;\n\t\t}\n\t\tlet group, lists, groupData, batch;\n\t\tfor (const groupId in groupMeshInstances) {\n\t\t\tif (!groupMeshInstances.hasOwnProperty(groupId)) continue;\n\t\t\tgroup = groupMeshInstances[groupId];\n\t\t\tgroupData = this._batchGroups[groupId];\n\t\t\tif (!groupData) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlists = this.prepare(group, groupData.dynamic, groupData.maxAabbSize, groupData._ui || groupData._sprite);\n\t\t\tfor (let i = 0; i < lists.length; i++) {\n\t\t\t\tbatch = this.create(lists[i], groupData.dynamic, parseInt(groupId, 10));\n\t\t\t\tif (batch) {\n\t\t\t\t\tbatch.addToLayers(this.scene, groupData.layers);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprepare(meshInstances, dynamic, maxAabbSize = Number.POSITIVE_INFINITY, translucent) {\n\t\tif (meshInstances.length === 0) return [];\n\t\tconst halfMaxAabbSize = maxAabbSize * 0.5;\n\t\tconst maxInstanceCount = this.device.supportsBoneTextures ? 1024 : this.device.boneLimit;\n\t\tconst maxNumVertices = this.device.extUintElement ? 0xffffffff : 0xffff;\n\t\tconst aabb = new BoundingBox();\n\t\tconst testAabb = new BoundingBox();\n\t\tlet skipTranslucentAabb = null;\n\t\tlet sf;\n\t\tconst lists = [];\n\t\tlet j = 0;\n\t\tif (translucent) {\n\t\t\tmeshInstances.sort((a, b) => {\n\t\t\t\treturn a.drawOrder - b.drawOrder;\n\t\t\t});\n\t\t}\n\t\tlet meshInstancesLeftA = meshInstances;\n\t\tlet meshInstancesLeftB;\n\t\tconst skipMesh = translucent ? function (mi) {\n\t\t\tif (skipTranslucentAabb) {\n\t\t\t\tskipTranslucentAabb.add(mi.aabb);\n\t\t\t} else {\n\t\t\t\tskipTranslucentAabb = mi.aabb.clone();\n\t\t\t}\n\t\t\tmeshInstancesLeftB.push(mi);\n\t\t} : function (mi) {\n\t\t\tmeshInstancesLeftB.push(mi);\n\t\t};\n\t\twhile (meshInstancesLeftA.length > 0) {\n\t\t\tlists[j] = [meshInstancesLeftA[0]];\n\t\t\tmeshInstancesLeftB = [];\n\t\t\tconst material = meshInstancesLeftA[0].material;\n\t\t\tconst layer = meshInstancesLeftA[0].layer;\n\t\t\tconst defs = meshInstancesLeftA[0]._shaderDefs;\n\t\t\tconst params = meshInstancesLeftA[0].parameters;\n\t\t\tconst stencil = meshInstancesLeftA[0].stencilFront;\n\t\t\tlet vertCount = meshInstancesLeftA[0].mesh.vertexBuffer.getNumVertices();\n\t\t\tconst drawOrder = meshInstancesLeftA[0].drawOrder;\n\t\t\taabb.copy(meshInstancesLeftA[0].aabb);\n\t\t\tconst scaleSign = getScaleSign(meshInstancesLeftA[0]);\n\t\t\tconst vertexFormatBatchingHash = meshInstancesLeftA[0].mesh.vertexBuffer.format.batchingHash;\n\t\t\tconst indexed = meshInstancesLeftA[0].mesh.primitive[0].indexed;\n\t\t\tskipTranslucentAabb = null;\n\t\t\tfor (let i = 1; i < meshInstancesLeftA.length; i++) {\n\t\t\t\tconst mi = meshInstancesLeftA[i];\n\t\t\t\tif (dynamic && lists[j].length >= maxInstanceCount) {\n\t\t\t\t\tmeshInstancesLeftB = meshInstancesLeftB.concat(meshInstancesLeftA.slice(i));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (material !== mi.material || layer !== mi.layer || vertexFormatBatchingHash !== mi.mesh.vertexBuffer.format.batchingHash || indexed !== mi.mesh.primitive[0].indexed || defs !== mi._shaderDefs || vertCount + mi.mesh.vertexBuffer.getNumVertices() > maxNumVertices) {\n\t\t\t\t\tskipMesh(mi);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttestAabb.copy(aabb);\n\t\t\t\ttestAabb.add(mi.aabb);\n\t\t\t\tif (testAabb.halfExtents.x > halfMaxAabbSize || testAabb.halfExtents.y > halfMaxAabbSize || testAabb.halfExtents.z > halfMaxAabbSize) {\n\t\t\t\t\tskipMesh(mi);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (stencil) {\n\t\t\t\t\tif (!(sf = mi.stencilFront) || stencil.func !== sf.func || stencil.zpass !== sf.zpass) {\n\t\t\t\t\t\tskipMesh(mi);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (scaleSign !== getScaleSign(mi)) {\n\t\t\t\t\tskipMesh(mi);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (!equalParamSets(params, mi.parameters)) {\n\t\t\t\t\tskipMesh(mi);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (translucent && skipTranslucentAabb && skipTranslucentAabb.intersects(mi.aabb) && mi.drawOrder !== drawOrder) {\n\t\t\t\t\tskipMesh(mi);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\taabb.add(mi.aabb);\n\t\t\t\tvertCount += mi.mesh.vertexBuffer.getNumVertices();\n\t\t\t\tlists[j].push(mi);\n\t\t\t}\n\t\t\tj++;\n\t\t\tmeshInstancesLeftA = meshInstancesLeftB;\n\t\t}\n\t\treturn lists;\n\t}\n\tcollectBatchedMeshData(meshInstances, dynamic) {\n\t\tlet streams = null;\n\t\tlet batchNumVerts = 0;\n\t\tlet batchNumIndices = 0;\n\t\tlet material = null;\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tif (meshInstances[i].visible) {\n\t\t\t\tconst mesh = meshInstances[i].mesh;\n\t\t\t\tconst numVerts = mesh.vertexBuffer.numVertices;\n\t\t\t\tbatchNumVerts += numVerts;\n\t\t\t\tif (mesh.primitive[0].indexed) {\n\t\t\t\t\tbatchNumIndices += mesh.primitive[0].count;\n\t\t\t\t} else {\n\t\t\t\t\tconst primitiveType = mesh.primitive[0].type;\n\t\t\t\t\tif (primitiveType === PRIMITIVE_TRIFAN || primitiveType === PRIMITIVE_TRISTRIP) {\n\t\t\t\t\t\tif (mesh.primitive[0].count === 4) {\n\t\t\t\t\t\t\tbatchNumIndices += 6;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!streams) {\n\t\t\t\t\tmaterial = meshInstances[i].material;\n\t\t\t\t\tstreams = {};\n\t\t\t\t\tconst elems = mesh.vertexBuffer.format.elements;\n\t\t\t\t\tfor (let j = 0; j < elems.length; j++) {\n\t\t\t\t\t\tconst semantic = elems[j].name;\n\t\t\t\t\t\tstreams[semantic] = {\n\t\t\t\t\t\t\tnumComponents: elems[j].numComponents,\n\t\t\t\t\t\t\tdataType: elems[j].dataType,\n\t\t\t\t\t\t\tnormalize: elems[j].normalize,\n\t\t\t\t\t\t\tcount: 0\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tif (dynamic) {\n\t\t\t\t\t\tstreams[SEMANTIC_BLENDINDICES] = {\n\t\t\t\t\t\t\tnumComponents: 1,\n\t\t\t\t\t\t\tdataType: TYPE_FLOAT32,\n\t\t\t\t\t\t\tnormalize: false,\n\t\t\t\t\t\t\tcount: 0\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn {\n\t\t\tstreams: streams,\n\t\t\tbatchNumVerts: batchNumVerts,\n\t\t\tbatchNumIndices: batchNumIndices,\n\t\t\tmaterial: material\n\t\t};\n\t}\n\tcreate(meshInstances, dynamic, batchGroupId) {\n\t\tif (!this._init) {\n\t\t\tconst boneLimit = `#define BONE_LIMIT ${this.device.getBoneLimit()}\\n`;\n\t\t\tthis.transformVS = `${boneLimit}#define DYNAMICBATCH\\n${shaderChunks.transformVS}`;\n\t\t\tthis.skinTexVS = shaderChunks.skinBatchTexVS;\n\t\t\tthis.skinConstVS = shaderChunks.skinBatchConstVS;\n\t\t\tthis.vertexFormats = {};\n\t\t\tthis._init = true;\n\t\t}\n\t\tlet stream = null;\n\t\tlet semantic;\n\t\tlet mesh, numVerts;\n\t\tlet batch = null;\n\t\tconst batchData = this.collectBatchedMeshData(meshInstances, dynamic);\n\t\tif (batchData.streams) {\n\t\t\tconst streams = batchData.streams;\n\t\t\tlet material = batchData.material;\n\t\t\tconst batchNumVerts = batchData.batchNumVerts;\n\t\t\tconst batchNumIndices = batchData.batchNumIndices;\n\t\t\tbatch = new Batch(meshInstances, dynamic, batchGroupId);\n\t\t\tthis._batchList.push(batch);\n\t\t\tlet indexBase, numIndices, indexData;\n\t\t\tlet verticesOffset = 0;\n\t\t\tlet indexOffset = 0;\n\t\t\tlet transform;\n\t\t\tconst indexArrayType = batchNumVerts <= 0xffff ? Uint16Array : Uint32Array;\n\t\t\tconst indices = new indexArrayType(batchNumIndices);\n\t\t\tfor (semantic in streams) {\n\t\t\t\tstream = streams[semantic];\n\t\t\t\tstream.typeArrayType = typedArrayTypes[stream.dataType];\n\t\t\t\tstream.elementByteSize = typedArrayTypesByteSize[stream.dataType];\n\t\t\t\tstream.buffer = new stream.typeArrayType(batchNumVerts * stream.numComponents);\n\t\t\t}\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tif (!meshInstances[i].visible) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmesh = meshInstances[i].mesh;\n\t\t\t\tnumVerts = mesh.vertexBuffer.numVertices;\n\t\t\t\tif (!dynamic) {\n\t\t\t\t\ttransform = meshInstances[i].node.getWorldTransform();\n\t\t\t\t}\n\t\t\t\tfor (semantic in streams) {\n\t\t\t\t\tif (semantic !== SEMANTIC_BLENDINDICES) {\n\t\t\t\t\t\tstream = streams[semantic];\n\t\t\t\t\t\tconst subarray = new stream.typeArrayType(stream.buffer.buffer, stream.elementByteSize * stream.count);\n\t\t\t\t\t\tconst totalComponents = mesh.getVertexStream(semantic, subarray) * stream.numComponents;\n\t\t\t\t\t\tstream.count += totalComponents;\n\t\t\t\t\t\tif (!dynamic && stream.numComponents >= 3) {\n\t\t\t\t\t\t\tif (semantic === SEMANTIC_POSITION) {\n\t\t\t\t\t\t\t\tconst m = transform.data;\n\t\t\t\t\t\t\t\tconst m0 = m[0];\n\t\t\t\t\t\t\t\tconst m1 = m[1];\n\t\t\t\t\t\t\t\tconst m2 = m[2];\n\t\t\t\t\t\t\t\tconst m4 = m[4];\n\t\t\t\t\t\t\t\tconst m5 = m[5];\n\t\t\t\t\t\t\t\tconst m6 = m[6];\n\t\t\t\t\t\t\t\tconst m8 = m[8];\n\t\t\t\t\t\t\t\tconst m9 = m[9];\n\t\t\t\t\t\t\t\tconst m10 = m[10];\n\t\t\t\t\t\t\t\tconst m12 = m[12];\n\t\t\t\t\t\t\t\tconst m13 = m[13];\n\t\t\t\t\t\t\t\tconst m14 = m[14];\n\t\t\t\t\t\t\t\tlet x, y, z;\n\t\t\t\t\t\t\t\tfor (let j = 0; j < totalComponents; j += stream.numComponents) {\n\t\t\t\t\t\t\t\t\tx = subarray[j];\n\t\t\t\t\t\t\t\t\ty = subarray[j + 1];\n\t\t\t\t\t\t\t\t\tz = subarray[j + 2];\n\t\t\t\t\t\t\t\t\tsubarray[j] = x * m0 + y * m4 + z * m8 + m12;\n\t\t\t\t\t\t\t\t\tsubarray[j + 1] = x * m1 + y * m5 + z * m9 + m13;\n\t\t\t\t\t\t\t\t\tsubarray[j + 2] = x * m2 + y * m6 + z * m10 + m14;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (semantic === SEMANTIC_NORMAL || semantic === SEMANTIC_TANGENT) {\n\t\t\t\t\t\t\t\tmat3.invertMat4(transform).transpose();\n\t\t\t\t\t\t\t\tconst [m0, m1, m2, m3, m4, m5, m6, m7, m8] = mat3.data;\n\t\t\t\t\t\t\t\tlet x, y, z;\n\t\t\t\t\t\t\t\tfor (let j = 0; j < totalComponents; j += stream.numComponents) {\n\t\t\t\t\t\t\t\t\tx = subarray[j];\n\t\t\t\t\t\t\t\t\ty = subarray[j + 1];\n\t\t\t\t\t\t\t\t\tz = subarray[j + 2];\n\t\t\t\t\t\t\t\t\tsubarray[j] = x * m0 + y * m3 + z * m6;\n\t\t\t\t\t\t\t\t\tsubarray[j + 1] = x * m1 + y * m4 + z * m7;\n\t\t\t\t\t\t\t\t\tsubarray[j + 2] = x * m2 + y * m5 + z * m8;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (dynamic) {\n\t\t\t\t\tstream = streams[SEMANTIC_BLENDINDICES];\n\t\t\t\t\tfor (let j = 0; j < numVerts; j++) {\n\t\t\t\t\t\tstream.buffer[stream.count++] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mesh.primitive[0].indexed) {\n\t\t\t\t\tindexBase = mesh.primitive[0].base;\n\t\t\t\t\tnumIndices = mesh.primitive[0].count;\n\t\t\t\t\tconst srcFormat = mesh.indexBuffer[0].getFormat();\n\t\t\t\t\tindexData = new typedArrayIndexFormats[srcFormat](mesh.indexBuffer[0].storage);\n\t\t\t\t} else {\n\t\t\t\t\tconst primitiveType = mesh.primitive[0].type;\n\t\t\t\t\tif (primitiveType === PRIMITIVE_TRIFAN || primitiveType === PRIMITIVE_TRISTRIP) {\n\t\t\t\t\t\tif (mesh.primitive[0].count === 4) {\n\t\t\t\t\t\t\tindexBase = 0;\n\t\t\t\t\t\t\tnumIndices = 6;\n\t\t\t\t\t\t\tindexData = primitiveType === PRIMITIVE_TRIFAN ? _triFanIndices : _triStripIndices;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnumIndices = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (let j = 0; j < numIndices; j++) {\n\t\t\t\t\tindices[j + indexOffset] = indexData[indexBase + j] + verticesOffset;\n\t\t\t\t}\n\t\t\t\tindexOffset += numIndices;\n\t\t\t\tverticesOffset += numVerts;\n\t\t\t}\n\t\t\tmesh = new Mesh(this.device);\n\t\t\tfor (semantic in streams) {\n\t\t\t\tstream = streams[semantic];\n\t\t\t\tmesh.setVertexStream(semantic, stream.buffer, stream.numComponents, undefined, stream.dataType, stream.normalize);\n\t\t\t}\n\t\t\tif (indices.length > 0) {\n\t\t\t\tmesh.setIndices(indices);\n\t\t\t}\n\t\t\tmesh.update(PRIMITIVE_TRIANGLES, false);\n\t\t\tif (dynamic) {\n\t\t\t\tmaterial = material.clone();\n\t\t\t\tmaterial.chunks.transformVS = this.transformVS;\n\t\t\t\tmaterial.chunks.skinTexVS = this.skinTexVS;\n\t\t\t\tmaterial.chunks.skinConstVS = this.skinConstVS;\n\t\t\t\tmaterial.update();\n\t\t\t}\n\t\t\tconst meshInstance = new MeshInstance(mesh, material, this.rootNode);\n\t\t\tmeshInstance.castShadow = batch.origMeshInstances[0].castShadow;\n\t\t\tmeshInstance.parameters = batch.origMeshInstances[0].parameters;\n\t\t\tmeshInstance.layer = batch.origMeshInstances[0].layer;\n\t\t\tmeshInstance._shaderDefs = batch.origMeshInstances[0]._shaderDefs;\n\t\t\tmeshInstance.cull = batch.origMeshInstances[0].cull;\n\t\t\tconst batchGroup = this._batchGroups[batchGroupId];\n\t\t\tif (batchGroup && batchGroup._ui) {\n\t\t\t\tmeshInstance.cull = false;\n\t\t\t}\n\t\t\tif (dynamic) {\n\t\t\t\tconst nodes = [];\n\t\t\t\tfor (let i = 0; i < batch.origMeshInstances.length; i++) {\n\t\t\t\t\tnodes.push(batch.origMeshInstances[i].node);\n\t\t\t\t}\n\t\t\t\tmeshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);\n\t\t\t}\n\t\t\tmeshInstance._updateAabb = false;\n\t\t\tmeshInstance.drawOrder = batch.origMeshInstances[0].drawOrder;\n\t\t\tmeshInstance.stencilFront = batch.origMeshInstances[0].stencilFront;\n\t\t\tmeshInstance.stencilBack = batch.origMeshInstances[0].stencilBack;\n\t\t\tmeshInstance.flipFacesFactor = getScaleSign(batch.origMeshInstances[0]);\n\t\t\tmeshInstance.castShadow = batch.origMeshInstances[0].castShadow;\n\t\t\tbatch.meshInstance = meshInstance;\n\t\t\tbatch.updateBoundingBox();\n\t\t}\n\t\treturn batch;\n\t}\n\tupdateAll() {\n\t\tif (this._dirtyGroups.length > 0) {\n\t\t\tthis.generate(this._dirtyGroups);\n\t\t}\n\t\tfor (let i = 0; i < this._batchList.length; i++) {\n\t\t\tif (!this._batchList[i].dynamic) continue;\n\t\t\tthis._batchList[i].updateBoundingBox();\n\t\t}\n\t}\n\tclone(batch, clonedMeshInstances) {\n\t\tconst batch2 = new Batch(clonedMeshInstances, batch.dynamic, batch.batchGroupId);\n\t\tthis._batchList.push(batch2);\n\t\tconst nodes = [];\n\t\tfor (let i = 0; i < clonedMeshInstances.length; i++) {\n\t\t\tnodes.push(clonedMeshInstances[i].node);\n\t\t}\n\t\tbatch2.meshInstance = new MeshInstance(batch.meshInstance.mesh, batch.meshInstance.material, batch.meshInstance.node);\n\t\tbatch2.meshInstance._updateAabb = false;\n\t\tbatch2.meshInstance.parameters = clonedMeshInstances[0].parameters;\n\t\tbatch2.meshInstance.cull = clonedMeshInstances[0].cull;\n\t\tbatch2.meshInstance.layer = clonedMeshInstances[0].layer;\n\t\tif (batch.dynamic) {\n\t\t\tbatch2.meshInstance.skinInstance = new SkinBatchInstance(this.device, nodes, this.rootNode);\n\t\t}\n\t\tbatch2.meshInstance.castShadow = batch.meshInstance.castShadow;\n\t\tbatch2.meshInstance._shader = batch.meshInstance._shader.slice();\n\t\tbatch2.meshInstance.castShadow = batch.meshInstance.castShadow;\n\t\treturn batch2;\n\t}\n\tdestroyBatch(batch) {\n\t\tbatch.destroy(this.scene, this._batchGroups[batch.batchGroupId].layers);\n\t}\n}\n\nexport { BatchManager };\n","import { BoundingBox } from '../../core/shape/bounding-box.js';\n\nclass Batch {\n\tconstructor(meshInstances, dynamic, batchGroupId) {\n\t\tthis._aabb = new BoundingBox();\n\t\tthis.origMeshInstances = void 0;\n\t\tthis.meshInstance = null;\n\t\tthis.dynamic = void 0;\n\t\tthis.batchGroupId = void 0;\n\t\tthis.origMeshInstances = meshInstances;\n\t\tthis.dynamic = dynamic;\n\t\tthis.batchGroupId = batchGroupId;\n\t}\n\tdestroy(scene, layers) {\n\t\tif (this.meshInstance) {\n\t\t\tthis.removeFromLayers(scene, layers);\n\t\t\tthis.meshInstance.destroy();\n\t\t\tthis.meshInstance = null;\n\t\t}\n\t}\n\taddToLayers(scene, layers) {\n\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\tconst layer = scene.layers.getLayerById(layers[i]);\n\t\t\tif (layer) {\n\t\t\t\tlayer.addMeshInstances([this.meshInstance]);\n\t\t\t}\n\t\t}\n\t}\n\tremoveFromLayers(scene, layers) {\n\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\tconst layer = scene.layers.getLayerById(layers[i]);\n\t\t\tif (layer) {\n\t\t\t\tlayer.removeMeshInstances([this.meshInstance]);\n\t\t\t}\n\t\t}\n\t}\n\tupdateBoundingBox() {\n\t\tthis._aabb.copy(this.origMeshInstances[0].aabb);\n\t\tfor (let i = 1; i < this.origMeshInstances.length; i++) {\n\t\t\tthis._aabb.add(this.origMeshInstances[i].aabb);\n\t\t}\n\t\tthis.meshInstance.aabb = this._aabb;\n\t\tthis.meshInstance._aabbVer = 0;\n\t}\n}\n\nexport { Batch };\n","import { SkinInstance } from '../skin-instance.js';\n\nclass SkinBatchInstance extends SkinInstance {\n\tconstructor(device, nodes, rootNode) {\n\t\tsuper();\n\t\tconst numBones = nodes.length;\n\t\tthis.init(device, numBones);\n\t\tthis.device = device;\n\t\tthis.rootNode = rootNode;\n\t\tthis.bones = nodes;\n\t}\n\tupdateMatrices(rootNode, skinUpdateIndex) {}\n\tupdateMatrixPalette(rootNode, skinUpdateIndex) {\n\t\tconst mp = this.matrixPalette;\n\t\tconst count = this.bones.length;\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst pe = this.bones[i].getWorldTransform().data;\n\t\t\tconst base = i * 12;\n\t\t\tmp[base] = pe[0];\n\t\t\tmp[base + 1] = pe[4];\n\t\t\tmp[base + 2] = pe[8];\n\t\t\tmp[base + 3] = pe[12];\n\t\t\tmp[base + 4] = pe[1];\n\t\t\tmp[base + 5] = pe[5];\n\t\t\tmp[base + 6] = pe[9];\n\t\t\tmp[base + 7] = pe[13];\n\t\t\tmp[base + 8] = pe[2];\n\t\t\tmp[base + 9] = pe[6];\n\t\t\tmp[base + 10] = pe[10];\n\t\t\tmp[base + 11] = pe[14];\n\t\t}\n\t\tthis.uploadBones(this.device);\n\t}\n}\n\nexport { SkinBatchInstance };\n","import { Color } from '../core/math/color.js';\nimport { Mat4 } from '../core/math/mat4.js';\nimport { Vec3 } from '../core/math/vec3.js';\nimport { Vec4 } from '../core/math/vec4.js';\nimport { math } from '../core/math/math.js';\nimport { Frustum } from '../core/shape/frustum.js';\nimport { ASPECT_AUTO, LAYERID_WORLD, LAYERID_DEPTH, LAYERID_SKYBOX, LAYERID_UI, LAYERID_IMMEDIATE, PROJECTION_PERSPECTIVE } from './constants.js';\nimport { RenderPassColorGrab } from './graphics/render-pass-color-grab.js';\nimport { RenderPassDepthGrab } from './graphics/render-pass-depth-grab.js';\nimport { RenderPassDepth } from './graphics/render-pass-depth.js';\n\nconst _deviceCoord = new Vec3();\nconst _halfSize = new Vec3();\nconst _point = new Vec3();\nconst _invViewProjMat = new Mat4();\nconst _frustumPoints = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];\nclass Camera {\n\tconstructor() {\n\t\tthis.shaderPassInfo = null;\n\t\tthis.renderPassColorGrab = null;\n\t\tthis.renderPassDepthGrab = null;\n\t\tthis.renderPasses = [];\n\t\tthis.jitter = 0;\n\t\tthis._aspectRatio = 16 / 9;\n\t\tthis._aspectRatioMode = ASPECT_AUTO;\n\t\tthis._calculateProjection = null;\n\t\tthis._calculateTransform = null;\n\t\tthis._clearColor = new Color(0.75, 0.75, 0.75, 1);\n\t\tthis._clearColorBuffer = true;\n\t\tthis._clearDepth = 1;\n\t\tthis._clearDepthBuffer = true;\n\t\tthis._clearStencil = 0;\n\t\tthis._clearStencilBuffer = true;\n\t\tthis._cullFaces = true;\n\t\tthis._farClip = 1000;\n\t\tthis._flipFaces = false;\n\t\tthis._fov = 45;\n\t\tthis._frustumCulling = true;\n\t\tthis._horizontalFov = false;\n\t\tthis._layers = [LAYERID_WORLD, LAYERID_DEPTH, LAYERID_SKYBOX, LAYERID_UI, LAYERID_IMMEDIATE];\n\t\tthis._layersSet = new Set(this._layers);\n\t\tthis._nearClip = 0.1;\n\t\tthis._node = null;\n\t\tthis._orthoHeight = 10;\n\t\tthis._projection = PROJECTION_PERSPECTIVE;\n\t\tthis._rect = new Vec4(0, 0, 1, 1);\n\t\tthis._renderTarget = null;\n\t\tthis._scissorRect = new Vec4(0, 0, 1, 1);\n\t\tthis._scissorRectClear = false;\n\t\tthis._aperture = 16.0;\n\t\tthis._shutter = 1.0 / 1000.0;\n\t\tthis._sensitivity = 1000;\n\t\tthis._projMat = new Mat4();\n\t\tthis._projMatDirty = true;\n\t\tthis._projMatSkybox = new Mat4();\n\t\tthis._viewMat = new Mat4();\n\t\tthis._viewMatDirty = true;\n\t\tthis._viewProjMat = new Mat4();\n\t\tthis._viewProjMatDirty = true;\n\t\tthis._shaderMatricesVersion = 0;\n\t\tthis._viewProjInverse = new Mat4();\n\t\tthis._viewProjCurrent = null;\n\t\tthis._viewProjPrevious = new Mat4();\n\t\tthis._jitters = [0, 0, 0, 0];\n\t\tthis.frustum = new Frustum();\n\t\tthis._xr = null;\n\t\tthis._xrProperties = {\n\t\t\thorizontalFov: this._horizontalFov,\n\t\t\tfov: this._fov,\n\t\t\taspectRatio: this._aspectRatio,\n\t\t\tfarClip: this._farClip,\n\t\t\tnearClip: this._nearClip\n\t\t};\n\t}\n\tdestroy() {\n\t\tvar _this$renderPassColor, _this$renderPassDepth;\n\t\t(_this$renderPassColor = this.renderPassColorGrab) == null || _this$renderPassColor.destroy();\n\t\tthis.renderPassColorGrab = null;\n\t\t(_this$renderPassDepth = this.renderPassDepthGrab) == null || _this$renderPassDepth.destroy();\n\t\tthis.renderPassDepthGrab = null;\n\t\tthis.renderPasses.length = 0;\n\t}\n\t_storeShaderMatrices(viewProjMat, jitterX, jitterY, renderVersion) {\n\t\tif (this._shaderMatricesVersion !== renderVersion) {\n\t\t\tvar _this$_viewProjCurren, _this$_viewProjCurren2;\n\t\t\tthis._shaderMatricesVersion = renderVersion;\n\t\t\tthis._viewProjPrevious.copy((_this$_viewProjCurren = this._viewProjCurrent) != null ? _this$_viewProjCurren : viewProjMat);\n\t\t\t(_this$_viewProjCurren2 = this._viewProjCurrent) != null ? _this$_viewProjCurren2 : this._viewProjCurrent = new Mat4();\n\t\t\tthis._viewProjCurrent.copy(viewProjMat);\n\t\t\tthis._viewProjInverse.invert(viewProjMat);\n\t\t\tthis._jitters[2] = this._jitters[0];\n\t\t\tthis._jitters[3] = this._jitters[1];\n\t\t\tthis._jitters[0] = jitterX;\n\t\t\tthis._jitters[1] = jitterY;\n\t\t}\n\t}\n\tget fullSizeClearRect() {\n\t\tconst rect = this._scissorRectClear ? this.scissorRect : this._rect;\n\t\treturn rect.x === 0 && rect.y === 0 && rect.z === 1 && rect.w === 1;\n\t}\n\tset aspectRatio(newValue) {\n\t\tif (this._aspectRatio !== newValue) {\n\t\t\tthis._aspectRatio = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\tget aspectRatio() {\n\t\tvar _this$xr;\n\t\treturn (_this$xr = this.xr) != null && _this$xr.active ? this._xrProperties.aspectRatio : this._aspectRatio;\n\t}\n\tset aspectRatioMode(newValue) {\n\t\tif (this._aspectRatioMode !== newValue) {\n\t\t\tthis._aspectRatioMode = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\tget aspectRatioMode() {\n\t\treturn this._aspectRatioMode;\n\t}\n\tset calculateProjection(newValue) {\n\t\tthis._calculateProjection = newValue;\n\t\tthis._projMatDirty = true;\n\t}\n\tget calculateProjection() {\n\t\treturn this._calculateProjection;\n\t}\n\tset calculateTransform(newValue) {\n\t\tthis._calculateTransform = newValue;\n\t}\n\tget calculateTransform() {\n\t\treturn this._calculateTransform;\n\t}\n\tset clearColor(newValue) {\n\t\tthis._clearColor.copy(newValue);\n\t}\n\tget clearColor() {\n\t\treturn this._clearColor;\n\t}\n\tset clearColorBuffer(newValue) {\n\t\tthis._clearColorBuffer = newValue;\n\t}\n\tget clearColorBuffer() {\n\t\treturn this._clearColorBuffer;\n\t}\n\tset clearDepth(newValue) {\n\t\tthis._clearDepth = newValue;\n\t}\n\tget clearDepth() {\n\t\treturn this._clearDepth;\n\t}\n\tset clearDepthBuffer(newValue) {\n\t\tthis._clearDepthBuffer = newValue;\n\t}\n\tget clearDepthBuffer() {\n\t\treturn this._clearDepthBuffer;\n\t}\n\tset clearStencil(newValue) {\n\t\tthis._clearStencil = newValue;\n\t}\n\tget clearStencil() {\n\t\treturn this._clearStencil;\n\t}\n\tset clearStencilBuffer(newValue) {\n\t\tthis._clearStencilBuffer = newValue;\n\t}\n\tget clearStencilBuffer() {\n\t\treturn this._clearStencilBuffer;\n\t}\n\tset cullFaces(newValue) {\n\t\tthis._cullFaces = newValue;\n\t}\n\tget cullFaces() {\n\t\treturn this._cullFaces;\n\t}\n\tset farClip(newValue) {\n\t\tif (this._farClip !== newValue) {\n\t\t\tthis._farClip = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\tget farClip() {\n\t\tvar _this$xr2;\n\t\treturn (_this$xr2 = this.xr) != null && _this$xr2.active ? this._xrProperties.farClip : this._farClip;\n\t}\n\tset flipFaces(newValue) {\n\t\tthis._flipFaces = newValue;\n\t}\n\tget flipFaces() {\n\t\treturn this._flipFaces;\n\t}\n\tset fov(newValue) {\n\t\tif (this._fov !== newValue) {\n\t\t\tthis._fov = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\tget fov() {\n\t\tvar _this$xr3;\n\t\treturn (_this$xr3 = this.xr) != null && _this$xr3.active ? this._xrProperties.fov : this._fov;\n\t}\n\tset frustumCulling(newValue) {\n\t\tthis._frustumCulling = newValue;\n\t}\n\tget frustumCulling() {\n\t\treturn this._frustumCulling;\n\t}\n\tset horizontalFov(newValue) {\n\t\tif (this._horizontalFov !== newValue) {\n\t\t\tthis._horizontalFov = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\tget horizontalFov() {\n\t\tvar _this$xr4;\n\t\treturn (_this$xr4 = this.xr) != null && _this$xr4.active ? this._xrProperties.horizontalFov : this._horizontalFov;\n\t}\n\tset layers(newValue) {\n\t\tthis._layers = newValue.slice(0);\n\t\tthis._layersSet = new Set(this._layers);\n\t}\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\tget layersSet() {\n\t\treturn this._layersSet;\n\t}\n\tset nearClip(newValue) {\n\t\tif (this._nearClip !== newValue) {\n\t\t\tthis._nearClip = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\tget nearClip() {\n\t\tvar _this$xr5;\n\t\treturn (_this$xr5 = this.xr) != null && _this$xr5.active ? this._xrProperties.nearClip : this._nearClip;\n\t}\n\tset node(newValue) {\n\t\tthis._node = newValue;\n\t}\n\tget node() {\n\t\treturn this._node;\n\t}\n\tset orthoHeight(newValue) {\n\t\tif (this._orthoHeight !== newValue) {\n\t\t\tthis._orthoHeight = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\tget orthoHeight() {\n\t\treturn this._orthoHeight;\n\t}\n\tset projection(newValue) {\n\t\tif (this._projection !== newValue) {\n\t\t\tthis._projection = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\tget projection() {\n\t\treturn this._projection;\n\t}\n\tget projectionMatrix() {\n\t\tthis._evaluateProjectionMatrix();\n\t\treturn this._projMat;\n\t}\n\tset rect(newValue) {\n\t\tthis._rect.copy(newValue);\n\t}\n\tget rect() {\n\t\treturn this._rect;\n\t}\n\tset renderTarget(newValue) {\n\t\tthis._renderTarget = newValue;\n\t}\n\tget renderTarget() {\n\t\treturn this._renderTarget;\n\t}\n\tset scissorRect(newValue) {\n\t\tthis._scissorRect.copy(newValue);\n\t}\n\tget scissorRect() {\n\t\treturn this._scissorRect;\n\t}\n\tget viewMatrix() {\n\t\tif (this._viewMatDirty) {\n\t\t\tconst wtm = this._node.getWorldTransform();\n\t\t\tthis._viewMat.copy(wtm).invert();\n\t\t\tthis._viewMatDirty = false;\n\t\t}\n\t\treturn this._viewMat;\n\t}\n\tset aperture(newValue) {\n\t\tthis._aperture = newValue;\n\t}\n\tget aperture() {\n\t\treturn this._aperture;\n\t}\n\tset sensitivity(newValue) {\n\t\tthis._sensitivity = newValue;\n\t}\n\tget sensitivity() {\n\t\treturn this._sensitivity;\n\t}\n\tset shutter(newValue) {\n\t\tthis._shutter = newValue;\n\t}\n\tget shutter() {\n\t\treturn this._shutter;\n\t}\n\tset xr(newValue) {\n\t\tif (this._xr !== newValue) {\n\t\t\tthis._xr = newValue;\n\t\t\tthis._projMatDirty = true;\n\t\t}\n\t}\n\tget xr() {\n\t\treturn this._xr;\n\t}\n\tclone() {\n\t\treturn new Camera().copy(this);\n\t}\n\tcopy(other) {\n\t\tthis._aspectRatio = other._aspectRatio;\n\t\tthis._farClip = other._farClip;\n\t\tthis._fov = other._fov;\n\t\tthis._horizontalFov = other._horizontalFov;\n\t\tthis._nearClip = other._nearClip;\n\t\tthis._xrProperties.aspectRatio = other._xrProperties.aspectRatio;\n\t\tthis._xrProperties.farClip = other._xrProperties.farClip;\n\t\tthis._xrProperties.fov = other._xrProperties.fov;\n\t\tthis._xrProperties.horizontalFov = other._xrProperties.horizontalFov;\n\t\tthis._xrProperties.nearClip = other._xrProperties.nearClip;\n\t\tthis.aspectRatioMode = other.aspectRatioMode;\n\t\tthis.calculateProjection = other.calculateProjection;\n\t\tthis.calculateTransform = other.calculateTransform;\n\t\tthis.clearColor = other.clearColor;\n\t\tthis.clearColorBuffer = other.clearColorBuffer;\n\t\tthis.clearDepth = other.clearDepth;\n\t\tthis.clearDepthBuffer = other.clearDepthBuffer;\n\t\tthis.clearStencil = other.clearStencil;\n\t\tthis.clearStencilBuffer = other.clearStencilBuffer;\n\t\tthis.cullFaces = other.cullFaces;\n\t\tthis.flipFaces = other.flipFaces;\n\t\tthis.frustumCulling = other.frustumCulling;\n\t\tthis.layers = other.layers;\n\t\tthis.orthoHeight = other.orthoHeight;\n\t\tthis.projection = other.projection;\n\t\tthis.rect = other.rect;\n\t\tthis.renderTarget = other.renderTarget;\n\t\tthis.scissorRect = other.scissorRect;\n\t\tthis.aperture = other.aperture;\n\t\tthis.shutter = other.shutter;\n\t\tthis.sensitivity = other.sensitivity;\n\t\tthis.shaderPassInfo = other.shaderPassInfo;\n\t\tthis.jitter = other.jitter;\n\t\tthis._projMatDirty = true;\n\t\treturn this;\n\t}\n\t_enableRenderPassColorGrab(device, enable) {\n\t\tif (enable) {\n\t\t\tif (!this.renderPassColorGrab) {\n\t\t\t\tthis.renderPassColorGrab = new RenderPassColorGrab(device);\n\t\t\t}\n\t\t} else {\n\t\t\tvar _this$renderPassColor2;\n\t\t\t(_this$renderPassColor2 = this.renderPassColorGrab) == null || _this$renderPassColor2.destroy();\n\t\t\tthis.renderPassColorGrab = null;\n\t\t}\n\t}\n\t_enableRenderPassDepthGrab(device, renderer, enable) {\n\t\tif (enable) {\n\t\t\tif (!this.renderPassDepthGrab) {\n\t\t\t\tthis.renderPassDepthGrab = device.isWebGL1 ? new RenderPassDepth(device, renderer, this) : new RenderPassDepthGrab(device, this);\n\t\t\t}\n\t\t} else {\n\t\t\tvar _this$renderPassDepth2;\n\t\t\t(_this$renderPassDepth2 = this.renderPassDepthGrab) == null || _this$renderPassDepth2.destroy();\n\t\t\tthis.renderPassDepthGrab = null;\n\t\t}\n\t}\n\t_updateViewProjMat() {\n\t\tif (this._projMatDirty || this._viewMatDirty || this._viewProjMatDirty) {\n\t\t\tthis._viewProjMat.mul2(this.projectionMatrix, this.viewMatrix);\n\t\t\tthis._viewProjMatDirty = false;\n\t\t}\n\t}\n\tworldToScreen(worldCoord, cw, ch, screenCoord = new Vec3()) {\n\t\tthis._updateViewProjMat();\n\t\tthis._viewProjMat.transformPoint(worldCoord, screenCoord);\n\t\tconst vpm = this._viewProjMat.data;\n\t\tconst w = worldCoord.x * vpm[3] + worldCoord.y * vpm[7] + worldCoord.z * vpm[11] + 1 * vpm[15];\n\t\tscreenCoord.x = (screenCoord.x / w + 1) * 0.5 * cw;\n\t\tscreenCoord.y = (1 - screenCoord.y / w) * 0.5 * ch;\n\t\treturn screenCoord;\n\t}\n\tscreenToWorld(x, y, z, cw, ch, worldCoord = new Vec3()) {\n\t\tconst range = this.farClip - this.nearClip;\n\t\t_deviceCoord.set(x / cw, (ch - y) / ch, z / range);\n\t\t_deviceCoord.mulScalar(2);\n\t\t_deviceCoord.sub(Vec3.ONE);\n\t\tif (this._projection === PROJECTION_PERSPECTIVE) {\n\t\t\tMat4._getPerspectiveHalfSize(_halfSize, this.fov, this.aspectRatio, this.nearClip, this.horizontalFov);\n\t\t\t_halfSize.x *= _deviceCoord.x;\n\t\t\t_halfSize.y *= _deviceCoord.y;\n\t\t\tconst invView = this._node.getWorldTransform();\n\t\t\t_halfSize.z = -this.nearClip;\n\t\t\tinvView.transformPoint(_halfSize, _point);\n\t\t\tconst cameraPos = this._node.getPosition();\n\t\t\tworldCoord.sub2(_point, cameraPos);\n\t\t\tworldCoord.normalize();\n\t\t\tworldCoord.mulScalar(z);\n\t\t\tworldCoord.add(cameraPos);\n\t\t} else {\n\t\t\tthis._updateViewProjMat();\n\t\t\t_invViewProjMat.copy(this._viewProjMat).invert();\n\t\t\t_invViewProjMat.transformPoint(_deviceCoord, worldCoord);\n\t\t}\n\t\treturn worldCoord;\n\t}\n\t_evaluateProjectionMatrix() {\n\t\tif (this._projMatDirty) {\n\t\t\tif (this._projection === PROJECTION_PERSPECTIVE) {\n\t\t\t\tthis._projMat.setPerspective(this.fov, this.aspectRatio, this.nearClip, this.farClip, this.horizontalFov);\n\t\t\t\tthis._projMatSkybox.copy(this._projMat);\n\t\t\t} else {\n\t\t\t\tconst y = this._orthoHeight;\n\t\t\t\tconst x = y * this.aspectRatio;\n\t\t\t\tthis._projMat.setOrtho(-x, x, -y, y, this.nearClip, this.farClip);\n\t\t\t\tthis._projMatSkybox.setPerspective(this.fov, this.aspectRatio, this.nearClip, this.farClip);\n\t\t\t}\n\t\t\tthis._projMatDirty = false;\n\t\t}\n\t}\n\tgetProjectionMatrixSkybox() {\n\t\tthis._evaluateProjectionMatrix();\n\t\treturn this._projMatSkybox;\n\t}\n\tgetExposure() {\n\t\tconst ev100 = Math.log2(this._aperture * this._aperture / this._shutter * 100.0 / this._sensitivity);\n\t\treturn 1.0 / (Math.pow(2.0, ev100) * 1.2);\n\t}\n\tgetScreenSize(sphere) {\n\t\tif (this._projection === PROJECTION_PERSPECTIVE) {\n\t\t\tconst distance = this._node.getPosition().distance(sphere.center);\n\t\t\tif (distance < sphere.radius) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tconst viewAngle = Math.asin(sphere.radius / distance);\n\t\t\tconst sphereViewHeight = Math.tan(viewAngle);\n\t\t\tconst screenViewHeight = Math.tan(this.fov / 2 * math.DEG_TO_RAD);\n\t\t\treturn Math.min(sphereViewHeight / screenViewHeight, 1);\n\t\t}\n\t\treturn math.clamp(sphere.radius / this._orthoHeight, 0, 1);\n\t}\n\tgetFrustumCorners(near = this.nearClip, far = this.farClip) {\n\t\tconst fov = this.fov * Math.PI / 180.0;\n\t\tlet y = this._projection === PROJECTION_PERSPECTIVE ? Math.tan(fov / 2.0) * near : this._orthoHeight;\n\t\tlet x = y * this.aspectRatio;\n\t\tconst points = _frustumPoints;\n\t\tpoints[0].x = x;\n\t\tpoints[0].y = -y;\n\t\tpoints[0].z = -near;\n\t\tpoints[1].x = x;\n\t\tpoints[1].y = y;\n\t\tpoints[1].z = -near;\n\t\tpoints[2].x = -x;\n\t\tpoints[2].y = y;\n\t\tpoints[2].z = -near;\n\t\tpoints[3].x = -x;\n\t\tpoints[3].y = -y;\n\t\tpoints[3].z = -near;\n\t\tif (this._projection === PROJECTION_PERSPECTIVE) {\n\t\t\ty = Math.tan(fov / 2.0) * far;\n\t\t\tx = y * this.aspectRatio;\n\t\t}\n\t\tpoints[4].x = x;\n\t\tpoints[4].y = -y;\n\t\tpoints[4].z = -far;\n\t\tpoints[5].x = x;\n\t\tpoints[5].y = y;\n\t\tpoints[5].z = -far;\n\t\tpoints[6].x = -x;\n\t\tpoints[6].y = y;\n\t\tpoints[6].z = -far;\n\t\tpoints[7].x = -x;\n\t\tpoints[7].y = -y;\n\t\tpoints[7].z = -far;\n\t\treturn points;\n\t}\n\tsetXrProperties(properties) {\n\t\tObject.assign(this._xrProperties, properties);\n\t\tthis._projMatDirty = true;\n\t}\n}\n\nexport { Camera };\n","import { EventHandler } from '../../core/event-handler.js';\nimport { sortPriority } from '../../core/sort.js';\nimport { LAYERID_DEPTH } from '../constants.js';\nimport { RenderAction } from './render-action.js';\n\nclass LayerComposition extends EventHandler {\n\tconstructor(name = 'Untitled') {\n\t\tsuper();\n\t\tthis.layerList = [];\n\t\tthis.layerIdMap = new Map();\n\t\tthis.layerNameMap = new Map();\n\t\tthis.layerOpaqueIndexMap = new Map();\n\t\tthis.layerTransparentIndexMap = new Map();\n\t\tthis.subLayerList = [];\n\t\tthis.subLayerEnabled = [];\n\t\tthis.cameras = [];\n\t\tthis.camerasMap = new Map();\n\t\tthis._renderActions = [];\n\t\tthis._dirty = false;\n\t\tthis.name = name;\n\t\tthis._opaqueOrder = {};\n\t\tthis._transparentOrder = {};\n\t}\n\tdestroy() {\n\t\tthis.destroyRenderActions();\n\t}\n\tdestroyRenderActions() {\n\t\tthis._renderActions.forEach(ra => ra.destroy());\n\t\tthis._renderActions.length = 0;\n\t}\n\t_update() {\n\t\tconst len = this.layerList.length;\n\t\tif (!this._dirty) {\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tif (this.layerList[i]._dirtyComposition) {\n\t\t\t\t\tthis._dirty = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this._dirty) {\n\t\t\tthis._dirty = false;\n\t\t\tthis.cameras.length = 0;\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tconst layer = this.layerList[i];\n\t\t\t\tlayer._dirtyComposition = false;\n\t\t\t\tfor (let j = 0; j < layer.cameras.length; j++) {\n\t\t\t\t\tconst camera = layer.cameras[j];\n\t\t\t\t\tconst index = this.cameras.indexOf(camera);\n\t\t\t\t\tif (index < 0) {\n\t\t\t\t\t\tthis.cameras.push(camera);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.cameras.length > 1) {\n\t\t\t\tsortPriority(this.cameras);\n\t\t\t}\n\t\t\tthis.camerasMap.clear();\n\t\t\tfor (let i = 0; i < this.cameras.length; i++) {\n\t\t\t\tthis.camerasMap.set(this.cameras[i], i);\n\t\t\t}\n\t\t\tlet renderActionCount = 0;\n\t\t\tthis.destroyRenderActions();\n\t\t\tfor (let i = 0; i < this.cameras.length; i++) {\n\t\t\t\tconst camera = this.cameras[i];\n\t\t\t\tif (camera.camera.renderPasses.length > 0) {\n\t\t\t\t\tthis.addDummyRenderAction(renderActionCount, camera);\n\t\t\t\t\trenderActionCount++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlet cameraFirstRenderAction = true;\n\t\t\t\tconst cameraFirstRenderActionIndex = renderActionCount;\n\t\t\t\tlet lastRenderAction = null;\n\t\t\t\tlet postProcessMarked = false;\n\t\t\t\tfor (let j = 0; j < len; j++) {\n\t\t\t\t\tconst layer = this.layerList[j];\n\t\t\t\t\tconst isLayerEnabled = layer.enabled && this.subLayerEnabled[j];\n\t\t\t\t\tif (isLayerEnabled) {\n\t\t\t\t\t\tif (layer.cameras.length > 0) {\n\t\t\t\t\t\t\tif (camera.layers.indexOf(layer.id) >= 0) {\n\t\t\t\t\t\t\t\tif (!postProcessMarked && layer.id === camera.disablePostEffectsLayer) {\n\t\t\t\t\t\t\t\t\tpostProcessMarked = true;\n\t\t\t\t\t\t\t\t\tif (lastRenderAction) {\n\t\t\t\t\t\t\t\t\t\tlastRenderAction.triggerPostprocess = true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tconst isTransparent = this.subLayerList[j];\n\t\t\t\t\t\t\t\tlastRenderAction = this.addRenderAction(renderActionCount, layer, isTransparent, camera, cameraFirstRenderAction, postProcessMarked);\n\t\t\t\t\t\t\t\trenderActionCount++;\n\t\t\t\t\t\t\t\tcameraFirstRenderAction = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cameraFirstRenderActionIndex < renderActionCount) {\n\t\t\t\t\tlastRenderAction.lastCameraUse = true;\n\t\t\t\t}\n\t\t\t\tif (!postProcessMarked && lastRenderAction) {\n\t\t\t\t\tlastRenderAction.triggerPostprocess = true;\n\t\t\t\t}\n\t\t\t\tif (camera.renderTarget && camera.postEffectsEnabled) {\n\t\t\t\t\tthis.propagateRenderTarget(cameraFirstRenderActionIndex - 1, camera);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._logRenderActions();\n\t\t}\n\t}\n\tgetNextRenderAction(renderActionIndex) {\n\t\tconst renderAction = new RenderAction();\n\t\tthis._renderActions.push(renderAction);\n\t\treturn renderAction;\n\t}\n\taddDummyRenderAction(renderActionIndex, camera) {\n\t\tconst renderAction = this.getNextRenderAction(renderActionIndex);\n\t\trenderAction.camera = camera;\n\t\trenderAction.useCameraPasses = true;\n\t}\n\taddRenderAction(renderActionIndex, layer, isTransparent, camera, cameraFirstRenderAction, postProcessMarked) {\n\t\tlet rt = layer.renderTarget;\n\t\tif (camera && camera.renderTarget) {\n\t\t\tif (layer.id !== LAYERID_DEPTH) {\n\t\t\t\trt = camera.renderTarget;\n\t\t\t}\n\t\t}\n\t\tlet used = false;\n\t\tconst renderActions = this._renderActions;\n\t\tfor (let i = renderActionIndex - 1; i >= 0; i--) {\n\t\t\tif (renderActions[i].camera === camera && renderActions[i].renderTarget === rt) {\n\t\t\t\tused = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (postProcessMarked && camera.postEffectsEnabled) {\n\t\t\trt = null;\n\t\t}\n\t\tconst renderAction = this.getNextRenderAction(renderActionIndex);\n\t\trenderAction.triggerPostprocess = false;\n\t\trenderAction.layer = layer;\n\t\trenderAction.transparent = isTransparent;\n\t\trenderAction.camera = camera;\n\t\trenderAction.renderTarget = rt;\n\t\trenderAction.firstCameraUse = cameraFirstRenderAction;\n\t\trenderAction.lastCameraUse = false;\n\t\tconst needsCameraClear = cameraFirstRenderAction || !used;\n\t\tconst needsLayerClear = layer.clearColorBuffer || layer.clearDepthBuffer || layer.clearStencilBuffer;\n\t\tif (needsCameraClear || needsLayerClear) {\n\t\t\trenderAction.setupClears(needsCameraClear ? camera : undefined, layer);\n\t\t}\n\t\treturn renderAction;\n\t}\n\tpropagateRenderTarget(startIndex, fromCamera) {\n\t\tfor (let a = startIndex; a >= 0; a--) {\n\t\t\tconst ra = this._renderActions[a];\n\t\t\tconst layer = ra.layer;\n\t\t\tif (ra.renderTarget && layer.id !== LAYERID_DEPTH) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (layer.id === LAYERID_DEPTH) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ra.useCameraPasses) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst thisCamera = ra == null ? void 0 : ra.camera.camera;\n\t\t\tif (thisCamera) {\n\t\t\t\tif (!fromCamera.camera.rect.equals(thisCamera.rect) || !fromCamera.camera.scissorRect.equals(thisCamera.scissorRect)) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tra.renderTarget = fromCamera.renderTarget;\n\t\t}\n\t}\n\t_logRenderActions() {}\n\t_isLayerAdded(layer) {\n\t\tconst found = this.layerIdMap.get(layer.id) === layer;\n\t\treturn found;\n\t}\n\t_isSublayerAdded(layer, transparent) {\n\t\tconst map = transparent ? this.layerTransparentIndexMap : this.layerOpaqueIndexMap;\n\t\tif (map.get(layer) !== undefined) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\tpush(layer) {\n\t\tif (this._isLayerAdded(layer)) return;\n\t\tthis.layerList.push(layer);\n\t\tthis.layerList.push(layer);\n\t\tthis._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;\n\t\tthis._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;\n\t\tthis.subLayerEnabled.push(true);\n\t\tthis.subLayerEnabled.push(true);\n\t\tthis._updateLayerMaps();\n\t\tthis._dirty = true;\n\t\tthis.fire('add', layer);\n\t}\n\tinsert(layer, index) {\n\t\tif (this._isLayerAdded(layer)) return;\n\t\tthis.layerList.splice(index, 0, layer, layer);\n\t\tthis.subLayerList.splice(index, 0, false, true);\n\t\tconst count = this.layerList.length;\n\t\tthis._updateOpaqueOrder(index, count - 1);\n\t\tthis._updateTransparentOrder(index, count - 1);\n\t\tthis.subLayerEnabled.splice(index, 0, true, true);\n\t\tthis._updateLayerMaps();\n\t\tthis._dirty = true;\n\t\tthis.fire('add', layer);\n\t}\n\tremove(layer) {\n\t\tlet id = this.layerList.indexOf(layer);\n\t\tdelete this._opaqueOrder[id];\n\t\tdelete this._transparentOrder[id];\n\t\twhile (id >= 0) {\n\t\t\tthis.layerList.splice(id, 1);\n\t\t\tthis.subLayerList.splice(id, 1);\n\t\t\tthis.subLayerEnabled.splice(id, 1);\n\t\t\tid = this.layerList.indexOf(layer);\n\t\t\tthis._dirty = true;\n\t\t\tthis.fire('remove', layer);\n\t\t}\n\t\tconst count = this.layerList.length;\n\t\tthis._updateOpaqueOrder(0, count - 1);\n\t\tthis._updateTransparentOrder(0, count - 1);\n\t\tthis._updateLayerMaps();\n\t}\n\tpushOpaque(layer) {\n\t\tif (this._isSublayerAdded(layer, false)) return;\n\t\tthis.layerList.push(layer);\n\t\tthis._opaqueOrder[layer.id] = this.subLayerList.push(false) - 1;\n\t\tthis.subLayerEnabled.push(true);\n\t\tthis._updateLayerMaps();\n\t\tthis._dirty = true;\n\t\tthis.fire('add', layer);\n\t}\n\tinsertOpaque(layer, index) {\n\t\tif (this._isSublayerAdded(layer, false)) return;\n\t\tthis.layerList.splice(index, 0, layer);\n\t\tthis.subLayerList.splice(index, 0, false);\n\t\tconst count = this.subLayerList.length;\n\t\tthis._updateOpaqueOrder(index, count - 1);\n\t\tthis.subLayerEnabled.splice(index, 0, true);\n\t\tthis._updateLayerMaps();\n\t\tthis._dirty = true;\n\t\tthis.fire('add', layer);\n\t}\n\tremoveOpaque(layer) {\n\t\tfor (let i = 0, len = this.layerList.length; i < len; i++) {\n\t\t\tif (this.layerList[i] === layer && !this.subLayerList[i]) {\n\t\t\t\tthis.layerList.splice(i, 1);\n\t\t\t\tthis.subLayerList.splice(i, 1);\n\t\t\t\tlen--;\n\t\t\t\tthis._updateOpaqueOrder(i, len - 1);\n\t\t\t\tthis.subLayerEnabled.splice(i, 1);\n\t\t\t\tthis._dirty = true;\n\t\t\t\tif (this.layerList.indexOf(layer) < 0) {\n\t\t\t\t\tthis.fire('remove', layer);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis._updateLayerMaps();\n\t}\n\tpushTransparent(layer) {\n\t\tif (this._isSublayerAdded(layer, true)) return;\n\t\tthis.layerList.push(layer);\n\t\tthis._transparentOrder[layer.id] = this.subLayerList.push(true) - 1;\n\t\tthis.subLayerEnabled.push(true);\n\t\tthis._updateLayerMaps();\n\t\tthis._dirty = true;\n\t\tthis.fire('add', layer);\n\t}\n\tinsertTransparent(layer, index) {\n\t\tif (this._isSublayerAdded(layer, true)) return;\n\t\tthis.layerList.splice(index, 0, layer);\n\t\tthis.subLayerList.splice(index, 0, true);\n\t\tconst count = this.subLayerList.length;\n\t\tthis._updateTransparentOrder(index, count - 1);\n\t\tthis.subLayerEnabled.splice(index, 0, true);\n\t\tthis._updateLayerMaps();\n\t\tthis._dirty = true;\n\t\tthis.fire('add', layer);\n\t}\n\tremoveTransparent(layer) {\n\t\tfor (let i = 0, len = this.layerList.length; i < len; i++) {\n\t\t\tif (this.layerList[i] === layer && this.subLayerList[i]) {\n\t\t\t\tthis.layerList.splice(i, 1);\n\t\t\t\tthis.subLayerList.splice(i, 1);\n\t\t\t\tlen--;\n\t\t\t\tthis._updateTransparentOrder(i, len - 1);\n\t\t\t\tthis.subLayerEnabled.splice(i, 1);\n\t\t\t\tthis._dirty = true;\n\t\t\t\tif (this.layerList.indexOf(layer) < 0) {\n\t\t\t\t\tthis.fire('remove', layer);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis._updateLayerMaps();\n\t}\n\tgetOpaqueIndex(layer) {\n\t\tvar _this$layerOpaqueInde;\n\t\treturn (_this$layerOpaqueInde = this.layerOpaqueIndexMap.get(layer)) != null ? _this$layerOpaqueInde : -1;\n\t}\n\tgetTransparentIndex(layer) {\n\t\tvar _this$layerTransparen;\n\t\treturn (_this$layerTransparen = this.layerTransparentIndexMap.get(layer)) != null ? _this$layerTransparen : -1;\n\t}\n\tisEnabled(layer, transparent) {\n\t\tconst index = transparent ? this.getTransparentIndex(layer) : this.getOpaqueIndex(layer);\n\t\treturn this.subLayerEnabled[index];\n\t}\n\t_updateLayerMaps() {\n\t\tthis.layerIdMap.clear();\n\t\tthis.layerNameMap.clear();\n\t\tthis.layerOpaqueIndexMap.clear();\n\t\tthis.layerTransparentIndexMap.clear();\n\t\tfor (let i = 0; i < this.layerList.length; i++) {\n\t\t\tconst layer = this.layerList[i];\n\t\t\tthis.layerIdMap.set(layer.id, layer);\n\t\t\tthis.layerNameMap.set(layer.name, layer);\n\t\t\tconst subLayerIndexMap = this.subLayerList[i] ? this.layerTransparentIndexMap : this.layerOpaqueIndexMap;\n\t\t\tsubLayerIndexMap.set(layer, i);\n\t\t}\n\t}\n\tgetLayerById(id) {\n\t\tvar _this$layerIdMap$get;\n\t\treturn (_this$layerIdMap$get = this.layerIdMap.get(id)) != null ? _this$layerIdMap$get : null;\n\t}\n\tgetLayerByName(name) {\n\t\tvar _this$layerNameMap$ge;\n\t\treturn (_this$layerNameMap$ge = this.layerNameMap.get(name)) != null ? _this$layerNameMap$ge : null;\n\t}\n\t_updateOpaqueOrder(startIndex, endIndex) {\n\t\tfor (let i = startIndex; i <= endIndex; i++) {\n\t\t\tif (this.subLayerList[i] === false) {\n\t\t\t\tthis._opaqueOrder[this.layerList[i].id] = i;\n\t\t\t}\n\t\t}\n\t}\n\t_updateTransparentOrder(startIndex, endIndex) {\n\t\tfor (let i = startIndex; i <= endIndex; i++) {\n\t\t\tif (this.subLayerList[i] === true) {\n\t\t\t\tthis._transparentOrder[this.layerList[i].id] = i;\n\t\t\t}\n\t\t}\n\t}\n\t_sortLayersDescending(layersA, layersB, order) {\n\t\tlet topLayerA = -1;\n\t\tlet topLayerB = -1;\n\t\tfor (let i = 0, len = layersA.length; i < len; i++) {\n\t\t\tconst id = layersA[i];\n\t\t\tif (order.hasOwnProperty(id)) {\n\t\t\t\ttopLayerA = Math.max(topLayerA, order[id]);\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0, len = layersB.length; i < len; i++) {\n\t\t\tconst id = layersB[i];\n\t\t\tif (order.hasOwnProperty(id)) {\n\t\t\t\ttopLayerB = Math.max(topLayerB, order[id]);\n\t\t\t}\n\t\t}\n\t\tif (topLayerA === -1 && topLayerB !== -1) {\n\t\t\treturn 1;\n\t\t} else if (topLayerB === -1 && topLayerA !== -1) {\n\t\t\treturn -1;\n\t\t}\n\t\treturn topLayerB - topLayerA;\n\t}\n\tsortTransparentLayers(layersA, layersB) {\n\t\treturn this._sortLayersDescending(layersA, layersB, this._transparentOrder);\n\t}\n\tsortOpaqueLayers(layersA, layersB) {\n\t\treturn this._sortLayersDescending(layersA, layersB, this._opaqueOrder);\n\t}\n}\n\nexport { LayerComposition };\n","class RenderAction {\n\tconstructor() {\n\t\tthis.layer = null;\n\t\tthis.transparent = false;\n\t\tthis.camera = null;\n\t\tthis.renderTarget = null;\n\t\tthis.lightClusters = null;\n\t\tthis.clearColor = false;\n\t\tthis.clearDepth = false;\n\t\tthis.clearStencil = false;\n\t\tthis.triggerPostprocess = false;\n\t\tthis.firstCameraUse = false;\n\t\tthis.lastCameraUse = false;\n\t\tthis.viewBindGroups = [];\n\t\tthis.useCameraPasses = false;\n\t}\n\tdestroy() {\n\t\tthis.viewBindGroups.forEach(bg => {\n\t\t\tbg.defaultUniformBuffer.destroy();\n\t\t\tbg.destroy();\n\t\t});\n\t\tthis.viewBindGroups.length = 0;\n\t}\n\tsetupClears(camera, layer) {\n\t\tthis.clearColor = (camera == null ? void 0 : camera.clearColorBuffer) || layer.clearColorBuffer;\n\t\tthis.clearDepth = (camera == null ? void 0 : camera.clearDepthBuffer) || layer.clearDepthBuffer;\n\t\tthis.clearStencil = (camera == null ? void 0 : camera.clearStencilBuffer) || layer.clearStencilBuffer;\n\t}\n}\n\nexport { RenderAction };\n","class CompressUtils {\n\tstatic setCompressedPRS(entity, data, compressed) {\n\t\tconst a = compressed.singleVecs;\n\t\tlet b, i;\n\t\tconst v = data.___1;\n\t\tif (!v) {\n\t\t\tb = compressed.tripleVecs;\n\t\t\ti = data.___2;\n\t\t}\n\t\tlet n = v ? v[0] : b[i];\n\t\tentity.setLocalPosition(a[n], a[n + 1], a[n + 2]);\n\t\tn = v ? v[1] : b[i + 1];\n\t\tentity.setLocalEulerAngles(a[n], a[n + 1], a[n + 2]);\n\t\tn = v ? v[2] : b[i + 2];\n\t\tentity.setLocalScale(a[n], a[n + 1], a[n + 2]);\n\t}\n\tstatic oneCharToKey(s, data) {\n\t\tconst i = s.charCodeAt(0) - data.fieldFirstCode;\n\t\treturn data.fieldArray[i];\n\t}\n\tstatic multCharToKey(s, data) {\n\t\tlet ind = 0;\n\t\tfor (let i = 0; i < s.length; i++) {\n\t\t\tind = ind * data.fieldCodeBase + s.charCodeAt(i) - data.fieldFirstCode;\n\t\t}\n\t\treturn data.fieldArray[ind];\n\t}\n}\n\nexport { CompressUtils };\n","import { CompressUtils } from './compress-utils.js';\n\nclass Decompress {\n\tconstructor(node, data) {\n\t\tthis._node = node;\n\t\tthis._data = data;\n\t}\n\trun() {\n\t\tconst type = Object.prototype.toString.call(this._node);\n\t\tif (type === '[object Object]') {\n\t\t\tthis._handleMap();\n\t\t} else if (type === '[object Array]') {\n\t\t\tthis._handleArray();\n\t\t} else {\n\t\t\tthis._result = this._node;\n\t\t}\n\t\treturn this._result;\n\t}\n\t_handleMap() {\n\t\tthis._result = {};\n\t\tconst a = Object.keys(this._node);\n\t\ta.forEach(this._handleKey, this);\n\t}\n\t_handleKey(origKey) {\n\t\tlet newKey = origKey;\n\t\tconst len = origKey.length;\n\t\tif (len === 1) {\n\t\t\tnewKey = CompressUtils.oneCharToKey(origKey, this._data);\n\t\t} else if (len === 2) {\n\t\t\tnewKey = CompressUtils.multCharToKey(origKey, this._data);\n\t\t}\n\t\tthis._result[newKey] = new Decompress(this._node[origKey], this._data).run();\n\t}\n\t_handleArray() {\n\t\tthis._result = [];\n\t\tthis._node.forEach(this._handleArElt, this);\n\t}\n\t_handleArElt(elt) {\n\t\tconst v = new Decompress(elt, this._data).run();\n\t\tthis._result.push(v);\n\t}\n}\n\nexport { Decompress };\n","const BLEND_SUBTRACTIVE = 0;\nconst BLEND_ADDITIVE = 1;\nconst BLEND_NORMAL = 2;\nconst BLEND_NONE = 3;\nconst BLEND_PREMULTIPLIED = 4;\nconst BLEND_MULTIPLICATIVE = 5;\nconst BLEND_ADDITIVEALPHA = 6;\nconst BLEND_MULTIPLICATIVE2X = 7;\nconst BLEND_SCREEN = 8;\nconst BLEND_MIN = 9;\nconst BLEND_MAX = 10;\nconst FOG_NONE = 'none';\nconst FOG_LINEAR = 'linear';\nconst FOG_EXP = 'exp';\nconst FOG_EXP2 = 'exp2';\nconst FRESNEL_NONE = 0;\nconst FRESNEL_SCHLICK = 2;\nconst LAYER_HUD = 0;\nconst LAYER_GIZMO = 1;\nconst LAYER_FX = 2;\nconst LAYER_WORLD = 15;\nconst LAYERID_WORLD = 0;\nconst LAYERID_DEPTH = 1;\nconst LAYERID_SKYBOX = 2;\nconst LAYERID_IMMEDIATE = 3;\nconst LAYERID_UI = 4;\nconst LIGHTTYPE_DIRECTIONAL = 0;\nconst LIGHTTYPE_OMNI = 1;\nconst LIGHTTYPE_POINT = LIGHTTYPE_OMNI;\nconst LIGHTTYPE_SPOT = 2;\nconst LIGHTTYPE_COUNT = 3;\nconst LIGHTSHAPE_PUNCTUAL = 0;\nconst LIGHTSHAPE_RECT = 1;\nconst LIGHTSHAPE_DISK = 2;\nconst LIGHTSHAPE_SPHERE = 3;\nconst LIGHTFALLOFF_LINEAR = 0;\nconst LIGHTFALLOFF_INVERSESQUARED = 1;\nconst SHADOW_PCF3 = 0;\nconst SHADOW_DEPTH = 0;\nconst SHADOW_VSM8 = 1;\nconst SHADOW_VSM16 = 2;\nconst SHADOW_VSM32 = 3;\nconst SHADOW_PCF5 = 4;\nconst SHADOW_PCF1 = 5;\nconst SHADOW_PCSS = 6;\nconst shadowTypeToString = {};\nshadowTypeToString[SHADOW_PCF3] = 'PCF3';\nshadowTypeToString[SHADOW_VSM8] = 'VSM8';\nshadowTypeToString[SHADOW_VSM16] = 'VSM16';\nshadowTypeToString[SHADOW_VSM32] = 'VSM32';\nshadowTypeToString[SHADOW_PCF5] = 'PCF5';\nshadowTypeToString[SHADOW_PCF1] = 'PCF1';\nshadowTypeToString[SHADOW_PCSS] = 'PCSS';\nconst BLUR_BOX = 0;\nconst BLUR_GAUSSIAN = 1;\nconst PARTICLESORT_NONE = 0;\nconst PARTICLESORT_DISTANCE = 1;\nconst PARTICLESORT_NEWER_FIRST = 2;\nconst PARTICLESORT_OLDER_FIRST = 3;\nconst PARTICLEMODE_GPU = 0;\nconst PARTICLEMODE_CPU = 1;\nconst EMITTERSHAPE_BOX = 0;\nconst EMITTERSHAPE_SPHERE = 1;\nconst PARTICLEORIENTATION_SCREEN = 0;\nconst PARTICLEORIENTATION_WORLD = 1;\nconst PARTICLEORIENTATION_EMITTER = 2;\nconst PROJECTION_PERSPECTIVE = 0;\nconst PROJECTION_ORTHOGRAPHIC = 1;\nconst RENDERSTYLE_SOLID = 0;\nconst RENDERSTYLE_WIREFRAME = 1;\nconst RENDERSTYLE_POINTS = 2;\nconst CUBEPROJ_NONE = 0;\nconst CUBEPROJ_BOX = 1;\nconst SPECULAR_PHONG = 0;\nconst SPECULAR_BLINN = 1;\nconst DETAILMODE_MUL = 'mul';\nconst DETAILMODE_ADD = 'add';\nconst DETAILMODE_SCREEN = 'screen';\nconst DETAILMODE_OVERLAY = 'overlay';\nconst DETAILMODE_MIN = 'min';\nconst DETAILMODE_MAX = 'max';\nconst GAMMA_NONE = 0;\nconst GAMMA_SRGB = 1;\nconst GAMMA_SRGBFAST = 2;\nconst GAMMA_SRGBHDR = 3;\nconst TONEMAP_LINEAR = 0;\nconst TONEMAP_FILMIC = 1;\nconst TONEMAP_HEJL = 2;\nconst TONEMAP_ACES = 3;\nconst TONEMAP_ACES2 = 4;\nconst TONEMAP_NEUTRAL = 5;\nconst SPECOCC_NONE = 0;\nconst SPECOCC_AO = 1;\nconst SPECOCC_GLOSSDEPENDENT = 2;\nconst SHADERDEF_NOSHADOW = 1;\nconst SHADERDEF_SKIN = 2;\nconst SHADERDEF_UV0 = 4;\nconst SHADERDEF_UV1 = 8;\nconst SHADERDEF_VCOLOR = 16;\nconst SHADERDEF_INSTANCING = 32;\nconst SHADERDEF_LM = 64;\nconst SHADERDEF_DIRLM = 128;\nconst SHADERDEF_SCREENSPACE = 256;\nconst SHADERDEF_TANGENTS = 512;\nconst SHADERDEF_MORPH_POSITION = 1024;\nconst SHADERDEF_MORPH_NORMAL = 2048;\nconst SHADERDEF_MORPH_TEXTURE_BASED = 4096;\nconst SHADERDEF_LMAMBIENT = 8192;\nconst SHADOWUPDATE_NONE = 0;\nconst SHADOWUPDATE_THISFRAME = 1;\nconst SHADOWUPDATE_REALTIME = 2;\nconst SORTKEY_FORWARD = 0;\nconst SORTKEY_DEPTH = 1;\nconst MASK_AFFECT_DYNAMIC = 1;\nconst MASK_AFFECT_LIGHTMAPPED = 2;\nconst MASK_BAKE = 4;\nconst SHADER_FORWARD = 0;\nconst SHADER_FORWARDHDR = 1;\nconst SHADER_DEPTH = 2;\nconst SHADER_PICK = 3;\nconst SHADER_SHADOW = 4;\nconst SHADER_PREPASS_VELOCITY = 5;\nconst SHADERPASS_FORWARD = 'forward';\nconst SHADERPASS_ALBEDO = 'debug_albedo';\nconst SHADERPASS_WORLDNORMAL = 'debug_world_normal';\nconst SHADERPASS_OPACITY = 'debug_opacity';\nconst SHADERPASS_SPECULARITY = 'debug_specularity';\nconst SHADERPASS_GLOSS = 'debug_gloss';\nconst SHADERPASS_METALNESS = 'debug_metalness';\nconst SHADERPASS_AO = 'debug_ao';\nconst SHADERPASS_EMISSION = 'debug_emission';\nconst SHADERPASS_LIGHTING = 'debug_lighting';\nconst SHADERPASS_UV0 = 'debug_uv0';\nconst SPRITE_RENDERMODE_SIMPLE = 0;\nconst SPRITE_RENDERMODE_SLICED = 1;\nconst SPRITE_RENDERMODE_TILED = 2;\nconst BAKE_COLOR = 0;\nconst BAKE_COLORDIR = 1;\nconst VIEW_CENTER = 0;\nconst VIEW_LEFT = 1;\nconst VIEW_RIGHT = 2;\nconst SORTMODE_NONE = 0;\nconst SORTMODE_MANUAL = 1;\nconst SORTMODE_MATERIALMESH = 2;\nconst SORTMODE_BACK2FRONT = 3;\nconst SORTMODE_FRONT2BACK = 4;\nconst SORTMODE_CUSTOM = 5;\nconst ASPECT_AUTO = 0;\nconst ASPECT_MANUAL = 1;\nconst ORIENTATION_HORIZONTAL = 0;\nconst ORIENTATION_VERTICAL = 1;\nconst SKYTYPE_INFINITE = 'infinite';\nconst SKYTYPE_BOX = 'box';\nconst SKYTYPE_DOME = 'dome';\nconst DITHER_NONE = 'none';\nconst DITHER_BAYER8 = 'bayer8';\nconst DITHER_BLUENOISE = 'bluenoise';\nconst DITHER_IGNNOISE = 'ignnoise';\n\nexport { ASPECT_AUTO, ASPECT_MANUAL, BAKE_COLOR, BAKE_COLORDIR, BLEND_ADDITIVE, BLEND_ADDITIVEALPHA, BLEND_MAX, BLEND_MIN, BLEND_MULTIPLICATIVE, BLEND_MULTIPLICATIVE2X, BLEND_NONE, BLEND_NORMAL, BLEND_PREMULTIPLIED, BLEND_SCREEN, BLEND_SUBTRACTIVE, BLUR_BOX, BLUR_GAUSSIAN, CUBEPROJ_BOX, CUBEPROJ_NONE, DETAILMODE_ADD, DETAILMODE_MAX, DETAILMODE_MIN, DETAILMODE_MUL, DETAILMODE_OVERLAY, DETAILMODE_SCREEN, DITHER_BAYER8, DITHER_BLUENOISE, DITHER_IGNNOISE, DITHER_NONE, EMITTERSHAPE_BOX, EMITTERSHAPE_SPHERE, FOG_EXP, FOG_EXP2, FOG_LINEAR, FOG_NONE, FRESNEL_NONE, FRESNEL_SCHLICK, GAMMA_NONE, GAMMA_SRGB, GAMMA_SRGBFAST, GAMMA_SRGBHDR, LAYERID_DEPTH, LAYERID_IMMEDIATE, LAYERID_SKYBOX, LAYERID_UI, LAYERID_WORLD, LAYER_FX, LAYER_GIZMO, LAYER_HUD, LAYER_WORLD, LIGHTFALLOFF_INVERSESQUARED, LIGHTFALLOFF_LINEAR, LIGHTSHAPE_DISK, LIGHTSHAPE_PUNCTUAL, LIGHTSHAPE_RECT, LIGHTSHAPE_SPHERE, LIGHTTYPE_COUNT, LIGHTTYPE_DIRECTIONAL, LIGHTTYPE_OMNI, LIGHTTYPE_POINT, LIGHTTYPE_SPOT, MASK_AFFECT_DYNAMIC, MASK_AFFECT_LIGHTMAPPED, MASK_BAKE, ORIENTATION_HORIZONTAL, ORIENTATION_VERTICAL, PARTICLEMODE_CPU, PARTICLEMODE_GPU, PARTICLEORIENTATION_EMITTER, PARTICLEORIENTATION_SCREEN, PARTICLEORIENTATION_WORLD, PARTICLESORT_DISTANCE, PARTICLESORT_NEWER_FIRST, PARTICLESORT_NONE, PARTICLESORT_OLDER_FIRST, PROJECTION_ORTHOGRAPHIC, PROJECTION_PERSPECTIVE, RENDERSTYLE_POINTS, RENDERSTYLE_SOLID, RENDERSTYLE_WIREFRAME, SHADERDEF_DIRLM, SHADERDEF_INSTANCING, SHADERDEF_LM, SHADERDEF_LMAMBIENT, SHADERDEF_MORPH_NORMAL, SHADERDEF_MORPH_POSITION, SHADERDEF_MORPH_TEXTURE_BASED, SHADERDEF_NOSHADOW, SHADERDEF_SCREENSPACE, SHADERDEF_SKIN, SHADERDEF_TANGENTS, SHADERDEF_UV0, SHADERDEF_UV1, SHADERDEF_VCOLOR, SHADERPASS_ALBEDO, SHADERPASS_AO, SHADERPASS_EMISSION, SHADERPASS_FORWARD, SHADERPASS_GLOSS, SHADERPASS_LIGHTING, SHADERPASS_METALNESS, SHADERPASS_OPACITY, SHADERPASS_SPECULARITY, SHADERPASS_UV0, SHADERPASS_WORLDNORMAL, SHADER_DEPTH, SHADER_FORWARD, SHADER_FORWARDHDR, SHADER_PICK, SHADER_PREPASS_VELOCITY, SHADER_SHADOW, SHADOWUPDATE_NONE, SHADOWUPDATE_REALTIME, SHADOWUPDATE_THISFRAME, SHADOW_DEPTH, SHADOW_PCF1, SHADOW_PCF3, SHADOW_PCF5, SHADOW_PCSS, SHADOW_VSM16, SHADOW_VSM32, SHADOW_VSM8, SKYTYPE_BOX, SKYTYPE_DOME, SKYTYPE_INFINITE, SORTKEY_DEPTH, SORTKEY_FORWARD, SORTMODE_BACK2FRONT, SORTMODE_CUSTOM, SORTMODE_FRONT2BACK, SORTMODE_MANUAL, SORTMODE_MATERIALMESH, SORTMODE_NONE, SPECOCC_AO, SPECOCC_GLOSSDEPENDENT, SPECOCC_NONE, SPECULAR_BLINN, SPECULAR_PHONG, SPRITE_RENDERMODE_SIMPLE, SPRITE_RENDERMODE_SLICED, SPRITE_RENDERMODE_TILED, TONEMAP_ACES, TONEMAP_ACES2, TONEMAP_FILMIC, TONEMAP_HEJL, TONEMAP_LINEAR, TONEMAP_NEUTRAL, VIEW_CENTER, VIEW_LEFT, VIEW_RIGHT, shadowTypeToString };\n","class FrameGraph {\n\tconstructor() {\n\t\tthis.renderPasses = [];\n\t\tthis.renderTargetMap = new Map();\n\t}\n\taddRenderPass(renderPass) {\n\t\trenderPass.frameUpdate();\n\t\tconst beforePasses = renderPass.beforePasses;\n\t\tfor (let i = 0; i < beforePasses.length; i++) {\n\t\t\tconst pass = beforePasses[i];\n\t\t\tif (pass.enabled) {\n\t\t\t\tthis.addRenderPass(pass);\n\t\t\t}\n\t\t}\n\t\tif (renderPass.enabled) {\n\t\t\tthis.renderPasses.push(renderPass);\n\t\t}\n\t\tconst afterPasses = renderPass.afterPasses;\n\t\tfor (let i = 0; i < afterPasses.length; i++) {\n\t\t\tconst pass = afterPasses[i];\n\t\t\tif (pass.enabled) {\n\t\t\t\tthis.addRenderPass(pass);\n\t\t\t}\n\t\t}\n\t}\n\treset() {\n\t\tthis.renderPasses.length = 0;\n\t}\n\tcompile() {\n\t\tconst renderTargetMap = this.renderTargetMap;\n\t\tconst renderPasses = this.renderPasses;\n\t\tfor (let i = 0; i < renderPasses.length; i++) {\n\t\t\tconst renderPass = renderPasses[i];\n\t\t\tconst renderTarget = renderPass.renderTarget;\n\t\t\tif (renderTarget !== undefined) {\n\t\t\t\tconst prevPass = renderTargetMap.get(renderTarget);\n\t\t\t\tif (prevPass) {\n\t\t\t\t\tconst count = renderPass.colorArrayOps.length;\n\t\t\t\t\tfor (let j = 0; j < count; j++) {\n\t\t\t\t\t\tconst colorOps = renderPass.colorArrayOps[j];\n\t\t\t\t\t\tif (!colorOps.clear) {\n\t\t\t\t\t\t\tprevPass.colorArrayOps[j].store = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!renderPass.depthStencilOps.clearDepth) {\n\t\t\t\t\t\tprevPass.depthStencilOps.storeDepth = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (!renderPass.depthStencilOps.clearStencil) {\n\t\t\t\t\t\tprevPass.depthStencilOps.storeStencil = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trenderTargetMap.set(renderTarget, renderPass);\n\t\t\t}\n\t\t}\n\t\tlet lastCubeTexture = null;\n\t\tlet lastCubeRenderPass = null;\n\t\tfor (let i = 0; i < renderPasses.length; i++) {\n\t\t\tconst renderPass = renderPasses[i];\n\t\t\tconst renderTarget = renderPass.renderTarget;\n\t\t\tconst thisTexture = renderTarget == null ? void 0 : renderTarget.colorBuffer;\n\t\t\tif (thisTexture != null && thisTexture.cubemap) {\n\t\t\t\tif (lastCubeTexture === thisTexture) {\n\t\t\t\t\tconst count = lastCubeRenderPass.colorArrayOps.length;\n\t\t\t\t\tfor (let j = 0; j < count; j++) {\n\t\t\t\t\t\tlastCubeRenderPass.colorArrayOps[j].mipmaps = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlastCubeTexture = renderTarget.colorBuffer;\n\t\t\t\tlastCubeRenderPass = renderPass;\n\t\t\t} else if (renderPass.requiresCubemaps) {\n\t\t\t\tlastCubeTexture = null;\n\t\t\t\tlastCubeRenderPass = null;\n\t\t\t}\n\t\t}\n\t\trenderTargetMap.clear();\n\t}\n\trender(device) {\n\t\tthis.compile();\n\t\tconst renderPasses = this.renderPasses;\n\t\tfor (let i = 0; i < renderPasses.length; i++) {\n\t\t\trenderPasses[i].render();\n\t\t}\n\t}\n}\n\nexport { FrameGraph };\n","import { Vec3 } from '../../core/math/vec3.js';\nimport { calculateTangents } from './geometry-utils.js';\nimport { Geometry } from './geometry.js';\n\nconst primitiveUv1Padding = 4.0 / 64;\nconst primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;\nclass BoxGeometry extends Geometry {\n\tconstructor(opts = {}) {\n\t\tvar _opts$halfExtents, _opts$widthSegments, _opts$lengthSegments, _opts$heightSegments, _opts$yOffset;\n\t\tsuper();\n\t\tconst he = (_opts$halfExtents = opts.halfExtents) != null ? _opts$halfExtents : new Vec3(0.5, 0.5, 0.5);\n\t\tconst ws = (_opts$widthSegments = opts.widthSegments) != null ? _opts$widthSegments : 1;\n\t\tconst ls = (_opts$lengthSegments = opts.lengthSegments) != null ? _opts$lengthSegments : 1;\n\t\tconst hs = (_opts$heightSegments = opts.heightSegments) != null ? _opts$heightSegments : 1;\n\t\tconst yOffset = (_opts$yOffset = opts.yOffset) != null ? _opts$yOffset : 0;\n\t\tconst minY = -he.y + yOffset;\n\t\tconst maxY = he.y + yOffset;\n\t\tconst corners = [new Vec3(-he.x, minY, he.z), new Vec3(he.x, minY, he.z), new Vec3(he.x, maxY, he.z), new Vec3(-he.x, maxY, he.z), new Vec3(he.x, minY, -he.z), new Vec3(-he.x, minY, -he.z), new Vec3(-he.x, maxY, -he.z), new Vec3(he.x, maxY, -he.z)];\n\t\tconst faceAxes = [[0, 1, 3], [4, 5, 7], [3, 2, 6], [1, 0, 4], [1, 4, 2], [5, 0, 6]];\n\t\tconst faceNormals = [[0, 0, 1], [0, 0, -1], [0, 1, 0], [0, -1, 0], [1, 0, 0], [-1, 0, 0]];\n\t\tconst sides = {\n\t\t\tFRONT: 0,\n\t\t\tBACK: 1,\n\t\t\tTOP: 2,\n\t\t\tBOTTOM: 3,\n\t\t\tRIGHT: 4,\n\t\t\tLEFT: 5\n\t\t};\n\t\tconst positions = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\t\tconst indices = [];\n\t\tlet vcounter = 0;\n\t\tconst generateFace = (side, uSegments, vSegments) => {\n\t\t\tconst temp1 = new Vec3();\n\t\t\tconst temp2 = new Vec3();\n\t\t\tconst temp3 = new Vec3();\n\t\t\tconst r = new Vec3();\n\t\t\tfor (let i = 0; i <= uSegments; i++) {\n\t\t\t\tfor (let j = 0; j <= vSegments; j++) {\n\t\t\t\t\ttemp1.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);\n\t\t\t\t\ttemp2.lerp(corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);\n\t\t\t\t\ttemp3.sub2(temp2, corners[faceAxes[side][0]]);\n\t\t\t\t\tr.add2(temp1, temp3);\n\t\t\t\t\tlet u = i / uSegments;\n\t\t\t\t\tlet v = j / vSegments;\n\t\t\t\t\tpositions.push(r.x, r.y, r.z);\n\t\t\t\t\tnormals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);\n\t\t\t\t\tuvs.push(u, 1 - v);\n\t\t\t\t\tu = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\t\tv = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\t\tu /= 3;\n\t\t\t\t\tv /= 3;\n\t\t\t\t\tu += side % 3 / 3;\n\t\t\t\t\tv += Math.floor(side / 3) / 3;\n\t\t\t\t\tif (i < uSegments && j < vSegments) {\n\t\t\t\t\t\tindices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);\n\t\t\t\t\t\tindices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);\n\t\t\t\t\t}\n\t\t\t\t\tvcounter++;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tgenerateFace(sides.FRONT, ws, hs);\n\t\tgenerateFace(sides.BACK, ws, hs);\n\t\tgenerateFace(sides.TOP, ws, ls);\n\t\tgenerateFace(sides.BOTTOM, ws, ls);\n\t\tgenerateFace(sides.RIGHT, ls, hs);\n\t\tgenerateFace(sides.LEFT, ls, hs);\n\t\tthis.positions = positions;\n\t\tthis.normals = normals;\n\t\tthis.uvs = uvs;\n\t\tthis.uvs1 = uvs;\n\t\tthis.indices = indices;\n\t\tif (opts.calculateTangents) {\n\t\t\tthis.tangents = calculateTangents(positions, normals, uvs, indices);\n\t\t}\n\t}\n}\n\nexport { BoxGeometry };\n","import { ConeBaseGeometry } from './cone-base-geometry.js';\nimport { calculateTangents } from './geometry-utils.js';\n\nclass CapsuleGeometry extends ConeBaseGeometry {\n\tconstructor(opts = {}) {\n\t\tvar _opts$radius, _opts$height, _opts$heightSegments, _opts$sides;\n\t\tconst radius = (_opts$radius = opts.radius) != null ? _opts$radius : 0.3;\n\t\tconst height = (_opts$height = opts.height) != null ? _opts$height : 1;\n\t\tconst heightSegments = (_opts$heightSegments = opts.heightSegments) != null ? _opts$heightSegments : 1;\n\t\tconst sides = (_opts$sides = opts.sides) != null ? _opts$sides : 20;\n\t\tsuper(radius, radius, height - 2 * radius, heightSegments, sides, true);\n\t\tif (opts.calculateTangents) {\n\t\t\tthis.tangents = calculateTangents(this.positions, this.normals, this.uvs, this.indices);\n\t\t}\n\t}\n}\n\nexport { CapsuleGeometry };\n","import { Vec3 } from '../../core/math/vec3.js';\nimport { Geometry } from './geometry.js';\n\nconst primitiveUv1Padding = 4.0 / 64;\nconst primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;\nclass ConeBaseGeometry extends Geometry {\n\tconstructor(baseRadius, peakRadius, height, heightSegments, capSegments, roundedCaps) {\n\t\tsuper();\n\t\tconst pos = new Vec3();\n\t\tconst bottomToTop = new Vec3();\n\t\tconst norm = new Vec3();\n\t\tconst top = new Vec3();\n\t\tconst bottom = new Vec3();\n\t\tconst tangent = new Vec3();\n\t\tconst positions = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\t\tconst uvs1 = [];\n\t\tconst indices = [];\n\t\tlet offset;\n\t\tif (height > 0) {\n\t\t\tfor (let i = 0; i <= heightSegments; i++) {\n\t\t\t\tfor (let j = 0; j <= capSegments; j++) {\n\t\t\t\t\tconst theta = j / capSegments * 2 * Math.PI - Math.PI;\n\t\t\t\t\tconst sinTheta = Math.sin(theta);\n\t\t\t\t\tconst cosTheta = Math.cos(theta);\n\t\t\t\t\tbottom.set(sinTheta * baseRadius, -height / 2, cosTheta * baseRadius);\n\t\t\t\t\ttop.set(sinTheta * peakRadius, height / 2, cosTheta * peakRadius);\n\t\t\t\t\tpos.lerp(bottom, top, i / heightSegments);\n\t\t\t\t\tbottomToTop.sub2(top, bottom).normalize();\n\t\t\t\t\ttangent.set(cosTheta, 0, -sinTheta);\n\t\t\t\t\tnorm.cross(tangent, bottomToTop).normalize();\n\t\t\t\t\tpositions.push(pos.x, pos.y, pos.z);\n\t\t\t\t\tnormals.push(norm.x, norm.y, norm.z);\n\t\t\t\t\tlet u = j / capSegments;\n\t\t\t\t\tlet v = i / heightSegments;\n\t\t\t\t\tuvs.push(u, 1 - v);\n\t\t\t\t\tconst _v = v;\n\t\t\t\t\tv = u;\n\t\t\t\t\tu = _v;\n\t\t\t\t\tu = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\t\tv = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\t\tu /= 3;\n\t\t\t\t\tuvs1.push(u, 1 - v);\n\t\t\t\t\tif (i < heightSegments && j < capSegments) {\n\t\t\t\t\t\tconst first = i * (capSegments + 1) + j;\n\t\t\t\t\t\tconst second = i * (capSegments + 1) + (j + 1);\n\t\t\t\t\t\tconst third = (i + 1) * (capSegments + 1) + j;\n\t\t\t\t\t\tconst fourth = (i + 1) * (capSegments + 1) + (j + 1);\n\t\t\t\t\t\tindices.push(first, second, third);\n\t\t\t\t\t\tindices.push(second, fourth, third);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (roundedCaps) {\n\t\t\tconst latitudeBands = Math.floor(capSegments / 2);\n\t\t\tconst longitudeBands = capSegments;\n\t\t\tconst capOffset = height / 2;\n\t\t\tfor (let lat = 0; lat <= latitudeBands; lat++) {\n\t\t\t\tconst theta = lat * Math.PI * 0.5 / latitudeBands;\n\t\t\t\tconst sinTheta = Math.sin(theta);\n\t\t\t\tconst cosTheta = Math.cos(theta);\n\t\t\t\tfor (let lon = 0; lon <= longitudeBands; lon++) {\n\t\t\t\t\tconst phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;\n\t\t\t\t\tconst sinPhi = Math.sin(phi);\n\t\t\t\t\tconst cosPhi = Math.cos(phi);\n\t\t\t\t\tconst x = cosPhi * sinTheta;\n\t\t\t\t\tconst y = cosTheta;\n\t\t\t\t\tconst z = sinPhi * sinTheta;\n\t\t\t\t\tlet u = 1 - lon / longitudeBands;\n\t\t\t\t\tlet v = 1 - lat / latitudeBands;\n\t\t\t\t\tpositions.push(x * peakRadius, y * peakRadius + capOffset, z * peakRadius);\n\t\t\t\t\tnormals.push(x, y, z);\n\t\t\t\t\tuvs.push(u, 1 - v);\n\t\t\t\t\tu = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\t\tv = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\t\tu /= 3;\n\t\t\t\t\tv /= 3;\n\t\t\t\t\tu += 1.0 / 3;\n\t\t\t\t\tuvs1.push(u, 1 - v);\n\t\t\t\t}\n\t\t\t}\n\t\t\toffset = (heightSegments + 1) * (capSegments + 1);\n\t\t\tfor (let lat = 0; lat < latitudeBands; ++lat) {\n\t\t\t\tfor (let lon = 0; lon < longitudeBands; ++lon) {\n\t\t\t\t\tconst first = lat * (longitudeBands + 1) + lon;\n\t\t\t\t\tconst second = first + longitudeBands + 1;\n\t\t\t\t\tindices.push(offset + first + 1, offset + second, offset + first);\n\t\t\t\t\tindices.push(offset + first + 1, offset + second + 1, offset + second);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let lat = 0; lat <= latitudeBands; lat++) {\n\t\t\t\tconst theta = Math.PI * 0.5 + lat * Math.PI * 0.5 / latitudeBands;\n\t\t\t\tconst sinTheta = Math.sin(theta);\n\t\t\t\tconst cosTheta = Math.cos(theta);\n\t\t\t\tfor (let lon = 0; lon <= longitudeBands; lon++) {\n\t\t\t\t\tconst phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;\n\t\t\t\t\tconst sinPhi = Math.sin(phi);\n\t\t\t\t\tconst cosPhi = Math.cos(phi);\n\t\t\t\t\tconst x = cosPhi * sinTheta;\n\t\t\t\t\tconst y = cosTheta;\n\t\t\t\t\tconst z = sinPhi * sinTheta;\n\t\t\t\t\tlet u = 1 - lon / longitudeBands;\n\t\t\t\t\tlet v = 1 - lat / latitudeBands;\n\t\t\t\t\tpositions.push(x * peakRadius, y * peakRadius - capOffset, z * peakRadius);\n\t\t\t\t\tnormals.push(x, y, z);\n\t\t\t\t\tuvs.push(u, 1 - v);\n\t\t\t\t\tu = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\t\tv = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\t\tu /= 3;\n\t\t\t\t\tv /= 3;\n\t\t\t\t\tu += 2.0 / 3;\n\t\t\t\t\tuvs1.push(u, 1 - v);\n\t\t\t\t}\n\t\t\t}\n\t\t\toffset = (heightSegments + 1) * (capSegments + 1) + (longitudeBands + 1) * (latitudeBands + 1);\n\t\t\tfor (let lat = 0; lat < latitudeBands; ++lat) {\n\t\t\t\tfor (let lon = 0; lon < longitudeBands; ++lon) {\n\t\t\t\t\tconst first = lat * (longitudeBands + 1) + lon;\n\t\t\t\t\tconst second = first + longitudeBands + 1;\n\t\t\t\t\tindices.push(offset + first + 1, offset + second, offset + first);\n\t\t\t\t\tindices.push(offset + first + 1, offset + second + 1, offset + second);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\toffset = (heightSegments + 1) * (capSegments + 1);\n\t\t\tif (baseRadius > 0) {\n\t\t\t\tfor (let i = 0; i < capSegments; i++) {\n\t\t\t\t\tconst theta = i / capSegments * 2 * Math.PI;\n\t\t\t\t\tconst x = Math.sin(theta);\n\t\t\t\t\tconst y = -height / 2;\n\t\t\t\t\tconst z = Math.cos(theta);\n\t\t\t\t\tlet u = 1 - (x + 1) / 2;\n\t\t\t\t\tlet v = (z + 1) / 2;\n\t\t\t\t\tpositions.push(x * baseRadius, y, z * baseRadius);\n\t\t\t\t\tnormals.push(0, -1, 0);\n\t\t\t\t\tuvs.push(u, 1 - v);\n\t\t\t\t\tu = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\t\tv = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\t\tu /= 3;\n\t\t\t\t\tv /= 3;\n\t\t\t\t\tu += 1 / 3;\n\t\t\t\t\tuvs1.push(u, 1 - v);\n\t\t\t\t\tif (i > 1) {\n\t\t\t\t\t\tindices.push(offset, offset + i, offset + i - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\toffset += capSegments;\n\t\t\tif (peakRadius > 0) {\n\t\t\t\tfor (let i = 0; i < capSegments; i++) {\n\t\t\t\t\tconst theta = i / capSegments * 2 * Math.PI;\n\t\t\t\t\tconst x = Math.sin(theta);\n\t\t\t\t\tconst y = height / 2;\n\t\t\t\t\tconst z = Math.cos(theta);\n\t\t\t\t\tlet u = 1 - (x + 1) / 2;\n\t\t\t\t\tlet v = (z + 1) / 2;\n\t\t\t\t\tpositions.push(x * peakRadius, y, z * peakRadius);\n\t\t\t\t\tnormals.push(0, 1, 0);\n\t\t\t\t\tuvs.push(u, 1 - v);\n\t\t\t\t\tu = u * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\t\tv = v * primitiveUv1PaddingScale + primitiveUv1Padding;\n\t\t\t\t\tu /= 3;\n\t\t\t\t\tv /= 3;\n\t\t\t\t\tu += 2 / 3;\n\t\t\t\t\tuvs1.push(u, 1 - v);\n\t\t\t\t\tif (i > 1) {\n\t\t\t\t\t\tindices.push(offset, offset + i - 1, offset + i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.positions = positions;\n\t\tthis.normals = normals;\n\t\tthis.uvs = uvs;\n\t\tthis.uvs1 = uvs1;\n\t\tthis.indices = indices;\n\t}\n}\n\nexport { ConeBaseGeometry };\n","import { ConeBaseGeometry } from './cone-base-geometry.js';\nimport { calculateTangents } from './geometry-utils.js';\n\nclass ConeGeometry extends ConeBaseGeometry {\n\tconstructor(opts = {}) {\n\t\tvar _opts$baseRadius, _opts$peakRadius, _opts$height, _opts$heightSegments, _opts$capSegments;\n\t\tconst baseRadius = (_opts$baseRadius = opts.baseRadius) != null ? _opts$baseRadius : 0.5;\n\t\tconst peakRadius = (_opts$peakRadius = opts.peakRadius) != null ? _opts$peakRadius : 0;\n\t\tconst height = (_opts$height = opts.height) != null ? _opts$height : 1;\n\t\tconst heightSegments = (_opts$heightSegments = opts.heightSegments) != null ? _opts$heightSegments : 5;\n\t\tconst capSegments = (_opts$capSegments = opts.capSegments) != null ? _opts$capSegments : 18;\n\t\tsuper(baseRadius, peakRadius, height, heightSegments, capSegments, false);\n\t\tif (opts.calculateTangents) {\n\t\t\tthis.tangents = calculateTangents(this.positions, this.normals, this.uvs, this.indices);\n\t\t}\n\t}\n}\n\nexport { ConeGeometry };\n","import { ConeBaseGeometry } from './cone-base-geometry.js';\nimport { calculateTangents } from './geometry-utils.js';\n\nclass CylinderGeometry extends ConeBaseGeometry {\n\tconstructor(opts = {}) {\n\t\tvar _opts$radius, _opts$height, _opts$heightSegments, _opts$capSegments;\n\t\tconst radius = (_opts$radius = opts.radius) != null ? _opts$radius : 0.5;\n\t\tconst height = (_opts$height = opts.height) != null ? _opts$height : 1;\n\t\tconst heightSegments = (_opts$heightSegments = opts.heightSegments) != null ? _opts$heightSegments : 5;\n\t\tconst capSegments = (_opts$capSegments = opts.capSegments) != null ? _opts$capSegments : 20;\n\t\tsuper(radius, radius, height, heightSegments, capSegments, false);\n\t\tif (opts.calculateTangents) {\n\t\t\tthis.tangents = calculateTangents(this.positions, this.normals, this.uvs, this.indices);\n\t\t}\n\t}\n}\n\nexport { CylinderGeometry };\n","import { SphereGeometry } from './sphere-geometry.js';\n\nclass DomeGeometry extends SphereGeometry {\n\tconstructor(opts = {}) {\n\t\tvar _opts$latitudeBands, _opts$longitudeBands;\n\t\tconst radius = 0.5;\n\t\tconst latitudeBands = (_opts$latitudeBands = opts.latitudeBands) != null ? _opts$latitudeBands : 16;\n\t\tconst longitudeBands = (_opts$longitudeBands = opts.longitudeBands) != null ? _opts$longitudeBands : 16;\n\t\tsuper({\n\t\t\tradius,\n\t\t\tlatitudeBands,\n\t\t\tlongitudeBands\n\t\t});\n\t\tconst bottomLimit = 0.1;\n\t\tconst curvatureRadius = 0.95;\n\t\tconst curvatureRadiusSq = curvatureRadius * curvatureRadius;\n\t\tconst positions = this.positions;\n\t\tfor (let i = 0; i < positions.length; i += 3) {\n\t\t\tconst x = positions[i] / radius;\n\t\t\tlet y = positions[i + 1] / radius;\n\t\t\tconst z = positions[i + 2] / radius;\n\t\t\tif (y < 0) {\n\t\t\t\ty *= 0.3;\n\t\t\t\tif (x * x + z * z < curvatureRadiusSq) {\n\t\t\t\t\ty = -bottomLimit;\n\t\t\t\t}\n\t\t\t}\n\t\t\ty += bottomLimit;\n\t\t\ty *= radius;\n\t\t\tpositions[i + 1] = y;\n\t\t}\n\t}\n}\n\nexport { DomeGeometry };\n","import { Vec2 } from '../../core/math/vec2.js';\nimport { Vec3 } from '../../core/math/vec3.js';\n\nconst calculateNormals = (positions, indices) => {\n\tconst triangleCount = indices.length / 3;\n\tconst vertexCount = positions.length / 3;\n\tconst p1 = new Vec3();\n\tconst p2 = new Vec3();\n\tconst p3 = new Vec3();\n\tconst p1p2 = new Vec3();\n\tconst p1p3 = new Vec3();\n\tconst faceNormal = new Vec3();\n\tconst normals = [];\n\tfor (let i = 0; i < positions.length; i++) {\n\t\tnormals[i] = 0;\n\t}\n\tfor (let i = 0; i < triangleCount; i++) {\n\t\tconst i1 = indices[i * 3];\n\t\tconst i2 = indices[i * 3 + 1];\n\t\tconst i3 = indices[i * 3 + 2];\n\t\tp1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);\n\t\tp2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);\n\t\tp3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);\n\t\tp1p2.sub2(p2, p1);\n\t\tp1p3.sub2(p3, p1);\n\t\tfaceNormal.cross(p1p2, p1p3).normalize();\n\t\tnormals[i1 * 3] += faceNormal.x;\n\t\tnormals[i1 * 3 + 1] += faceNormal.y;\n\t\tnormals[i1 * 3 + 2] += faceNormal.z;\n\t\tnormals[i2 * 3] += faceNormal.x;\n\t\tnormals[i2 * 3 + 1] += faceNormal.y;\n\t\tnormals[i2 * 3 + 2] += faceNormal.z;\n\t\tnormals[i3 * 3] += faceNormal.x;\n\t\tnormals[i3 * 3 + 1] += faceNormal.y;\n\t\tnormals[i3 * 3 + 2] += faceNormal.z;\n\t}\n\tfor (let i = 0; i < vertexCount; i++) {\n\t\tconst nx = normals[i * 3];\n\t\tconst ny = normals[i * 3 + 1];\n\t\tconst nz = normals[i * 3 + 2];\n\t\tconst invLen = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz);\n\t\tnormals[i * 3] *= invLen;\n\t\tnormals[i * 3 + 1] *= invLen;\n\t\tnormals[i * 3 + 2] *= invLen;\n\t}\n\treturn normals;\n};\nconst calculateTangents = (positions, normals, uvs, indices) => {\n\tconst triangleCount = indices.length / 3;\n\tconst vertexCount = positions.length / 3;\n\tconst v1 = new Vec3();\n\tconst v2 = new Vec3();\n\tconst v3 = new Vec3();\n\tconst w1 = new Vec2();\n\tconst w2 = new Vec2();\n\tconst w3 = new Vec2();\n\tconst sdir = new Vec3();\n\tconst tdir = new Vec3();\n\tconst tan1 = new Float32Array(vertexCount * 3);\n\tconst tan2 = new Float32Array(vertexCount * 3);\n\tconst tangents = [];\n\tfor (let i = 0; i < triangleCount; i++) {\n\t\tconst i1 = indices[i * 3];\n\t\tconst i2 = indices[i * 3 + 1];\n\t\tconst i3 = indices[i * 3 + 2];\n\t\tv1.set(positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]);\n\t\tv2.set(positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]);\n\t\tv3.set(positions[i3 * 3], positions[i3 * 3 + 1], positions[i3 * 3 + 2]);\n\t\tw1.set(uvs[i1 * 2], uvs[i1 * 2 + 1]);\n\t\tw2.set(uvs[i2 * 2], uvs[i2 * 2 + 1]);\n\t\tw3.set(uvs[i3 * 2], uvs[i3 * 2 + 1]);\n\t\tconst x1 = v2.x - v1.x;\n\t\tconst x2 = v3.x - v1.x;\n\t\tconst y1 = v2.y - v1.y;\n\t\tconst y2 = v3.y - v1.y;\n\t\tconst z1 = v2.z - v1.z;\n\t\tconst z2 = v3.z - v1.z;\n\t\tconst s1 = w2.x - w1.x;\n\t\tconst s2 = w3.x - w1.x;\n\t\tconst _t = w2.y - w1.y;\n\t\tconst _t2 = w3.y - w1.y;\n\t\tconst area = s1 * _t2 - s2 * _t;\n\t\tif (area === 0) {\n\t\t\tsdir.set(0, 1, 0);\n\t\t\ttdir.set(1, 0, 0);\n\t\t} else {\n\t\t\tconst r = 1 / area;\n\t\t\tsdir.set((_t2 * x1 - _t * x2) * r, (_t2 * y1 - _t * y2) * r, (_t2 * z1 - _t * z2) * r);\n\t\t\ttdir.set((s1 * x2 - s2 * x1) * r, (s1 * y2 - s2 * y1) * r, (s1 * z2 - s2 * z1) * r);\n\t\t}\n\t\ttan1[i1 * 3 + 0] += sdir.x;\n\t\ttan1[i1 * 3 + 1] += sdir.y;\n\t\ttan1[i1 * 3 + 2] += sdir.z;\n\t\ttan1[i2 * 3 + 0] += sdir.x;\n\t\ttan1[i2 * 3 + 1] += sdir.y;\n\t\ttan1[i2 * 3 + 2] += sdir.z;\n\t\ttan1[i3 * 3 + 0] += sdir.x;\n\t\ttan1[i3 * 3 + 1] += sdir.y;\n\t\ttan1[i3 * 3 + 2] += sdir.z;\n\t\ttan2[i1 * 3 + 0] += tdir.x;\n\t\ttan2[i1 * 3 + 1] += tdir.y;\n\t\ttan2[i1 * 3 + 2] += tdir.z;\n\t\ttan2[i2 * 3 + 0] += tdir.x;\n\t\ttan2[i2 * 3 + 1] += tdir.y;\n\t\ttan2[i2 * 3 + 2] += tdir.z;\n\t\ttan2[i3 * 3 + 0] += tdir.x;\n\t\ttan2[i3 * 3 + 1] += tdir.y;\n\t\ttan2[i3 * 3 + 2] += tdir.z;\n\t}\n\tconst t1 = new Vec3();\n\tconst t2 = new Vec3();\n\tconst n = new Vec3();\n\tconst temp = new Vec3();\n\tfor (let i = 0; i < vertexCount; i++) {\n\t\tn.set(normals[i * 3], normals[i * 3 + 1], normals[i * 3 + 2]);\n\t\tt1.set(tan1[i * 3], tan1[i * 3 + 1], tan1[i * 3 + 2]);\n\t\tt2.set(tan2[i * 3], tan2[i * 3 + 1], tan2[i * 3 + 2]);\n\t\tconst ndott = n.dot(t1);\n\t\ttemp.copy(n).mulScalar(ndott);\n\t\ttemp.sub2(t1, temp).normalize();\n\t\ttangents[i * 4] = temp.x;\n\t\ttangents[i * 4 + 1] = temp.y;\n\t\ttangents[i * 4 + 2] = temp.z;\n\t\ttemp.cross(n, t1);\n\t\ttangents[i * 4 + 3] = temp.dot(t2) < 0.0 ? -1.0 : 1.0;\n\t}\n\treturn tangents;\n};\n\nexport { calculateNormals, calculateTangents };\n","import { calculateNormals, calculateTangents } from './geometry-utils.js';\n\nclass Geometry {\n\tconstructor() {\n\t\tthis.positions = void 0;\n\t\tthis.normals = void 0;\n\t\tthis.colors = void 0;\n\t\tthis.uvs = void 0;\n\t\tthis.uvs1 = void 0;\n\t\tthis.blendIndices = void 0;\n\t\tthis.blendWeights = void 0;\n\t\tthis.tangents = void 0;\n\t\tthis.indices = void 0;\n\t}\n\tcalculateNormals() {\n\t\tthis.normals = calculateNormals(this.positions, this.indices);\n\t}\n\tcalculateTangents() {\n\t\tthis.tangents = calculateTangents(this.positions, this.normals, this.uvs, this.indices);\n\t}\n}\n\nexport { Geometry };\n","import { Vec2 } from '../../core/math/vec2.js';\nimport { calculateTangents } from './geometry-utils.js';\nimport { Geometry } from './geometry.js';\n\nclass PlaneGeometry extends Geometry {\n\tconstructor(opts = {}) {\n\t\tvar _opts$halfExtents, _opts$widthSegments, _opts$lengthSegments;\n\t\tsuper();\n\t\tconst he = (_opts$halfExtents = opts.halfExtents) != null ? _opts$halfExtents : new Vec2(0.5, 0.5);\n\t\tconst ws = (_opts$widthSegments = opts.widthSegments) != null ? _opts$widthSegments : 5;\n\t\tconst ls = (_opts$lengthSegments = opts.lengthSegments) != null ? _opts$lengthSegments : 5;\n\t\tconst positions = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\t\tconst indices = [];\n\t\tlet vcounter = 0;\n\t\tfor (let i = 0; i <= ws; i++) {\n\t\t\tfor (let j = 0; j <= ls; j++) {\n\t\t\t\tconst x = -he.x + 2 * he.x * i / ws;\n\t\t\t\tconst y = 0.0;\n\t\t\t\tconst z = -(-he.y + 2 * he.y * j / ls);\n\t\t\t\tconst u = i / ws;\n\t\t\t\tconst v = j / ls;\n\t\t\t\tpositions.push(x, y, z);\n\t\t\t\tnormals.push(0, 1, 0);\n\t\t\t\tuvs.push(u, 1 - v);\n\t\t\t\tif (i < ws && j < ls) {\n\t\t\t\t\tindices.push(vcounter + ls + 1, vcounter + 1, vcounter);\n\t\t\t\t\tindices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);\n\t\t\t\t}\n\t\t\t\tvcounter++;\n\t\t\t}\n\t\t}\n\t\tthis.positions = positions;\n\t\tthis.normals = normals;\n\t\tthis.uvs = uvs;\n\t\tthis.uvs1 = uvs;\n\t\tthis.indices = indices;\n\t\tif (opts.calculateTangents) {\n\t\t\tthis.tangents = calculateTangents(positions, normals, uvs, indices);\n\t\t}\n\t}\n}\n\nexport { PlaneGeometry };\n","import { calculateTangents } from './geometry-utils.js';\nimport { Geometry } from './geometry.js';\n\nclass SphereGeometry extends Geometry {\n\tconstructor(opts = {}) {\n\t\tvar _opts$radius, _opts$latitudeBands, _opts$longitudeBands;\n\t\tsuper();\n\t\tconst radius = (_opts$radius = opts.radius) != null ? _opts$radius : 0.5;\n\t\tconst latitudeBands = (_opts$latitudeBands = opts.latitudeBands) != null ? _opts$latitudeBands : 16;\n\t\tconst longitudeBands = (_opts$longitudeBands = opts.longitudeBands) != null ? _opts$longitudeBands : 16;\n\t\tconst positions = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\t\tconst indices = [];\n\t\tfor (let lat = 0; lat <= latitudeBands; lat++) {\n\t\t\tconst theta = lat * Math.PI / latitudeBands;\n\t\t\tconst sinTheta = Math.sin(theta);\n\t\t\tconst cosTheta = Math.cos(theta);\n\t\t\tfor (let lon = 0; lon <= longitudeBands; lon++) {\n\t\t\t\tconst phi = lon * 2 * Math.PI / longitudeBands - Math.PI / 2;\n\t\t\t\tconst sinPhi = Math.sin(phi);\n\t\t\t\tconst cosPhi = Math.cos(phi);\n\t\t\t\tconst x = cosPhi * sinTheta;\n\t\t\t\tconst y = cosTheta;\n\t\t\t\tconst z = sinPhi * sinTheta;\n\t\t\t\tconst u = 1 - lon / longitudeBands;\n\t\t\t\tconst v = 1 - lat / latitudeBands;\n\t\t\t\tpositions.push(x * radius, y * radius, z * radius);\n\t\t\t\tnormals.push(x, y, z);\n\t\t\t\tuvs.push(u, 1 - v);\n\t\t\t}\n\t\t}\n\t\tfor (let lat = 0; lat < latitudeBands; ++lat) {\n\t\t\tfor (let lon = 0; lon < longitudeBands; ++lon) {\n\t\t\t\tconst first = lat * (longitudeBands + 1) + lon;\n\t\t\t\tconst second = first + longitudeBands + 1;\n\t\t\t\tindices.push(first + 1, second, first);\n\t\t\t\tindices.push(first + 1, second + 1, second);\n\t\t\t}\n\t\t}\n\t\tthis.positions = positions;\n\t\tthis.normals = normals;\n\t\tthis.uvs = uvs;\n\t\tthis.uvs1 = uvs;\n\t\tthis.indices = indices;\n\t\tif (opts.calculateTangents) {\n\t\t\tthis.tangents = calculateTangents(positions, normals, uvs, indices);\n\t\t}\n\t}\n}\n\nexport { SphereGeometry };\n","import { math } from '../../core/math/math.js';\nimport { calculateTangents } from './geometry-utils.js';\nimport { Geometry } from './geometry.js';\n\nclass TorusGeometry extends Geometry {\n\tconstructor(opts = {}) {\n\t\tvar _opts$tubeRadius, _opts$ringRadius, _opts$sectorAngle, _opts$segments, _opts$sides;\n\t\tsuper();\n\t\tconst rc = (_opts$tubeRadius = opts.tubeRadius) != null ? _opts$tubeRadius : 0.2;\n\t\tconst rt = (_opts$ringRadius = opts.ringRadius) != null ? _opts$ringRadius : 0.3;\n\t\tconst sectorAngle = ((_opts$sectorAngle = opts.sectorAngle) != null ? _opts$sectorAngle : 360) * math.DEG_TO_RAD;\n\t\tconst segments = (_opts$segments = opts.segments) != null ? _opts$segments : 30;\n\t\tconst sides = (_opts$sides = opts.sides) != null ? _opts$sides : 20;\n\t\tconst positions = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\t\tconst indices = [];\n\t\tfor (let i = 0; i <= sides; i++) {\n\t\t\tfor (let j = 0; j <= segments; j++) {\n\t\t\t\tconst x = Math.cos(sectorAngle * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));\n\t\t\t\tconst y = Math.sin(2 * Math.PI * i / sides) * rc;\n\t\t\t\tconst z = Math.sin(sectorAngle * j / segments) * (rt + rc * Math.cos(2 * Math.PI * i / sides));\n\t\t\t\tconst nx = Math.cos(sectorAngle * j / segments) * Math.cos(2 * Math.PI * i / sides);\n\t\t\t\tconst ny = Math.sin(2 * Math.PI * i / sides);\n\t\t\t\tconst nz = Math.sin(sectorAngle * j / segments) * Math.cos(2 * Math.PI * i / sides);\n\t\t\t\tconst u = i / sides;\n\t\t\t\tconst v = 1 - j / segments;\n\t\t\t\tpositions.push(x, y, z);\n\t\t\t\tnormals.push(nx, ny, nz);\n\t\t\t\tuvs.push(u, 1.0 - v);\n\t\t\t\tif (i < sides && j < segments) {\n\t\t\t\t\tconst first = i * (segments + 1) + j;\n\t\t\t\t\tconst second = (i + 1) * (segments + 1) + j;\n\t\t\t\t\tconst third = i * (segments + 1) + (j + 1);\n\t\t\t\t\tconst fourth = (i + 1) * (segments + 1) + (j + 1);\n\t\t\t\t\tindices.push(first, second, third);\n\t\t\t\t\tindices.push(second, fourth, third);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.positions = positions;\n\t\tthis.normals = normals;\n\t\tthis.uvs = uvs;\n\t\tthis.uvs1 = uvs;\n\t\tthis.indices = indices;\n\t\tif (opts.calculateTangents) {\n\t\t\tthis.tangents = calculateTangents(positions, normals, uvs, indices);\n\t\t}\n\t}\n}\n\nexport { TorusGeometry };\n","import { EventHandler } from '../core/event-handler.js';\nimport { Tags } from '../core/tags.js';\nimport { Mat3 } from '../core/math/mat3.js';\nimport { Mat4 } from '../core/math/mat4.js';\nimport { Quat } from '../core/math/quat.js';\nimport { Vec3 } from '../core/math/vec3.js';\n\nconst scaleCompensatePosTransform = new Mat4();\nconst scaleCompensatePos = new Vec3();\nconst scaleCompensateRot = new Quat();\nconst scaleCompensateRot2 = new Quat();\nconst scaleCompensateScale = new Vec3();\nconst scaleCompensateScaleForParent = new Vec3();\nconst tmpMat4 = new Mat4();\nconst tmpQuat = new Quat();\nconst position = new Vec3();\nconst invParentWtm = new Mat4();\nconst rotation = new Quat();\nconst invParentRot = new Quat();\nconst matrix = new Mat4();\nconst target = new Vec3();\nconst up = new Vec3();\nfunction createTest(attr, value) {\n\tif (attr instanceof Function) {\n\t\treturn attr;\n\t}\n\treturn node => {\n\t\tlet x = node[attr];\n\t\tif (x instanceof Function) {\n\t\t\tx = x();\n\t\t}\n\t\treturn x === value;\n\t};\n}\nfunction findNode(node, test) {\n\tif (test(node)) {\n\t\treturn node;\n\t}\n\tconst children = node._children;\n\tconst len = children.length;\n\tfor (let i = 0; i < len; ++i) {\n\t\tconst result = findNode(children[i], test);\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\t}\n\treturn null;\n}\nclass GraphNode extends EventHandler {\n\tconstructor(name = 'Untitled') {\n\t\tsuper();\n\t\tthis.name = void 0;\n\t\tthis.tags = new Tags(this);\n\t\tthis._labels = {};\n\t\tthis.localPosition = new Vec3();\n\t\tthis.localRotation = new Quat();\n\t\tthis.localScale = new Vec3(1, 1, 1);\n\t\tthis.localEulerAngles = new Vec3();\n\t\tthis.position = new Vec3();\n\t\tthis.rotation = new Quat();\n\t\tthis.eulerAngles = new Vec3();\n\t\tthis._scale = null;\n\t\tthis.localTransform = new Mat4();\n\t\tthis._dirtyLocal = false;\n\t\tthis._aabbVer = 0;\n\t\tthis._frozen = false;\n\t\tthis.worldTransform = new Mat4();\n\t\tthis._dirtyWorld = false;\n\t\tthis._worldScaleSign = 0;\n\t\tthis._normalMatrix = new Mat3();\n\t\tthis._dirtyNormal = true;\n\t\tthis._right = null;\n\t\tthis._up = null;\n\t\tthis._forward = null;\n\t\tthis._parent = null;\n\t\tthis._children = [];\n\t\tthis._graphDepth = 0;\n\t\tthis._enabled = true;\n\t\tthis._enabledInHierarchy = false;\n\t\tthis.scaleCompensation = false;\n\t\tthis.name = name;\n\t}\n\tget right() {\n\t\tif (!this._right) {\n\t\t\tthis._right = new Vec3();\n\t\t}\n\t\treturn this.getWorldTransform().getX(this._right).normalize();\n\t}\n\tget up() {\n\t\tif (!this._up) {\n\t\t\tthis._up = new Vec3();\n\t\t}\n\t\treturn this.getWorldTransform().getY(this._up).normalize();\n\t}\n\tget forward() {\n\t\tif (!this._forward) {\n\t\t\tthis._forward = new Vec3();\n\t\t}\n\t\treturn this.getWorldTransform().getZ(this._forward).normalize().mulScalar(-1);\n\t}\n\tget normalMatrix() {\n\t\tconst normalMat = this._normalMatrix;\n\t\tif (this._dirtyNormal) {\n\t\t\tnormalMat.invertMat4(this.getWorldTransform()).transpose();\n\t\t\tthis._dirtyNormal = false;\n\t\t}\n\t\treturn normalMat;\n\t}\n\tset enabled(enabled) {\n\t\tif (this._enabled !== enabled) {\n\t\t\tvar _this$_parent;\n\t\t\tthis._enabled = enabled;\n\t\t\tif (enabled && (_this$_parent = this._parent) != null && _this$_parent.enabled || !enabled) {\n\t\t\t\tthis._notifyHierarchyStateChanged(this, enabled);\n\t\t\t}\n\t\t}\n\t}\n\tget enabled() {\n\t\treturn this._enabled && this._enabledInHierarchy;\n\t}\n\tget parent() {\n\t\treturn this._parent;\n\t}\n\tget path() {\n\t\tlet node = this._parent;\n\t\tif (!node) {\n\t\t\treturn '';\n\t\t}\n\t\tlet result = this.name;\n\t\twhile (node && node._parent) {\n\t\t\tresult = `${node.name}/${result}`;\n\t\t\tnode = node._parent;\n\t\t}\n\t\treturn result;\n\t}\n\tget root() {\n\t\tlet result = this;\n\t\twhile (result._parent) {\n\t\t\tresult = result._parent;\n\t\t}\n\t\treturn result;\n\t}\n\tget children() {\n\t\treturn this._children;\n\t}\n\tget graphDepth() {\n\t\treturn this._graphDepth;\n\t}\n\t_notifyHierarchyStateChanged(node, enabled) {\n\t\tnode._onHierarchyStateChanged(enabled);\n\t\tconst c = node._children;\n\t\tfor (let i = 0, len = c.length; i < len; i++) {\n\t\t\tif (c[i]._enabled) {\n\t\t\t\tthis._notifyHierarchyStateChanged(c[i], enabled);\n\t\t\t}\n\t\t}\n\t}\n\t_onHierarchyStateChanged(enabled) {\n\t\tthis._enabledInHierarchy = enabled;\n\t\tif (enabled && !this._frozen) {\n\t\t\tthis._unfreezeParentToRoot();\n\t\t}\n\t}\n\t_cloneInternal(clone) {\n\t\tclone.name = this.name;\n\t\tconst tags = this.tags._list;\n\t\tclone.tags.clear();\n\t\tfor (let i = 0; i < tags.length; i++) {\n\t\t\tclone.tags.add(tags[i]);\n\t\t}\n\t\tclone._labels = Object.assign({}, this._labels);\n\t\tclone.localPosition.copy(this.localPosition);\n\t\tclone.localRotation.copy(this.localRotation);\n\t\tclone.localScale.copy(this.localScale);\n\t\tclone.localEulerAngles.copy(this.localEulerAngles);\n\t\tclone.position.copy(this.position);\n\t\tclone.rotation.copy(this.rotation);\n\t\tclone.eulerAngles.copy(this.eulerAngles);\n\t\tclone.localTransform.copy(this.localTransform);\n\t\tclone._dirtyLocal = this._dirtyLocal;\n\t\tclone.worldTransform.copy(this.worldTransform);\n\t\tclone._dirtyWorld = this._dirtyWorld;\n\t\tclone._dirtyNormal = this._dirtyNormal;\n\t\tclone._aabbVer = this._aabbVer + 1;\n\t\tclone._enabled = this._enabled;\n\t\tclone.scaleCompensation = this.scaleCompensation;\n\t\tclone._enabledInHierarchy = false;\n\t}\n\tclone() {\n\t\tconst clone = new this.constructor();\n\t\tthis._cloneInternal(clone);\n\t\treturn clone;\n\t}\n\tcopy(source) {\n\t\tsource._cloneInternal(this);\n\t\treturn this;\n\t}\n\tdestroy() {\n\t\tthis.remove();\n\t\tconst children = this._children;\n\t\twhile (children.length) {\n\t\t\tconst child = children.pop();\n\t\t\tchild._parent = null;\n\t\t\tchild.destroy();\n\t\t}\n\t\tthis.fire('destroy', this);\n\t\tthis.off();\n\t}\n\tfind(attr, value) {\n\t\tconst results = [];\n\t\tconst test = createTest(attr, value);\n\t\tthis.forEach(node => {\n\t\t\tif (test(node)) {\n\t\t\t\tresults.push(node);\n\t\t\t}\n\t\t});\n\t\treturn results;\n\t}\n\tfindOne(attr, value) {\n\t\tconst test = createTest(attr, value);\n\t\treturn findNode(this, test);\n\t}\n\tfindByTag() {\n\t\tconst query = arguments;\n\t\tconst results = [];\n\t\tconst queryNode = (node, checkNode) => {\n\t\t\tif (checkNode && node.tags.has(...query)) {\n\t\t\t\tresults.push(node);\n\t\t\t}\n\t\t\tfor (let i = 0; i < node._children.length; i++) {\n\t\t\t\tqueryNode(node._children[i], true);\n\t\t\t}\n\t\t};\n\t\tqueryNode(this, false);\n\t\treturn results;\n\t}\n\tfindByName(name) {\n\t\treturn this.findOne('name', name);\n\t}\n\tfindByPath(path) {\n\t\tconst parts = Array.isArray(path) ? path : path.split('/');\n\t\tlet result = this;\n\t\tfor (let i = 0, imax = parts.length; i < imax; ++i) {\n\t\t\tresult = result.children.find(c => c.name === parts[i]);\n\t\t\tif (!result) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tforEach(callback, thisArg) {\n\t\tcallback.call(thisArg, this);\n\t\tconst children = this._children;\n\t\tconst len = children.length;\n\t\tfor (let i = 0; i < len; ++i) {\n\t\t\tchildren[i].forEach(callback, thisArg);\n\t\t}\n\t}\n\tisDescendantOf(node) {\n\t\tlet parent = this._parent;\n\t\twhile (parent) {\n\t\t\tif (parent === node) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tparent = parent._parent;\n\t\t}\n\t\treturn false;\n\t}\n\tisAncestorOf(node) {\n\t\treturn node.isDescendantOf(this);\n\t}\n\tgetEulerAngles() {\n\t\tthis.getWorldTransform().getEulerAngles(this.eulerAngles);\n\t\treturn this.eulerAngles;\n\t}\n\tgetLocalEulerAngles() {\n\t\tthis.localRotation.getEulerAngles(this.localEulerAngles);\n\t\treturn this.localEulerAngles;\n\t}\n\tgetLocalPosition() {\n\t\treturn this.localPosition;\n\t}\n\tgetLocalRotation() {\n\t\treturn this.localRotation;\n\t}\n\tgetLocalScale() {\n\t\treturn this.localScale;\n\t}\n\tgetLocalTransform() {\n\t\tif (this._dirtyLocal) {\n\t\t\tthis.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);\n\t\t\tthis._dirtyLocal = false;\n\t\t}\n\t\treturn this.localTransform;\n\t}\n\tgetPosition() {\n\t\tthis.getWorldTransform().getTranslation(this.position);\n\t\treturn this.position;\n\t}\n\tgetRotation() {\n\t\tthis.rotation.setFromMat4(this.getWorldTransform());\n\t\treturn this.rotation;\n\t}\n\tgetScale() {\n\t\tif (!this._scale) {\n\t\t\tthis._scale = new Vec3();\n\t\t}\n\t\treturn this.getWorldTransform().getScale(this._scale);\n\t}\n\tgetWorldTransform() {\n\t\tif (!this._dirtyLocal && !this._dirtyWorld) {\n\t\t\treturn this.worldTransform;\n\t\t}\n\t\tif (this._parent) {\n\t\t\tthis._parent.getWorldTransform();\n\t\t}\n\t\tthis._sync();\n\t\treturn this.worldTransform;\n\t}\n\tget worldScaleSign() {\n\t\tif (this._worldScaleSign === 0) {\n\t\t\tthis._worldScaleSign = this.getWorldTransform().scaleSign;\n\t\t}\n\t\treturn this._worldScaleSign;\n\t}\n\tremove() {\n\t\tvar _this$_parent2;\n\t\t(_this$_parent2 = this._parent) == null || _this$_parent2.removeChild(this);\n\t}\n\treparent(parent, index) {\n\t\tthis.remove();\n\t\tif (parent) {\n\t\t\tif (index >= 0) {\n\t\t\t\tparent.insertChild(this, index);\n\t\t\t} else {\n\t\t\t\tparent.addChild(this);\n\t\t\t}\n\t\t}\n\t}\n\tsetLocalEulerAngles(x, y, z) {\n\t\tthis.localRotation.setFromEulerAngles(x, y, z);\n\t\tif (!this._dirtyLocal) {\n\t\t\tthis._dirtifyLocal();\n\t\t}\n\t}\n\tsetLocalPosition(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\tthis.localPosition.copy(x);\n\t\t} else {\n\t\t\tthis.localPosition.set(x, y, z);\n\t\t}\n\t\tif (!this._dirtyLocal) {\n\t\t\tthis._dirtifyLocal();\n\t\t}\n\t}\n\tsetLocalRotation(x, y, z, w) {\n\t\tif (x instanceof Quat) {\n\t\t\tthis.localRotation.copy(x);\n\t\t} else {\n\t\t\tthis.localRotation.set(x, y, z, w);\n\t\t}\n\t\tif (!this._dirtyLocal) {\n\t\t\tthis._dirtifyLocal();\n\t\t}\n\t}\n\tsetLocalScale(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\tthis.localScale.copy(x);\n\t\t} else {\n\t\t\tthis.localScale.set(x, y, z);\n\t\t}\n\t\tif (!this._dirtyLocal) {\n\t\t\tthis._dirtifyLocal();\n\t\t}\n\t}\n\t_dirtifyLocal() {\n\t\tif (!this._dirtyLocal) {\n\t\t\tthis._dirtyLocal = true;\n\t\t\tif (!this._dirtyWorld) {\n\t\t\t\tthis._dirtifyWorld();\n\t\t\t}\n\t\t}\n\t}\n\t_unfreezeParentToRoot() {\n\t\tlet p = this._parent;\n\t\twhile (p) {\n\t\t\tp._frozen = false;\n\t\t\tp = p._parent;\n\t\t}\n\t}\n\t_dirtifyWorld() {\n\t\tif (!this._dirtyWorld) {\n\t\t\tthis._unfreezeParentToRoot();\n\t\t}\n\t\tthis._dirtifyWorldInternal();\n\t}\n\t_dirtifyWorldInternal() {\n\t\tif (!this._dirtyWorld) {\n\t\t\tthis._frozen = false;\n\t\t\tthis._dirtyWorld = true;\n\t\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\t\tif (!this._children[i]._dirtyWorld) {\n\t\t\t\t\tthis._children[i]._dirtifyWorldInternal();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis._dirtyNormal = true;\n\t\tthis._worldScaleSign = 0;\n\t\tthis._aabbVer++;\n\t}\n\tsetPosition(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\tposition.copy(x);\n\t\t} else {\n\t\t\tposition.set(x, y, z);\n\t\t}\n\t\tif (this._parent === null) {\n\t\t\tthis.localPosition.copy(position);\n\t\t} else {\n\t\t\tinvParentWtm.copy(this._parent.getWorldTransform()).invert();\n\t\t\tinvParentWtm.transformPoint(position, this.localPosition);\n\t\t}\n\t\tif (!this._dirtyLocal) {\n\t\t\tthis._dirtifyLocal();\n\t\t}\n\t}\n\tsetRotation(x, y, z, w) {\n\t\tif (x instanceof Quat) {\n\t\t\trotation.copy(x);\n\t\t} else {\n\t\t\trotation.set(x, y, z, w);\n\t\t}\n\t\tif (this._parent === null) {\n\t\t\tthis.localRotation.copy(rotation);\n\t\t} else {\n\t\t\tconst parentRot = this._parent.getRotation();\n\t\t\tinvParentRot.copy(parentRot).invert();\n\t\t\tthis.localRotation.copy(invParentRot).mul(rotation);\n\t\t}\n\t\tif (!this._dirtyLocal) {\n\t\t\tthis._dirtifyLocal();\n\t\t}\n\t}\n\tsetPositionAndRotation(position, rotation) {\n\t\tif (this._parent === null) {\n\t\t\tthis.localPosition.copy(position);\n\t\t\tthis.localRotation.copy(rotation);\n\t\t} else {\n\t\t\tconst parentWtm = this._parent.getWorldTransform();\n\t\t\tinvParentWtm.copy(parentWtm).invert();\n\t\t\tinvParentWtm.transformPoint(position, this.localPosition);\n\t\t\tthis.localRotation.setFromMat4(invParentWtm).mul(rotation);\n\t\t}\n\t\tif (!this._dirtyLocal) {\n\t\t\tthis._dirtifyLocal();\n\t\t}\n\t}\n\tsetEulerAngles(x, y, z) {\n\t\tthis.localRotation.setFromEulerAngles(x, y, z);\n\t\tif (this._parent !== null) {\n\t\t\tconst parentRot = this._parent.getRotation();\n\t\t\tinvParentRot.copy(parentRot).invert();\n\t\t\tthis.localRotation.mul2(invParentRot, this.localRotation);\n\t\t}\n\t\tif (!this._dirtyLocal) {\n\t\t\tthis._dirtifyLocal();\n\t\t}\n\t}\n\taddChild(node) {\n\t\tthis._prepareInsertChild(node);\n\t\tthis._children.push(node);\n\t\tthis._onInsertChild(node);\n\t}\n\taddChildAndSaveTransform(node) {\n\t\tconst wPos = node.getPosition();\n\t\tconst wRot = node.getRotation();\n\t\tthis._prepareInsertChild(node);\n\t\tnode.setPosition(tmpMat4.copy(this.worldTransform).invert().transformPoint(wPos));\n\t\tnode.setRotation(tmpQuat.copy(this.getRotation()).invert().mul(wRot));\n\t\tthis._children.push(node);\n\t\tthis._onInsertChild(node);\n\t}\n\tinsertChild(node, index) {\n\t\tthis._prepareInsertChild(node);\n\t\tthis._children.splice(index, 0, node);\n\t\tthis._onInsertChild(node);\n\t}\n\t_prepareInsertChild(node) {\n\t\tnode.remove();\n\t}\n\t_fireOnHierarchy(name, nameHierarchy, parent) {\n\t\tthis.fire(name, parent);\n\t\tfor (let i = 0; i < this._children.length; i++) {\n\t\t\tthis._children[i]._fireOnHierarchy(nameHierarchy, nameHierarchy, parent);\n\t\t}\n\t}\n\t_onInsertChild(node) {\n\t\tnode._parent = this;\n\t\tconst enabledInHierarchy = node._enabled && this.enabled;\n\t\tif (node._enabledInHierarchy !== enabledInHierarchy) {\n\t\t\tnode._enabledInHierarchy = enabledInHierarchy;\n\t\t\tnode._notifyHierarchyStateChanged(node, enabledInHierarchy);\n\t\t}\n\t\tnode._updateGraphDepth();\n\t\tnode._dirtifyWorld();\n\t\tif (this._frozen) {\n\t\t\tnode._unfreezeParentToRoot();\n\t\t}\n\t\tnode._fireOnHierarchy('insert', 'inserthierarchy', this);\n\t\tif (this.fire) this.fire('childinsert', node);\n\t}\n\t_updateGraphDepth() {\n\t\tthis._graphDepth = this._parent ? this._parent._graphDepth + 1 : 0;\n\t\tfor (let i = 0, len = this._children.length; i < len; i++) {\n\t\t\tthis._children[i]._updateGraphDepth();\n\t\t}\n\t}\n\tremoveChild(child) {\n\t\tconst index = this._children.indexOf(child);\n\t\tif (index === -1) {\n\t\t\treturn;\n\t\t}\n\t\tthis._children.splice(index, 1);\n\t\tchild._parent = null;\n\t\tchild._fireOnHierarchy('remove', 'removehierarchy', this);\n\t\tthis.fire('childremove', child);\n\t}\n\t_sync() {\n\t\tif (this._dirtyLocal) {\n\t\t\tthis.localTransform.setTRS(this.localPosition, this.localRotation, this.localScale);\n\t\t\tthis._dirtyLocal = false;\n\t\t}\n\t\tif (this._dirtyWorld) {\n\t\t\tif (this._parent === null) {\n\t\t\t\tthis.worldTransform.copy(this.localTransform);\n\t\t\t} else {\n\t\t\t\tif (this.scaleCompensation) {\n\t\t\t\t\tlet parentWorldScale;\n\t\t\t\t\tconst parent = this._parent;\n\t\t\t\t\tlet scale = this.localScale;\n\t\t\t\t\tlet parentToUseScaleFrom = parent;\n\t\t\t\t\tif (parentToUseScaleFrom) {\n\t\t\t\t\t\twhile (parentToUseScaleFrom && parentToUseScaleFrom.scaleCompensation) {\n\t\t\t\t\t\t\tparentToUseScaleFrom = parentToUseScaleFrom._parent;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (parentToUseScaleFrom) {\n\t\t\t\t\t\t\tparentToUseScaleFrom = parentToUseScaleFrom._parent;\n\t\t\t\t\t\t\tif (parentToUseScaleFrom) {\n\t\t\t\t\t\t\t\tparentWorldScale = parentToUseScaleFrom.worldTransform.getScale();\n\t\t\t\t\t\t\t\tscaleCompensateScale.mul2(parentWorldScale, this.localScale);\n\t\t\t\t\t\t\t\tscale = scaleCompensateScale;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tscaleCompensateRot2.setFromMat4(parent.worldTransform);\n\t\t\t\t\tscaleCompensateRot.mul2(scaleCompensateRot2, this.localRotation);\n\t\t\t\t\tlet tmatrix = parent.worldTransform;\n\t\t\t\t\tif (parent.scaleCompensation) {\n\t\t\t\t\t\tscaleCompensateScaleForParent.mul2(parentWorldScale, parent.getLocalScale());\n\t\t\t\t\t\tscaleCompensatePosTransform.setTRS(parent.worldTransform.getTranslation(scaleCompensatePos), scaleCompensateRot2, scaleCompensateScaleForParent);\n\t\t\t\t\t\ttmatrix = scaleCompensatePosTransform;\n\t\t\t\t\t}\n\t\t\t\t\ttmatrix.transformPoint(this.localPosition, scaleCompensatePos);\n\t\t\t\t\tthis.worldTransform.setTRS(scaleCompensatePos, scaleCompensateRot, scale);\n\t\t\t\t} else {\n\t\t\t\t\tthis.worldTransform.mulAffine2(this._parent.worldTransform, this.localTransform);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._dirtyWorld = false;\n\t\t}\n\t}\n\tsyncHierarchy() {\n\t\tif (!this._enabled) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._frozen) {\n\t\t\treturn;\n\t\t}\n\t\tthis._frozen = true;\n\t\tif (this._dirtyLocal || this._dirtyWorld) {\n\t\t\tthis._sync();\n\t\t}\n\t\tconst children = this._children;\n\t\tfor (let i = 0, len = children.length; i < len; i++) {\n\t\t\tchildren[i].syncHierarchy();\n\t\t}\n\t}\n\tlookAt(x, y, z, ux = 0, uy = 1, uz = 0) {\n\t\tif (x instanceof Vec3) {\n\t\t\ttarget.copy(x);\n\t\t\tif (y instanceof Vec3) {\n\t\t\t\tup.copy(y);\n\t\t\t} else {\n\t\t\t\tup.copy(Vec3.UP);\n\t\t\t}\n\t\t} else if (z === undefined) {\n\t\t\treturn;\n\t\t} else {\n\t\t\ttarget.set(x, y, z);\n\t\t\tup.set(ux, uy, uz);\n\t\t}\n\t\tmatrix.setLookAt(this.getPosition(), target, up);\n\t\trotation.setFromMat4(matrix);\n\t\tthis.setRotation(rotation);\n\t}\n\ttranslate(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\tposition.copy(x);\n\t\t} else {\n\t\t\tposition.set(x, y, z);\n\t\t}\n\t\tposition.add(this.getPosition());\n\t\tthis.setPosition(position);\n\t}\n\ttranslateLocal(x, y, z) {\n\t\tif (x instanceof Vec3) {\n\t\t\tposition.copy(x);\n\t\t} else {\n\t\t\tposition.set(x, y, z);\n\t\t}\n\t\tthis.localRotation.transformVector(position, position);\n\t\tthis.localPosition.add(position);\n\t\tif (!this._dirtyLocal) {\n\t\t\tthis._dirtifyLocal();\n\t\t}\n\t}\n\trotate(x, y, z) {\n\t\trotation.setFromEulerAngles(x, y, z);\n\t\tif (this._parent === null) {\n\t\t\tthis.localRotation.mul2(rotation, this.localRotation);\n\t\t} else {\n\t\t\tconst rot = this.getRotation();\n\t\t\tconst parentRot = this._parent.getRotation();\n\t\t\tinvParentRot.copy(parentRot).invert();\n\t\t\trotation.mul2(invParentRot, rotation);\n\t\t\tthis.localRotation.mul2(rotation, rot);\n\t\t}\n\t\tif (!this._dirtyLocal) {\n\t\t\tthis._dirtifyLocal();\n\t\t}\n\t}\n\trotateLocal(x, y, z) {\n\t\trotation.setFromEulerAngles(x, y, z);\n\t\tthis.localRotation.mul(rotation);\n\t\tif (!this._dirtyLocal) {\n\t\t\tthis._dirtifyLocal();\n\t\t}\n\t}\n}\n\nexport { GraphNode };\n","import { Vec4 } from '../../core/math/vec4.js';\nimport { Texture } from '../../platform/graphics/texture.js';\nimport { reprojectTexture } from './reproject-texture.js';\nimport { PIXELFORMAT_RGBA8, TEXTURETYPE_RGBP, TEXTURETYPE_DEFAULT, ADDRESS_CLAMP_TO_EDGE, TEXTUREPROJECTION_EQUIRECT, PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F } from '../../platform/graphics/constants.js';\n\nconst fixCubemapSeams = true;\nconst calcLevels = (width, height = 0) => {\n\treturn 1 + Math.floor(Math.log2(Math.max(width, height)));\n};\nconst supportsFloat16 = device => {\n\treturn device.extTextureHalfFloat && device.textureHalfFloatRenderable;\n};\nconst supportsFloat32 = device => {\n\treturn device.extTextureFloat && device.textureFloatRenderable;\n};\nconst lightingSourcePixelFormat = device => {\n\treturn supportsFloat16(device) ? PIXELFORMAT_RGBA16F : supportsFloat32(device) ? PIXELFORMAT_RGBA32F : PIXELFORMAT_RGBA8;\n};\nconst lightingPixelFormat = device => {\n\treturn PIXELFORMAT_RGBA8;\n};\nconst createCubemap = (device, size, format, mipmaps) => {\n\treturn new Texture(device, {\n\t\tname: `lighting-${size}`,\n\t\tcubemap: true,\n\t\twidth: size,\n\t\theight: size,\n\t\tformat: format,\n\t\ttype: TEXTURETYPE_RGBP ,\n\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\tfixCubemapSeams: fixCubemapSeams,\n\t\tmipmaps: !!mipmaps\n\t});\n};\nclass EnvLighting {\n\tstatic generateSkyboxCubemap(source, size) {\n\t\tconst device = source.device;\n\t\tconst result = createCubemap(device, size || (source.cubemap ? source.width : source.width / 4), PIXELFORMAT_RGBA8, false);\n\t\treprojectTexture(source, result, {\n\t\t\tnumSamples: 1024\n\t\t});\n\t\treturn result;\n\t}\n\tstatic generateLightingSource(source, options) {\n\t\tconst device = source.device;\n\t\tconst format = lightingSourcePixelFormat(device);\n\t\tconst result = (options == null ? void 0 : options.target) || new Texture(device, {\n\t\t\tname: 'lighting-source',\n\t\t\tcubemap: true,\n\t\t\twidth: (options == null ? void 0 : options.size) || 128,\n\t\t\theight: (options == null ? void 0 : options.size) || 128,\n\t\t\tformat: format,\n\t\t\ttype: format === PIXELFORMAT_RGBA8 ? TEXTURETYPE_RGBP : TEXTURETYPE_DEFAULT,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\tfixCubemapSeams: false,\n\t\t\tmipmaps: true\n\t\t});\n\t\treprojectTexture(source, result, {\n\t\t\tnumSamples: source.mipmaps ? 1 : 1024\n\t\t});\n\t\treturn result;\n\t}\n\tstatic generateAtlas(source, options) {\n\t\tconst device = source.device;\n\t\tconst format = lightingPixelFormat();\n\t\tconst result = (options == null ? void 0 : options.target) || new Texture(device, {\n\t\t\tname: 'envAtlas',\n\t\t\twidth: (options == null ? void 0 : options.size) || 512,\n\t\t\theight: (options == null ? void 0 : options.size) || 512,\n\t\t\tformat: format,\n\t\t\ttype: TEXTURETYPE_RGBP ,\n\t\t\tprojection: TEXTUREPROJECTION_EQUIRECT,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\tmipmaps: false\n\t\t});\n\t\tconst s = result.width / 512;\n\t\tconst rect = new Vec4(0, 0, 512 * s, 256 * s);\n\t\tconst levels = calcLevels(256) - calcLevels(4);\n\t\tfor (let i = 0; i < levels; ++i) {\n\t\t\treprojectTexture(source, result, {\n\t\t\t\tnumSamples: 1,\n\t\t\t\trect: rect,\n\t\t\t\tseamPixels: s\n\t\t\t});\n\t\t\trect.x += rect.w;\n\t\t\trect.y += rect.w;\n\t\t\trect.z = Math.max(1, Math.floor(rect.z * 0.5));\n\t\t\trect.w = Math.max(1, Math.floor(rect.w * 0.5));\n\t\t}\n\t\trect.set(0, 256 * s, 256 * s, 128 * s);\n\t\tfor (let i = 1; i < 7; ++i) {\n\t\t\treprojectTexture(source, result, {\n\t\t\t\tnumSamples: (options == null ? void 0 : options.numReflectionSamples) || 1024,\n\t\t\t\tdistribution: (options == null ? void 0 : options.distribution) || 'ggx',\n\t\t\t\tspecularPower: Math.max(1, 2048 >> i * 2),\n\t\t\t\trect: rect,\n\t\t\t\tseamPixels: s\n\t\t\t});\n\t\t\trect.y += rect.w;\n\t\t\trect.z = Math.max(1, Math.floor(rect.z * 0.5));\n\t\t\trect.w = Math.max(1, Math.floor(rect.w * 0.5));\n\t\t}\n\t\trect.set(128 * s, (256 + 128) * s, 64 * s, 32 * s);\n\t\treprojectTexture(source, result, {\n\t\t\tnumSamples: (options == null ? void 0 : options.numAmbientSamples) || 2048,\n\t\t\tdistribution: 'lambert',\n\t\t\trect: rect,\n\t\t\tseamPixels: s\n\t\t});\n\t\treturn result;\n\t}\n\tstatic generatePrefilteredAtlas(sources, options) {\n\t\tconst device = sources[0].device;\n\t\tconst format = sources[0].format;\n\t\tconst type = sources[0].type;\n\t\tconst result = (options == null ? void 0 : options.target) || new Texture(device, {\n\t\t\tname: 'envPrefilteredAtlas',\n\t\t\twidth: (options == null ? void 0 : options.size) || 512,\n\t\t\theight: (options == null ? void 0 : options.size) || 512,\n\t\t\tformat: format,\n\t\t\ttype: type,\n\t\t\tprojection: TEXTUREPROJECTION_EQUIRECT,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\tmipmaps: false\n\t\t});\n\t\tconst s = result.width / 512;\n\t\tconst rect = new Vec4(0, 0, 512 * s, 256 * s);\n\t\tconst levels = calcLevels(512);\n\t\tfor (let i = 0; i < levels; ++i) {\n\t\t\treprojectTexture(sources[0], result, {\n\t\t\t\tnumSamples: 1,\n\t\t\t\trect: rect,\n\t\t\t\tseamPixels: s\n\t\t\t});\n\t\t\trect.x += rect.w;\n\t\t\trect.y += rect.w;\n\t\t\trect.z = Math.max(1, Math.floor(rect.z * 0.5));\n\t\t\trect.w = Math.max(1, Math.floor(rect.w * 0.5));\n\t\t}\n\t\trect.set(0, 256 * s, 256 * s, 128 * s);\n\t\tfor (let i = 1; i < sources.length; ++i) {\n\t\t\treprojectTexture(sources[i], result, {\n\t\t\t\tnumSamples: 1,\n\t\t\t\trect: rect,\n\t\t\t\tseamPixels: s\n\t\t\t});\n\t\t\trect.y += rect.w;\n\t\t\trect.z = Math.max(1, Math.floor(rect.z * 0.5));\n\t\t\trect.w = Math.max(1, Math.floor(rect.w * 0.5));\n\t\t}\n\t\trect.set(128 * s, (256 + 128) * s, 64 * s, 32 * s);\n\t\tif (options != null && options.legacyAmbient) {\n\t\t\treprojectTexture(sources[5], result, {\n\t\t\t\tnumSamples: 1,\n\t\t\t\trect: rect,\n\t\t\t\tseamPixels: s\n\t\t\t});\n\t\t} else {\n\t\t\treprojectTexture(sources[0], result, {\n\t\t\t\tnumSamples: (options == null ? void 0 : options.numSamples) || 2048,\n\t\t\t\tdistribution: 'lambert',\n\t\t\t\trect: rect,\n\t\t\t\tseamPixels: s\n\t\t\t});\n\t\t}\n\t\treturn result;\n\t}\n}\n\nexport { EnvLighting };\n","import { Vec3 } from '../../core/math/vec3.js';\nimport { LIGHTTYPE_DIRECTIONAL } from '../constants.js';\n\nconst lightCubeDir = [new Vec3(-1, 0, 0), new Vec3(1, 0, 0), new Vec3(0, -1, 0), new Vec3(0, 1, 0), new Vec3(0, 0, -1), new Vec3(0, 0, 1)];\nclass LightCube {\n\tconstructor() {\n\t\tthis.colors = new Float32Array(6 * 3);\n\t}\n\tupdate(ambientLight, lights) {\n\t\tconst colors = this.colors;\n\t\tconst {\n\t\t\tr,\n\t\t\tg,\n\t\t\tb\n\t\t} = ambientLight;\n\t\tfor (let j = 0; j < 6; j++) {\n\t\t\tcolors[j * 3] = r;\n\t\t\tcolors[j * 3 + 1] = g;\n\t\t\tcolors[j * 3 + 2] = b;\n\t\t}\n\t\tfor (let j = 0; j < lights.length; j++) {\n\t\t\tconst light = lights[j];\n\t\t\tif (light._type === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\tfor (let c = 0; c < 6; c++) {\n\t\t\t\t\tconst weight = Math.max(lightCubeDir[c].dot(light._direction), 0) * light._intensity;\n\t\t\t\t\tconst lightColor = light._color;\n\t\t\t\t\tcolors[c * 3] += lightColor.r * weight;\n\t\t\t\t\tcolors[c * 3 + 1] += lightColor.g * weight;\n\t\t\t\t\tcolors[c * 3 + 2] += lightColor.b * weight;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { LightCube };\n","import { RefCountedCache } from '../../core/ref-counted-cache.js';\n\nclass LightmapCache {\n\tstatic incRef(texture) {\n\t\tthis.cache.incRef(texture);\n\t}\n\tstatic decRef(texture) {\n\t\tthis.cache.decRef(texture);\n\t}\n\tstatic destroy() {\n\t\tthis.cache.destroy();\n\t}\n}\nLightmapCache.cache = new RefCountedCache();\n\nexport { LightmapCache };\n","import { blueNoiseData } from '../../core/math/blue-noise.js';\nimport { PIXELFORMAT_RGBA8, ADDRESS_REPEAT, TEXTURETYPE_DEFAULT, FILTER_NEAREST } from '../../platform/graphics/constants.js';\nimport { DeviceCache } from '../../platform/graphics/device-cache.js';\nimport { Texture } from '../../platform/graphics/texture.js';\n\nconst createTexture = (device, namePrefix, size, data) => {\n\tconst texture = new Texture(device, {\n\t\tname: `${namePrefix}${size}`,\n\t\twidth: size,\n\t\theight: size,\n\t\tformat: PIXELFORMAT_RGBA8,\n\t\taddressU: ADDRESS_REPEAT,\n\t\taddressV: ADDRESS_REPEAT,\n\t\ttype: TEXTURETYPE_DEFAULT,\n\t\tmagFilter: FILTER_NEAREST,\n\t\tminFilter: FILTER_NEAREST,\n\t\tanisotropy: 1,\n\t\tmipmaps: false\n\t});\n\ttexture.lock().set(data);\n\ttexture.unlock();\n\treturn texture;\n};\nconst deviceCacheBlueNoise = new DeviceCache();\nconst getBlueNoiseTexture = device => {\n\treturn deviceCacheBlueNoise.get(device, () => {\n\t\tconst data = blueNoiseData();\n\t\tconst size = Math.sqrt(data.length / 4);\n\t\treturn createTexture(device, 'BlueNoise', size, data);\n\t});\n};\n\nexport { getBlueNoiseTexture };\n","import { Vec4 } from '../../core/math/vec4.js';\nimport { QuadRender } from './quad-render.js';\nimport { RenderPassQuad } from './render-pass-quad.js';\n\nconst _tempRect = new Vec4();\nfunction drawQuadWithShader(device, target, shader, rect, scissorRect) {\n\tconst quad = new QuadRender(shader);\n\tif (!rect) {\n\t\trect = _tempRect;\n\t\trect.x = 0;\n\t\trect.y = 0;\n\t\trect.z = target ? target.width : device.width;\n\t\trect.w = target ? target.height : device.height;\n\t}\n\tconst renderPass = new RenderPassQuad(device, quad, rect, scissorRect);\n\trenderPass.init(target);\n\trenderPass.colorOps.clear = false;\n\trenderPass.depthStencilOps.clearDepth = false;\n\tif (device.isWebGPU && target === null && device.samples > 1) {\n\t\trenderPass.colorOps.store = true;\n\t}\n\trenderPass.render();\n\tquad.destroy();\n}\nfunction drawTexture(device, texture, target, shader, rect, scissorRect) {\n\tshader = shader || device.getCopyShader();\n\tdevice.constantTexSource.setValue(texture);\n\tdrawQuadWithShader(device, target, shader, rect, scissorRect);\n}\n\nexport { drawQuadWithShader, drawTexture };\n","import { Vec4 } from '../../core/math/vec4.js';\nimport { BindGroup } from '../../platform/graphics/bind-group.js';\nimport { BINDGROUP_MESH, PRIMITIVE_TRISTRIP } from '../../platform/graphics/constants.js';\nimport { ShaderProcessorOptions } from '../../platform/graphics/shader-processor-options.js';\nimport { UniformBuffer } from '../../platform/graphics/uniform-buffer.js';\nimport { processShader } from '../shader-lib/utils.js';\n\nconst _quadPrimitive = {\n\ttype: PRIMITIVE_TRISTRIP,\n\tbase: 0,\n\tcount: 4,\n\tindexed: false\n};\nconst _tempViewport = new Vec4();\nconst _tempScissor = new Vec4();\nclass QuadRender {\n\tconstructor(shader) {\n\t\tthis.uniformBuffer = void 0;\n\t\tthis.bindGroup = void 0;\n\t\tconst device = shader.device;\n\t\tthis.shader = shader;\n\t\tif (device.supportsUniformBuffers) {\n\t\t\tconst processingOptions = new ShaderProcessorOptions();\n\t\t\tthis.shader = processShader(shader, processingOptions);\n\t\t\tconst ubFormat = this.shader.meshUniformBufferFormat;\n\t\t\tif (ubFormat) {\n\t\t\t\tthis.uniformBuffer = new UniformBuffer(device, ubFormat, false);\n\t\t\t}\n\t\t\tconst bindGroupFormat = this.shader.meshBindGroupFormat;\n\t\t\tthis.bindGroup = new BindGroup(device, bindGroupFormat, this.uniformBuffer);\n\t\t}\n\t}\n\tdestroy() {\n\t\tvar _this$uniformBuffer, _this$bindGroup;\n\t\t(_this$uniformBuffer = this.uniformBuffer) == null || _this$uniformBuffer.destroy();\n\t\tthis.uniformBuffer = null;\n\t\t(_this$bindGroup = this.bindGroup) == null || _this$bindGroup.destroy();\n\t\tthis.bindGroup = null;\n\t}\n\trender(viewport, scissor) {\n\t\tconst device = this.shader.device;\n\t\tif (viewport) {\n\t\t\tvar _scissor;\n\t\t\t_tempViewport.set(device.vx, device.vy, device.vw, device.vh);\n\t\t\t_tempScissor.set(device.sx, device.sy, device.sw, device.sh);\n\t\t\tscissor = (_scissor = scissor) != null ? _scissor : viewport;\n\t\t\tdevice.setViewport(viewport.x, viewport.y, viewport.z, viewport.w);\n\t\t\tdevice.setScissor(scissor.x, scissor.y, scissor.z, scissor.w);\n\t\t}\n\t\tdevice.setVertexBuffer(device.quadVertexBuffer, 0);\n\t\tconst shader = this.shader;\n\t\tdevice.setShader(shader);\n\t\tif (device.supportsUniformBuffers) {\n\t\t\tvar _bindGroup$defaultUni;\n\t\t\tconst bindGroup = this.bindGroup;\n\t\t\t(_bindGroup$defaultUni = bindGroup.defaultUniformBuffer) == null || _bindGroup$defaultUni.update();\n\t\t\tbindGroup.update();\n\t\t\tdevice.setBindGroup(BINDGROUP_MESH, bindGroup);\n\t\t}\n\t\tdevice.draw(_quadPrimitive);\n\t\tif (viewport) {\n\t\t\tdevice.setViewport(_tempViewport.x, _tempViewport.y, _tempViewport.z, _tempViewport.w);\n\t\t\tdevice.setScissor(_tempScissor.x, _tempScissor.y, _tempScissor.z, _tempScissor.w);\n\t\t}\n\t}\n}\n\nexport { QuadRender };\n","import { FILTER_LINEAR_MIPMAP_LINEAR, FILTER_LINEAR, ADDRESS_CLAMP_TO_EDGE } from '../../platform/graphics/constants.js';\nimport { RenderPass } from '../../platform/graphics/render-pass.js';\nimport { RenderTarget } from '../../platform/graphics/render-target.js';\nimport { Texture } from '../../platform/graphics/texture.js';\n\nconst _colorUniformNames = ['uSceneColorMap', 'texture_grabPass'];\nclass RenderPassColorGrab extends RenderPass {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.colorRenderTarget = null;\n\t\tthis.source = null;\n\t}\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.releaseRenderTarget(this.colorRenderTarget);\n\t}\n\tshouldReallocate(targetRT, sourceTexture, sourceFormat) {\n\t\tconst targetFormat = targetRT == null ? void 0 : targetRT.colorBuffer.format;\n\t\tif (targetFormat !== sourceFormat) {\n\t\t\treturn true;\n\t\t}\n\t\tconst width = (sourceTexture == null ? void 0 : sourceTexture.width) || this.device.width;\n\t\tconst height = (sourceTexture == null ? void 0 : sourceTexture.height) || this.device.height;\n\t\treturn !targetRT || width !== targetRT.width || height !== targetRT.height;\n\t}\n\tallocateRenderTarget(renderTarget, sourceRenderTarget, device, format) {\n\t\tconst mipmaps = device.isWebGL2;\n\t\tconst texture = new Texture(device, {\n\t\t\tname: _colorUniformNames[0],\n\t\t\tformat,\n\t\t\twidth: sourceRenderTarget ? sourceRenderTarget.colorBuffer.width : device.width,\n\t\t\theight: sourceRenderTarget ? sourceRenderTarget.colorBuffer.height : device.height,\n\t\t\tmipmaps,\n\t\t\tminFilter: mipmaps ? FILTER_LINEAR_MIPMAP_LINEAR : FILTER_LINEAR,\n\t\t\tmagFilter: FILTER_LINEAR,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t\t});\n\t\tif (renderTarget) {\n\t\t\trenderTarget.destroyFrameBuffers();\n\t\t\trenderTarget._colorBuffer = texture;\n\t\t\trenderTarget._colorBuffers = [texture];\n\t\t} else {\n\t\t\trenderTarget = new RenderTarget({\n\t\t\t\tname: 'ColorGrabRT',\n\t\t\t\tcolorBuffer: texture,\n\t\t\t\tdepth: false,\n\t\t\t\tstencil: false,\n\t\t\t\tautoResolve: false\n\t\t\t});\n\t\t}\n\t\treturn renderTarget;\n\t}\n\treleaseRenderTarget(rt) {\n\t\tif (rt) {\n\t\t\trt.destroyTextureBuffers();\n\t\t\trt.destroy();\n\t\t}\n\t}\n\tframeUpdate() {\n\t\tvar _sourceRt$colorBuffer;\n\t\tconst device = this.device;\n\t\tconst sourceRt = this.source;\n\t\tconst sourceFormat = (_sourceRt$colorBuffer = sourceRt == null ? void 0 : sourceRt.colorBuffer.format) != null ? _sourceRt$colorBuffer : this.device.backBufferFormat;\n\t\tif (this.shouldReallocate(this.colorRenderTarget, sourceRt == null ? void 0 : sourceRt.colorBuffer, sourceFormat)) {\n\t\t\tthis.releaseRenderTarget(this.colorRenderTarget);\n\t\t\tthis.colorRenderTarget = this.allocateRenderTarget(this.colorRenderTarget, sourceRt, device, sourceFormat);\n\t\t}\n\t\tconst colorBuffer = this.colorRenderTarget.colorBuffer;\n\t\t_colorUniformNames.forEach(name => device.scope.resolve(name).setValue(colorBuffer));\n\t}\n\texecute() {\n\t\tconst device = this.device;\n\t\tconst sourceRt = this.source;\n\t\tconst colorBuffer = this.colorRenderTarget.colorBuffer;\n\t\tif (device.isWebGPU) {\n\t\t\tdevice.copyRenderTarget(sourceRt, this.colorRenderTarget, true, false);\n\t\t\tdevice.mipmapRenderer.generate(this.colorRenderTarget.colorBuffer.impl);\n\t\t} else if (device.isWebGL2) {\n\t\t\tdevice.copyRenderTarget(sourceRt, this.colorRenderTarget, true, false);\n\t\t\tdevice.activeTexture(device.maxCombinedTextures - 1);\n\t\t\tdevice.bindTexture(colorBuffer);\n\t\t\tdevice.gl.generateMipmap(colorBuffer.impl._glTarget);\n\t\t} else {\n\t\t\tif (!colorBuffer.impl._glTexture) {\n\t\t\t\tcolorBuffer.impl.initialize(device, colorBuffer);\n\t\t\t}\n\t\t\tdevice.bindTexture(colorBuffer);\n\t\t\tconst gl = device.gl;\n\t\t\tgl.copyTexImage2D(gl.TEXTURE_2D, 0, colorBuffer.impl._glFormat, 0, 0, colorBuffer.width, colorBuffer.height, 0);\n\t\t\tcolorBuffer._needsUpload = false;\n\t\t\tcolorBuffer._needsMipmapsUpload = false;\n\t\t}\n\t}\n}\n\nexport { RenderPassColorGrab };\n","import { FILTER_NEAREST, ADDRESS_CLAMP_TO_EDGE, PIXELFORMAT_DEPTHSTENCIL, PIXELFORMAT_DEPTH, PIXELFORMAT_R32F } from '../../platform/graphics/constants.js';\nimport { RenderPass } from '../../platform/graphics/render-pass.js';\nimport { RenderTarget } from '../../platform/graphics/render-target.js';\nimport { Texture } from '../../platform/graphics/texture.js';\n\nconst _depthUniformNames = ['uSceneDepthMap', 'uDepthMap'];\nclass RenderPassDepthGrab extends RenderPass {\n\tconstructor(device, camera) {\n\t\tsuper(device);\n\t\tthis.depthRenderTarget = null;\n\t\tthis.camera = null;\n\t\tthis.camera = camera;\n\t}\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tthis.releaseRenderTarget(this.depthRenderTarget);\n\t}\n\tshouldReallocate(targetRT, sourceTexture) {\n\t\tconst width = (sourceTexture == null ? void 0 : sourceTexture.width) || this.device.width;\n\t\tconst height = (sourceTexture == null ? void 0 : sourceTexture.height) || this.device.height;\n\t\treturn !targetRT || width !== targetRT.width || height !== targetRT.height;\n\t}\n\tallocateRenderTarget(renderTarget, sourceRenderTarget, device, format, isDepth) {\n\t\tconst texture = new Texture(device, {\n\t\t\tname: _depthUniformNames[0],\n\t\t\tformat,\n\t\t\twidth: sourceRenderTarget ? sourceRenderTarget.colorBuffer.width : device.width,\n\t\t\theight: sourceRenderTarget ? sourceRenderTarget.colorBuffer.height : device.height,\n\t\t\tmipmaps: false,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t\t});\n\t\tif (renderTarget) {\n\t\t\trenderTarget.destroyFrameBuffers();\n\t\t\tif (isDepth) {\n\t\t\t\trenderTarget._depthBuffer = texture;\n\t\t\t} else {\n\t\t\t\trenderTarget._colorBuffer = texture;\n\t\t\t\trenderTarget._colorBuffers = [texture];\n\t\t\t}\n\t\t} else {\n\t\t\trenderTarget = new RenderTarget({\n\t\t\t\tname: 'DepthGrabRT',\n\t\t\t\tcolorBuffer: isDepth ? null : texture,\n\t\t\t\tdepthBuffer: isDepth ? texture : null,\n\t\t\t\tdepth: !isDepth,\n\t\t\t\tstencil: device.supportsStencil,\n\t\t\t\tautoResolve: false\n\t\t\t});\n\t\t}\n\t\treturn renderTarget;\n\t}\n\treleaseRenderTarget(rt) {\n\t\tif (rt) {\n\t\t\trt.destroyTextureBuffers();\n\t\t\trt.destroy();\n\t\t}\n\t}\n\tbefore() {\n\t\tvar _camera$renderTarget, _camera$renderTarget$, _camera$renderTarget2, _camera$renderTarget3;\n\t\tconst camera = this.camera;\n\t\tconst device = this.device;\n\t\tconst destinationRt = (_camera$renderTarget = camera == null ? void 0 : camera.renderTarget) != null ? _camera$renderTarget : device.backBuffer;\n\t\tlet useDepthBuffer = true;\n\t\tlet format = destinationRt.stencil ? PIXELFORMAT_DEPTHSTENCIL : PIXELFORMAT_DEPTH;\n\t\tif (device.isWebGPU) {\n\t\t\tconst numSamples = destinationRt.samples;\n\t\t\tif (numSamples > 1) {\n\t\t\t\tformat = PIXELFORMAT_R32F;\n\t\t\t\tuseDepthBuffer = false;\n\t\t\t}\n\t\t}\n\t\tconst sourceTexture = (_camera$renderTarget$ = (_camera$renderTarget2 = camera.renderTarget) == null ? void 0 : _camera$renderTarget2.depthBuffer) != null ? _camera$renderTarget$ : (_camera$renderTarget3 = camera.renderTarget) == null ? void 0 : _camera$renderTarget3.colorBuffer;\n\t\tif (this.shouldReallocate(this.depthRenderTarget, sourceTexture)) {\n\t\t\tthis.releaseRenderTarget(this.depthRenderTarget);\n\t\t\tthis.depthRenderTarget = this.allocateRenderTarget(this.depthRenderTarget, camera.renderTarget, device, format, useDepthBuffer);\n\t\t}\n\t\tconst colorBuffer = useDepthBuffer ? this.depthRenderTarget.depthBuffer : this.depthRenderTarget.colorBuffer;\n\t\t_depthUniformNames.forEach(name => device.scope.resolve(name).setValue(colorBuffer));\n\t}\n\texecute() {\n\t\tconst device = this.device;\n\t\tif (device.isWebGL2 && device.renderTarget.samples > 1) {\n\t\t\tconst src = device.renderTarget.impl._glFrameBuffer;\n\t\t\tconst dest = this.depthRenderTarget;\n\t\t\tdevice.renderTarget = dest;\n\t\t\tdevice.updateBegin();\n\t\t\tthis.depthRenderTarget.impl.internalResolve(device, src, dest.impl._glFrameBuffer, this.depthRenderTarget, device.gl.DEPTH_BUFFER_BIT);\n\t\t} else {\n\t\t\tdevice.copyRenderTarget(device.renderTarget, this.depthRenderTarget, false, true);\n\t\t}\n\t}\n}\n\nexport { RenderPassDepthGrab };\n","import { Color } from '../../core/math/color.js';\nimport { PIXELFORMAT_RGBA8, FILTER_NEAREST, ADDRESS_CLAMP_TO_EDGE } from '../../platform/graphics/constants.js';\nimport { Texture } from '../../platform/graphics/texture.js';\nimport { RenderPass } from '../../platform/graphics/render-pass.js';\nimport { BlendState } from '../../platform/graphics/blend-state.js';\nimport { RenderTarget } from '../../platform/graphics/render-target.js';\nimport { LAYERID_DEPTH, SHADER_DEPTH } from '../constants.js';\n\nconst webgl1DepthClearColor = new Color(254.0 / 255, 254.0 / 255, 254.0 / 255, 254.0 / 255);\nconst tempMeshInstances = [];\nconst lights = [[], [], []];\nconst _depthUniformNames = ['uSceneDepthMap', 'uDepthMap'];\nclass RenderPassDepth extends RenderPass {\n\tconstructor(device, renderer, camera) {\n\t\tsuper(device);\n\t\tthis.renderer = renderer;\n\t\tthis.camera = camera;\n\t\tthis.setupRenderTarget();\n\t}\n\tdestroy() {\n\t\tsuper.destroy();\n\t\tif (this.renderTarget) {\n\t\t\tthis.renderTarget.destroyTextureBuffers();\n\t\t\tthis.renderTarget.destroy();\n\t\t\tthis.renderTarget = null;\n\t\t}\n\t}\n\tupdate(scene) {\n\t\tthis.scene = scene;\n\t}\n\tsetupRenderTarget() {\n\t\tconst texture = new Texture(this.device, {\n\t\t\tname: _depthUniformNames[0],\n\t\t\tformat: PIXELFORMAT_RGBA8,\n\t\t\twidth: 4,\n\t\t\theight: 4,\n\t\t\tmipmaps: false,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t\t});\n\t\tconst renderTarget = new RenderTarget({\n\t\t\tname: `${_depthUniformNames[0]}RT}`,\n\t\t\tcolorBuffer: texture,\n\t\t\tdepth: true,\n\t\t\tstencil: false\n\t\t});\n\t\tthis.init(renderTarget, {});\n\t\tthis.setClearColor(webgl1DepthClearColor);\n\t\tthis.setClearDepth(1.0);\n\t}\n\tbefore() {\n\t\tconst device = this.device;\n\t\tconst colorBuffer = this.renderTarget.colorBuffer;\n\t\t_depthUniformNames.forEach(name => device.scope.resolve(name).setValue(colorBuffer));\n\t}\n\texecute() {\n\t\tconst {\n\t\t\tdevice,\n\t\t\trenderer,\n\t\t\tcamera,\n\t\t\tscene,\n\t\t\trenderTarget\n\t\t} = this;\n\t\tconst layers = scene.layers.layerList;\n\t\tconst subLayerEnabled = scene.layers.subLayerEnabled;\n\t\tconst isTransparent = scene.layers.subLayerList;\n\t\tfor (let i = 0; i < layers.length; i++) {\n\t\t\tconst layer = layers[i];\n\t\t\tif (layer.enabled && subLayerEnabled[i]) {\n\t\t\t\tif (layer.camerasSet.has(camera)) {\n\t\t\t\t\tif (layer.id === LAYERID_DEPTH) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst culledInstances = layer.getCulledInstances(camera);\n\t\t\t\t\tconst meshInstances = isTransparent[i] ? culledInstances.transparent : culledInstances.opaque;\n\t\t\t\t\tfor (let j = 0; j < meshInstances.length; j++) {\n\t\t\t\t\t\tvar _meshInstance$materia;\n\t\t\t\t\t\tconst meshInstance = meshInstances[j];\n\t\t\t\t\t\tif ((_meshInstance$materia = meshInstance.material) != null && _meshInstance$materia.depthWrite) {\n\t\t\t\t\t\t\ttempMeshInstances.push(meshInstance);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\trenderer.setCameraUniforms(camera, renderTarget);\n\t\t\t\t\trenderer.renderForward(camera, tempMeshInstances, lights, SHADER_DEPTH, meshInstance => {\n\t\t\t\t\t\tdevice.setBlendState(BlendState.NOBLEND);\n\t\t\t\t\t}, layer);\n\t\t\t\t\ttempMeshInstances.length = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { RenderPassDepth };\n","import { CULLFACE_NONE } from '../../platform/graphics/constants.js';\nimport { DepthState } from '../../platform/graphics/depth-state.js';\nimport { RenderPass } from '../../platform/graphics/render-pass.js';\n\nclass RenderPassQuad extends RenderPass {\n\tconstructor(device, quad, rect, scissorRect) {\n\t\tsuper(device);\n\t\tthis.quad = quad;\n\t\tthis.rect = rect;\n\t\tthis.scissorRect = scissorRect;\n\t}\n\texecute() {\n\t\tconst {\n\t\t\tdevice\n\t\t} = this;\n\t\tdevice.setCullMode(CULLFACE_NONE);\n\t\tdevice.setDepthState(DepthState.NODEPTH);\n\t\tdevice.setStencilState(null, null);\n\t\tthis.quad.render(this.rect, this.scissorRect);\n\t}\n}\n\nexport { RenderPassQuad };\n","import { random } from '../../core/math/random.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { TEXTUREPROJECTION_OCTAHEDRAL, TEXTUREPROJECTION_CUBE, FILTER_NEAREST } from '../../platform/graphics/constants.js';\nimport { DeviceCache } from '../../platform/graphics/device-cache.js';\nimport { GraphicsDevice } from '../../platform/graphics/graphics-device.js';\nimport { RenderTarget } from '../../platform/graphics/render-target.js';\nimport { drawQuadWithShader } from './quad-render-utils.js';\nimport { Texture } from '../../platform/graphics/texture.js';\nimport { ChunkUtils } from '../shader-lib/chunk-utils.js';\nimport { shaderChunks } from '../shader-lib/chunks/chunks.js';\nimport { getProgramLibrary } from '../shader-lib/get-program-library.js';\nimport { createShaderFromCode } from '../shader-lib/utils.js';\nimport { BlendState } from '../../platform/graphics/blend-state.js';\n\nconst getProjectionName = projection => {\n\tswitch (projection) {\n\t\tcase TEXTUREPROJECTION_CUBE:\n\t\t\treturn 'Cubemap';\n\t\tcase TEXTUREPROJECTION_OCTAHEDRAL:\n\t\t\treturn 'Octahedral';\n\t\tdefault:\n\t\t\treturn 'Equirect';\n\t}\n};\nconst packFloat32ToRGBA8 = (value, array, offset) => {\n\tif (value <= 0) {\n\t\tarray[offset + 0] = 0;\n\t\tarray[offset + 1] = 0;\n\t\tarray[offset + 2] = 0;\n\t\tarray[offset + 3] = 0;\n\t} else if (value >= 1.0) {\n\t\tarray[offset + 0] = 255;\n\t\tarray[offset + 1] = 0;\n\t\tarray[offset + 2] = 0;\n\t\tarray[offset + 3] = 0;\n\t} else {\n\t\tlet encX = 1 * value % 1;\n\t\tlet encY = 255 * value % 1;\n\t\tlet encZ = 65025 * value % 1;\n\t\tconst encW = 16581375.0 * value % 1;\n\t\tencX -= encY / 255;\n\t\tencY -= encZ / 255;\n\t\tencZ -= encW / 255;\n\t\tarray[offset + 0] = Math.min(255, Math.floor(encX * 256));\n\t\tarray[offset + 1] = Math.min(255, Math.floor(encY * 256));\n\t\tarray[offset + 2] = Math.min(255, Math.floor(encZ * 256));\n\t\tarray[offset + 3] = Math.min(255, Math.floor(encW * 256));\n\t}\n};\nconst packSamples = samples => {\n\tconst numSamples = samples.length;\n\tconst w = Math.min(numSamples, 512);\n\tconst h = Math.ceil(numSamples / w);\n\tconst data = new Uint8Array(w * h * 4);\n\tlet off = 0;\n\tfor (let i = 0; i < numSamples; i += 4) {\n\t\tpackFloat32ToRGBA8(samples[i + 0] * 0.5 + 0.5, data, off + 0);\n\t\tpackFloat32ToRGBA8(samples[i + 1] * 0.5 + 0.5, data, off + 4);\n\t\tpackFloat32ToRGBA8(samples[i + 2] * 0.5 + 0.5, data, off + 8);\n\t\tpackFloat32ToRGBA8(samples[i + 3] / 8, data, off + 12);\n\t\toff += 16;\n\t}\n\treturn {\n\t\twidth: w,\n\t\theight: h,\n\t\tdata: data\n\t};\n};\nconst hemisphereSamplePhong = (dstVec, x, y, specularPower) => {\n\tconst phi = y * 2 * Math.PI;\n\tconst cosTheta = Math.pow(1 - x, 1 / (specularPower + 1));\n\tconst sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n\tdstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();\n};\nconst hemisphereSampleLambert = (dstVec, x, y) => {\n\tconst phi = y * 2 * Math.PI;\n\tconst cosTheta = Math.sqrt(1 - x);\n\tconst sinTheta = Math.sqrt(x);\n\tdstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();\n};\nconst hemisphereSampleGGX = (dstVec, x, y, a) => {\n\tconst phi = y * 2 * Math.PI;\n\tconst cosTheta = Math.sqrt((1 - x) / (1 + (a * a - 1) * x));\n\tconst sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n\tdstVec.set(Math.cos(phi) * sinTheta, Math.sin(phi) * sinTheta, cosTheta).normalize();\n};\nconst D_GGX = (NoH, linearRoughness) => {\n\tconst a = NoH * linearRoughness;\n\tconst k = linearRoughness / (1.0 - NoH * NoH + a * a);\n\treturn k * k * (1 / Math.PI);\n};\nconst generatePhongSamples = (numSamples, specularPower) => {\n\tconst H = new Vec3();\n\tconst result = [];\n\tfor (let i = 0; i < numSamples; ++i) {\n\t\themisphereSamplePhong(H, i / numSamples, random.radicalInverse(i), specularPower);\n\t\tresult.push(H.x, H.y, H.z, 0);\n\t}\n\treturn result;\n};\nconst generateLambertSamples = (numSamples, sourceTotalPixels) => {\n\tconst pixelsPerSample = sourceTotalPixels / numSamples;\n\tconst H = new Vec3();\n\tconst result = [];\n\tfor (let i = 0; i < numSamples; ++i) {\n\t\themisphereSampleLambert(H, i / numSamples, random.radicalInverse(i));\n\t\tconst pdf = H.z / Math.PI;\n\t\tconst mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);\n\t\tresult.push(H.x, H.y, H.z, mipLevel);\n\t}\n\treturn result;\n};\nconst requiredSamplesGGX = {\n\t'16': {\n\t\t'2': 26,\n\t\t'8': 20,\n\t\t'32': 17,\n\t\t'128': 16,\n\t\t'512': 16\n\t},\n\t'32': {\n\t\t'2': 53,\n\t\t'8': 40,\n\t\t'32': 34,\n\t\t'128': 32,\n\t\t'512': 32\n\t},\n\t'128': {\n\t\t'2': 214,\n\t\t'8': 163,\n\t\t'32': 139,\n\t\t'128': 130,\n\t\t'512': 128\n\t},\n\t'1024': {\n\t\t'2': 1722,\n\t\t'8': 1310,\n\t\t'32': 1114,\n\t\t'128': 1041,\n\t\t'512': 1025\n\t}\n};\nconst getRequiredSamplesGGX = (numSamples, specularPower) => {\n\tconst table = requiredSamplesGGX[numSamples];\n\treturn table && table[specularPower] || numSamples;\n};\nconst generateGGXSamples = (numSamples, specularPower, sourceTotalPixels) => {\n\tconst pixelsPerSample = sourceTotalPixels / numSamples;\n\tconst roughness = 1 - Math.log2(specularPower) / 11.0;\n\tconst a = roughness * roughness;\n\tconst H = new Vec3();\n\tconst L = new Vec3();\n\tconst N = new Vec3(0, 0, 1);\n\tconst result = [];\n\tconst requiredSamples = getRequiredSamplesGGX(numSamples, specularPower);\n\tfor (let i = 0; i < requiredSamples; ++i) {\n\t\themisphereSampleGGX(H, i / requiredSamples, random.radicalInverse(i), a);\n\t\tconst NoH = H.z;\n\t\tL.set(H.x, H.y, H.z).mulScalar(2 * NoH).sub(N);\n\t\tif (L.z > 0) {\n\t\t\tconst pdf = D_GGX(Math.min(1, NoH), a) / 4 + 0.001;\n\t\t\tconst mipLevel = 0.5 * Math.log2(pixelsPerSample / pdf);\n\t\t\tresult.push(L.x, L.y, L.z, mipLevel);\n\t\t}\n\t}\n\twhile (result.length < numSamples * 4) {\n\t\tresult.push(0, 0, 0, 0);\n\t}\n\treturn result;\n};\nconst createSamplesTex = (device, name, samples) => {\n\tconst packedSamples = packSamples(samples);\n\treturn new Texture(device, {\n\t\tname: name,\n\t\twidth: packedSamples.width,\n\t\theight: packedSamples.height,\n\t\tmipmaps: false,\n\t\tminFilter: FILTER_NEAREST,\n\t\tmagFilter: FILTER_NEAREST,\n\t\tlevels: [packedSamples.data]\n\t});\n};\nclass SimpleCache {\n\tconstructor(destroyContent = true) {\n\t\tthis.map = new Map();\n\t\tthis.destroyContent = destroyContent;\n\t}\n\tdestroy() {\n\t\tif (this.destroyContent) {\n\t\t\tthis.map.forEach((value, key) => {\n\t\t\t\tvalue.destroy();\n\t\t\t});\n\t\t}\n\t}\n\tget(key, missFunc) {\n\t\tif (!this.map.has(key)) {\n\t\t\tconst result = missFunc();\n\t\t\tthis.map.set(key, result);\n\t\t\treturn result;\n\t\t}\n\t\treturn this.map.get(key);\n\t}\n}\nconst samplesCache = new SimpleCache(false);\nconst deviceCache = new DeviceCache();\nconst getCachedTexture = (device, key, getSamplesFnc) => {\n\tconst cache = deviceCache.get(device, () => {\n\t\treturn new SimpleCache();\n\t});\n\treturn cache.get(key, () => {\n\t\treturn createSamplesTex(device, key, samplesCache.get(key, getSamplesFnc));\n\t});\n};\nconst generateLambertSamplesTex = (device, numSamples, sourceTotalPixels) => {\n\tconst key = `lambert-samples-${numSamples}-${sourceTotalPixels}`;\n\treturn getCachedTexture(device, key, () => {\n\t\treturn generateLambertSamples(numSamples, sourceTotalPixels);\n\t});\n};\nconst generatePhongSamplesTex = (device, numSamples, specularPower) => {\n\tconst key = `phong-samples-${numSamples}-${specularPower}`;\n\treturn getCachedTexture(device, key, () => {\n\t\treturn generatePhongSamples(numSamples, specularPower);\n\t});\n};\nconst generateGGXSamplesTex = (device, numSamples, specularPower, sourceTotalPixels) => {\n\tconst key = `ggx-samples-${numSamples}-${specularPower}-${sourceTotalPixels}`;\n\treturn getCachedTexture(device, key, () => {\n\t\treturn generateGGXSamples(numSamples, specularPower, sourceTotalPixels);\n\t});\n};\nconst vsCode = `\nattribute vec2 vertex_position;\n\nuniform vec4 uvMod;\n\nvarying vec2 vUv0;\n\nvoid main(void) {\n\t\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\t\tvUv0 = getImageEffectUV((vertex_position.xy * 0.5 + 0.5) * uvMod.xy + uvMod.zw);\n}\n`;\nfunction reprojectTexture(source, target, options = {}) {\n\tvar _options$seamPixels, _options$rect$z, _options$rect, _options$rect$w, _options$rect2;\n\tif (source instanceof GraphicsDevice) {\n\t\tsource = arguments[1];\n\t\ttarget = arguments[2];\n\t\toptions = {};\n\t\tif (arguments[3] !== undefined) {\n\t\t\toptions.specularPower = arguments[3];\n\t\t}\n\t\tif (arguments[4] !== undefined) {\n\t\t\toptions.numSamples = arguments[4];\n\t\t}\n\t}\n\tconst seamPixels = (_options$seamPixels = options.seamPixels) != null ? _options$seamPixels : 0;\n\tconst innerWidth = ((_options$rect$z = (_options$rect = options.rect) == null ? void 0 : _options$rect.z) != null ? _options$rect$z : target.width) - seamPixels * 2;\n\tconst innerHeight = ((_options$rect$w = (_options$rect2 = options.rect) == null ? void 0 : _options$rect2.w) != null ? _options$rect$w : target.height) - seamPixels * 2;\n\tif (innerWidth < 1 || innerHeight < 1) {\n\t\treturn false;\n\t}\n\tconst funcNames = {\n\t\t'none': 'reproject',\n\t\t'lambert': 'prefilterSamplesUnweighted',\n\t\t'phong': 'prefilterSamplesUnweighted',\n\t\t'ggx': 'prefilterSamples'\n\t};\n\tconst specularPower = options.hasOwnProperty('specularPower') ? options.specularPower : 1;\n\tconst face = options.hasOwnProperty('face') ? options.face : null;\n\tconst distribution = options.hasOwnProperty('distribution') ? options.distribution : specularPower === 1 ? 'none' : 'phong';\n\tconst processFunc = funcNames[distribution] || 'reproject';\n\tconst prefilterSamples = processFunc.startsWith('prefilterSamples');\n\tconst decodeFunc = ChunkUtils.decodeFunc(source.encoding);\n\tconst encodeFunc = ChunkUtils.encodeFunc(target.encoding);\n\tconst sourceFunc = `sample${getProjectionName(source.projection)}`;\n\tconst targetFunc = `getDirection${getProjectionName(target.projection)}`;\n\tconst numSamples = options.hasOwnProperty('numSamples') ? options.numSamples : 1024;\n\tconst shaderKey = `${processFunc}_${decodeFunc}_${encodeFunc}_${sourceFunc}_${targetFunc}_${numSamples}`;\n\tconst device = source.device;\n\tlet shader = getProgramLibrary(device).getCachedShader(shaderKey);\n\tif (!shader) {\n\t\tconst defines = `#define PROCESS_FUNC ${processFunc}\\n${prefilterSamples ? '#define USE_SAMPLES_TEX\\n' : ''}${source.cubemap ? '#define CUBEMAP_SOURCE\\n' : ''}#define DECODE_FUNC ${decodeFunc}\\n` + `#define ENCODE_FUNC ${encodeFunc}\\n` + `#define SOURCE_FUNC ${sourceFunc}\\n` + `#define TARGET_FUNC ${targetFunc}\\n` + `#define NUM_SAMPLES ${numSamples}\\n` + `#define NUM_SAMPLES_SQRT ${Math.round(Math.sqrt(numSamples)).toFixed(1)}\\n`;\n\t\tshader = createShaderFromCode(device, vsCode, `${defines}\\n${shaderChunks.reprojectPS}`, shaderKey);\n\t}\n\tdevice.setBlendState(BlendState.NOBLEND);\n\tconst constantSource = device.scope.resolve(source.cubemap ? 'sourceCube' : 'sourceTex');\n\tconstantSource.setValue(source);\n\tconst constantParams = device.scope.resolve('params');\n\tdevice.scope.resolve('params2');\n\tconst uvModParam = device.scope.resolve('uvMod');\n\tif (seamPixels > 0) {\n\t\tuvModParam.setValue([(innerWidth + seamPixels * 2) / innerWidth, (innerHeight + seamPixels * 2) / innerHeight, -seamPixels / innerWidth, -seamPixels / innerHeight]);\n\t} else {\n\t\tuvModParam.setValue([1, 1, 0, 0]);\n\t}\n\tconst params = [0, source.fixCubemapSeams ? 1.0 / source.width : 0.0, target.fixCubemapSeams ? 1.0 / target.width : 0.0];\n\tif (prefilterSamples) {\n\t\tconst sourceTotalPixels = source.width * source.height * (source.cubemap ? 6 : 1);\n\t\tconst samplesTex = distribution === 'ggx' ? generateGGXSamplesTex(device, numSamples, specularPower, sourceTotalPixels) : distribution === 'lambert' ? generateLambertSamplesTex(device, numSamples, sourceTotalPixels) : generatePhongSamplesTex(device, numSamples, specularPower);\n\t\tdevice.scope.resolve('samplesTex').setValue(samplesTex);\n\t\tdevice.scope.resolve('samplesTexInverseSize').setValue([1.0 / samplesTex.width, 1.0 / samplesTex.height]);\n\t}\n\tfor (let f = 0; f < (target.cubemap ? 6 : 1); f++) {\n\t\tif (face === null || f === face) {\n\t\t\tvar _options;\n\t\t\tconst renderTarget = new RenderTarget({\n\t\t\t\tcolorBuffer: target,\n\t\t\t\tface: f,\n\t\t\t\tdepth: false,\n\t\t\t\tflipY: device.isWebGPU\n\t\t\t});\n\t\t\tparams[0] = f;\n\t\t\tconstantParams.setValue(params);\n\t\t\tdrawQuadWithShader(device, renderTarget, shader, (_options = options) == null ? void 0 : _options.rect);\n\t\t\trenderTarget.destroy();\n\t\t}\n\t}\n\treturn true;\n}\n\nexport { reprojectTexture };\n","import { Quat } from '../../core/math/quat.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { Vec4 } from '../../core/math/vec4.js';\nimport { GSplatData } from './gsplat-data.js';\n\nconst SH_C0 = 0.28209479177387814;\nclass SplatCompressedIterator {\n\tconstructor(gsplatData, p, r, s, c, sh) {\n\t\tconst unpackUnorm = (value, bits) => {\n\t\t\tconst t = (1 << bits) - 1;\n\t\t\treturn (value & t) / t;\n\t\t};\n\t\tconst unpack111011 = (result, value) => {\n\t\t\tresult.x = unpackUnorm(value >>> 21, 11);\n\t\t\tresult.y = unpackUnorm(value >>> 11, 10);\n\t\t\tresult.z = unpackUnorm(value, 11);\n\t\t};\n\t\tconst unpack8888 = (result, value) => {\n\t\t\tresult.x = unpackUnorm(value >>> 24, 8);\n\t\t\tresult.y = unpackUnorm(value >>> 16, 8);\n\t\t\tresult.z = unpackUnorm(value >>> 8, 8);\n\t\t\tresult.w = unpackUnorm(value, 8);\n\t\t};\n\t\tconst unpackRot = (result, value) => {\n\t\t\tconst norm = 1.0 / (Math.sqrt(2) * 0.5);\n\t\t\tconst a = (unpackUnorm(value >>> 20, 10) - 0.5) * norm;\n\t\t\tconst b = (unpackUnorm(value >>> 10, 10) - 0.5) * norm;\n\t\t\tconst c = (unpackUnorm(value, 10) - 0.5) * norm;\n\t\t\tconst m = Math.sqrt(1.0 - (a * a + b * b + c * c));\n\t\t\tswitch (value >>> 30) {\n\t\t\t\tcase 0:\n\t\t\t\t\tresult.set(a, b, c, m);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tresult.set(m, b, c, a);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tresult.set(b, m, c, a);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tresult.set(b, c, m, a);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\t\tconst lerp = (a, b, t) => {\n\t\t\treturn a === b ? a : a * (1 - t) + b * t;\n\t\t};\n\t\tconst {\n\t\t\tchunkData,\n\t\t\tchunkSize,\n\t\t\tvertexData,\n\t\t\tshData,\n\t\t\tshBands\n\t\t} = gsplatData;\n\t\tconst shCoeffs = [3, 8, 15][shBands - 1];\n\t\tthis.read = i => {\n\t\t\tconst ci = Math.floor(i / 256) * chunkSize;\n\t\t\tif (p) {\n\t\t\t\tunpack111011(p, vertexData[i * 4 + 0]);\n\t\t\t\tp.x = lerp(chunkData[ci + 0], chunkData[ci + 3], p.x);\n\t\t\t\tp.y = lerp(chunkData[ci + 1], chunkData[ci + 4], p.y);\n\t\t\t\tp.z = lerp(chunkData[ci + 2], chunkData[ci + 5], p.z);\n\t\t\t}\n\t\t\tif (r) {\n\t\t\t\tunpackRot(r, vertexData[i * 4 + 1]);\n\t\t\t}\n\t\t\tif (s) {\n\t\t\t\tunpack111011(s, vertexData[i * 4 + 2]);\n\t\t\t\ts.x = lerp(chunkData[ci + 6], chunkData[ci + 9], s.x);\n\t\t\t\ts.y = lerp(chunkData[ci + 7], chunkData[ci + 10], s.y);\n\t\t\t\ts.z = lerp(chunkData[ci + 8], chunkData[ci + 11], s.z);\n\t\t\t}\n\t\t\tif (c) {\n\t\t\t\tunpack8888(c, vertexData[i * 4 + 3]);\n\t\t\t\tif (chunkSize > 12) {\n\t\t\t\t\tc.x = lerp(chunkData[ci + 12], chunkData[ci + 15], c.x);\n\t\t\t\t\tc.y = lerp(chunkData[ci + 13], chunkData[ci + 16], c.y);\n\t\t\t\t\tc.z = lerp(chunkData[ci + 14], chunkData[ci + 17], c.z);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sh && shBands > 0) {\n\t\t\t\tfor (let j = 0; j < 3; ++j) {\n\t\t\t\t\tfor (let k = 0; k < 15; ++k) {\n\t\t\t\t\t\tsh[j * 15 + k] = k < shCoeffs ? shData[(i * 3 + j) * shCoeffs + k] * (8 / 255) - 4 : 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n}\nclass GSplatCompressedData {\n\tconstructor() {\n\t\tthis.numSplats = void 0;\n\t\tthis.chunkData = void 0;\n\t\tthis.vertexData = void 0;\n\t\tthis.shData = void 0;\n\t}\n\tcreateIter(p, r, s, c, sh) {\n\t\treturn new SplatCompressedIterator(this, p, r, s, c, sh);\n\t}\n\tcalcAabb(result) {\n\t\tconst {\n\t\t\tchunkData,\n\t\t\tnumChunks,\n\t\t\tchunkSize\n\t\t} = this;\n\t\tlet s = Math.exp(Math.max(chunkData[9], chunkData[10], chunkData[11]));\n\t\tlet mx = chunkData[0] - s;\n\t\tlet my = chunkData[1] - s;\n\t\tlet mz = chunkData[2] - s;\n\t\tlet Mx = chunkData[3] + s;\n\t\tlet My = chunkData[4] + s;\n\t\tlet Mz = chunkData[5] + s;\n\t\tfor (let i = 1; i < numChunks; ++i) {\n\t\t\tconst off = i * chunkSize;\n\t\t\ts = Math.exp(Math.max(chunkData[off + 9], chunkData[off + 10], chunkData[off + 11]));\n\t\t\tmx = Math.min(mx, chunkData[off + 0] - s);\n\t\t\tmy = Math.min(my, chunkData[off + 1] - s);\n\t\t\tmz = Math.min(mz, chunkData[off + 2] - s);\n\t\t\tMx = Math.max(Mx, chunkData[off + 3] + s);\n\t\t\tMy = Math.max(My, chunkData[off + 4] + s);\n\t\t\tMz = Math.max(Mz, chunkData[off + 5] + s);\n\t\t}\n\t\tresult.center.set((mx + Mx) * 0.5, (my + My) * 0.5, (mz + Mz) * 0.5);\n\t\tresult.halfExtents.set((Mx - mx) * 0.5, (My - my) * 0.5, (Mz - mz) * 0.5);\n\t\treturn true;\n\t}\n\tgetCenters(result) {\n\t\tconst {\n\t\t\tvertexData,\n\t\t\tchunkData,\n\t\t\tnumChunks,\n\t\t\tchunkSize\n\t\t} = this;\n\t\tlet mx, my, mz, Mx, My, Mz;\n\t\tfor (let c = 0; c < numChunks; ++c) {\n\t\t\tconst off = c * chunkSize;\n\t\t\tmx = chunkData[off + 0];\n\t\t\tmy = chunkData[off + 1];\n\t\t\tmz = chunkData[off + 2];\n\t\t\tMx = chunkData[off + 3];\n\t\t\tMy = chunkData[off + 4];\n\t\t\tMz = chunkData[off + 5];\n\t\t\tconst end = Math.min(this.numSplats, (c + 1) * 256);\n\t\t\tfor (let i = c * 256; i < end; ++i) {\n\t\t\t\tconst p = vertexData[i * 4];\n\t\t\t\tconst px = (p >>> 21) / 2047;\n\t\t\t\tconst py = (p >>> 11 & 0x3ff) / 1023;\n\t\t\t\tconst pz = (p & 0x7ff) / 2047;\n\t\t\t\tresult[i * 3 + 0] = (1 - px) * mx + px * Mx;\n\t\t\t\tresult[i * 3 + 1] = (1 - py) * my + py * My;\n\t\t\t\tresult[i * 3 + 2] = (1 - pz) * mz + pz * Mz;\n\t\t\t}\n\t\t}\n\t}\n\tcalcFocalPoint(result) {\n\t\tconst {\n\t\t\tchunkData,\n\t\t\tnumChunks,\n\t\t\tchunkSize\n\t\t} = this;\n\t\tresult.x = 0;\n\t\tresult.y = 0;\n\t\tresult.z = 0;\n\t\tfor (let i = 0; i < numChunks; ++i) {\n\t\t\tconst off = i * chunkSize;\n\t\t\tresult.x += chunkData[off + 0] + chunkData[off + 3];\n\t\t\tresult.y += chunkData[off + 1] + chunkData[off + 4];\n\t\t\tresult.z += chunkData[off + 2] + chunkData[off + 5];\n\t\t}\n\t\tresult.mulScalar(0.5 / numChunks);\n\t}\n\tget isCompressed() {\n\t\treturn true;\n\t}\n\tget numChunks() {\n\t\treturn Math.ceil(this.numSplats / 256);\n\t}\n\tget chunkSize() {\n\t\treturn this.chunkData.length / this.numChunks;\n\t}\n\tget shBands() {\n\t\tvar _sizes, _this$shData;\n\t\tconst sizes = {\n\t\t\t3: 1,\n\t\t\t8: 2,\n\t\t\t15: 3\n\t\t};\n\t\treturn (_sizes = sizes[((_this$shData = this.shData) == null ? void 0 : _this$shData.length) / this.numSplats / 3]) != null ? _sizes : 0;\n\t}\n\tdecompress() {\n\t\tconst members = ['x', 'y', 'z', 'f_dc_0', 'f_dc_1', 'f_dc_2', 'opacity', 'rot_0', 'rot_1', 'rot_2', 'rot_3', 'scale_0', 'scale_1', 'scale_2'];\n\t\tconst {\n\t\t\tshBands\n\t\t} = this;\n\t\tif (shBands > 0) {\n\t\t\tconst shMembers = [];\n\t\t\tfor (let i = 0; i < 45; ++i) {\n\t\t\t\tshMembers.push(`f_rest_${i}`);\n\t\t\t}\n\t\t\tmembers.splice(members.indexOf('f_dc_0') + 1, 0, ...shMembers);\n\t\t}\n\t\tconst data = {};\n\t\tmembers.forEach(name => {\n\t\t\tdata[name] = new Float32Array(this.numSplats);\n\t\t});\n\t\tconst p = new Vec3();\n\t\tconst r = new Quat();\n\t\tconst s = new Vec3();\n\t\tconst c = new Vec4();\n\t\tconst sh = shBands > 0 ? new Float32Array(45) : null;\n\t\tconst iter = this.createIter(p, r, s, c, sh);\n\t\tfor (let i = 0; i < this.numSplats; ++i) {\n\t\t\titer.read(i);\n\t\t\tdata.x[i] = p.x;\n\t\t\tdata.y[i] = p.y;\n\t\t\tdata.z[i] = p.z;\n\t\t\tdata.rot_1[i] = r.x;\n\t\t\tdata.rot_2[i] = r.y;\n\t\t\tdata.rot_3[i] = r.z;\n\t\t\tdata.rot_0[i] = r.w;\n\t\t\tdata.scale_0[i] = s.x;\n\t\t\tdata.scale_1[i] = s.y;\n\t\t\tdata.scale_2[i] = s.z;\n\t\t\tdata.f_dc_0[i] = (c.x - 0.5) / SH_C0;\n\t\t\tdata.f_dc_1[i] = (c.y - 0.5) / SH_C0;\n\t\t\tdata.f_dc_2[i] = (c.z - 0.5) / SH_C0;\n\t\t\tdata.opacity[i] = c.w <= 0 ? -40 : c.w >= 1 ? 40 : -Math.log(1 / c.w - 1);\n\t\t\tif (sh) {\n\t\t\t\tfor (let _c = 0; _c < 45; ++_c) {\n\t\t\t\t\tdata[`f_rest_${_c}`][i] = sh[_c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new GSplatData([{\n\t\t\tname: 'vertex',\n\t\t\tcount: this.numSplats,\n\t\t\tproperties: members.map(name => {\n\t\t\t\treturn {\n\t\t\t\t\tname: name,\n\t\t\t\t\ttype: 'float',\n\t\t\t\t\tbyteSize: 4,\n\t\t\t\t\tstorage: data[name]\n\t\t\t\t};\n\t\t\t})\n\t\t}]);\n\t}\n}\n\nexport { GSplatCompressedData };\n","import { CULLFACE_NONE, SEMANTIC_POSITION, SEMANTIC_ATTR13 } from '../../platform/graphics/constants.js';\nimport { ShaderProcessorOptions } from '../../platform/graphics/shader-processor-options.js';\nimport { DITHER_NONE, BLEND_NONE, BLEND_NORMAL, SHADER_FORWARDHDR, GAMMA_SRGBHDR, GAMMA_NONE, TONEMAP_LINEAR } from '../constants.js';\nimport { Material } from '../materials/material.js';\nimport { getProgramLibrary } from '../shader-lib/get-program-library.js';\nimport { hashCode } from '../../core/hash.js';\nimport { ShaderUtils } from '../../platform/graphics/shader-utils.js';\nimport { shaderChunks } from '../shader-lib/chunks/chunks.js';\nimport { ShaderGenerator } from '../shader-lib/programs/shader-generator.js';\nimport { ShaderPass } from '../shader-pass.js';\n\nconst splatCoreVS = `\n\tuniform mat4 matrix_model;\n\tuniform mat4 matrix_view;\n\tuniform mat4 matrix_projection;\n\tuniform vec2 viewport;\n\tuniform vec4 tex_params;\n\tuniform highp usampler2D splatOrder;\n\tuniform highp usampler2D packedTexture;\n\tuniform highp sampler2D chunkTexture;\n\tattribute vec3 vertex_position;\n\tattribute uint vertex_id_attrib;\n\t#ifndef DITHER_NONE\n\t\tvarying float id;\n\t#endif\n\tuint orderId;\n\tuint splatId;\n\tivec2 packedUV;\n\tivec2 chunkUV;\n\tvec4 chunkDataA;\n\tvec4 chunkDataB;\n\tvec4 chunkDataC;\n\tvec4 chunkDataD;\n\tvec4 chunkDataE;\n\tuvec4 packedData;\n\tbool calcSplatUV() {\n\t\tuint numSplats = uint(tex_params.x);\n\t\tuint packedWidth = uint(tex_params.y);\n\t\tuint chunkWidth = uint(tex_params.z);\n\t\torderId = vertex_id_attrib + uint(vertex_position.z);\n\t\tif (orderId >= numSplats) {\n\t\t\treturn false;\n\t\t}\n\t\tivec2 orderUV = ivec2(\n\t\t\tint(orderId % packedWidth),\n\t\t\tint(orderId / packedWidth)\n\t\t);\n\t\tsplatId = texelFetch(splatOrder, orderUV, 0).r;\n\t\tpackedUV = ivec2(\n\t\t\tint(splatId % packedWidth),\n\t\t\tint(splatId / packedWidth)\n\t\t);\n\t\tuint chunkId = splatId / 256u;\n\t\tchunkUV = ivec2(\n\t\t\tint((chunkId % chunkWidth) * 5u),\n\t\t\tint(chunkId / chunkWidth)\n\t\t);\n\t\treturn true;\n\t}\n\tvoid readData() {\n\t\tchunkDataA = texelFetch(chunkTexture, chunkUV, 0);\n\t\tchunkDataB = texelFetch(chunkTexture, ivec2(chunkUV.x + 1, chunkUV.y), 0);\n\t\tchunkDataC = texelFetch(chunkTexture, ivec2(chunkUV.x + 2, chunkUV.y), 0);\n\t\tchunkDataD = texelFetch(chunkTexture, ivec2(chunkUV.x + 3, chunkUV.y), 0);\n\t\tchunkDataE = texelFetch(chunkTexture, ivec2(chunkUV.x + 4, chunkUV.y), 0);\n\t\tpackedData = texelFetch(packedTexture, packedUV, 0);\n\t}\n\tvec3 unpack111011(uint bits) {\n\t\treturn vec3(\n\t\t\tfloat(bits >> 21u) / 2047.0,\n\t\t\tfloat((bits >> 11u) & 0x3ffu) / 1023.0,\n\t\t\tfloat(bits & 0x7ffu) / 2047.0\n\t\t);\n\t}\n\tvec4 unpack8888(uint bits) {\n\t\treturn vec4(\n\t\t\tfloat(bits >> 24u) / 255.0,\n\t\t\tfloat((bits >> 16u) & 0xffu) / 255.0,\n\t\t\tfloat((bits >> 8u) & 0xffu) / 255.0,\n\t\t\tfloat(bits & 0xffu) / 255.0\n\t\t);\n\t}\n\tfloat norm = 1.0 / (sqrt(2.0) * 0.5);\n\tvec4 unpackRotation(uint bits) {\n\t\tfloat a = (float((bits >> 20u) & 0x3ffu) / 1023.0 - 0.5) * norm;\n\t\tfloat b = (float((bits >> 10u) & 0x3ffu) / 1023.0 - 0.5) * norm;\n\t\tfloat c = (float(bits & 0x3ffu) / 1023.0 - 0.5) * norm;\n\t\tfloat m = sqrt(1.0 - (a * a + b * b + c * c));\n\t\tuint mode = bits >> 30u;\n\t\tif (mode == 0u) return vec4(m, a, b, c);\n\t\tif (mode == 1u) return vec4(a, m, b, c);\n\t\tif (mode == 2u) return vec4(a, b, m, c);\n\t\treturn vec4(a, b, c, m);\n\t}\n\tvec3 getCenter() {\n\t\treturn mix(chunkDataA.xyz, vec3(chunkDataA.w, chunkDataB.xy), unpack111011(packedData.x));\n\t}\n\tvec4 getRotation() {\n\t\treturn unpackRotation(packedData.y);\n\t}\n\tvec3 getScale() {\n\t\treturn exp(mix(vec3(chunkDataB.zw, chunkDataC.x), chunkDataC.yzw, unpack111011(packedData.z)));\n\t}\n\tvec4 getColor() {\n\t\tvec4 r = unpack8888(packedData.w);\n\t\treturn vec4(mix(chunkDataD.xyz, vec3(chunkDataD.w, chunkDataE.xy), r.rgb), r.w);\n\t}\n\tmat3 quatToMat3(vec4 R) {\n\t\tfloat x = R.x;\n\t\tfloat y = R.y;\n\t\tfloat z = R.z;\n\t\tfloat w = R.w;\n\t\treturn mat3(\n\t\t\t1.0 - 2.0 * (z * z + w * w),\n\t\t\t\t  2.0 * (y * z + x * w),\n\t\t\t\t  2.0 * (y * w - x * z),\n\t\t\t\t  2.0 * (y * z - x * w),\n\t\t\t1.0 - 2.0 * (y * y + w * w),\n\t\t\t\t  2.0 * (z * w + x * y),\n\t\t\t\t  2.0 * (y * w + x * z),\n\t\t\t\t  2.0 * (z * w - x * y),\n\t\t\t1.0 - 2.0 * (y * y + z * z)\n\t\t);\n\t}\n\tvoid getCovariance(out vec3 covA, out vec3 covB) {\n\t\tmat3 rot = quatToMat3(getRotation());\n\t\tvec3 scale = getScale();\n\t\tmat3 M = transpose(mat3(\n\t\t\tscale.x * rot[0],\n\t\t\tscale.y * rot[1],\n\t\t\tscale.z * rot[2]\n\t\t));\n\t\tcovA = vec3(dot(M[0], M[0]), dot(M[0], M[1]), dot(M[0], M[2]));\n\t\tcovB = vec3(dot(M[1], M[1]), dot(M[1], M[2]), dot(M[2], M[2]));\n\t}\n\tvec4 calcV1V2(in vec3 splat_cam, in vec3 covA, in vec3 covB, mat3 W) {\n\t\tmat3 Vrk = mat3(\n\t\t\tcovA.x, covA.y, covA.z, \n\t\t\tcovA.y, covB.x, covB.y,\n\t\t\tcovA.z, covB.y, covB.z\n\t\t);\n\t\tfloat focal = viewport.x * matrix_projection[0][0];\n\t\tfloat J1 = focal / splat_cam.z;\n\t\tvec2 J2 = -J1 / splat_cam.z * splat_cam.xy;\n\t\tmat3 J = mat3(\n\t\t\tJ1, 0.0, J2.x, \n\t\t\t0.0, J1, J2.y, \n\t\t\t0.0, 0.0, 0.0\n\t\t);\n\t\tmat3 T = W * J;\n\t\tmat3 cov = transpose(T) * Vrk * T;\n\t\tfloat diagonal1 = cov[0][0] + 0.3;\n\t\tfloat offDiagonal = cov[0][1];\n\t\tfloat diagonal2 = cov[1][1] + 0.3;\n\t\tfloat mid = 0.5 * (diagonal1 + diagonal2);\n\t\tfloat radius = length(vec2((diagonal1 - diagonal2) / 2.0, offDiagonal));\n\t\tfloat lambda1 = mid + radius;\n\t\tfloat lambda2 = max(mid - radius, 0.1);\n\t\tvec2 diagonalVector = normalize(vec2(offDiagonal, lambda1 - diagonal1));\n\t\tvec2 v1 = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;\n\t\tvec2 v2 = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);\n\t\treturn vec4(v1, v2);\n\t}\n#if defined(USE_SH)\n\t#define SH_C1 0.4886025119029199f\n\t#define SH_C2_0 1.0925484305920792f\n\t#define SH_C2_1 -1.0925484305920792f\n\t#define SH_C2_2 0.31539156525252005f\n\t#define SH_C2_3 -1.0925484305920792f\n\t#define SH_C2_4 0.5462742152960396f\n\t#define SH_C3_0 -0.5900435899266435f\n\t#define SH_C3_1 2.890611442640554f\n\t#define SH_C3_2 -0.4570457994644658f\n\t#define SH_C3_3 0.3731763325901154f\n\t#define SH_C3_4 -0.4570457994644658f\n\t#define SH_C3_5 1.445305721320277f\n\t#define SH_C3_6 -0.5900435899266435f\n\tuniform highp usampler2D shTexture0;\n\tuniform highp usampler2D shTexture1;\n\tuniform highp usampler2D shTexture2;\n\tvec4 sunpack8888(in uint bits) {\n\t\treturn vec4((uvec4(bits) >> uvec4(0u, 8u, 16u, 24u)) & 0xffu) * (8.0 / 255.0) - 4.0;\n\t}\n\tvoid readSHData(out vec3 sh[15]) {\n\t\tuvec4 shData0 = texelFetch(shTexture0, packedUV, 0);\n\t\tuvec4 shData1 = texelFetch(shTexture1, packedUV, 0);\n\t\tuvec4 shData2 = texelFetch(shTexture2, packedUV, 0);\n\t\tvec4 r0 = sunpack8888(shData0.x);\n\t\tvec4 r1 = sunpack8888(shData0.y);\n\t\tvec4 r2 = sunpack8888(shData0.z);\n\t\tvec4 r3 = sunpack8888(shData0.w);\n\t\tvec4 g0 = sunpack8888(shData1.x);\n\t\tvec4 g1 = sunpack8888(shData1.y);\n\t\tvec4 g2 = sunpack8888(shData1.z);\n\t\tvec4 g3 = sunpack8888(shData1.w);\n\t\tvec4 b0 = sunpack8888(shData2.x);\n\t\tvec4 b1 = sunpack8888(shData2.y);\n\t\tvec4 b2 = sunpack8888(shData2.z);\n\t\tvec4 b3 = sunpack8888(shData2.w);\n\t\tsh[0] =  vec3(r0.x, g0.x, b0.x);\n\t\tsh[1] =  vec3(r0.y, g0.y, b0.y);\n\t\tsh[2] =  vec3(r0.z, g0.z, b0.z);\n\t\tsh[3] =  vec3(r0.w, g0.w, b0.w);\n\t\tsh[4] =  vec3(r1.x, g1.x, b1.x);\n\t\tsh[5] =  vec3(r1.y, g1.y, b1.y);\n\t\tsh[6] =  vec3(r1.z, g1.z, b1.z);\n\t\tsh[7] =  vec3(r1.w, g1.w, b1.w);\n\t\tsh[8] =  vec3(r2.x, g2.x, b2.x);\n\t\tsh[9] =  vec3(r2.y, g2.y, b2.y);\n\t\tsh[10] = vec3(r2.z, g2.z, b2.z);\n\t\tsh[11] = vec3(r2.w, g2.w, b2.w);\n\t\tsh[12] = vec3(r3.x, g3.x, b3.x);\n\t\tsh[13] = vec3(r3.y, g3.y, b3.y);\n\t\tsh[14] = vec3(r3.z, g3.z, b3.z);\n\t}\n\tvec3 evalSH(in vec3 dir) {\n\t\tvec3 sh[15];\n\t\treadSHData(sh);\n\t\tvec3 result = vec3(0.0);\n\t\tfloat x = dir.x;\n\t\tfloat y = dir.y;\n\t\tfloat z = dir.z;\n\t\tresult += SH_C1 * (-sh[0] * y + sh[1] * z - sh[2] * x);\n\t\tfloat xx = x * x;\n\t\tfloat yy = y * y;\n\t\tfloat zz = z * z;\n\t\tfloat xy = x * y;\n\t\tfloat yz = y * z;\n\t\tfloat xz = x * z;\n\t\tresult +=\n\t\t\tsh[3] * (SH_C2_0 * xy) *  +\n\t\t\tsh[4] * (SH_C2_1 * yz) +\n\t\t\tsh[5] * (SH_C2_2 * (2.0 * zz - xx - yy)) +\n\t\t\tsh[6] * (SH_C2_3 * xz) +\n\t\t\tsh[7] * (SH_C2_4 * (xx - yy));\n\t\tresult +=\n\t\t\tsh[8]  * (SH_C3_0 * y * (3.0 * xx - yy)) +\n\t\t\tsh[9]  * (SH_C3_1 * xy * z) +\n\t\t\tsh[10] * (SH_C3_2 * y * (4.0 * zz - xx - yy)) +\n\t\t\tsh[11] * (SH_C3_3 * z * (2.0 * zz - 3.0 * xx - 3.0 * yy)) +\n\t\t\tsh[12] * (SH_C3_4 * x * (4.0 * zz - xx - yy)) +\n\t\t\tsh[13] * (SH_C3_5 * z * (xx - yy)) +\n\t\t\tsh[14] * (SH_C3_6 * x * (xx - 3.0 * yy));\n\t\treturn result;\n\t}\n#else\n\tvec3 evalSH(in vec3 dir) {\n\t\treturn vec3(0.0);\n\t}\n#endif\n`;\nconst splatCoreFS = `\n\t#ifndef DITHER_NONE\n\t\tvarying float id;\n\t#endif\n\t#ifdef PICK_PASS\n\t\tuniform vec4 uColor;\n\t#endif\n\tvec4 evalSplat(vec2 texCoord, vec4 color) {\n\t\tmediump float A = dot(texCoord, texCoord);\n\t\tif (A > 1.0) {\n\t\t\tdiscard;\n\t\t}\n\t\tmediump float B = exp(-A * 4.0) * color.a;\n\t\tif (B < 1.0 / 255.0) {\n\t\t\tdiscard;\n\t\t}\n\t\t#ifdef PICK_PASS\n\t\t\tif (B < 0.3) {\n\t\t\t\tdiscard;\n\t\t\t}\n\t\t\treturn uColor;\n\t\t#endif\n\t\t#ifndef DITHER_NONE\n\t\t\topacityDither(B, id * 0.013);\n\t\t#endif\n\t\t#ifdef TONEMAP_ENABLED\n\t\t\treturn vec4(gammaCorrectOutput(toneMap(decodeGamma(color.rgb))), B);\n\t\t#else\n\t\t\treturn vec4(color.rgb, B);\n\t\t#endif\n\t}\n`;\nclass GSplatCompressedShaderGenerator {\n\tgenerateKey(options) {\n\t\tvar _options$defines$sort, _options$defines;\n\t\tconst vsHash = hashCode(options.vertex);\n\t\tconst fsHash = hashCode(options.fragment);\n\t\tconst defines = (_options$defines$sort = (_options$defines = options.defines) == null ? void 0 : _options$defines.sort().join('-')) != null ? _options$defines$sort : '';\n\t\treturn `splat-${options.pass}-${options.gamma}-${options.toneMapping}-${vsHash}-${fsHash}-${options.dither}-${defines}`;\n\t}\n\tcreateShaderDefinition(device, options) {\n\t\tvar _options$defines2;\n\t\tconst shaderPassInfo = ShaderPass.get(device).getByIndex(options.pass);\n\t\tconst shaderPassDefines = shaderPassInfo.shaderDefines;\n\t\tconst optionDefines = ((_options$defines2 = options.defines) != null ? _options$defines2 : []).map(d => `#define ${d}`).join('\\n');\n\t\tconst defines = `${shaderPassDefines}\\n` + `${optionDefines}\\n` + `#define DITHER_${options.dither.toUpperCase()}\\n` + `#define TONEMAP_${options.toneMapping === TONEMAP_LINEAR ? 'DISABLED' : 'ENABLED'}\\n`;\n\t\tconst vs = defines + splatCoreVS + options.vertex;\n\t\tconst fs = defines + shaderChunks.decodePS + (options.dither === DITHER_NONE ? '' : shaderChunks.bayerPS + shaderChunks.opacityDitherPS) + ShaderGenerator.tonemapCode(options.toneMapping) + ShaderGenerator.gammaCode(options.gamma) + splatCoreFS + options.fragment;\n\t\treturn ShaderUtils.createDefinition(device, {\n\t\t\tname: 'SplatShader',\n\t\t\tattributes: {\n\t\t\t\tvertex_position: SEMANTIC_POSITION,\n\t\t\t\tvertex_id_attrib: SEMANTIC_ATTR13\n\t\t\t},\n\t\t\tvertexCode: vs,\n\t\t\tfragmentCode: fs\n\t\t});\n\t}\n}\nconst gsplatCompressed = new GSplatCompressedShaderGenerator();\nconst splatMainVS = `\n\tvarying mediump vec2 texCoord;\n\tvarying mediump vec4 color;\n\tuniform vec3 view_position;\n\tmediump vec4 discardVec = vec4(0.0, 0.0, 2.0, 1.0);\n\tvoid main(void)\n\t{\n\t\tif (!calcSplatUV()) {\n\t\t\tgl_Position = discardVec;\n\t\t\treturn;\n\t\t}\n\t\treadData();\n\t\tvec3 center = getCenter();\n\t\tmat4 model_view = matrix_view * matrix_model;\n\t\tvec4 splat_cam = model_view * vec4(center, 1.0);\n\t\tvec4 splat_proj = matrix_projection * splat_cam;\n\t\tif (splat_proj.z < -splat_proj.w) {\n\t\t\tgl_Position = discardVec;\n\t\t\treturn;\n\t\t}\n\t\tvec3 covA, covB;\n\t\tgetCovariance(covA, covB);\n\t\tvec4 v1v2 = calcV1V2(splat_cam.xyz, covA, covB, transpose(mat3(model_view)));\n\t\tcolor = getColor();\n\t\tfloat scale = min(1.0, sqrt(-log(1.0 / 255.0 / color.a)) / 2.0);\n\t\tv1v2 *= scale;\n\t\tif (dot(v1v2.xy, v1v2.xy) < 4.0 && dot(v1v2.zw, v1v2.zw) < 4.0) {\n\t\t\tgl_Position = discardVec;\n\t\t\treturn;\n\t\t}\n\t\tgl_Position = splat_proj + vec4((vertex_position.x * v1v2.xy + vertex_position.y * v1v2.zw) / viewport * splat_proj.w, 0, 0);\n\t\ttexCoord = vertex_position.xy * scale / 2.0;\n\t\t#ifdef USE_SH\n\t\t\tvec4 worldCenter = matrix_model * vec4(center, 1.0);\n\t\t\tvec3 viewDir = normalize((worldCenter.xyz / worldCenter.w - view_position) * mat3(matrix_model));\n\t\t\tcolor.xyz = max(color.xyz + evalSH(viewDir), 0.0);\n\t\t#endif\n\t\t#ifndef DITHER_NONE\n\t\t\tid = float(splatId);\n\t\t#endif\n\t}\n`;\nconst splatMainFS = `\n\tvarying mediump vec2 texCoord;\n\tvarying mediump vec4 color;\n\tvoid main(void)\n\t{\n\t\tgl_FragColor = evalSplat(texCoord, color);\n\t}\n`;\nconst createGSplatCompressedMaterial = (options = {}) => {\n\tvar _options$dither;\n\tconst ditherEnum = (_options$dither = options.dither) != null ? _options$dither : DITHER_NONE;\n\tconst dither = ditherEnum !== DITHER_NONE;\n\tconst material = new Material();\n\tmaterial.name = 'compressedSplatMaterial';\n\tmaterial.cull = CULLFACE_NONE;\n\tmaterial.blendType = dither ? BLEND_NONE : BLEND_NORMAL;\n\tmaterial.depthWrite = dither;\n\tmaterial.getShaderVariant = function (device, scene, defs, unused, pass, sortedLights, viewUniformFormat, viewBindGroupFormat) {\n\t\tvar _options$vertex, _options$fragment;\n\t\tconst programOptions = {\n\t\t\tpass: pass,\n\t\t\tgamma: pass === SHADER_FORWARDHDR ? scene.gammaCorrection ? GAMMA_SRGBHDR : GAMMA_NONE : scene.gammaCorrection,\n\t\t\ttoneMapping: pass === SHADER_FORWARDHDR ? TONEMAP_LINEAR : scene.toneMapping,\n\t\t\tvertex: (_options$vertex = options.vertex) != null ? _options$vertex : splatMainVS,\n\t\t\tfragment: (_options$fragment = options.fragment) != null ? _options$fragment : splatMainFS,\n\t\t\tdither: ditherEnum,\n\t\t\tdefines: options.defines\n\t\t};\n\t\tconst processingOptions = new ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat);\n\t\tconst library = getProgramLibrary(device);\n\t\tlibrary.register('splat-compressed', gsplatCompressed);\n\t\treturn library.getProgram('splat-compressed', programOptions, processingOptions);\n\t};\n\tmaterial.update();\n\treturn material;\n};\n\nexport { createGSplatCompressedMaterial };\n","import { extends as _extends } from '../../../_virtual/_rollupPluginBabelHelpers.js';\nimport { Vec2 } from '../../core/math/vec2.js';\nimport { PIXELFORMAT_RGBA32U, PIXELFORMAT_RGBA32F, FILTER_NEAREST, ADDRESS_CLAMP_TO_EDGE } from '../../platform/graphics/constants.js';\nimport { Texture } from '../../platform/graphics/texture.js';\nimport { BoundingBox } from '../../core/shape/bounding-box.js';\nimport { createGSplatCompressedMaterial } from './gsplat-compressed-material.js';\n\nconst strideCopy = (target, targetStride, src, srcStride, numEntries) => {\n\tfor (let i = 0; i < numEntries; ++i) {\n\t\tfor (let j = 0; j < srcStride; ++j) {\n\t\t\ttarget[i * targetStride + j] = src[i * srcStride + j];\n\t\t}\n\t}\n};\nclass GSplatCompressed {\n\tconstructor(device, gsplatData) {\n\t\tthis.device = void 0;\n\t\tthis.numSplats = void 0;\n\t\tthis.aabb = void 0;\n\t\tthis.centers = void 0;\n\t\tthis.packedTexture = void 0;\n\t\tthis.chunkTexture = void 0;\n\t\tthis.shTexture0 = void 0;\n\t\tthis.shTexture1 = void 0;\n\t\tthis.shTexture2 = void 0;\n\t\tconst {\n\t\t\tchunkData,\n\t\t\tchunkSize,\n\t\t\tnumChunks,\n\t\t\tnumSplats,\n\t\t\tvertexData,\n\t\t\tshBands\n\t\t} = gsplatData;\n\t\tthis.device = device;\n\t\tthis.numSplats = numSplats;\n\t\tthis.aabb = new BoundingBox();\n\t\tgsplatData.calcAabb(this.aabb);\n\t\tthis.centers = new Float32Array(numSplats * 3);\n\t\tgsplatData.getCenters(this.centers);\n\t\tthis.packedTexture = this.createTexture('packedData', PIXELFORMAT_RGBA32U, this.evalTextureSize(numSplats), vertexData);\n\t\tconst chunkTextureSize = this.evalTextureSize(numChunks);\n\t\tchunkTextureSize.x *= 5;\n\t\tthis.chunkTexture = this.createTexture('chunkData', PIXELFORMAT_RGBA32F, chunkTextureSize);\n\t\tconst chunkTextureData = this.chunkTexture.lock();\n\t\tstrideCopy(chunkTextureData, 20, chunkData, chunkSize, numChunks);\n\t\tif (chunkSize === 12) {\n\t\t\tfor (let i = 0; i < numChunks; ++i) {\n\t\t\t\tchunkTextureData[i * 20 + 15] = 1;\n\t\t\t\tchunkTextureData[i * 20 + 16] = 1;\n\t\t\t\tchunkTextureData[i * 20 + 17] = 1;\n\t\t\t}\n\t\t}\n\t\tthis.chunkTexture.unlock();\n\t\tif (shBands > 0) {\n\t\t\tconst {\n\t\t\t\tshData\n\t\t\t} = gsplatData;\n\t\t\tconst size = this.evalTextureSize(numSplats);\n\t\t\tconst texture0 = this.createTexture('shTexture0', PIXELFORMAT_RGBA32U, size);\n\t\t\tconst texture1 = this.createTexture('shTexture1', PIXELFORMAT_RGBA32U, size);\n\t\t\tconst texture2 = this.createTexture('shTexture2', PIXELFORMAT_RGBA32U, size);\n\t\t\tconst data0 = texture0.lock();\n\t\t\tconst data1 = texture1.lock();\n\t\t\tconst data2 = texture2.lock();\n\t\t\tconst target0 = new Uint8Array(data0.buffer);\n\t\t\tconst target1 = new Uint8Array(data1.buffer);\n\t\t\tconst target2 = new Uint8Array(data2.buffer);\n\t\t\tconst srcCoeffs = [3, 8, 15][shBands - 1];\n\t\t\tfor (let i = 0; i < numSplats; ++i) {\n\t\t\t\tfor (let j = 0; j < 15; ++j) {\n\t\t\t\t\ttarget0[i * 16 + j] = j < srcCoeffs ? shData[(i * 3 + 0) * srcCoeffs + j] : 127;\n\t\t\t\t\ttarget1[i * 16 + j] = j < srcCoeffs ? shData[(i * 3 + 1) * srcCoeffs + j] : 127;\n\t\t\t\t\ttarget2[i * 16 + j] = j < srcCoeffs ? shData[(i * 3 + 2) * srcCoeffs + j] : 127;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttexture0.unlock();\n\t\t\ttexture1.unlock();\n\t\t\ttexture2.unlock();\n\t\t\tthis.shTexture0 = texture0;\n\t\t\tthis.shTexture1 = texture1;\n\t\t\tthis.shTexture2 = texture2;\n\t\t} else {\n\t\t\tthis.shTexture0 = null;\n\t\t\tthis.shTexture1 = null;\n\t\t\tthis.shTexture2 = null;\n\t\t}\n\t}\n\tdestroy() {\n\t\tvar _this$packedTexture, _this$chunkTexture, _this$shTexture, _this$shTexture2, _this$shTexture3;\n\t\t(_this$packedTexture = this.packedTexture) == null || _this$packedTexture.destroy();\n\t\t(_this$chunkTexture = this.chunkTexture) == null || _this$chunkTexture.destroy();\n\t\t(_this$shTexture = this.shTexture0) == null || _this$shTexture.destroy();\n\t\t(_this$shTexture2 = this.shTexture1) == null || _this$shTexture2.destroy();\n\t\t(_this$shTexture3 = this.shTexture2) == null || _this$shTexture3.destroy();\n\t}\n\tcreateMaterial(options) {\n\t\tconst hasSH = this.shTexture0 !== null;\n\t\tconst result = createGSplatCompressedMaterial(_extends({}, hasSH ? {\n\t\t\tdefines: ['USE_SH']\n\t\t} : {}, options));\n\t\tresult.setParameter('packedTexture', this.packedTexture);\n\t\tresult.setParameter('chunkTexture', this.chunkTexture);\n\t\tresult.setParameter('tex_params', new Float32Array([this.numSplats, this.packedTexture.width, this.chunkTexture.width / 5, 0]));\n\t\tif (hasSH) {\n\t\t\tresult.setParameter('shTexture0', this.shTexture0);\n\t\t\tresult.setParameter('shTexture1', this.shTexture1);\n\t\t\tresult.setParameter('shTexture2', this.shTexture2);\n\t\t}\n\t\treturn result;\n\t}\n\tevalTextureSize(count) {\n\t\tconst width = Math.ceil(Math.sqrt(count));\n\t\tconst height = Math.ceil(count / width);\n\t\treturn new Vec2(width, height);\n\t}\n\tcreateTexture(name, format, size, data) {\n\t\treturn new Texture(this.device, _extends({\n\t\t\tname: name,\n\t\t\twidth: size.x,\n\t\t\theight: size.y,\n\t\t\tformat: format,\n\t\t\tcubemap: false,\n\t\t\tmipmaps: false,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t\t}, data ? {\n\t\t\tlevels: [data]\n\t\t} : {}));\n\t}\n}\n\nexport { GSplatCompressed };\n","import { Color } from '../../core/math/color.js';\nimport { Mat4 } from '../../core/math/mat4.js';\nimport { Quat } from '../../core/math/quat.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { BoundingBox } from '../../core/shape/bounding-box.js';\n\nconst mat4 = new Mat4();\nconst quat = new Quat();\nconst aabb = new BoundingBox();\nconst aabb2 = new BoundingBox();\nconst debugColor = new Color(1, 1, 0, 0.4);\nconst SH_C0 = 0.28209479177387814;\nclass SplatIterator {\n\tconstructor(gsplatData, p, r, s, c) {\n\t\tconst x = gsplatData.getProp('x');\n\t\tconst y = gsplatData.getProp('y');\n\t\tconst z = gsplatData.getProp('z');\n\t\tconst rx = gsplatData.getProp('rot_1');\n\t\tconst ry = gsplatData.getProp('rot_2');\n\t\tconst rz = gsplatData.getProp('rot_3');\n\t\tconst rw = gsplatData.getProp('rot_0');\n\t\tconst sx = gsplatData.getProp('scale_0');\n\t\tconst sy = gsplatData.getProp('scale_1');\n\t\tconst sz = gsplatData.getProp('scale_2');\n\t\tconst cr = gsplatData.getProp('f_dc_0');\n\t\tconst cg = gsplatData.getProp('f_dc_1');\n\t\tconst cb = gsplatData.getProp('f_dc_2');\n\t\tconst ca = gsplatData.getProp('opacity');\n\t\tconst sigmoid = v => {\n\t\t\tif (v > 0) {\n\t\t\t\treturn 1 / (1 + Math.exp(-v));\n\t\t\t}\n\t\t\tconst t = Math.exp(v);\n\t\t\treturn t / (1 + t);\n\t\t};\n\t\tthis.read = i => {\n\t\t\tif (p) {\n\t\t\t\tp.x = x[i];\n\t\t\t\tp.y = y[i];\n\t\t\t\tp.z = z[i];\n\t\t\t}\n\t\t\tif (r) {\n\t\t\t\tr.set(rx[i], ry[i], rz[i], rw[i]);\n\t\t\t}\n\t\t\tif (s) {\n\t\t\t\ts.set(Math.exp(sx[i]), Math.exp(sy[i]), Math.exp(sz[i]));\n\t\t\t}\n\t\t\tif (c) {\n\t\t\t\tc.set(0.5 + cr[i] * SH_C0, 0.5 + cg[i] * SH_C0, 0.5 + cb[i] * SH_C0, sigmoid(ca[i]));\n\t\t\t}\n\t\t};\n\t}\n}\nconst calcSplatMat = (result, p, r) => {\n\tquat.set(r.x, r.y, r.z, r.w).normalize();\n\tresult.setTRS(p, quat, Vec3.ONE);\n};\nclass GSplatData {\n\tconstructor(elements) {\n\t\tthis.elements = void 0;\n\t\tthis.numSplats = void 0;\n\t\tthis.elements = elements;\n\t\tthis.numSplats = this.getElement('vertex').count;\n\t}\n\tstatic calcSplatAabb(result, p, r, s) {\n\t\tcalcSplatMat(mat4, p, r);\n\t\taabb.center.set(0, 0, 0);\n\t\taabb.halfExtents.set(s.x * 2, s.y * 2, s.z * 2);\n\t\tresult.setFromTransformedAabb(aabb, mat4);\n\t}\n\tgetProp(name, elementName = 'vertex') {\n\t\tvar _this$getElement;\n\t\treturn (_this$getElement = this.getElement(elementName)) == null || (_this$getElement = _this$getElement.properties.find(p => p.name === name)) == null ? void 0 : _this$getElement.storage;\n\t}\n\tgetElement(name) {\n\t\treturn this.elements.find(e => e.name === name);\n\t}\n\taddProp(name, storage) {\n\t\tthis.getElement('vertex').properties.push({\n\t\t\ttype: 'float',\n\t\t\tname,\n\t\t\tstorage,\n\t\t\tbyteSize: 4\n\t\t});\n\t}\n\tcreateIter(p, r, s, c) {\n\t\treturn new SplatIterator(this, p, r, s, c);\n\t}\n\tcalcAabb(result, pred) {\n\t\tlet mx, my, mz, Mx, My, Mz;\n\t\tlet first = true;\n\t\tconst x = this.getProp('x');\n\t\tconst y = this.getProp('y');\n\t\tconst z = this.getProp('z');\n\t\tconst sx = this.getProp('scale_0');\n\t\tconst sy = this.getProp('scale_1');\n\t\tconst sz = this.getProp('scale_2');\n\t\tfor (let i = 0; i < this.numSplats; ++i) {\n\t\t\tif (pred && !pred(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst scaleVal = 2.0 * Math.exp(Math.max(sx[i], sy[i], sz[i]));\n\t\t\tconst px = x[i];\n\t\t\tconst py = y[i];\n\t\t\tconst pz = z[i];\n\t\t\tif (first) {\n\t\t\t\tfirst = false;\n\t\t\t\tmx = px - scaleVal;\n\t\t\t\tmy = py - scaleVal;\n\t\t\t\tmz = pz - scaleVal;\n\t\t\t\tMx = px + scaleVal;\n\t\t\t\tMy = py + scaleVal;\n\t\t\t\tMz = pz + scaleVal;\n\t\t\t} else {\n\t\t\t\tmx = Math.min(mx, px - scaleVal);\n\t\t\t\tmy = Math.min(my, py - scaleVal);\n\t\t\t\tmz = Math.min(mz, pz - scaleVal);\n\t\t\t\tMx = Math.max(Mx, px + scaleVal);\n\t\t\t\tMy = Math.max(My, py + scaleVal);\n\t\t\t\tMz = Math.max(Mz, pz + scaleVal);\n\t\t\t}\n\t\t}\n\t\tif (!first) {\n\t\t\tresult.center.set((mx + Mx) * 0.5, (my + My) * 0.5, (mz + Mz) * 0.5);\n\t\t\tresult.halfExtents.set((Mx - mx) * 0.5, (My - my) * 0.5, (Mz - mz) * 0.5);\n\t\t}\n\t\treturn !first;\n\t}\n\tcalcAabbExact(result, pred) {\n\t\tconst p = new Vec3();\n\t\tconst r = new Quat();\n\t\tconst s = new Vec3();\n\t\tconst iter = this.createIter(p, r, s);\n\t\tlet first = true;\n\t\tfor (let i = 0; i < this.numSplats; ++i) {\n\t\t\tif (pred && !pred(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\titer.read(i);\n\t\t\tif (first) {\n\t\t\t\tfirst = false;\n\t\t\t\tGSplatData.calcSplatAabb(result, p, r, s);\n\t\t\t} else {\n\t\t\t\tGSplatData.calcSplatAabb(aabb2, p, r, s);\n\t\t\t\tresult.add(aabb2);\n\t\t\t}\n\t\t}\n\t\treturn !first;\n\t}\n\tgetCenters(result) {\n\t\tconst x = this.getProp('x');\n\t\tconst y = this.getProp('y');\n\t\tconst z = this.getProp('z');\n\t\tfor (let i = 0; i < this.numSplats; ++i) {\n\t\t\tresult[i * 3 + 0] = x[i];\n\t\t\tresult[i * 3 + 1] = y[i];\n\t\t\tresult[i * 3 + 2] = z[i];\n\t\t}\n\t}\n\tcalcFocalPoint(result, pred) {\n\t\tconst x = this.getProp('x');\n\t\tconst y = this.getProp('y');\n\t\tconst z = this.getProp('z');\n\t\tconst sx = this.getProp('scale_0');\n\t\tconst sy = this.getProp('scale_1');\n\t\tconst sz = this.getProp('scale_2');\n\t\tresult.x = 0;\n\t\tresult.y = 0;\n\t\tresult.z = 0;\n\t\tlet sum = 0;\n\t\tfor (let i = 0; i < this.numSplats; ++i) {\n\t\t\tif (pred && !pred(i)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst weight = 1.0 / (1.0 + Math.exp(Math.max(sx[i], sy[i], sz[i])));\n\t\t\tresult.x += x[i] * weight;\n\t\t\tresult.y += y[i] * weight;\n\t\t\tresult.z += z[i] * weight;\n\t\t\tsum += weight;\n\t\t}\n\t\tresult.mulScalar(1 / sum);\n\t}\n\trenderWireframeBounds(scene, worldMat) {\n\t\tconst p = new Vec3();\n\t\tconst r = new Quat();\n\t\tconst s = new Vec3();\n\t\tconst min = new Vec3();\n\t\tconst max = new Vec3();\n\t\tconst iter = this.createIter(p, r, s);\n\t\tfor (let i = 0; i < this.numSplats; ++i) {\n\t\t\titer.read(i);\n\t\t\tcalcSplatMat(mat4, p, r);\n\t\t\tmat4.mul2(worldMat, mat4);\n\t\t\tmin.set(s.x * -2.0, s.y * -2.0, s.z * -2.0);\n\t\t\tmax.set(s.x * 2.0, s.y * 2.0, s.z * 2.0);\n\t\t\tscene.immediate.drawWireAlignedBox(min, max, debugColor, true, scene.defaultDrawLayer, mat4);\n\t\t}\n\t}\n\tget isCompressed() {\n\t\treturn false;\n\t}\n\tget hasSHData() {\n\t\tfor (let i = 0; i < 45; ++i) {\n\t\t\tif (!this.getProp(`f_rest_${i}`)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tcalcMortonOrder() {\n\t\tconst calcMinMax = arr => {\n\t\t\tlet min = arr[0];\n\t\t\tlet max = arr[0];\n\t\t\tfor (let i = 1; i < arr.length; i++) {\n\t\t\t\tif (arr[i] < min) min = arr[i];\n\t\t\t\tif (arr[i] > max) max = arr[i];\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tmin,\n\t\t\t\tmax\n\t\t\t};\n\t\t};\n\t\tconst encodeMorton3 = (x, y, z) => {\n\t\t\tconst Part1By2 = x => {\n\t\t\t\tx &= 0x000003ff;\n\t\t\t\tx = (x ^ x << 16) & 0xff0000ff;\n\t\t\t\tx = (x ^ x << 8) & 0x0300f00f;\n\t\t\t\tx = (x ^ x << 4) & 0x030c30c3;\n\t\t\t\tx = (x ^ x << 2) & 0x09249249;\n\t\t\t\treturn x;\n\t\t\t};\n\t\t\treturn (Part1By2(z) << 2) + (Part1By2(y) << 1) + Part1By2(x);\n\t\t};\n\t\tconst x = this.getProp('x');\n\t\tconst y = this.getProp('y');\n\t\tconst z = this.getProp('z');\n\t\tconst {\n\t\t\tmin: minX,\n\t\t\tmax: maxX\n\t\t} = calcMinMax(x);\n\t\tconst {\n\t\t\tmin: minY,\n\t\t\tmax: maxY\n\t\t} = calcMinMax(y);\n\t\tconst {\n\t\t\tmin: minZ,\n\t\t\tmax: maxZ\n\t\t} = calcMinMax(z);\n\t\tconst sizeX = minX === maxX ? 0 : 1024 / (maxX - minX);\n\t\tconst sizeY = minY === maxY ? 0 : 1024 / (maxY - minY);\n\t\tconst sizeZ = minZ === maxZ ? 0 : 1024 / (maxZ - minZ);\n\t\tconst codes = new Map();\n\t\tfor (let i = 0; i < this.numSplats; i++) {\n\t\t\tconst ix = Math.floor((x[i] - minX) * sizeX);\n\t\t\tconst iy = Math.floor((y[i] - minY) * sizeY);\n\t\t\tconst iz = Math.floor((z[i] - minZ) * sizeZ);\n\t\t\tconst code = encodeMorton3(ix, iy, iz);\n\t\t\tconst val = codes.get(code);\n\t\t\tif (val) {\n\t\t\t\tval.push(i);\n\t\t\t} else {\n\t\t\t\tcodes.set(code, [i]);\n\t\t\t}\n\t\t}\n\t\tconst keys = Array.from(codes.keys()).sort((a, b) => a - b);\n\t\tconst indices = new Uint32Array(this.numSplats);\n\t\tlet idx = 0;\n\t\tfor (let i = 0; i < keys.length; ++i) {\n\t\t\tconst val = codes.get(keys[i]);\n\t\t\tfor (let j = 0; j < val.length; ++j) {\n\t\t\t\tindices[idx++] = val[j];\n\t\t\t}\n\t\t}\n\t\treturn indices;\n\t}\n\treorder(order) {\n\t\tconst cache = new Map();\n\t\tconst getStorage = size => {\n\t\t\tif (cache.has(size)) {\n\t\t\t\tconst buffer = cache.get(size);\n\t\t\t\tcache.delete(size);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t\treturn new ArrayBuffer(size);\n\t\t};\n\t\tconst returnStorage = buffer => {\n\t\t\tcache.set(buffer.byteLength, buffer);\n\t\t};\n\t\tconst reorder = data => {\n\t\t\tconst result = new data.constructor(getStorage(data.byteLength));\n\t\t\tfor (let i = 0; i < order.length; i++) {\n\t\t\t\tresult[i] = data[order[i]];\n\t\t\t}\n\t\t\treturnStorage(data.buffer);\n\t\t\treturn result;\n\t\t};\n\t\tthis.elements.forEach(element => {\n\t\t\telement.properties.forEach(property => {\n\t\t\t\tif (property.storage) {\n\t\t\t\t\tproperty.storage = reorder(property.storage);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\treorderData() {\n\t\tthis.reorder(this.calcMortonOrder());\n\t}\n}\n\nexport { GSplatData };\n","import { Mat4 } from '../../core/math/mat4.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { PIXELFORMAT_R32U, SEMANTIC_ATTR13, TYPE_UINT32, BUFFER_STATIC } from '../../platform/graphics/constants.js';\nimport { DITHER_NONE } from '../constants.js';\nimport { MeshInstance } from '../mesh-instance.js';\nimport { Mesh } from '../mesh.js';\nimport { GSplatSorter } from './gsplat-sorter.js';\nimport { VertexFormat } from '../../platform/graphics/vertex-format.js';\nimport { VertexBuffer } from '../../platform/graphics/vertex-buffer.js';\n\nconst mat = new Mat4();\nconst cameraPosition = new Vec3();\nconst cameraDirection = new Vec3();\nconst viewport = [0, 0];\nclass GSplatInstance {\n\tconstructor(splat, options) {\n\t\tthis.splat = void 0;\n\t\tthis.mesh = void 0;\n\t\tthis.meshInstance = void 0;\n\t\tthis.material = void 0;\n\t\tthis.orderTexture = void 0;\n\t\tthis.options = {};\n\t\tthis.sorter = null;\n\t\tthis.lastCameraPosition = new Vec3();\n\t\tthis.lastCameraDirection = new Vec3();\n\t\tthis.cameras = [];\n\t\tthis.splat = splat;\n\t\toptions = Object.assign(this.options, options);\n\t\tconst device = splat.device;\n\t\tthis.orderTexture = this.splat.createTexture('splatOrder', PIXELFORMAT_R32U, this.splat.evalTextureSize(this.splat.numSplats));\n\t\tthis.createMaterial(options);\n\t\tconst splatInstanceSize = 128;\n\t\tconst numSplats = Math.ceil(splat.numSplats / splatInstanceSize) * splatInstanceSize;\n\t\tconst numSplatInstances = numSplats / splatInstanceSize;\n\t\tconst indexData = new Uint32Array(numSplatInstances);\n\t\tfor (let i = 0; i < numSplatInstances; ++i) {\n\t\t\tindexData[i] = i * splatInstanceSize;\n\t\t}\n\t\tconst vertexFormat = new VertexFormat(device, [{\n\t\t\tsemantic: SEMANTIC_ATTR13,\n\t\t\tcomponents: 1,\n\t\t\ttype: TYPE_UINT32,\n\t\t\tasInt: true\n\t\t}]);\n\t\tconst indicesVB = new VertexBuffer(device, vertexFormat, numSplatInstances, {\n\t\t\tusage: BUFFER_STATIC,\n\t\t\tdata: indexData.buffer\n\t\t});\n\t\tconst meshPositions = new Float32Array(12 * splatInstanceSize);\n\t\tconst meshIndices = new Uint32Array(6 * splatInstanceSize);\n\t\tfor (let i = 0; i < splatInstanceSize; ++i) {\n\t\t\tmeshPositions.set([-2, -2, i, 2, -2, i, 2, 2, i, -2, 2, i], i * 12);\n\t\t\tconst b = i * 4;\n\t\t\tmeshIndices.set([0 + b, 1 + b, 2 + b, 0 + b, 2 + b, 3 + b], i * 6);\n\t\t}\n\t\tconst mesh = new Mesh(device);\n\t\tmesh.setPositions(meshPositions, 3);\n\t\tmesh.setIndices(meshIndices);\n\t\tmesh.update();\n\t\tthis.mesh = mesh;\n\t\tthis.mesh.aabb.copy(splat.aabb);\n\t\tthis.meshInstance = new MeshInstance(this.mesh, this.material);\n\t\tthis.meshInstance.setInstancing(indicesVB, true);\n\t\tthis.meshInstance.gsplatInstance = this;\n\t\tthis.meshInstance.instancingCount = 0;\n\t\tthis.centers = new Float32Array(splat.centers);\n\t\tif (!options.dither || options.dither === DITHER_NONE) {\n\t\t\tthis.sorter = new GSplatSorter();\n\t\t\tthis.sorter.init(this.orderTexture, this.centers);\n\t\t\tthis.sorter.on('updated', count => {\n\t\t\t\tthis.meshInstance.instancingCount = Math.ceil(count / splatInstanceSize);\n\t\t\t\tconst tex_params = this.material.getParameter('tex_params');\n\t\t\t\tif (tex_params != null && tex_params.data) {\n\t\t\t\t\ttex_params.data[0] = count;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\tdestroy() {\n\t\tvar _this$material, _this$meshInstance, _this$sorter;\n\t\t(_this$material = this.material) == null || _this$material.destroy();\n\t\t(_this$meshInstance = this.meshInstance) == null || _this$meshInstance.destroy();\n\t\t(_this$sorter = this.sorter) == null || _this$sorter.destroy();\n\t}\n\tclone() {\n\t\treturn new GSplatInstance(this.splat, this.options);\n\t}\n\tcreateMaterial(options) {\n\t\tthis.material = this.splat.createMaterial(options);\n\t\tthis.material.setParameter('splatOrder', this.orderTexture);\n\t\tif (this.meshInstance) {\n\t\t\tthis.meshInstance.material = this.material;\n\t\t}\n\t}\n\tupdateViewport() {\n\t\tconst device = this.splat.device;\n\t\tviewport[0] = device.width;\n\t\tviewport[1] = device.height;\n\t\tif (this.cameras.length > 0) {\n\t\t\tconst camera = this.cameras[0];\n\t\t\tconst xr = camera.xr;\n\t\t\tif (xr && xr.active && xr.views.list.length === 2) {\n\t\t\t\tviewport[0] /= 2;\n\t\t\t}\n\t\t}\n\t\tthis.material.setParameter('viewport', viewport);\n\t}\n\tsort(cameraNode) {\n\t\tif (this.sorter) {\n\t\t\tconst cameraMat = cameraNode.getWorldTransform();\n\t\t\tcameraMat.getTranslation(cameraPosition);\n\t\t\tcameraMat.getZ(cameraDirection);\n\t\t\tconst modelMat = this.meshInstance.node.getWorldTransform();\n\t\t\tconst invModelMat = mat.invert(modelMat);\n\t\t\tinvModelMat.transformPoint(cameraPosition, cameraPosition);\n\t\t\tinvModelMat.transformVector(cameraDirection, cameraDirection);\n\t\t\tif (!cameraPosition.equalsApprox(this.lastCameraPosition) || !cameraDirection.equalsApprox(this.lastCameraDirection)) {\n\t\t\t\tthis.lastCameraPosition.copy(cameraPosition);\n\t\t\t\tthis.lastCameraDirection.copy(cameraDirection);\n\t\t\t\tthis.sorter.setCamera(cameraPosition, cameraDirection);\n\t\t\t}\n\t\t}\n\t\tthis.updateViewport();\n\t}\n\tupdate() {\n\t\tif (this.cameras.length > 0) {\n\t\t\tconst camera = this.cameras[0];\n\t\t\tthis.sort(camera._node);\n\t\t\tthis.cameras.length = 0;\n\t\t}\n\t}\n}\n\nexport { GSplatInstance };\n","import { CULLFACE_NONE } from '../../platform/graphics/constants.js';\nimport { ShaderProcessorOptions } from '../../platform/graphics/shader-processor-options.js';\nimport { DITHER_NONE, BLEND_NONE, BLEND_NORMAL, SHADER_FORWARDHDR, GAMMA_SRGBHDR, GAMMA_NONE, TONEMAP_LINEAR } from '../constants.js';\nimport { Material } from '../materials/material.js';\nimport { getProgramLibrary } from '../shader-lib/get-program-library.js';\nimport { gsplat } from './shader-generator-gsplat.js';\n\nconst splatMainVS = `\n\tuniform vec3 view_position;\n\tuniform sampler2D splatColor;\n\tvarying mediump vec2 texCoord;\n\tvarying mediump vec4 color;\n\tmediump vec4 discardVec = vec4(0.0, 0.0, 2.0, 1.0);\n\tvoid main(void)\n\t{\n\t\tif (!calcSplatUV()) {\n\t\t\tgl_Position = discardVec;\n\t\t\treturn;\n\t\t}\n\t\tvec3 center = getCenter();\n\t\tmat4 model_view = matrix_view * matrix_model;\n\t\tvec4 splat_cam = model_view * vec4(center, 1.0);\n\t\tif (splat_cam.z > 0.0) {\n\t\t\tgl_Position = discardVec;\n\t\t\treturn;\n\t\t}\n\t\tvec4 splat_proj = matrix_projection * splat_cam;\n\t\tsplat_proj.z = clamp(splat_proj.z, -abs(splat_proj.w), abs(splat_proj.w));\n\t\tvec3 covA, covB;\n\t\tgetCovariance(covA, covB);\n\t\tvec4 v1v2 = calcV1V2(splat_cam.xyz, covA, covB, transpose(mat3(model_view)));\n\t\tcolor = texelFetch(splatColor, splatUV, 0);\n\t\tfloat scale = min(1.0, sqrt(-log(1.0 / 255.0 / color.a)) / 2.0);\n\t\tv1v2 *= scale;\n\t\tif (dot(v1v2.xy, v1v2.xy) < 4.0 && dot(v1v2.zw, v1v2.zw) < 4.0) {\n\t\t\tgl_Position = discardVec;\n\t\t\treturn;\n\t\t}\n\t\tgl_Position = splat_proj + vec4((vertex_position.x * v1v2.xy + vertex_position.y * v1v2.zw) / viewport * splat_proj.w, 0, 0);\n\t\ttexCoord = vertex_position.xy * scale / 2.0;\n\t\t#ifdef USE_SH1\n\t\t\tvec4 worldCenter = matrix_model * vec4(center, 1.0);\n\t\t\tvec3 viewDir = normalize((worldCenter.xyz / worldCenter.w - view_position) * mat3(matrix_model));\n\t\t\tcolor.xyz = max(color.xyz + evalSH(viewDir), 0.0);\n\t\t#endif\n\t\t#ifndef DITHER_NONE\n\t\t\tid = float(splatId);\n\t\t#endif\n\t}\n`;\nconst splatMainFS = `\n\tvarying mediump vec2 texCoord;\n\tvarying mediump vec4 color;\n\tvoid main(void)\n\t{\n\t\tgl_FragColor = evalSplat(texCoord, color);\n\t}\n`;\nconst createGSplatMaterial = (options = {}) => {\n\tvar _options$dither;\n\tconst ditherEnum = (_options$dither = options.dither) != null ? _options$dither : DITHER_NONE;\n\tconst dither = ditherEnum !== DITHER_NONE;\n\tconst material = new Material();\n\tmaterial.name = 'splatMaterial';\n\tmaterial.cull = CULLFACE_NONE;\n\tmaterial.blendType = dither ? BLEND_NONE : BLEND_NORMAL;\n\tmaterial.depthWrite = dither;\n\tmaterial.getShaderVariant = function (device, scene, defs, unused, pass, sortedLights, viewUniformFormat, viewBindGroupFormat) {\n\t\tvar _options$vertex, _options$fragment;\n\t\tconst programOptions = {\n\t\t\tpass: pass,\n\t\t\tgamma: pass === SHADER_FORWARDHDR ? scene.gammaCorrection ? GAMMA_SRGBHDR : GAMMA_NONE : scene.gammaCorrection,\n\t\t\ttoneMapping: pass === SHADER_FORWARDHDR ? TONEMAP_LINEAR : scene.toneMapping,\n\t\t\tvertex: (_options$vertex = options.vertex) != null ? _options$vertex : splatMainVS,\n\t\t\tfragment: (_options$fragment = options.fragment) != null ? _options$fragment : splatMainFS,\n\t\t\tdither: ditherEnum,\n\t\t\tdefines: options.defines\n\t\t};\n\t\tconst processingOptions = new ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat);\n\t\tconst library = getProgramLibrary(device);\n\t\tlibrary.register('splat', gsplat);\n\t\treturn library.getProgram('splat', programOptions, processingOptions);\n\t};\n\tmaterial.update();\n\treturn material;\n};\n\nexport { createGSplatMaterial };\n","import { EventHandler } from '../../core/event-handler.js';\nimport { TEXTURELOCK_READ } from '../../platform/graphics/constants.js';\n\nfunction SortWorker() {\n\tlet order;\n\tlet centers;\n\tlet mapping;\n\tlet cameraPosition;\n\tlet cameraDirection;\n\tlet forceUpdate = false;\n\tconst lastCameraPosition = {\n\t\tx: 0,\n\t\ty: 0,\n\t\tz: 0\n\t};\n\tconst lastCameraDirection = {\n\t\tx: 0,\n\t\ty: 0,\n\t\tz: 0\n\t};\n\tconst boundMin = {\n\t\tx: 0,\n\t\ty: 0,\n\t\tz: 0\n\t};\n\tconst boundMax = {\n\t\tx: 0,\n\t\ty: 0,\n\t\tz: 0\n\t};\n\tlet distances;\n\tlet countBuffer;\n\tconst binarySearch = (m, n, compare_fn) => {\n\t\twhile (m <= n) {\n\t\t\tconst k = n + m >> 1;\n\t\t\tconst cmp = compare_fn(k);\n\t\t\tif (cmp > 0) {\n\t\t\t\tm = k + 1;\n\t\t\t} else if (cmp < 0) {\n\t\t\t\tn = k - 1;\n\t\t\t} else {\n\t\t\t\treturn k;\n\t\t\t}\n\t\t}\n\t\treturn ~m;\n\t};\n\tconst update = () => {\n\t\tvar _distances;\n\t\tif (!order || !centers || centers.length === 0 || !cameraPosition || !cameraDirection) return;\n\t\tconst px = cameraPosition.x;\n\t\tconst py = cameraPosition.y;\n\t\tconst pz = cameraPosition.z;\n\t\tconst dx = cameraDirection.x;\n\t\tconst dy = cameraDirection.y;\n\t\tconst dz = cameraDirection.z;\n\t\tconst epsilon = 0.001;\n\t\tif (!forceUpdate && Math.abs(px - lastCameraPosition.x) < epsilon && Math.abs(py - lastCameraPosition.y) < epsilon && Math.abs(pz - lastCameraPosition.z) < epsilon && Math.abs(dx - lastCameraDirection.x) < epsilon && Math.abs(dy - lastCameraDirection.y) < epsilon && Math.abs(dz - lastCameraDirection.z) < epsilon) {\n\t\t\treturn;\n\t\t}\n\t\tforceUpdate = false;\n\t\tlastCameraPosition.x = px;\n\t\tlastCameraPosition.y = py;\n\t\tlastCameraPosition.z = pz;\n\t\tlastCameraDirection.x = dx;\n\t\tlastCameraDirection.y = dy;\n\t\tlastCameraDirection.z = dz;\n\t\tlet minDist;\n\t\tlet maxDist;\n\t\tfor (let i = 0; i < 8; ++i) {\n\t\t\tconst x = (i & 1 ? boundMin.x : boundMax.x) - px;\n\t\t\tconst y = (i & 2 ? boundMin.y : boundMax.y) - py;\n\t\t\tconst z = (i & 4 ? boundMin.z : boundMax.z) - pz;\n\t\t\tconst d = x * dx + y * dy + z * dz;\n\t\t\tif (i === 0) {\n\t\t\t\tminDist = maxDist = d;\n\t\t\t} else {\n\t\t\t\tminDist = Math.min(minDist, d);\n\t\t\t\tmaxDist = Math.max(maxDist, d);\n\t\t\t}\n\t\t}\n\t\tconst numVertices = centers.length / 3;\n\t\tconst compareBits = Math.max(10, Math.min(20, Math.round(Math.log2(numVertices / 4))));\n\t\tconst bucketCount = 2 ** compareBits + 1;\n\t\tif (((_distances = distances) == null ? void 0 : _distances.length) !== numVertices) {\n\t\t\tdistances = new Uint32Array(numVertices);\n\t\t}\n\t\tif (!countBuffer || countBuffer.length !== bucketCount) {\n\t\t\tcountBuffer = new Uint32Array(bucketCount);\n\t\t} else {\n\t\t\tcountBuffer.fill(0);\n\t\t}\n\t\tconst range = maxDist - minDist;\n\t\tconst divider = range < 1e-6 ? 0 : 1 / range * 2 ** compareBits;\n\t\tfor (let i = 0; i < numVertices; ++i) {\n\t\t\tconst istride = i * 3;\n\t\t\tconst x = centers[istride + 0] - px;\n\t\t\tconst y = centers[istride + 1] - py;\n\t\t\tconst z = centers[istride + 2] - pz;\n\t\t\tconst d = x * dx + y * dy + z * dz;\n\t\t\tconst sortKey = Math.floor((d - minDist) * divider);\n\t\t\tdistances[i] = sortKey;\n\t\t\tcountBuffer[sortKey]++;\n\t\t}\n\t\tfor (let i = 1; i < bucketCount; i++) {\n\t\t\tcountBuffer[i] += countBuffer[i - 1];\n\t\t}\n\t\tfor (let i = 0; i < numVertices; i++) {\n\t\t\tconst distance = distances[i];\n\t\t\tconst destIndex = --countBuffer[distance];\n\t\t\torder[destIndex] = i;\n\t\t}\n\t\tconst dist = i => distances[order[i]] / divider + minDist;\n\t\tconst findZero = () => {\n\t\t\tconst result = binarySearch(0, numVertices - 1, i => -dist(i));\n\t\t\treturn Math.min(numVertices, Math.abs(result));\n\t\t};\n\t\tconst count = dist(numVertices - 1) >= 0 ? findZero() : numVertices;\n\t\tif (mapping) {\n\t\t\tfor (let i = 0; i < numVertices; ++i) {\n\t\t\t\torder[i] = mapping[order[i]];\n\t\t\t}\n\t\t}\n\t\tself.postMessage({\n\t\t\torder: order.buffer,\n\t\t\tcount\n\t\t}, [order.buffer]);\n\t\torder = null;\n\t};\n\tself.onmessage = message => {\n\t\tif (message.data.order) {\n\t\t\torder = new Uint32Array(message.data.order);\n\t\t}\n\t\tif (message.data.centers) {\n\t\t\tcenters = new Float32Array(message.data.centers);\n\t\t\tboundMin.x = boundMax.x = centers[0];\n\t\t\tboundMin.y = boundMax.y = centers[1];\n\t\t\tboundMin.z = boundMax.z = centers[2];\n\t\t\tconst numVertices = centers.length / 3;\n\t\t\tfor (let i = 1; i < numVertices; ++i) {\n\t\t\t\tconst x = centers[i * 3 + 0];\n\t\t\t\tconst y = centers[i * 3 + 1];\n\t\t\t\tconst z = centers[i * 3 + 2];\n\t\t\t\tboundMin.x = Math.min(boundMin.x, x);\n\t\t\t\tboundMin.y = Math.min(boundMin.y, y);\n\t\t\t\tboundMin.z = Math.min(boundMin.z, z);\n\t\t\t\tboundMax.x = Math.max(boundMax.x, x);\n\t\t\t\tboundMax.y = Math.max(boundMax.y, y);\n\t\t\t\tboundMax.z = Math.max(boundMax.z, z);\n\t\t\t}\n\t\t\tforceUpdate = true;\n\t\t}\n\t\tif (message.data.hasOwnProperty('mapping')) {\n\t\t\tmapping = message.data.mapping ? new Uint32Array(message.data.mapping) : null;\n\t\t\tforceUpdate = true;\n\t\t}\n\t\tif (message.data.cameraPosition) cameraPosition = message.data.cameraPosition;\n\t\tif (message.data.cameraDirection) cameraDirection = message.data.cameraDirection;\n\t\tupdate();\n\t};\n}\nclass GSplatSorter extends EventHandler {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.worker = void 0;\n\t\tthis.orderTexture = void 0;\n\t\tthis.centers = void 0;\n\t\tthis.worker = new Worker(URL.createObjectURL(new Blob([`(${SortWorker.toString()})()`], {\n\t\t\ttype: 'application/javascript'\n\t\t})));\n\t\tthis.worker.onmessage = message => {\n\t\t\tconst newOrder = message.data.order;\n\t\t\tconst oldOrder = this.orderTexture._levels[0].buffer;\n\t\t\tthis.worker.postMessage({\n\t\t\t\torder: oldOrder\n\t\t\t}, [oldOrder]);\n\t\t\tthis.orderTexture._levels[0] = new Uint32Array(newOrder);\n\t\t\tthis.orderTexture.upload();\n\t\t\tthis.fire('updated', message.data.count);\n\t\t};\n\t}\n\tdestroy() {\n\t\tthis.worker.terminate();\n\t\tthis.worker = null;\n\t}\n\tinit(orderTexture, centers) {\n\t\tthis.orderTexture = orderTexture;\n\t\tthis.centers = centers.slice();\n\t\tconst orderBuffer = this.orderTexture.lock({\n\t\t\tmode: TEXTURELOCK_READ\n\t\t}).buffer.slice();\n\t\tthis.orderTexture.unlock();\n\t\tthis.worker.postMessage({\n\t\t\torder: orderBuffer,\n\t\t\tcenters: centers.buffer\n\t\t}, [orderBuffer, centers.buffer]);\n\t}\n\tsetMapping(mapping) {\n\t\tif (mapping) {\n\t\t\tconst centers = new Float32Array(mapping.length * 3);\n\t\t\tfor (let i = 0; i < mapping.length; ++i) {\n\t\t\t\tconst src = mapping[i] * 3;\n\t\t\t\tconst dst = i * 3;\n\t\t\t\tcenters[dst + 0] = this.centers[src + 0];\n\t\t\t\tcenters[dst + 1] = this.centers[src + 1];\n\t\t\t\tcenters[dst + 2] = this.centers[src + 2];\n\t\t\t}\n\t\t\tthis.worker.postMessage({\n\t\t\t\tcenters: centers.buffer,\n\t\t\t\tmapping: mapping.buffer\n\t\t\t}, [centers.buffer, mapping.buffer]);\n\t\t} else {\n\t\t\tconst centers = this.centers.slice();\n\t\t\tthis.worker.postMessage({\n\t\t\t\tcenters: centers.buffer,\n\t\t\t\tmapping: null\n\t\t\t}, [centers.buffer]);\n\t\t}\n\t}\n\tsetCamera(pos, dir) {\n\t\tthis.worker.postMessage({\n\t\t\tcameraPosition: {\n\t\t\t\tx: pos.x,\n\t\t\t\ty: pos.y,\n\t\t\t\tz: pos.z\n\t\t\t},\n\t\t\tcameraDirection: {\n\t\t\t\tx: dir.x,\n\t\t\t\ty: dir.y,\n\t\t\t\tz: dir.z\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport { GSplatSorter };\n","import { extends as _extends } from '../../../_virtual/_rollupPluginBabelHelpers.js';\nimport { FloatPacking } from '../../core/math/float-packing.js';\nimport { Quat } from '../../core/math/quat.js';\nimport { Vec2 } from '../../core/math/vec2.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { Mat3 } from '../../core/math/mat3.js';\nimport { PIXELFORMAT_RGBA8, PIXELFORMAT_RGBA32U, PIXELFORMAT_RGBA16F, FILTER_NEAREST, ADDRESS_CLAMP_TO_EDGE } from '../../platform/graphics/constants.js';\nimport { Texture } from '../../platform/graphics/texture.js';\nimport { BoundingBox } from '../../core/shape/bounding-box.js';\nimport { createGSplatMaterial } from './gsplat-material.js';\n\nconst getSHData = gsplatData => {\n\tconst result = [];\n\tfor (let i = 0; i < 45; ++i) {\n\t\tresult.push(gsplatData.getProp(`f_rest_${i}`));\n\t}\n\treturn result;\n};\nclass GSplat {\n\tconstructor(device, gsplatData) {\n\t\tthis.device = void 0;\n\t\tthis.numSplats = void 0;\n\t\tthis.centers = void 0;\n\t\tthis.aabb = void 0;\n\t\tthis.colorTexture = void 0;\n\t\tthis.transformATexture = void 0;\n\t\tthis.transformBTexture = void 0;\n\t\tthis.hasSH = void 0;\n\t\tthis.sh1to3Texture = void 0;\n\t\tthis.sh4to7Texture = void 0;\n\t\tthis.sh8to11Texture = void 0;\n\t\tthis.sh12to15Texture = void 0;\n\t\tconst numSplats = gsplatData.numSplats;\n\t\tthis.device = device;\n\t\tthis.numSplats = numSplats;\n\t\tthis.centers = new Float32Array(gsplatData.numSplats * 3);\n\t\tgsplatData.getCenters(this.centers);\n\t\tthis.aabb = new BoundingBox();\n\t\tgsplatData.calcAabb(this.aabb);\n\t\tconst size = this.evalTextureSize(numSplats);\n\t\tthis.colorTexture = this.createTexture('splatColor', PIXELFORMAT_RGBA8, size);\n\t\tthis.transformATexture = this.createTexture('transformA', PIXELFORMAT_RGBA32U, size);\n\t\tthis.transformBTexture = this.createTexture('transformB', PIXELFORMAT_RGBA16F, size);\n\t\tthis.updateColorData(gsplatData);\n\t\tthis.updateTransformData(gsplatData);\n\t\tthis.hasSH = gsplatData.hasSHData;\n\t\tif (this.hasSH) {\n\t\t\tthis.sh1to3Texture = this.createTexture('splatSH_1to3', PIXELFORMAT_RGBA32U, size);\n\t\t\tthis.sh4to7Texture = this.createTexture('splatSH_4to7', PIXELFORMAT_RGBA32U, size);\n\t\t\tthis.sh8to11Texture = this.createTexture('splatSH_8to11', PIXELFORMAT_RGBA32U, size);\n\t\t\tthis.sh12to15Texture = this.createTexture('splatSH_12to15', PIXELFORMAT_RGBA32U, size);\n\t\t\tthis.updateSHData(gsplatData);\n\t\t}\n\t}\n\tdestroy() {\n\t\tvar _this$colorTexture, _this$transformATextu, _this$transformBTextu, _this$sh1to3Texture, _this$sh4to7Texture, _this$sh8to11Texture, _this$sh12to15Texture;\n\t\t(_this$colorTexture = this.colorTexture) == null || _this$colorTexture.destroy();\n\t\t(_this$transformATextu = this.transformATexture) == null || _this$transformATextu.destroy();\n\t\t(_this$transformBTextu = this.transformBTexture) == null || _this$transformBTextu.destroy();\n\t\t(_this$sh1to3Texture = this.sh1to3Texture) == null || _this$sh1to3Texture.destroy();\n\t\t(_this$sh4to7Texture = this.sh4to7Texture) == null || _this$sh4to7Texture.destroy();\n\t\t(_this$sh8to11Texture = this.sh8to11Texture) == null || _this$sh8to11Texture.destroy();\n\t\t(_this$sh12to15Texture = this.sh12to15Texture) == null || _this$sh12to15Texture.destroy();\n\t}\n\tcreateMaterial(options) {\n\t\tconst result = createGSplatMaterial(_extends({}, this.hasSH ? {\n\t\t\tdefines: ['USE_SH1', 'USE_SH2', 'USE_SH3']\n\t\t} : {}, options));\n\t\tresult.setParameter('splatColor', this.colorTexture);\n\t\tresult.setParameter('transformA', this.transformATexture);\n\t\tresult.setParameter('transformB', this.transformBTexture);\n\t\tresult.setParameter('tex_params', new Float32Array([this.numSplats, this.colorTexture.width, 0, 0]));\n\t\tif (this.hasSH) {\n\t\t\tresult.setParameter('splatSH_1to3', this.sh1to3Texture);\n\t\t\tresult.setParameter('splatSH_4to7', this.sh4to7Texture);\n\t\t\tresult.setParameter('splatSH_8to11', this.sh8to11Texture);\n\t\t\tresult.setParameter('splatSH_12to15', this.sh12to15Texture);\n\t\t}\n\t\treturn result;\n\t}\n\tevalTextureSize(count) {\n\t\tconst width = Math.ceil(Math.sqrt(count));\n\t\tconst height = Math.ceil(count / width);\n\t\treturn new Vec2(width, height);\n\t}\n\tcreateTexture(name, format, size) {\n\t\treturn new Texture(this.device, {\n\t\t\tname: name,\n\t\t\twidth: size.x,\n\t\t\theight: size.y,\n\t\t\tformat: format,\n\t\t\tcubemap: false,\n\t\t\tmipmaps: false,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t\t});\n\t}\n\tgetTextureFormat(device, preferHighPrecision) {\n\t\tif (device.isWebGL1) {\n\t\t\tpreferHighPrecision = false;\n\t\t}\n\t\tconst halfSupported = device.extTextureHalfFloat && device.textureHalfFloatUpdatable;\n\t\tconst floatSupported = device.extTextureFloat;\n\t\tlet halfFormat;\n\t\tif (preferHighPrecision) {\n\t\t\tif (floatSupported) {\n\t\t\t\thalfFormat = false;\n\t\t\t} else if (halfSupported) {\n\t\t\t\thalfFormat = true;\n\t\t\t}\n\t\t} else {\n\t\t\tif (halfSupported) {\n\t\t\t\thalfFormat = true;\n\t\t\t} else if (floatSupported) {\n\t\t\t\thalfFormat = false;\n\t\t\t}\n\t\t}\n\t\treturn halfFormat;\n\t}\n\tupdateColorData(gsplatData) {\n\t\tconst texture = this.colorTexture;\n\t\tif (!texture) {\n\t\t\treturn;\n\t\t}\n\t\tconst data = texture.lock();\n\t\tconst cr = gsplatData.getProp('f_dc_0');\n\t\tconst cg = gsplatData.getProp('f_dc_1');\n\t\tconst cb = gsplatData.getProp('f_dc_2');\n\t\tconst ca = gsplatData.getProp('opacity');\n\t\tconst SH_C0 = 0.28209479177387814;\n\t\tfor (let i = 0; i < this.numSplats; ++i) {\n\t\t\tconst r = (cr[i] * SH_C0 + 0.5) * 255;\n\t\t\tconst g = (cg[i] * SH_C0 + 0.5) * 255;\n\t\t\tconst b = (cb[i] * SH_C0 + 0.5) * 255;\n\t\t\tconst a = 255 / (1 + Math.exp(-ca[i]));\n\t\t\tdata[i * 4 + 0] = r < 0 ? 0 : r > 255 ? 255 : r;\n\t\t\tdata[i * 4 + 1] = g < 0 ? 0 : g > 255 ? 255 : g;\n\t\t\tdata[i * 4 + 2] = b < 0 ? 0 : b > 255 ? 255 : b;\n\t\t\tdata[i * 4 + 3] = a < 0 ? 0 : a > 255 ? 255 : a;\n\t\t}\n\t\ttexture.unlock();\n\t}\n\tupdateTransformData(gsplatData) {\n\t\tconst float2Half = FloatPacking.float2Half;\n\t\tif (!this.transformATexture) {\n\t\t\treturn;\n\t\t}\n\t\tconst dataA = this.transformATexture.lock();\n\t\tconst dataAFloat32 = new Float32Array(dataA.buffer);\n\t\tconst dataB = this.transformBTexture.lock();\n\t\tconst p = new Vec3();\n\t\tconst r = new Quat();\n\t\tconst s = new Vec3();\n\t\tconst iter = gsplatData.createIter(p, r, s);\n\t\tconst mat = new Mat3();\n\t\tconst cA = new Vec3();\n\t\tconst cB = new Vec3();\n\t\tfor (let i = 0; i < this.numSplats; i++) {\n\t\t\titer.read(i);\n\t\t\tr.normalize();\n\t\t\tmat.setFromQuat(r);\n\t\t\tthis.computeCov3d(mat, s, cA, cB);\n\t\t\tdataAFloat32[i * 4 + 0] = p.x;\n\t\t\tdataAFloat32[i * 4 + 1] = p.y;\n\t\t\tdataAFloat32[i * 4 + 2] = p.z;\n\t\t\tdataA[i * 4 + 3] = float2Half(cB.x) | float2Half(cB.y) << 16;\n\t\t\tdataB[i * 4 + 0] = float2Half(cA.x);\n\t\t\tdataB[i * 4 + 1] = float2Half(cA.y);\n\t\t\tdataB[i * 4 + 2] = float2Half(cA.z);\n\t\t\tdataB[i * 4 + 3] = float2Half(cB.z);\n\t\t}\n\t\tthis.transformATexture.unlock();\n\t\tthis.transformBTexture.unlock();\n\t}\n\tcomputeCov3d(rot, scale, covA, covB) {\n\t\tconst sx = scale.x;\n\t\tconst sy = scale.y;\n\t\tconst sz = scale.z;\n\t\tconst data = rot.data;\n\t\tconst r00 = data[0] * sx;\n\t\tconst r01 = data[1] * sx;\n\t\tconst r02 = data[2] * sx;\n\t\tconst r10 = data[3] * sy;\n\t\tconst r11 = data[4] * sy;\n\t\tconst r12 = data[5] * sy;\n\t\tconst r20 = data[6] * sz;\n\t\tconst r21 = data[7] * sz;\n\t\tconst r22 = data[8] * sz;\n\t\tcovA.x = r00 * r00 + r10 * r10 + r20 * r20;\n\t\tcovA.y = r00 * r01 + r10 * r11 + r20 * r21;\n\t\tcovA.z = r00 * r02 + r10 * r12 + r20 * r22;\n\t\tcovB.x = r01 * r01 + r11 * r11 + r21 * r21;\n\t\tcovB.y = r01 * r02 + r11 * r12 + r21 * r22;\n\t\tcovB.z = r02 * r02 + r12 * r12 + r22 * r22;\n\t}\n\tupdateSHData(gsplatData) {\n\t\tconst sh1to3Data = this.sh1to3Texture.lock();\n\t\tconst sh4to7Data = this.sh4to7Texture.lock();\n\t\tconst sh8to11Data = this.sh8to11Texture.lock();\n\t\tconst sh12to15Data = this.sh12to15Texture.lock();\n\t\tconst src = getSHData(gsplatData);\n\t\tconst t11 = (1 << 11) - 1;\n\t\tconst t10 = (1 << 10) - 1;\n\t\tconst pack = (r, g, b) => {\n\t\t\tconst rb = Math.floor(r * t11 + 0.5);\n\t\t\tconst gb = Math.floor(g * t10 + 0.5);\n\t\t\tconst bb = Math.floor(b * t11 + 0.5);\n\t\t\treturn (rb < 0 ? 0 : rb > t11 ? t11 : rb) << 21 | (gb < 0 ? 0 : gb > t10 ? t10 : gb) << 11 | (bb < 0 ? 0 : bb > t11 ? t11 : bb);\n\t\t};\n\t\tconst float32 = new Float32Array(1);\n\t\tconst uint32 = new Uint32Array(float32.buffer);\n\t\tconst c = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\t\tfor (let i = 0; i < gsplatData.numSplats; ++i) {\n\t\t\tfor (let j = 0; j < 45; ++j) {\n\t\t\t\tc[j] = src[j][i];\n\t\t\t}\n\t\t\tlet m = Math.abs(c[0]);\n\t\t\tfor (let j = 1; j < 45; ++j) {\n\t\t\t\tconst as = Math.abs(c[j]);\n\t\t\t\tif (as > m) m = as;\n\t\t\t}\n\t\t\tif (m === 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (let j = 0; j < 45; ++j) {\n\t\t\t\tc[j] = c[j] / m * 0.5 + 0.5;\n\t\t\t}\n\t\t\tfloat32[0] = m;\n\t\t\tsh1to3Data[i * 4 + 0] = uint32[0];\n\t\t\tsh1to3Data[i * 4 + 1] = pack(c[0], c[15], c[30]);\n\t\t\tsh1to3Data[i * 4 + 2] = pack(c[1], c[16], c[31]);\n\t\t\tsh1to3Data[i * 4 + 3] = pack(c[2], c[17], c[32]);\n\t\t\tsh4to7Data[i * 4 + 0] = pack(c[3], c[18], c[33]);\n\t\t\tsh4to7Data[i * 4 + 1] = pack(c[4], c[19], c[34]);\n\t\t\tsh4to7Data[i * 4 + 2] = pack(c[5], c[20], c[35]);\n\t\t\tsh4to7Data[i * 4 + 3] = pack(c[6], c[21], c[36]);\n\t\t\tsh8to11Data[i * 4 + 0] = pack(c[7], c[22], c[37]);\n\t\t\tsh8to11Data[i * 4 + 1] = pack(c[8], c[23], c[38]);\n\t\t\tsh8to11Data[i * 4 + 2] = pack(c[9], c[24], c[39]);\n\t\t\tsh8to11Data[i * 4 + 3] = pack(c[10], c[25], c[40]);\n\t\t\tsh12to15Data[i * 4 + 0] = pack(c[11], c[26], c[41]);\n\t\t\tsh12to15Data[i * 4 + 1] = pack(c[12], c[27], c[42]);\n\t\t\tsh12to15Data[i * 4 + 2] = pack(c[13], c[28], c[43]);\n\t\t\tsh12to15Data[i * 4 + 3] = pack(c[14], c[29], c[44]);\n\t\t}\n\t\tthis.sh1to3Texture.unlock();\n\t\tthis.sh4to7Texture.unlock();\n\t\tthis.sh8to11Texture.unlock();\n\t\tthis.sh12to15Texture.unlock();\n\t}\n}\n\nexport { GSplat };\n","import { hashCode } from '../../core/hash.js';\nimport { SEMANTIC_POSITION, SEMANTIC_ATTR13 } from '../../platform/graphics/constants.js';\nimport { ShaderUtils } from '../../platform/graphics/shader-utils.js';\nimport { TONEMAP_LINEAR, DITHER_NONE } from '../constants.js';\nimport { shaderChunks } from '../shader-lib/chunks/chunks.js';\nimport { ShaderGenerator } from '../shader-lib/programs/shader-generator.js';\nimport { ShaderPass } from '../shader-pass.js';\n\nconst splatCoreVS = `\n\tuniform mat4 matrix_model;\n\tuniform mat4 matrix_view;\n\tuniform mat4 matrix_projection;\n\tuniform vec2 viewport;\n\tuniform vec4 tex_params;\n\tuniform highp usampler2D splatOrder;\n\tuniform highp usampler2D transformA;\n\tuniform highp sampler2D transformB;\n\tattribute vec3 vertex_position;\n\tattribute uint vertex_id_attrib;\n\t#ifndef DITHER_NONE\n\t\tvarying float id;\n\t#endif\n\tuint orderId;\n\tuint splatId;\n\tivec2 splatUV;\n\tbool calcSplatUV() {\n\t\tuint numSplats = uint(tex_params.x);\n\t\tuint textureWidth = uint(tex_params.y);\n\t\torderId = vertex_id_attrib + uint(vertex_position.z);\n\t\tif (orderId >= numSplats) {\n\t\t\treturn false;\n\t\t}\n\t\tivec2 orderUV = ivec2(\n\t\t\tint(orderId % textureWidth),\n\t\t\tint(orderId / textureWidth)\n\t\t);\n\t\tsplatId = texelFetch(splatOrder, orderUV, 0).r;\n\t\tsplatUV = ivec2(\n\t\t\tint(splatId % textureWidth),\n\t\t\tint(splatId / textureWidth)\n\t\t);\n\t\treturn true;\n\t}\n\tuvec4 tA;\n\tvec3 getCenter() {\n\t\ttA = texelFetch(transformA, splatUV, 0);\n\t\treturn uintBitsToFloat(tA.xyz);\n\t}\n\tvoid getCovariance(out vec3 covA, out vec3 covB) {\n\t\tvec4 tB = texelFetch(transformB, splatUV, 0);\n\t\tvec2 tC = unpackHalf2x16(tA.w);\n\t\tcovA = tB.xyz;\n\t\tcovB = vec3(tC.x, tC.y, tB.w);\n\t}\n\tvec4 calcV1V2(in vec3 splat_cam, in vec3 covA, in vec3 covB, mat3 W) {\n\t\tmat3 Vrk = mat3(\n\t\t\tcovA.x, covA.y, covA.z, \n\t\t\tcovA.y, covB.x, covB.y,\n\t\t\tcovA.z, covB.y, covB.z\n\t\t);\n\t\tfloat focal = viewport.x * matrix_projection[0][0];\n\t\tfloat J1 = focal / splat_cam.z;\n\t\tvec2 J2 = -J1 / splat_cam.z * splat_cam.xy;\n\t\tmat3 J = mat3(\n\t\t\tJ1, 0.0, J2.x, \n\t\t\t0.0, J1, J2.y, \n\t\t\t0.0, 0.0, 0.0\n\t\t);\n\t\tmat3 T = W * J;\n\t\tmat3 cov = transpose(T) * Vrk * T;\n\t\tfloat diagonal1 = cov[0][0] + 0.3;\n\t\tfloat offDiagonal = cov[0][1];\n\t\tfloat diagonal2 = cov[1][1] + 0.3;\n\t\tfloat mid = 0.5 * (diagonal1 + diagonal2);\n\t\tfloat radius = length(vec2((diagonal1 - diagonal2) / 2.0, offDiagonal));\n\t\tfloat lambda1 = mid + radius;\n\t\tfloat lambda2 = max(mid - radius, 0.1);\n\t\tvec2 diagonalVector = normalize(vec2(offDiagonal, lambda1 - diagonal1));\n\t\tvec2 v1 = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;\n\t\tvec2 v2 = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);\n\t\treturn vec4(v1, v2);\n\t}\n\tvec3 unpack111011(uint bits) {\n\t\treturn vec3(\n\t\t\tfloat(bits >> 21u) / 2047.0,\n\t\t\tfloat((bits >> 11u) & 0x3ffu) / 1023.0,\n\t\t\tfloat(bits & 0x7ffu) / 2047.0\n\t\t);\n\t}\n\tvoid fetchScale(in uvec4 t, out float scale, out vec3 a, out vec3 b, out vec3 c) {\n\t\tscale = uintBitsToFloat(t.x);\n\t\ta = unpack111011(t.y) * 2.0 - 1.0;\n\t\tb = unpack111011(t.z) * 2.0 - 1.0;\n\t\tc = unpack111011(t.w) * 2.0 - 1.0;\n\t}\n\tvoid fetch(in uvec4 t, out vec3 a, out vec3 b, out vec3 c, out vec3 d) {\n\t\ta = unpack111011(t.x) * 2.0 - 1.0;\n\t\tb = unpack111011(t.y) * 2.0 - 1.0;\n\t\tc = unpack111011(t.z) * 2.0 - 1.0;\n\t\td = unpack111011(t.w) * 2.0 - 1.0;\n\t}\n\t#if defined(USE_SH1)\n\t\t#define SH_C1 0.4886025119029199f\n\t\tuniform highp usampler2D splatSH_1to3;\n\t#if defined(USE_SH2)\n\t\t#define SH_C2_0 1.0925484305920792f\n\t\t#define SH_C2_1 -1.0925484305920792f\n\t\t#define SH_C2_2 0.31539156525252005f\n\t\t#define SH_C2_3 -1.0925484305920792f\n\t\t#define SH_C2_4 0.5462742152960396f\n\t\tuniform highp usampler2D splatSH_4to7;\n\t\tuniform highp usampler2D splatSH_8to11;\n\t#if defined(USE_SH3)\n\t\t#define SH_C3_0 -0.5900435899266435f\n\t\t#define SH_C3_1 2.890611442640554f\n\t\t#define SH_C3_2 -0.4570457994644658f\n\t\t#define SH_C3_3 0.3731763325901154f\n\t\t#define SH_C3_4 -0.4570457994644658f\n\t\t#define SH_C3_5 1.445305721320277f\n\t\t#define SH_C3_6 -0.5900435899266435f\n\t\tuniform highp usampler2D splatSH_12to15;\n\t#endif\n\t#endif\n\t#endif\n\tvec3 evalSH(in vec3 dir) {\n\t\tvec3 result = vec3(0.0);\n\t#if defined(USE_SH1)\n\t\tfloat x = dir.x;\n\t\tfloat y = dir.y;\n\t\tfloat z = dir.z;\n\t\tfloat scale;\n\t\tvec3 sh1, sh2, sh3;\n\t\tfetchScale(texelFetch(splatSH_1to3, splatUV, 0), scale, sh1, sh2, sh3);\n\t\tresult += SH_C1 * (-sh1 * y + sh2 * z - sh3 * x);\n\t#if defined(USE_SH2)\n\t\tfloat xx = x * x;\n\t\tfloat yy = y * y;\n\t\tfloat zz = z * z;\n\t\tfloat xy = x * y;\n\t\tfloat yz = y * z;\n\t\tfloat xz = x * z;\n\t\tvec3 sh4, sh5, sh6, sh7;\n\t\tvec3 sh8, sh9, sh10, sh11;\n\t\tfetch(texelFetch(splatSH_4to7, splatUV, 0), sh4, sh5, sh6, sh7);\n\t\tfetch(texelFetch(splatSH_8to11, splatUV, 0), sh8, sh9, sh10, sh11);\n\t\tresult +=\n\t\t\tsh4 * (SH_C2_0 * xy) *  +\n\t\t\tsh5 * (SH_C2_1 * yz) +\n\t\t\tsh6 * (SH_C2_2 * (2.0 * zz - xx - yy)) +\n\t\t\tsh7 * (SH_C2_3 * xz) +\n\t\t\tsh8 * (SH_C2_4 * (xx - yy));\n\t#if defined(USE_SH3)\n\t\tvec3 sh12, sh13, sh14, sh15;\n\t\tfetch(texelFetch(splatSH_12to15, splatUV, 0), sh12, sh13, sh14, sh15);\n\t\tresult +=\n\t\t\tsh9  * (SH_C3_0 * y * (3.0 * xx - yy)) +\n\t\t\tsh10 * (SH_C3_1 * xy * z) +\n\t\t\tsh11 * (SH_C3_2 * y * (4.0 * zz - xx - yy)) +\n\t\t\tsh12 * (SH_C3_3 * z * (2.0 * zz - 3.0 * xx - 3.0 * yy)) +\n\t\t\tsh13 * (SH_C3_4 * x * (4.0 * zz - xx - yy)) +\n\t\t\tsh14 * (SH_C3_5 * z * (xx - yy)) +\n\t\t\tsh15 * (SH_C3_6 * x * (xx - 3.0 * yy));\n\t#endif\n\t#endif\n\t\tresult *= scale;\n\t#endif\n\t\treturn result;\n\t}\n`;\nconst splatCoreFS = `\n\t#ifndef DITHER_NONE\n\t\tvarying float id;\n\t#endif\n\t#ifdef PICK_PASS\n\t\tuniform vec4 uColor;\n\t#endif\n\tvec4 evalSplat(vec2 texCoord, vec4 color) {\n\t\tmediump float A = dot(texCoord, texCoord);\n\t\tif (A > 1.0) {\n\t\t\tdiscard;\n\t\t}\n\t\tmediump float B = exp(-A * 4.0) * color.a;\n\t\tif (B < 1.0 / 255.0) {\n\t\t\tdiscard;\n\t\t}\n\t\t#ifdef PICK_PASS\n\t\t\tif (B < 0.3) {\n\t\t\t\tdiscard;\n\t\t\t}\n\t\t\treturn uColor;\n\t\t#endif\n\t\t#ifndef DITHER_NONE\n\t\t\topacityDither(B, id * 0.013);\n\t\t#endif\n\t\t#ifdef TONEMAP_ENABLED\n\t\t\treturn vec4(gammaCorrectOutput(toneMap(decodeGamma(color.rgb))), B);\n\t\t#else\n\t\t\treturn vec4(color.rgb, B);\n\t\t#endif\n\t}\n`;\nclass GSplatShaderGenerator {\n\tgenerateKey(options) {\n\t\tvar _options$defines$sort, _options$defines;\n\t\tconst vsHash = hashCode(options.vertex);\n\t\tconst fsHash = hashCode(options.fragment);\n\t\tconst defines = (_options$defines$sort = (_options$defines = options.defines) == null ? void 0 : _options$defines.sort().join('-')) != null ? _options$defines$sort : '';\n\t\treturn `splat-${options.pass}-${options.gamma}-${options.toneMapping}-${vsHash}-${fsHash}-${options.dither}-${defines}`;\n\t}\n\tcreateShaderDefinition(device, options) {\n\t\tvar _options$defines2;\n\t\tconst shaderPassInfo = ShaderPass.get(device).getByIndex(options.pass);\n\t\tconst shaderPassDefines = shaderPassInfo.shaderDefines;\n\t\tconst optionDefines = ((_options$defines2 = options.defines) != null ? _options$defines2 : []).map(d => `#define ${d}`).join('\\n');\n\t\tconst defines = `${shaderPassDefines}\\n` + `${optionDefines}\\n` + `#define DITHER_${options.dither.toUpperCase()}\\n` + `#define TONEMAP_${options.toneMapping === TONEMAP_LINEAR ? 'DISABLED' : 'ENABLED'}\\n`;\n\t\tconst vs = defines + splatCoreVS + options.vertex;\n\t\tconst fs = defines + shaderChunks.decodePS + (options.dither === DITHER_NONE ? '' : shaderChunks.bayerPS + shaderChunks.opacityDitherPS) + ShaderGenerator.tonemapCode(options.toneMapping) + ShaderGenerator.gammaCode(options.gamma) + splatCoreFS + options.fragment;\n\t\treturn ShaderUtils.createDefinition(device, {\n\t\t\tname: 'SplatShader',\n\t\t\tattributes: {\n\t\t\t\tvertex_position: SEMANTIC_POSITION,\n\t\t\t\tvertex_id_attrib: SEMANTIC_ATTR13\n\t\t\t},\n\t\t\tvertexCode: vs,\n\t\t\tfragmentCode: fs\n\t\t});\n\t}\n}\nconst gsplat = new GSplatShaderGenerator();\n\nexport { gsplat };\n","import { Mat4 } from '../../core/math/mat4.js';\nimport { PRIMITIVE_LINES } from '../../platform/graphics/constants.js';\nimport { Mesh } from '../mesh.js';\nimport { MeshInstance } from '../mesh-instance.js';\nimport { GraphNode } from '../graph-node.js';\n\nconst identityGraphNode = new GraphNode();\nidentityGraphNode.worldTransform = Mat4.IDENTITY;\nidentityGraphNode._dirtyWorld = identityGraphNode._dirtyNormal = false;\nclass ImmediateBatch {\n\tconstructor(device, material, layer) {\n\t\tthis.material = material;\n\t\tthis.layer = layer;\n\t\tthis.positions = [];\n\t\tthis.colors = [];\n\t\tthis.mesh = new Mesh(device);\n\t\tthis.meshInstance = null;\n\t}\n\taddLines(positions, color) {\n\t\tconst destPos = this.positions;\n\t\tconst count = positions.length;\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst pos = positions[i];\n\t\t\tdestPos.push(pos.x, pos.y, pos.z);\n\t\t}\n\t\tconst destCol = this.colors;\n\t\tif (color.length) {\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst col = color[i];\n\t\t\t\tdestCol.push(col.r, col.g, col.b, col.a);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tdestCol.push(color.r, color.g, color.b, color.a);\n\t\t\t}\n\t\t}\n\t}\n\taddLinesArrays(positions, color) {\n\t\tconst destPos = this.positions;\n\t\tfor (let i = 0; i < positions.length; i += 3) {\n\t\t\tdestPos.push(positions[i], positions[i + 1], positions[i + 2]);\n\t\t}\n\t\tconst destCol = this.colors;\n\t\tif (color.length) {\n\t\t\tfor (let i = 0; i < color.length; i += 4) {\n\t\t\t\tdestCol.push(color[i], color[i + 1], color[i + 2], color[i + 3]);\n\t\t\t}\n\t\t} else {\n\t\t\tconst count = positions.length / 3;\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tdestCol.push(color.r, color.g, color.b, color.a);\n\t\t\t}\n\t\t}\n\t}\n\tonPreRender(visibleList, transparent) {\n\t\tif (this.positions.length > 0 && this.material.transparent === transparent) {\n\t\t\tthis.mesh.setPositions(this.positions);\n\t\t\tthis.mesh.setColors(this.colors);\n\t\t\tthis.mesh.update(PRIMITIVE_LINES, false);\n\t\t\tif (!this.meshInstance) {\n\t\t\t\tthis.meshInstance = new MeshInstance(this.mesh, this.material, identityGraphNode);\n\t\t\t}\n\t\t\tvisibleList.push(this.meshInstance);\n\t\t}\n\t}\n\tclear() {\n\t\tthis.positions.length = 0;\n\t\tthis.colors.length = 0;\n\t}\n}\n\nexport { ImmediateBatch };\n","import { ImmediateBatch } from './immediate-batch.js';\n\nclass ImmediateBatches {\n\tconstructor(device) {\n\t\tthis.device = device;\n\t\tthis.map = new Map();\n\t}\n\tgetBatch(material, layer) {\n\t\tlet batch = this.map.get(material);\n\t\tif (!batch) {\n\t\t\tbatch = new ImmediateBatch(this.device, material, layer);\n\t\t\tthis.map.set(material, batch);\n\t\t}\n\t\treturn batch;\n\t}\n\tonPreRender(visibleList, transparent) {\n\t\tthis.map.forEach(batch => {\n\t\t\tbatch.onPreRender(visibleList, transparent);\n\t\t});\n\t}\n\tclear() {\n\t\tthis.map.forEach(batch => batch.clear());\n\t}\n}\n\nexport { ImmediateBatches };\n","import { PRIMITIVE_TRISTRIP } from '../../platform/graphics/constants.js';\nimport { BLEND_NORMAL } from '../constants.js';\nimport { GraphNode } from '../graph-node.js';\nimport { Mesh } from '../mesh.js';\nimport { MeshInstance } from '../mesh-instance.js';\nimport { BasicMaterial } from '../materials/basic-material.js';\nimport { createShaderFromCode } from '../shader-lib/utils.js';\nimport { shaderChunks } from '../shader-lib/chunks/chunks.js';\nimport { ImmediateBatches } from './immediate-batches.js';\nimport { Vec3 } from '../../core/math/vec3.js';\n\nconst tempPoints = [];\nconst vec = new Vec3();\nclass Immediate {\n\tconstructor(device) {\n\t\tthis.device = device;\n\t\tthis.quadMesh = null;\n\t\tthis.textureShader = null;\n\t\tthis.depthTextureShader = null;\n\t\tthis.cubeLocalPos = null;\n\t\tthis.cubeWorldPos = null;\n\t\tthis.batchesMap = new Map();\n\t\tthis.allBatches = new Set();\n\t\tthis.updatedLayers = new Set();\n\t\tthis._materialDepth = null;\n\t\tthis._materialNoDepth = null;\n\t\tthis.layerMeshInstances = new Map();\n\t}\n\tcreateMaterial(depthTest) {\n\t\tconst material = new BasicMaterial();\n\t\tmaterial.vertexColors = true;\n\t\tmaterial.blendType = BLEND_NORMAL;\n\t\tmaterial.depthTest = depthTest;\n\t\tmaterial.update();\n\t\treturn material;\n\t}\n\tget materialDepth() {\n\t\tif (!this._materialDepth) {\n\t\t\tthis._materialDepth = this.createMaterial(true);\n\t\t}\n\t\treturn this._materialDepth;\n\t}\n\tget materialNoDepth() {\n\t\tif (!this._materialNoDepth) {\n\t\t\tthis._materialNoDepth = this.createMaterial(false);\n\t\t}\n\t\treturn this._materialNoDepth;\n\t}\n\tgetBatch(layer, depthTest) {\n\t\tlet batches = this.batchesMap.get(layer);\n\t\tif (!batches) {\n\t\t\tbatches = new ImmediateBatches(this.device);\n\t\t\tthis.batchesMap.set(layer, batches);\n\t\t}\n\t\tthis.allBatches.add(batches);\n\t\tconst material = depthTest ? this.materialDepth : this.materialNoDepth;\n\t\treturn batches.getBatch(material, layer);\n\t}\n\tgetShader(id, fragment) {\n\t\tif (!this[id]) {\n\t\t\tconst vertex = `\n\t\t\t\tattribute vec2 vertex_position;\n\t\t\t\tuniform mat4 matrix_model;\n\t\t\t\tvarying vec2 uv0;\n\t\t\t\tvoid main(void) {\n\t\t\t\t\tgl_Position = matrix_model * vec4(vertex_position, 0, 1);\n\t\t\t\t\tuv0 = vertex_position.xy + 0.5;\n\t\t\t\t}\n\t\t\t`;\n\t\t\tthis[id] = createShaderFromCode(this.device, vertex, fragment, `DebugShader:${id}`);\n\t\t}\n\t\treturn this[id];\n\t}\n\tgetTextureShader() {\n\t\treturn this.getShader('textureShader', `\n\t\t\tvarying vec2 uv0;\n\t\t\tuniform sampler2D colorMap;\n\t\t\tvoid main (void) {\n\t\t\t\tgl_FragColor = vec4(texture2D(colorMap, uv0).xyz, 1);\n\t\t\t}\n\t\t`);\n\t}\n\tgetUnfilterableTextureShader() {\n\t\treturn this.getShader('textureShaderUnfilterable', `\n\t\t\tvarying vec2 uv0;\n\t\t\tuniform highp sampler2D colorMap;\n\t\t\tvoid main (void) {\n\t\t\t\tivec2 uv = ivec2(uv0 * textureSize(colorMap, 0));\n\t\t\t\tgl_FragColor = vec4(texelFetch(colorMap, uv, 0).xyz, 1);\n\t\t\t}\n\t\t`);\n\t}\n\tgetDepthTextureShader() {\n\t\treturn this.getShader('depthTextureShader', `\n\t\t\t${shaderChunks.screenDepthPS}\n\t\t\tvarying vec2 uv0;\n\t\t\tvoid main() {\n\t\t\t\tfloat depth = getLinearScreenDepth(getImageEffectUV(uv0)) * camera_params.x;\n\t\t\t\tgl_FragColor = vec4(vec3(depth), 1.0);\n\t\t\t}\n\t\t`);\n\t}\n\tgetQuadMesh() {\n\t\tif (!this.quadMesh) {\n\t\t\tthis.quadMesh = new Mesh(this.device);\n\t\t\tthis.quadMesh.setPositions([-0.5, -0.5, 0, 0.5, -0.5, 0, -0.5, 0.5, 0, 0.5, 0.5, 0]);\n\t\t\tthis.quadMesh.update(PRIMITIVE_TRISTRIP);\n\t\t}\n\t\treturn this.quadMesh;\n\t}\n\tdrawMesh(material, matrix, mesh, meshInstance, layer) {\n\t\tif (!meshInstance) {\n\t\t\tconst graphNode = this.getGraphNode(matrix);\n\t\t\tmeshInstance = new MeshInstance(mesh, material, graphNode);\n\t\t}\n\t\tlet layerMeshInstances = this.layerMeshInstances.get(layer);\n\t\tif (!layerMeshInstances) {\n\t\t\tlayerMeshInstances = [];\n\t\t\tthis.layerMeshInstances.set(layer, layerMeshInstances);\n\t\t}\n\t\tlayerMeshInstances.push(meshInstance);\n\t}\n\tdrawWireAlignedBox(min, max, color, depthTest, layer, mat) {\n\t\tif (mat) {\n\t\t\tconst mulPoint = (x, y, z) => {\n\t\t\t\tvec.set(x, y, z);\n\t\t\t\tmat.transformPoint(vec, vec);\n\t\t\t\ttempPoints.push(vec.x, vec.y, vec.z);\n\t\t\t};\n\t\t\tmulPoint(min.x, min.y, min.z);\n\t\t\tmulPoint(min.x, max.y, min.z);\n\t\t\tmulPoint(min.x, max.y, min.z);\n\t\t\tmulPoint(max.x, max.y, min.z);\n\t\t\tmulPoint(max.x, max.y, min.z);\n\t\t\tmulPoint(max.x, min.y, min.z);\n\t\t\tmulPoint(max.x, min.y, min.z);\n\t\t\tmulPoint(min.x, min.y, min.z);\n\t\t\tmulPoint(min.x, min.y, max.z);\n\t\t\tmulPoint(min.x, max.y, max.z);\n\t\t\tmulPoint(min.x, max.y, max.z);\n\t\t\tmulPoint(max.x, max.y, max.z);\n\t\t\tmulPoint(max.x, max.y, max.z);\n\t\t\tmulPoint(max.x, min.y, max.z);\n\t\t\tmulPoint(max.x, min.y, max.z);\n\t\t\tmulPoint(min.x, min.y, max.z);\n\t\t\tmulPoint(min.x, min.y, min.z);\n\t\t\tmulPoint(min.x, min.y, max.z);\n\t\t\tmulPoint(min.x, max.y, min.z);\n\t\t\tmulPoint(min.x, max.y, max.z);\n\t\t\tmulPoint(max.x, max.y, min.z);\n\t\t\tmulPoint(max.x, max.y, max.z);\n\t\t\tmulPoint(max.x, min.y, min.z);\n\t\t\tmulPoint(max.x, min.y, max.z);\n\t\t} else {\n\t\t\ttempPoints.push(min.x, min.y, min.z, min.x, max.y, min.z, min.x, max.y, min.z, max.x, max.y, min.z, max.x, max.y, min.z, max.x, min.y, min.z, max.x, min.y, min.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, max.z, min.x, max.y, max.z, max.x, max.y, max.z, max.x, max.y, max.z, max.x, min.y, max.z, max.x, min.y, max.z, min.x, min.y, max.z, min.x, min.y, min.z, min.x, min.y, max.z, min.x, max.y, min.z, min.x, max.y, max.z, max.x, max.y, min.z, max.x, max.y, max.z, max.x, min.y, min.z, max.x, min.y, max.z);\n\t\t}\n\t\tconst batch = this.getBatch(layer, depthTest);\n\t\tbatch.addLinesArrays(tempPoints, color);\n\t\ttempPoints.length = 0;\n\t}\n\tdrawWireSphere(center, radius, color, numSegments, depthTest, layer) {\n\t\tconst step = 2 * Math.PI / numSegments;\n\t\tlet angle = 0;\n\t\tfor (let i = 0; i < numSegments; i++) {\n\t\t\tconst sin0 = Math.sin(angle);\n\t\t\tconst cos0 = Math.cos(angle);\n\t\t\tangle += step;\n\t\t\tconst sin1 = Math.sin(angle);\n\t\t\tconst cos1 = Math.cos(angle);\n\t\t\ttempPoints.push(center.x + radius * sin0, center.y, center.z + radius * cos0);\n\t\t\ttempPoints.push(center.x + radius * sin1, center.y, center.z + radius * cos1);\n\t\t\ttempPoints.push(center.x + radius * sin0, center.y + radius * cos0, center.z);\n\t\t\ttempPoints.push(center.x + radius * sin1, center.y + radius * cos1, center.z);\n\t\t\ttempPoints.push(center.x, center.y + radius * sin0, center.z + radius * cos0);\n\t\t\ttempPoints.push(center.x, center.y + radius * sin1, center.z + radius * cos1);\n\t\t}\n\t\tconst batch = this.getBatch(layer, depthTest);\n\t\tbatch.addLinesArrays(tempPoints, color);\n\t\ttempPoints.length = 0;\n\t}\n\tgetGraphNode(matrix) {\n\t\tconst graphNode = new GraphNode('ImmediateDebug');\n\t\tgraphNode.worldTransform = matrix;\n\t\tgraphNode._dirtyWorld = graphNode._dirtyNormal = false;\n\t\treturn graphNode;\n\t}\n\tonPreRenderLayer(layer, visibleList, transparent) {\n\t\tthis.batchesMap.forEach((batches, batchLayer) => {\n\t\t\tif (batchLayer === layer) {\n\t\t\t\tbatches.onPreRender(visibleList, transparent);\n\t\t\t}\n\t\t});\n\t\tif (!this.updatedLayers.has(layer)) {\n\t\t\tthis.updatedLayers.add(layer);\n\t\t\tconst meshInstances = this.layerMeshInstances.get(layer);\n\t\t\tif (meshInstances) {\n\t\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\t\tvisibleList.push(meshInstances[i]);\n\t\t\t\t}\n\t\t\t\tmeshInstances.length = 0;\n\t\t\t}\n\t\t}\n\t}\n\tonPostRender() {\n\t\tthis.allBatches.forEach(batch => batch.clear());\n\t\tthis.allBatches.clear();\n\t\tthis.updatedLayers.clear();\n\t}\n}\n\nexport { Immediate };\n","import { hash32Fnv1a } from '../core/hash.js';\nimport { SORTMODE_MATERIALMESH, SORTMODE_BACK2FRONT, SHADER_FORWARD, LIGHTTYPE_DIRECTIONAL, LAYER_FX, SORTMODE_NONE, SORTMODE_CUSTOM, SORTMODE_FRONT2BACK, SORTKEY_FORWARD } from './constants.js';\nimport { Material } from './materials/material.js';\n\nfunction sortManual(drawCallA, drawCallB) {\n\treturn drawCallA.drawOrder - drawCallB.drawOrder;\n}\nfunction sortMaterialMesh(drawCallA, drawCallB) {\n\tconst keyA = drawCallA._key[SORTKEY_FORWARD];\n\tconst keyB = drawCallB._key[SORTKEY_FORWARD];\n\tif (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {\n\t\treturn drawCallB.mesh.id - drawCallA.mesh.id;\n\t}\n\treturn keyB - keyA;\n}\nfunction sortBackToFront(drawCallA, drawCallB) {\n\treturn drawCallB.zdist - drawCallA.zdist;\n}\nfunction sortFrontToBack(drawCallA, drawCallB) {\n\treturn drawCallA.zdist - drawCallB.zdist;\n}\nconst sortCallbacks = [null, sortManual, sortMaterialMesh, sortBackToFront, sortFrontToBack];\nlet layerCounter = 0;\nconst lightKeys = [];\nconst _tempMaterials = new Set();\nclass CulledInstances {\n\tconstructor() {\n\t\tthis.opaque = [];\n\t\tthis.transparent = [];\n\t}\n}\nclass Layer {\n\tconstructor(options = {}) {\n\t\tvar _options$enabled, _options$opaqueSortMo, _options$transparentS, _options$shaderPass;\n\t\tthis.meshInstances = [];\n\t\tthis.meshInstancesSet = new Set();\n\t\tthis.shadowCasters = [];\n\t\tthis.shadowCastersSet = new Set();\n\t\tthis._visibleInstances = new WeakMap();\n\t\tthis._lights = [];\n\t\tthis._lightsSet = new Set();\n\t\tthis._clusteredLightsSet = new Set();\n\t\tthis._splitLights = [[], [], []];\n\t\tthis._splitLightsDirty = true;\n\t\tthis.requiresLightCube = false;\n\t\tthis.cameras = [];\n\t\tthis.camerasSet = new Set();\n\t\tthis._dirtyComposition = false;\n\t\tif (options.id !== undefined) {\n\t\t\tthis.id = options.id;\n\t\t\tlayerCounter = Math.max(this.id + 1, layerCounter);\n\t\t} else {\n\t\t\tthis.id = layerCounter++;\n\t\t}\n\t\tthis.name = options.name;\n\t\tthis._enabled = (_options$enabled = options.enabled) != null ? _options$enabled : true;\n\t\tthis._refCounter = this._enabled ? 1 : 0;\n\t\tthis.opaqueSortMode = (_options$opaqueSortMo = options.opaqueSortMode) != null ? _options$opaqueSortMo : SORTMODE_MATERIALMESH;\n\t\tthis.transparentSortMode = (_options$transparentS = options.transparentSortMode) != null ? _options$transparentS : SORTMODE_BACK2FRONT;\n\t\tif (options.renderTarget) {\n\t\t\tthis.renderTarget = options.renderTarget;\n\t\t}\n\t\tthis.shaderPass = (_options$shaderPass = options.shaderPass) != null ? _options$shaderPass : SHADER_FORWARD;\n\t\tthis._clearColorBuffer = !!options.clearColorBuffer;\n\t\tthis._clearDepthBuffer = !!options.clearDepthBuffer;\n\t\tthis._clearStencilBuffer = !!options.clearStencilBuffer;\n\t\tthis.onPreCull = options.onPreCull;\n\t\tthis.onPreRender = options.onPreRender;\n\t\tthis.onPreRenderOpaque = options.onPreRenderOpaque;\n\t\tthis.onPreRenderTransparent = options.onPreRenderTransparent;\n\t\tthis.onPostCull = options.onPostCull;\n\t\tthis.onPostRender = options.onPostRender;\n\t\tthis.onPostRenderOpaque = options.onPostRenderOpaque;\n\t\tthis.onPostRenderTransparent = options.onPostRenderTransparent;\n\t\tthis.onDrawCall = options.onDrawCall;\n\t\tthis.onEnable = options.onEnable;\n\t\tthis.onDisable = options.onDisable;\n\t\tif (this._enabled && this.onEnable) {\n\t\t\tthis.onEnable();\n\t\t}\n\t\tthis.layerReference = options.layerReference;\n\t\tthis.customSortCallback = null;\n\t\tthis.customCalculateSortValues = null;\n\t\tthis._lightHash = 0;\n\t\tthis._lightHashDirty = false;\n\t\tthis._lightIdHash = 0;\n\t\tthis._lightIdHashDirty = false;\n\t\tthis._shaderVersion = -1;\n\t}\n\tset enabled(val) {\n\t\tif (val !== this._enabled) {\n\t\t\tthis._dirtyComposition = true;\n\t\t\tthis._enabled = val;\n\t\t\tif (val) {\n\t\t\t\tthis.incrementCounter();\n\t\t\t\tif (this.onEnable) this.onEnable();\n\t\t\t} else {\n\t\t\t\tthis.decrementCounter();\n\t\t\t\tif (this.onDisable) this.onDisable();\n\t\t\t}\n\t\t}\n\t}\n\tget enabled() {\n\t\treturn this._enabled;\n\t}\n\tset clearColorBuffer(val) {\n\t\tthis._clearColorBuffer = val;\n\t\tthis._dirtyComposition = true;\n\t}\n\tget clearColorBuffer() {\n\t\treturn this._clearColorBuffer;\n\t}\n\tset clearDepthBuffer(val) {\n\t\tthis._clearDepthBuffer = val;\n\t\tthis._dirtyComposition = true;\n\t}\n\tget clearDepthBuffer() {\n\t\treturn this._clearDepthBuffer;\n\t}\n\tset clearStencilBuffer(val) {\n\t\tthis._clearStencilBuffer = val;\n\t\tthis._dirtyComposition = true;\n\t}\n\tget clearStencilBuffer() {\n\t\treturn this._clearStencilBuffer;\n\t}\n\tget hasClusteredLights() {\n\t\treturn this._clusteredLightsSet.size > 0;\n\t}\n\tget clusteredLightsSet() {\n\t\treturn this._clusteredLightsSet;\n\t}\n\tincrementCounter() {\n\t\tif (this._refCounter === 0) {\n\t\t\tthis._enabled = true;\n\t\t\tif (this.onEnable) this.onEnable();\n\t\t}\n\t\tthis._refCounter++;\n\t}\n\tdecrementCounter() {\n\t\tif (this._refCounter === 1) {\n\t\t\tthis._enabled = false;\n\t\t\tif (this.onDisable) this.onDisable();\n\t\t} else if (this._refCounter === 0) {\n\t\t\treturn;\n\t\t}\n\t\tthis._refCounter--;\n\t}\n\taddMeshInstances(meshInstances, skipShadowCasters) {\n\t\tconst destMeshInstances = this.meshInstances;\n\t\tconst destMeshInstancesSet = this.meshInstancesSet;\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tconst mi = meshInstances[i];\n\t\t\tif (!destMeshInstancesSet.has(mi)) {\n\t\t\t\tdestMeshInstances.push(mi);\n\t\t\t\tdestMeshInstancesSet.add(mi);\n\t\t\t\t_tempMaterials.add(mi.material);\n\t\t\t}\n\t\t}\n\t\tif (!skipShadowCasters) {\n\t\t\tthis.addShadowCasters(meshInstances);\n\t\t}\n\t\tif (_tempMaterials.size > 0) {\n\t\t\tconst sceneShaderVer = this._shaderVersion;\n\t\t\t_tempMaterials.forEach(mat => {\n\t\t\t\tif (sceneShaderVer >= 0 && mat._shaderVersion !== sceneShaderVer) {\n\t\t\t\t\tif (mat.getShaderVariant !== Material.prototype.getShaderVariant) {\n\t\t\t\t\t\tmat.clearVariants();\n\t\t\t\t\t}\n\t\t\t\t\tmat._shaderVersion = sceneShaderVer;\n\t\t\t\t}\n\t\t\t});\n\t\t\t_tempMaterials.clear();\n\t\t}\n\t}\n\tremoveMeshInstances(meshInstances, skipShadowCasters) {\n\t\tconst destMeshInstances = this.meshInstances;\n\t\tconst destMeshInstancesSet = this.meshInstancesSet;\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tconst mi = meshInstances[i];\n\t\t\tif (destMeshInstancesSet.has(mi)) {\n\t\t\t\tdestMeshInstancesSet.delete(mi);\n\t\t\t\tconst j = destMeshInstances.indexOf(mi);\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tdestMeshInstances.splice(j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!skipShadowCasters) {\n\t\t\tthis.removeShadowCasters(meshInstances);\n\t\t}\n\t}\n\taddShadowCasters(meshInstances) {\n\t\tconst shadowCasters = this.shadowCasters;\n\t\tconst shadowCastersSet = this.shadowCastersSet;\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tconst mi = meshInstances[i];\n\t\t\tif (mi.castShadow && !shadowCastersSet.has(mi)) {\n\t\t\t\tshadowCastersSet.add(mi);\n\t\t\t\tshadowCasters.push(mi);\n\t\t\t}\n\t\t}\n\t}\n\tremoveShadowCasters(meshInstances) {\n\t\tconst shadowCasters = this.shadowCasters;\n\t\tconst shadowCastersSet = this.shadowCastersSet;\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tconst mi = meshInstances[i];\n\t\t\tif (shadowCastersSet.has(mi)) {\n\t\t\t\tshadowCastersSet.delete(mi);\n\t\t\t\tconst j = shadowCasters.indexOf(mi);\n\t\t\t\tif (j >= 0) {\n\t\t\t\t\tshadowCasters.splice(j, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tclearMeshInstances(skipShadowCasters = false) {\n\t\tthis.meshInstances.length = 0;\n\t\tthis.meshInstancesSet.clear();\n\t\tif (!skipShadowCasters) {\n\t\t\tthis.shadowCasters.length = 0;\n\t\t\tthis.shadowCastersSet.clear();\n\t\t}\n\t}\n\tmarkLightsDirty() {\n\t\tthis._lightHashDirty = true;\n\t\tthis._lightIdHashDirty = true;\n\t\tthis._splitLightsDirty = true;\n\t}\n\taddLight(light) {\n\t\tconst l = light.light;\n\t\tif (!this._lightsSet.has(l)) {\n\t\t\tthis._lightsSet.add(l);\n\t\t\tthis._lights.push(l);\n\t\t\tthis.markLightsDirty();\n\t\t}\n\t\tif (l.type !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\tthis._clusteredLightsSet.add(l);\n\t\t}\n\t}\n\tremoveLight(light) {\n\t\tconst l = light.light;\n\t\tif (this._lightsSet.has(l)) {\n\t\t\tthis._lightsSet.delete(l);\n\t\t\tthis._lights.splice(this._lights.indexOf(l), 1);\n\t\t\tthis.markLightsDirty();\n\t\t}\n\t\tif (l.type !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\tthis._clusteredLightsSet.delete(l);\n\t\t}\n\t}\n\tclearLights() {\n\t\tthis._lightsSet.forEach(light => light.removeLayer(this));\n\t\tthis._lightsSet.clear();\n\t\tthis._clusteredLightsSet.clear();\n\t\tthis._lights.length = 0;\n\t\tthis.markLightsDirty();\n\t}\n\tget splitLights() {\n\t\tif (this._splitLightsDirty) {\n\t\t\tthis._splitLightsDirty = false;\n\t\t\tconst splitLights = this._splitLights;\n\t\t\tfor (let i = 0; i < splitLights.length; i++) {\n\t\t\t\tsplitLights[i].length = 0;\n\t\t\t}\n\t\t\tconst lights = this._lights;\n\t\t\tfor (let i = 0; i < lights.length; i++) {\n\t\t\t\tconst light = lights[i];\n\t\t\t\tif (light.enabled) {\n\t\t\t\t\tsplitLights[light._type].push(light);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i = 0; i < splitLights.length; i++) {\n\t\t\t\tsplitLights[i].sort((a, b) => a.key - b.key);\n\t\t\t}\n\t\t}\n\t\treturn this._splitLights;\n\t}\n\tevaluateLightHash(localLights, directionalLights, useIds) {\n\t\tlet hash = 0;\n\t\tconst lights = this._lights;\n\t\tfor (let i = 0; i < lights.length; i++) {\n\t\t\tconst isLocalLight = lights[i].type !== LIGHTTYPE_DIRECTIONAL;\n\t\t\tif (localLights && isLocalLight || directionalLights && !isLocalLight) {\n\t\t\t\tlightKeys.push(useIds ? lights[i].id : lights[i].key);\n\t\t\t}\n\t\t}\n\t\tif (lightKeys.length > 0) {\n\t\t\tlightKeys.sort();\n\t\t\thash = hash32Fnv1a(lightKeys);\n\t\t\tlightKeys.length = 0;\n\t\t}\n\t\treturn hash;\n\t}\n\tgetLightHash(isClustered) {\n\t\tif (this._lightHashDirty) {\n\t\t\tthis._lightHashDirty = false;\n\t\t\tthis._lightHash = this.evaluateLightHash(!isClustered, true, false);\n\t\t}\n\t\treturn this._lightHash;\n\t}\n\tgetLightIdHash() {\n\t\tif (this._lightIdHashDirty) {\n\t\t\tthis._lightIdHashDirty = false;\n\t\t\tthis._lightIdHash = this.evaluateLightHash(true, false, true);\n\t\t}\n\t\treturn this._lightIdHash;\n\t}\n\taddCamera(camera) {\n\t\tif (!this.camerasSet.has(camera.camera)) {\n\t\t\tthis.camerasSet.add(camera.camera);\n\t\t\tthis.cameras.push(camera);\n\t\t\tthis._dirtyComposition = true;\n\t\t}\n\t}\n\tremoveCamera(camera) {\n\t\tif (this.camerasSet.has(camera.camera)) {\n\t\t\tthis.camerasSet.delete(camera.camera);\n\t\t\tconst index = this.cameras.indexOf(camera);\n\t\t\tthis.cameras.splice(index, 1);\n\t\t\tthis._dirtyComposition = true;\n\t\t}\n\t}\n\tclearCameras() {\n\t\tthis.cameras.length = 0;\n\t\tthis.camerasSet.clear();\n\t\tthis._dirtyComposition = true;\n\t}\n\t_calculateSortDistances(drawCalls, drawCallsCount, camPos, camFwd) {\n\t\tfor (let i = 0; i < drawCallsCount; i++) {\n\t\t\tconst drawCall = drawCalls[i];\n\t\t\tif (drawCall.layer <= LAYER_FX) continue;\n\t\t\tif (drawCall.calculateSortDistance) {\n\t\t\t\tdrawCall.zdist = drawCall.calculateSortDistance(drawCall, camPos, camFwd);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst meshPos = drawCall.aabb.center;\n\t\t\tconst tempx = meshPos.x - camPos.x;\n\t\t\tconst tempy = meshPos.y - camPos.y;\n\t\t\tconst tempz = meshPos.z - camPos.z;\n\t\t\tdrawCall.zdist = tempx * camFwd.x + tempy * camFwd.y + tempz * camFwd.z;\n\t\t}\n\t}\n\tgetCulledInstances(camera) {\n\t\tlet instances = this._visibleInstances.get(camera);\n\t\tif (!instances) {\n\t\t\tinstances = new CulledInstances();\n\t\t\tthis._visibleInstances.set(camera, instances);\n\t\t}\n\t\treturn instances;\n\t}\n\tsortVisible(camera, transparent) {\n\t\tconst sortMode = transparent ? this.transparentSortMode : this.opaqueSortMode;\n\t\tif (sortMode === SORTMODE_NONE) {\n\t\t\treturn;\n\t\t}\n\t\tconst culledInstances = this.getCulledInstances(camera);\n\t\tconst instances = transparent ? culledInstances.transparent : culledInstances.opaque;\n\t\tconst cameraNode = camera.node;\n\t\tif (sortMode === SORTMODE_CUSTOM) {\n\t\t\tconst sortPos = cameraNode.getPosition();\n\t\t\tconst sortDir = cameraNode.forward;\n\t\t\tif (this.customCalculateSortValues) {\n\t\t\t\tthis.customCalculateSortValues(instances, instances.length, sortPos, sortDir);\n\t\t\t}\n\t\t\tif (this.customSortCallback) {\n\t\t\t\tinstances.sort(this.customSortCallback);\n\t\t\t}\n\t\t} else {\n\t\t\tif (sortMode === SORTMODE_BACK2FRONT || sortMode === SORTMODE_FRONT2BACK) {\n\t\t\t\tconst sortPos = cameraNode.getPosition();\n\t\t\t\tconst sortDir = cameraNode.forward;\n\t\t\t\tthis._calculateSortDistances(instances, instances.length, sortPos, sortDir);\n\t\t\t}\n\t\t\tinstances.sort(sortCallbacks[sortMode]);\n\t\t}\n\t}\n}\n\nexport { CulledInstances, Layer };\n","import { math } from '../core/math/math.js';\nimport { Color } from '../core/math/color.js';\nimport { Mat4 } from '../core/math/mat4.js';\nimport { Vec2 } from '../core/math/vec2.js';\nimport { Vec3 } from '../core/math/vec3.js';\nimport { Vec4 } from '../core/math/vec4.js';\nimport { LIGHTTYPE_DIRECTIONAL, MASK_AFFECT_DYNAMIC, LIGHTFALLOFF_LINEAR, SHADOW_PCF3, BLUR_GAUSSIAN, LIGHTSHAPE_PUNCTUAL, SHADOWUPDATE_REALTIME, LIGHTTYPE_OMNI, SHADOW_PCSS, SHADOW_PCF5, SHADOW_VSM32, SHADOW_VSM16, SHADOW_VSM8, SHADOW_PCF1, MASK_BAKE, SHADOWUPDATE_NONE, SHADOWUPDATE_THISFRAME, LIGHTTYPE_SPOT } from './constants.js';\nimport { ShadowRenderer } from './renderer/shadow-renderer.js';\nimport { DepthState } from '../platform/graphics/depth-state.js';\n\nconst tmpVec = new Vec3();\nconst tmpBiases = {\n\tbias: 0,\n\tnormalBias: 0\n};\nconst chanId = {\n\tr: 0,\n\tg: 1,\n\tb: 2,\n\ta: 3\n};\nconst lightTypes = {\n\t'directional': LIGHTTYPE_DIRECTIONAL,\n\t'omni': LIGHTTYPE_OMNI,\n\t'point': LIGHTTYPE_OMNI,\n\t'spot': LIGHTTYPE_SPOT\n};\nconst directionalCascades = [[new Vec4(0, 0, 1, 1)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5), new Vec4(0.5, 0, 0.5, 0.5)], [new Vec4(0, 0, 0.5, 0.5), new Vec4(0, 0.5, 0.5, 0.5), new Vec4(0.5, 0, 0.5, 0.5), new Vec4(0.5, 0.5, 0.5, 0.5)]];\nlet id = 0;\nclass LightRenderData {\n\tconstructor(device, camera, face, light) {\n\t\tthis.light = light;\n\t\tthis.camera = camera;\n\t\tthis.shadowCamera = ShadowRenderer.createShadowCamera(device, light._shadowType, light._type, face);\n\t\tthis.shadowMatrix = new Mat4();\n\t\tthis.shadowViewport = new Vec4(0, 0, 1, 1);\n\t\tthis.shadowScissor = new Vec4(0, 0, 1, 1);\n\t\tthis.depthRangeCompensation = 0;\n\t\tthis.projectionCompensation = 0;\n\t\tthis.face = face;\n\t\tthis.visibleCasters = [];\n\t\tthis.viewBindGroups = [];\n\t}\n\tdestroy() {\n\t\tthis.viewBindGroups.forEach(bg => {\n\t\t\tbg.defaultUniformBuffer.destroy();\n\t\t\tbg.destroy();\n\t\t});\n\t\tthis.viewBindGroups.length = 0;\n\t}\n\tget shadowBuffer() {\n\t\tconst rt = this.shadowCamera.renderTarget;\n\t\tif (rt) {\n\t\t\tconst light = this.light;\n\t\t\tif (light._type === LIGHTTYPE_OMNI) {\n\t\t\t\treturn rt.colorBuffer;\n\t\t\t}\n\t\t\treturn light._isPcf && light.device.supportsDepthShadow ? rt.depthBuffer : rt.colorBuffer;\n\t\t}\n\t\treturn null;\n\t}\n}\nclass Light {\n\tconstructor(graphicsDevice, clusteredLighting) {\n\t\tthis.layers = new Set();\n\t\tthis.clusteredLighting = void 0;\n\t\tthis.shadowDepthState = DepthState.DEFAULT.clone();\n\t\tthis.device = graphicsDevice;\n\t\tthis.clusteredLighting = clusteredLighting;\n\t\tthis.id = id++;\n\t\tthis._type = LIGHTTYPE_DIRECTIONAL;\n\t\tthis._color = new Color(0.8, 0.8, 0.8);\n\t\tthis._intensity = 1;\n\t\tthis._affectSpecularity = true;\n\t\tthis._luminance = 0;\n\t\tthis._castShadows = false;\n\t\tthis._enabled = false;\n\t\tthis._mask = MASK_AFFECT_DYNAMIC;\n\t\tthis.isStatic = false;\n\t\tthis.key = 0;\n\t\tthis.bakeDir = true;\n\t\tthis.bakeNumSamples = 1;\n\t\tthis.bakeArea = 0;\n\t\tthis.attenuationStart = 10;\n\t\tthis.attenuationEnd = 10;\n\t\tthis._falloffMode = LIGHTFALLOFF_LINEAR;\n\t\tthis._shadowType = SHADOW_PCF3;\n\t\tthis._vsmBlurSize = 11;\n\t\tthis.vsmBlurMode = BLUR_GAUSSIAN;\n\t\tthis.vsmBias = 0.01 * 0.25;\n\t\tthis._cookie = null;\n\t\tthis.cookieIntensity = 1;\n\t\tthis._cookieFalloff = true;\n\t\tthis._cookieChannel = 'rgb';\n\t\tthis._cookieTransform = null;\n\t\tthis._cookieTransformUniform = new Float32Array(4);\n\t\tthis._cookieOffset = null;\n\t\tthis._cookieOffsetUniform = new Float32Array(2);\n\t\tthis._cookieTransformSet = false;\n\t\tthis._cookieOffsetSet = false;\n\t\tthis._innerConeAngle = 40;\n\t\tthis._outerConeAngle = 45;\n\t\tthis.cascades = null;\n\t\tthis._shadowMatrixPalette = null;\n\t\tthis._shadowCascadeDistances = null;\n\t\tthis.numCascades = 1;\n\t\tthis.cascadeDistribution = 0.5;\n\t\tthis._shape = LIGHTSHAPE_PUNCTUAL;\n\t\tthis._finalColor = new Float32Array([0.8, 0.8, 0.8]);\n\t\tconst c = Math.pow(this._finalColor[0], 2.2);\n\t\tthis._linearFinalColor = new Float32Array([c, c, c]);\n\t\tthis._position = new Vec3(0, 0, 0);\n\t\tthis._direction = new Vec3(0, 0, 0);\n\t\tthis._innerConeAngleCos = Math.cos(this._innerConeAngle * Math.PI / 180);\n\t\tthis._updateOuterAngle(this._outerConeAngle);\n\t\tthis._usePhysicalUnits = undefined;\n\t\tthis._shadowMap = null;\n\t\tthis._shadowRenderParams = [];\n\t\tthis._shadowCameraParams = [];\n\t\tthis.shadowDistance = 40;\n\t\tthis._shadowResolution = 1024;\n\t\tthis._shadowBias = -0.0005;\n\t\tthis.shadowIntensity = 1.0;\n\t\tthis._normalOffsetBias = 0.0;\n\t\tthis.shadowUpdateMode = SHADOWUPDATE_REALTIME;\n\t\tthis.shadowUpdateOverrides = null;\n\t\tthis._penumbraSize = 1.0;\n\t\tthis._isVsm = false;\n\t\tthis._isPcf = true;\n\t\tthis._cookieMatrix = null;\n\t\tthis._atlasViewport = null;\n\t\tthis.atlasViewportAllocated = false;\n\t\tthis.atlasVersion = 0;\n\t\tthis.atlasSlotIndex = 0;\n\t\tthis.atlasSlotUpdated = false;\n\t\tthis._node = null;\n\t\tthis._renderData = [];\n\t\tthis.visibleThisFrame = false;\n\t\tthis.maxScreenSize = 0;\n\t\tthis._updateShadowBias();\n\t}\n\tdestroy() {\n\t\tthis._destroyShadowMap();\n\t\tthis.releaseRenderData();\n\t\tthis._renderData = null;\n\t}\n\treleaseRenderData() {\n\t\tif (this._renderData) {\n\t\t\tfor (let i = 0; i < this._renderData.length; i++) {\n\t\t\t\tthis._renderData[i].destroy();\n\t\t\t}\n\t\t\tthis._renderData.length = 0;\n\t\t}\n\t}\n\taddLayer(layer) {\n\t\tthis.layers.add(layer);\n\t}\n\tremoveLayer(layer) {\n\t\tthis.layers.delete(layer);\n\t}\n\tset shadowBias(value) {\n\t\tif (this._shadowBias !== value) {\n\t\t\tthis._shadowBias = value;\n\t\t\tthis._updateShadowBias();\n\t\t}\n\t}\n\tget shadowBias() {\n\t\treturn this._shadowBias;\n\t}\n\tset numCascades(value) {\n\t\tif (!this.cascades || this.numCascades !== value) {\n\t\t\tthis.cascades = directionalCascades[value - 1];\n\t\t\tthis._shadowMatrixPalette = new Float32Array(4 * 16);\n\t\t\tthis._shadowCascadeDistances = new Float32Array(4);\n\t\t\tthis._destroyShadowMap();\n\t\t\tthis.updateKey();\n\t\t}\n\t}\n\tget numCascades() {\n\t\treturn this.cascades.length;\n\t}\n\tset shadowMap(shadowMap) {\n\t\tif (this._shadowMap !== shadowMap) {\n\t\t\tthis._destroyShadowMap();\n\t\t\tthis._shadowMap = shadowMap;\n\t\t}\n\t}\n\tget shadowMap() {\n\t\treturn this._shadowMap;\n\t}\n\tset mask(value) {\n\t\tif (this._mask !== value) {\n\t\t\tthis._mask = value;\n\t\t\tthis.updateKey();\n\t\t}\n\t}\n\tget mask() {\n\t\treturn this._mask;\n\t}\n\tget numShadowFaces() {\n\t\tconst type = this._type;\n\t\tif (type === LIGHTTYPE_DIRECTIONAL) {\n\t\t\treturn this.numCascades;\n\t\t} else if (type === LIGHTTYPE_OMNI) {\n\t\t\treturn 6;\n\t\t}\n\t\treturn 1;\n\t}\n\tset type(value) {\n\t\tif (this._type === value) {\n\t\t\treturn;\n\t\t}\n\t\tthis._type = value;\n\t\tthis._destroyShadowMap();\n\t\tthis._updateShadowBias();\n\t\tthis.updateKey();\n\t\tconst stype = this._shadowType;\n\t\tthis._shadowType = null;\n\t\tthis.shadowUpdateOverrides = null;\n\t\tthis.shadowType = stype;\n\t}\n\tget type() {\n\t\treturn this._type;\n\t}\n\tset shape(value) {\n\t\tif (this._shape === value) {\n\t\t\treturn;\n\t\t}\n\t\tthis._shape = value;\n\t\tthis._destroyShadowMap();\n\t\tthis.updateKey();\n\t\tconst stype = this._shadowType;\n\t\tthis._shadowType = null;\n\t\tthis.shadowType = stype;\n\t}\n\tget shape() {\n\t\treturn this._shape;\n\t}\n\tset usePhysicalUnits(value) {\n\t\tif (this._usePhysicalUnits !== value) {\n\t\t\tthis._usePhysicalUnits = value;\n\t\t\tthis._updateFinalColor();\n\t\t}\n\t}\n\tget usePhysicalUnits() {\n\t\treturn this._usePhysicalUnits;\n\t}\n\tset shadowType(value) {\n\t\tif (this._shadowType === value) {\n\t\t\treturn;\n\t\t}\n\t\tconst device = this.device;\n\t\tif (this._type === LIGHTTYPE_OMNI && value !== SHADOW_PCF3 && value !== SHADOW_PCSS) {\n\t\t\tvalue = SHADOW_PCF3;\n\t\t}\n\t\tconst supportsDepthShadow = device.supportsDepthShadow;\n\t\tif (value === SHADOW_PCF5 && !supportsDepthShadow) {\n\t\t\tvalue = SHADOW_PCF3;\n\t\t}\n\t\tif (value === SHADOW_VSM32 && (!device.textureFloatRenderable || !device.textureFloatFilterable)) {\n\t\t\tvalue = SHADOW_VSM16;\n\t\t}\n\t\tif (value === SHADOW_VSM16 && !device.textureHalfFloatRenderable) {\n\t\t\tvalue = SHADOW_VSM8;\n\t\t}\n\t\tthis._isVsm = value >= SHADOW_VSM8 && value <= SHADOW_VSM32;\n\t\tthis._isPcf = value === SHADOW_PCF1 || value === SHADOW_PCF3 || value === SHADOW_PCF5;\n\t\tthis._shadowType = value;\n\t\tthis._destroyShadowMap();\n\t\tthis.updateKey();\n\t}\n\tget shadowType() {\n\t\treturn this._shadowType;\n\t}\n\tset enabled(value) {\n\t\tif (this._enabled !== value) {\n\t\t\tthis._enabled = value;\n\t\t\tthis.layersDirty();\n\t\t}\n\t}\n\tget enabled() {\n\t\treturn this._enabled;\n\t}\n\tset castShadows(value) {\n\t\tif (this._castShadows !== value) {\n\t\t\tthis._castShadows = value;\n\t\t\tthis._destroyShadowMap();\n\t\t\tthis.layersDirty();\n\t\t\tthis.updateKey();\n\t\t}\n\t}\n\tget castShadows() {\n\t\treturn this._castShadows && this._mask !== MASK_BAKE && this._mask !== 0;\n\t}\n\tget bakeShadows() {\n\t\treturn this._castShadows && this._mask === MASK_BAKE;\n\t}\n\tset shadowResolution(value) {\n\t\tif (this._shadowResolution !== value) {\n\t\t\tif (this._type === LIGHTTYPE_OMNI) {\n\t\t\t\tvalue = Math.min(value, this.device.maxCubeMapSize);\n\t\t\t} else {\n\t\t\t\tvalue = Math.min(value, this.device.maxTextureSize);\n\t\t\t}\n\t\t\tthis._shadowResolution = value;\n\t\t\tthis._destroyShadowMap();\n\t\t}\n\t}\n\tget shadowResolution() {\n\t\treturn this._shadowResolution;\n\t}\n\tset vsmBlurSize(value) {\n\t\tif (this._vsmBlurSize === value) {\n\t\t\treturn;\n\t\t}\n\t\tif (value % 2 === 0) value++;\n\t\tthis._vsmBlurSize = value;\n\t}\n\tget vsmBlurSize() {\n\t\treturn this._vsmBlurSize;\n\t}\n\tset normalOffsetBias(value) {\n\t\tif (this._normalOffsetBias === value) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this._normalOffsetBias && value || this._normalOffsetBias && !value) {\n\t\t\tthis.updateKey();\n\t\t}\n\t\tthis._normalOffsetBias = value;\n\t}\n\tget normalOffsetBias() {\n\t\treturn this._normalOffsetBias;\n\t}\n\tset falloffMode(value) {\n\t\tif (this._falloffMode === value) {\n\t\t\treturn;\n\t\t}\n\t\tthis._falloffMode = value;\n\t\tthis.updateKey();\n\t}\n\tget falloffMode() {\n\t\treturn this._falloffMode;\n\t}\n\tset innerConeAngle(value) {\n\t\tif (this._innerConeAngle === value) {\n\t\t\treturn;\n\t\t}\n\t\tthis._innerConeAngle = value;\n\t\tthis._innerConeAngleCos = Math.cos(value * Math.PI / 180);\n\t\tif (this._usePhysicalUnits) {\n\t\t\tthis._updateFinalColor();\n\t\t}\n\t}\n\tget innerConeAngle() {\n\t\treturn this._innerConeAngle;\n\t}\n\tset outerConeAngle(value) {\n\t\tif (this._outerConeAngle === value) {\n\t\t\treturn;\n\t\t}\n\t\tthis._outerConeAngle = value;\n\t\tthis._updateOuterAngle(value);\n\t\tif (this._usePhysicalUnits) {\n\t\t\tthis._updateFinalColor();\n\t\t}\n\t}\n\tget outerConeAngle() {\n\t\treturn this._outerConeAngle;\n\t}\n\tset penumbraSize(value) {\n\t\tthis._penumbraSize = value;\n\t}\n\tget penumbraSize() {\n\t\treturn this._penumbraSize;\n\t}\n\t_updateOuterAngle(angle) {\n\t\tconst radAngle = angle * Math.PI / 180;\n\t\tthis._outerConeAngleCos = Math.cos(radAngle);\n\t\tthis._outerConeAngleSin = Math.sin(radAngle);\n\t}\n\tset intensity(value) {\n\t\tif (this._intensity !== value) {\n\t\t\tthis._intensity = value;\n\t\t\tthis._updateFinalColor();\n\t\t}\n\t}\n\tget intensity() {\n\t\treturn this._intensity;\n\t}\n\tset affectSpecularity(value) {\n\t\tif (this._type === LIGHTTYPE_DIRECTIONAL) {\n\t\t\tthis._affectSpecularity = value;\n\t\t\tthis.updateKey();\n\t\t}\n\t}\n\tget affectSpecularity() {\n\t\treturn this._affectSpecularity;\n\t}\n\tset luminance(value) {\n\t\tif (this._luminance !== value) {\n\t\t\tthis._luminance = value;\n\t\t\tthis._updateFinalColor();\n\t\t}\n\t}\n\tget luminance() {\n\t\treturn this._luminance;\n\t}\n\tget cookieMatrix() {\n\t\tif (!this._cookieMatrix) {\n\t\t\tthis._cookieMatrix = new Mat4();\n\t\t}\n\t\treturn this._cookieMatrix;\n\t}\n\tget atlasViewport() {\n\t\tif (!this._atlasViewport) {\n\t\t\tthis._atlasViewport = new Vec4(0, 0, 1, 1);\n\t\t}\n\t\treturn this._atlasViewport;\n\t}\n\tset cookie(value) {\n\t\tif (this._cookie === value) {\n\t\t\treturn;\n\t\t}\n\t\tthis._cookie = value;\n\t\tthis.updateKey();\n\t}\n\tget cookie() {\n\t\treturn this._cookie;\n\t}\n\tset cookieFalloff(value) {\n\t\tif (this._cookieFalloff === value) {\n\t\t\treturn;\n\t\t}\n\t\tthis._cookieFalloff = value;\n\t\tthis.updateKey();\n\t}\n\tget cookieFalloff() {\n\t\treturn this._cookieFalloff;\n\t}\n\tset cookieChannel(value) {\n\t\tif (this._cookieChannel === value) {\n\t\t\treturn;\n\t\t}\n\t\tif (value.length < 3) {\n\t\t\tconst chr = value.charAt(value.length - 1);\n\t\t\tconst addLen = 3 - value.length;\n\t\t\tfor (let i = 0; i < addLen; i++) {\n\t\t\t\tvalue += chr;\n\t\t\t}\n\t\t}\n\t\tthis._cookieChannel = value;\n\t\tthis.updateKey();\n\t}\n\tget cookieChannel() {\n\t\treturn this._cookieChannel;\n\t}\n\tset cookieTransform(value) {\n\t\tif (this._cookieTransform === value) {\n\t\t\treturn;\n\t\t}\n\t\tthis._cookieTransform = value;\n\t\tthis._cookieTransformSet = !!value;\n\t\tif (value && !this._cookieOffset) {\n\t\t\tthis.cookieOffset = new Vec2();\n\t\t\tthis._cookieOffsetSet = false;\n\t\t}\n\t\tthis.updateKey();\n\t}\n\tget cookieTransform() {\n\t\treturn this._cookieTransform;\n\t}\n\tset cookieOffset(value) {\n\t\tif (this._cookieOffset === value) {\n\t\t\treturn;\n\t\t}\n\t\tconst xformNew = !!(this._cookieTransformSet || value);\n\t\tif (xformNew && !value && this._cookieOffset) {\n\t\t\tthis._cookieOffset.set(0, 0);\n\t\t} else {\n\t\t\tthis._cookieOffset = value;\n\t\t}\n\t\tthis._cookieOffsetSet = !!value;\n\t\tif (value && !this._cookieTransform) {\n\t\t\tthis.cookieTransform = new Vec4(1, 1, 0, 0);\n\t\t\tthis._cookieTransformSet = false;\n\t\t}\n\t\tthis.updateKey();\n\t}\n\tget cookieOffset() {\n\t\treturn this._cookieOffset;\n\t}\n\tbeginFrame() {\n\t\tthis.visibleThisFrame = this._type === LIGHTTYPE_DIRECTIONAL && this._enabled;\n\t\tthis.maxScreenSize = 0;\n\t\tthis.atlasViewportAllocated = false;\n\t\tthis.atlasSlotUpdated = false;\n\t}\n\t_destroyShadowMap() {\n\t\tthis.releaseRenderData();\n\t\tif (this._shadowMap) {\n\t\t\tif (!this._shadowMap.cached) {\n\t\t\t\tthis._shadowMap.destroy();\n\t\t\t}\n\t\t\tthis._shadowMap = null;\n\t\t}\n\t\tif (this.shadowUpdateMode === SHADOWUPDATE_NONE) {\n\t\t\tthis.shadowUpdateMode = SHADOWUPDATE_THISFRAME;\n\t\t}\n\t\tif (this.shadowUpdateOverrides) {\n\t\t\tfor (let i = 0; i < this.shadowUpdateOverrides.length; i++) {\n\t\t\t\tif (this.shadowUpdateOverrides[i] === SHADOWUPDATE_NONE) {\n\t\t\t\t\tthis.shadowUpdateOverrides[i] = SHADOWUPDATE_THISFRAME;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tgetRenderData(camera, face) {\n\t\tfor (let i = 0; i < this._renderData.length; i++) {\n\t\t\tconst current = this._renderData[i];\n\t\t\tif (current.camera === camera && current.face === face) {\n\t\t\t\treturn current;\n\t\t\t}\n\t\t}\n\t\tconst rd = new LightRenderData(this.device, camera, face, this);\n\t\tthis._renderData.push(rd);\n\t\treturn rd;\n\t}\n\tclone() {\n\t\tconst clone = new Light(this.device, this.clusteredLighting);\n\t\tclone.type = this._type;\n\t\tclone.setColor(this._color);\n\t\tclone.intensity = this._intensity;\n\t\tclone.affectSpecularity = this._affectSpecularity;\n\t\tclone.luminance = this._luminance;\n\t\tclone.castShadows = this.castShadows;\n\t\tclone._enabled = this._enabled;\n\t\tclone.attenuationStart = this.attenuationStart;\n\t\tclone.attenuationEnd = this.attenuationEnd;\n\t\tclone.falloffMode = this._falloffMode;\n\t\tclone.shadowType = this._shadowType;\n\t\tclone.vsmBlurSize = this._vsmBlurSize;\n\t\tclone.vsmBlurMode = this.vsmBlurMode;\n\t\tclone.vsmBias = this.vsmBias;\n\t\tclone.penumbraSize = this.penumbraSize;\n\t\tclone.shadowUpdateMode = this.shadowUpdateMode;\n\t\tclone.mask = this.mask;\n\t\tif (this.shadowUpdateOverrides) {\n\t\t\tclone.shadowUpdateOverrides = this.shadowUpdateOverrides.slice();\n\t\t}\n\t\tclone.innerConeAngle = this._innerConeAngle;\n\t\tclone.outerConeAngle = this._outerConeAngle;\n\t\tclone.numCascades = this.numCascades;\n\t\tclone.cascadeDistribution = this.cascadeDistribution;\n\t\tclone.shape = this._shape;\n\t\tclone.shadowDepthState.copy(this.shadowDepthState);\n\t\tclone.shadowBias = this.shadowBias;\n\t\tclone.normalOffsetBias = this._normalOffsetBias;\n\t\tclone.shadowResolution = this._shadowResolution;\n\t\tclone.shadowDistance = this.shadowDistance;\n\t\tclone.shadowIntensity = this.shadowIntensity;\n\t\treturn clone;\n\t}\n\tstatic getLightUnitConversion(type, outerAngle = Math.PI / 4, innerAngle = 0) {\n\t\tswitch (type) {\n\t\t\tcase LIGHTTYPE_SPOT:\n\t\t\t\t{\n\t\t\t\t\tconst falloffEnd = Math.cos(outerAngle);\n\t\t\t\t\tconst falloffStart = Math.cos(innerAngle);\n\t\t\t\t\treturn 2 * Math.PI * (1 - falloffStart + (falloffStart - falloffEnd) / 2.0);\n\t\t\t\t}\n\t\t\tcase LIGHTTYPE_OMNI:\n\t\t\t\treturn 4 * Math.PI;\n\t\t\tcase LIGHTTYPE_DIRECTIONAL:\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\t_getUniformBiasValues(lightRenderData) {\n\t\tconst farClip = lightRenderData.shadowCamera._farClip;\n\t\tswitch (this._type) {\n\t\t\tcase LIGHTTYPE_OMNI:\n\t\t\t\ttmpBiases.bias = this.shadowBias;\n\t\t\t\ttmpBiases.normalBias = this._normalOffsetBias;\n\t\t\t\tbreak;\n\t\t\tcase LIGHTTYPE_SPOT:\n\t\t\t\tif (this._isVsm) {\n\t\t\t\t\ttmpBiases.bias = -0.00001 * 20;\n\t\t\t\t} else {\n\t\t\t\t\ttmpBiases.bias = this.shadowBias * 20;\n\t\t\t\t\tif (this.device.isWebGL1 && this.device.extStandardDerivatives) tmpBiases.bias *= -100;\n\t\t\t\t}\n\t\t\t\ttmpBiases.normalBias = this._isVsm ? this.vsmBias / (this.attenuationEnd / 7.0) : this._normalOffsetBias;\n\t\t\t\tbreak;\n\t\t\tcase LIGHTTYPE_DIRECTIONAL:\n\t\t\t\tif (this._isVsm) {\n\t\t\t\t\ttmpBiases.bias = -0.00001 * 20;\n\t\t\t\t} else {\n\t\t\t\t\ttmpBiases.bias = this.shadowBias / farClip * 100;\n\t\t\t\t\tif (this.device.isWebGL1 && this.device.extStandardDerivatives) tmpBiases.bias *= -100;\n\t\t\t\t}\n\t\t\t\ttmpBiases.normalBias = this._isVsm ? this.vsmBias / (farClip / 7.0) : this._normalOffsetBias;\n\t\t\t\tbreak;\n\t\t}\n\t\treturn tmpBiases;\n\t}\n\tgetColor() {\n\t\treturn this._color;\n\t}\n\tgetBoundingSphere(sphere) {\n\t\tif (this._type === LIGHTTYPE_SPOT) {\n\t\t\tconst size = this.attenuationEnd;\n\t\t\tconst angle = this._outerConeAngle;\n\t\t\tconst cosAngle = this._outerConeAngleCos;\n\t\t\tconst node = this._node;\n\t\t\ttmpVec.copy(node.up);\n\t\t\tif (angle > 45) {\n\t\t\t\tsphere.radius = size * this._outerConeAngleSin;\n\t\t\t\ttmpVec.mulScalar(-size * cosAngle);\n\t\t\t} else {\n\t\t\t\tsphere.radius = size / (2 * cosAngle);\n\t\t\t\ttmpVec.mulScalar(-sphere.radius);\n\t\t\t}\n\t\t\tsphere.center.add2(node.getPosition(), tmpVec);\n\t\t} else if (this._type === LIGHTTYPE_OMNI) {\n\t\t\tsphere.center = this._node.getPosition();\n\t\t\tsphere.radius = this.attenuationEnd;\n\t\t}\n\t}\n\tgetBoundingBox(box) {\n\t\tif (this._type === LIGHTTYPE_SPOT) {\n\t\t\tconst range = this.attenuationEnd;\n\t\t\tconst angle = this._outerConeAngle;\n\t\t\tconst node = this._node;\n\t\t\tconst scl = Math.abs(Math.sin(angle * math.DEG_TO_RAD) * range);\n\t\t\tbox.center.set(0, -range * 0.5, 0);\n\t\t\tbox.halfExtents.set(scl, range * 0.5, scl);\n\t\t\tbox.setFromTransformedAabb(box, node.getWorldTransform(), true);\n\t\t} else if (this._type === LIGHTTYPE_OMNI) {\n\t\t\tbox.center.copy(this._node.getPosition());\n\t\t\tbox.halfExtents.set(this.attenuationEnd, this.attenuationEnd, this.attenuationEnd);\n\t\t}\n\t}\n\t_updateShadowBias() {\n\t\tconst device = this.device;\n\t\tif (device.isWebGL2 || device.isWebGPU) {\n\t\t\tif (this._type === LIGHTTYPE_OMNI && !this.clusteredLighting) {\n\t\t\t\tthis.shadowDepthState.depthBias = 0;\n\t\t\t\tthis.shadowDepthState.depthBiasSlope = 0;\n\t\t\t} else {\n\t\t\t\tconst bias = this.shadowBias * -1000.0;\n\t\t\t\tthis.shadowDepthState.depthBias = bias;\n\t\t\t\tthis.shadowDepthState.depthBiasSlope = bias;\n\t\t\t}\n\t\t}\n\t}\n\t_updateFinalColor() {\n\t\tconst color = this._color;\n\t\tconst r = color.r;\n\t\tconst g = color.g;\n\t\tconst b = color.b;\n\t\tlet i = this._intensity;\n\t\tif (this._usePhysicalUnits) {\n\t\t\ti = this._luminance / Light.getLightUnitConversion(this._type, this._outerConeAngle * math.DEG_TO_RAD, this._innerConeAngle * math.DEG_TO_RAD);\n\t\t}\n\t\tconst finalColor = this._finalColor;\n\t\tconst linearFinalColor = this._linearFinalColor;\n\t\tfinalColor[0] = r * i;\n\t\tfinalColor[1] = g * i;\n\t\tfinalColor[2] = b * i;\n\t\tif (i >= 1) {\n\t\t\tlinearFinalColor[0] = Math.pow(r, 2.2) * i;\n\t\t\tlinearFinalColor[1] = Math.pow(g, 2.2) * i;\n\t\t\tlinearFinalColor[2] = Math.pow(b, 2.2) * i;\n\t\t} else {\n\t\t\tlinearFinalColor[0] = Math.pow(finalColor[0], 2.2);\n\t\t\tlinearFinalColor[1] = Math.pow(finalColor[1], 2.2);\n\t\t\tlinearFinalColor[2] = Math.pow(finalColor[2], 2.2);\n\t\t}\n\t}\n\tsetColor() {\n\t\tif (arguments.length === 1) {\n\t\t\tthis._color.set(arguments[0].r, arguments[0].g, arguments[0].b);\n\t\t} else if (arguments.length === 3) {\n\t\t\tthis._color.set(arguments[0], arguments[1], arguments[2]);\n\t\t}\n\t\tthis._updateFinalColor();\n\t}\n\tlayersDirty() {\n\t\tthis.layers.forEach(layer => {\n\t\t\tlayer.markLightsDirty();\n\t\t});\n\t}\n\tupdateKey() {\n\t\tlet key = this._type << 29 | (this._castShadows ? 1 : 0) << 28 | this._shadowType << 25 | this._falloffMode << 23 | (this._normalOffsetBias !== 0.0 ? 1 : 0) << 22 | (this._cookie ? 1 : 0) << 21 | (this._cookieFalloff ? 1 : 0) << 20 | chanId[this._cookieChannel.charAt(0)] << 18 | (this._cookieTransform ? 1 : 0) << 12 | this._shape << 10 | this.numCascades - 1 << 8 | (this.affectSpecularity ? 1 : 0) << 7 | this.mask << 6;\n\t\tif (this._cookieChannel.length === 3) {\n\t\t\tkey |= chanId[this._cookieChannel.charAt(1)] << 16;\n\t\t\tkey |= chanId[this._cookieChannel.charAt(2)] << 14;\n\t\t}\n\t\tif (key !== this.key) {\n\t\t\tthis.layersDirty();\n\t\t}\n\t\tthis.key = key;\n\t}\n}\n\nexport { Light, lightTypes };\n","import { Vec2 } from '../../core/math/vec2.js';\nimport { Vec4 } from '../../core/math/vec4.js';\nimport { PIXELFORMAT_RGBA8, FILTER_NEAREST, ADDRESS_CLAMP_TO_EDGE } from '../../platform/graphics/constants.js';\nimport { RenderTarget } from '../../platform/graphics/render-target.js';\nimport { Texture } from '../../platform/graphics/texture.js';\nimport { SHADOW_PCF3, LIGHTTYPE_SPOT, LIGHTTYPE_OMNI } from '../constants.js';\nimport { ShadowMap } from '../renderer/shadow-map.js';\n\nconst _tempArray = [];\nconst _tempArray2 = [];\nconst _viewport = new Vec4();\nconst _scissor = new Vec4();\nclass Slot {\n\tconstructor(rect) {\n\t\tthis.size = Math.floor(rect.w * 1024);\n\t\tthis.used = false;\n\t\tthis.lightId = -1;\n\t\tthis.rect = rect;\n\t}\n}\nclass LightTextureAtlas {\n\tconstructor(device) {\n\t\tthis.device = device;\n\t\tthis.version = 1;\n\t\tthis.shadowAtlasResolution = 2048;\n\t\tthis.shadowAtlas = null;\n\t\tthis.shadowEdgePixels = 3;\n\t\tthis.cookieAtlasResolution = 4;\n\t\tthis.cookieAtlas = new Texture(this.device, {\n\t\t\tname: 'CookieAtlas',\n\t\t\twidth: this.cookieAtlasResolution,\n\t\t\theight: this.cookieAtlasResolution,\n\t\t\tformat: PIXELFORMAT_RGBA8,\n\t\t\tcubemap: false,\n\t\t\tmipmaps: false,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE\n\t\t});\n\t\tthis.cookieRenderTarget = new RenderTarget({\n\t\t\tcolorBuffer: this.cookieAtlas,\n\t\t\tdepth: false,\n\t\t\tflipY: true\n\t\t});\n\t\tthis.slots = [];\n\t\tthis.atlasSplit = [];\n\t\tthis.cubeSlotsOffsets = [new Vec2(0, 0), new Vec2(0, 1), new Vec2(1, 0), new Vec2(1, 1), new Vec2(2, 0), new Vec2(2, 1)];\n\t\tthis.scissorVec = new Vec4();\n\t\tthis.allocateShadowAtlas(1);\n\t\tthis.allocateCookieAtlas(1);\n\t\tthis.allocateUniforms();\n\t}\n\tdestroy() {\n\t\tthis.destroyShadowAtlas();\n\t\tthis.destroyCookieAtlas();\n\t}\n\tdestroyShadowAtlas() {\n\t\tvar _this$shadowAtlas;\n\t\t(_this$shadowAtlas = this.shadowAtlas) == null || _this$shadowAtlas.destroy();\n\t\tthis.shadowAtlas = null;\n\t}\n\tdestroyCookieAtlas() {\n\t\tvar _this$cookieAtlas, _this$cookieRenderTar;\n\t\t(_this$cookieAtlas = this.cookieAtlas) == null || _this$cookieAtlas.destroy();\n\t\tthis.cookieAtlas = null;\n\t\t(_this$cookieRenderTar = this.cookieRenderTarget) == null || _this$cookieRenderTar.destroy();\n\t\tthis.cookieRenderTarget = null;\n\t}\n\tallocateShadowAtlas(resolution) {\n\t\tif (!this.shadowAtlas || this.shadowAtlas.texture.width !== resolution) {\n\t\t\tthis.version++;\n\t\t\tthis.destroyShadowAtlas();\n\t\t\tthis.shadowAtlas = ShadowMap.createAtlas(this.device, resolution, SHADOW_PCF3);\n\t\t\tthis.shadowAtlas.cached = true;\n\t\t\tconst scissorOffset = 4 / this.shadowAtlasResolution;\n\t\t\tthis.scissorVec.set(scissorOffset, scissorOffset, -2 * scissorOffset, -2 * scissorOffset);\n\t\t}\n\t}\n\tallocateCookieAtlas(resolution) {\n\t\tif (this.cookieAtlas.width !== resolution) {\n\t\t\tthis.cookieRenderTarget.resize(resolution, resolution);\n\t\t\tthis.version++;\n\t\t}\n\t}\n\tallocateUniforms() {\n\t\tthis._shadowAtlasTextureId = this.device.scope.resolve('shadowAtlasTexture');\n\t\tthis._shadowAtlasParamsId = this.device.scope.resolve('shadowAtlasParams');\n\t\tthis._shadowAtlasParams = new Float32Array(2);\n\t\tthis._cookieAtlasTextureId = this.device.scope.resolve('cookieAtlasTexture');\n\t}\n\tupdateUniforms() {\n\t\tconst isShadowFilterPcf = true;\n\t\tconst rt = this.shadowAtlas.renderTargets[0];\n\t\tconst isDepthShadow = !this.device.isWebGL1 && isShadowFilterPcf;\n\t\tconst shadowBuffer = isDepthShadow ? rt.depthBuffer : rt.colorBuffer;\n\t\tthis._shadowAtlasTextureId.setValue(shadowBuffer);\n\t\tthis._shadowAtlasParams[0] = this.shadowAtlasResolution;\n\t\tthis._shadowAtlasParams[1] = this.shadowEdgePixels;\n\t\tthis._shadowAtlasParamsId.setValue(this._shadowAtlasParams);\n\t\tthis._cookieAtlasTextureId.setValue(this.cookieAtlas);\n\t}\n\tsubdivide(numLights, lightingParams) {\n\t\tlet atlasSplit = lightingParams.atlasSplit;\n\t\tif (!atlasSplit) {\n\t\t\tconst gridSize = Math.ceil(Math.sqrt(numLights));\n\t\t\tatlasSplit = _tempArray2;\n\t\t\tatlasSplit[0] = gridSize;\n\t\t\tatlasSplit.length = 1;\n\t\t}\n\t\tconst arraysEqual = (a, b) => a.length === b.length && a.every((v, i) => v === b[i]);\n\t\tif (!arraysEqual(atlasSplit, this.atlasSplit)) {\n\t\t\tthis.version++;\n\t\t\tthis.slots.length = 0;\n\t\t\tthis.atlasSplit.length = 0;\n\t\t\tthis.atlasSplit.push(...atlasSplit);\n\t\t\tconst splitCount = this.atlasSplit[0];\n\t\t\tif (splitCount > 1) {\n\t\t\t\tconst invSize = 1 / splitCount;\n\t\t\t\tfor (let i = 0; i < splitCount; i++) {\n\t\t\t\t\tfor (let j = 0; j < splitCount; j++) {\n\t\t\t\t\t\tconst rect = new Vec4(i * invSize, j * invSize, invSize, invSize);\n\t\t\t\t\t\tconst nextLevelSplit = this.atlasSplit[1 + i * splitCount + j];\n\t\t\t\t\t\tif (nextLevelSplit > 1) {\n\t\t\t\t\t\t\tfor (let x = 0; x < nextLevelSplit; x++) {\n\t\t\t\t\t\t\t\tfor (let y = 0; y < nextLevelSplit; y++) {\n\t\t\t\t\t\t\t\t\tconst invSizeNext = invSize / nextLevelSplit;\n\t\t\t\t\t\t\t\t\tconst rectNext = new Vec4(rect.x + x * invSizeNext, rect.y + y * invSizeNext, invSizeNext, invSizeNext);\n\t\t\t\t\t\t\t\t\tthis.slots.push(new Slot(rectNext));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.slots.push(new Slot(rect));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.slots.push(new Slot(new Vec4(0, 0, 1, 1)));\n\t\t\t}\n\t\t\tthis.slots.sort((a, b) => {\n\t\t\t\treturn b.size - a.size;\n\t\t\t});\n\t\t}\n\t}\n\tcollectLights(localLights, lightingParams) {\n\t\tconst cookiesEnabled = lightingParams.cookiesEnabled;\n\t\tconst shadowsEnabled = lightingParams.shadowsEnabled;\n\t\tlet needsShadowAtlas = false;\n\t\tlet needsCookieAtlas = false;\n\t\tconst lights = _tempArray;\n\t\tlights.length = 0;\n\t\tconst processLights = list => {\n\t\t\tfor (let i = 0; i < list.length; i++) {\n\t\t\t\tconst light = list[i];\n\t\t\t\tif (light.visibleThisFrame) {\n\t\t\t\t\tconst lightShadow = shadowsEnabled && light.castShadows;\n\t\t\t\t\tconst lightCookie = cookiesEnabled && !!light.cookie;\n\t\t\t\t\tneedsShadowAtlas || (needsShadowAtlas = lightShadow);\n\t\t\t\t\tneedsCookieAtlas || (needsCookieAtlas = lightCookie);\n\t\t\t\t\tif (lightShadow || lightCookie) {\n\t\t\t\t\t\tlights.push(light);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\tif (cookiesEnabled || shadowsEnabled) {\n\t\t\tprocessLights(localLights);\n\t\t}\n\t\tlights.sort((a, b) => {\n\t\t\treturn b.maxScreenSize - a.maxScreenSize;\n\t\t});\n\t\tif (needsShadowAtlas) {\n\t\t\tthis.allocateShadowAtlas(this.shadowAtlasResolution);\n\t\t}\n\t\tif (needsCookieAtlas) {\n\t\t\tthis.allocateCookieAtlas(this.cookieAtlasResolution);\n\t\t}\n\t\tif (needsShadowAtlas || needsCookieAtlas) {\n\t\t\tthis.subdivide(lights.length, lightingParams);\n\t\t}\n\t\treturn lights;\n\t}\n\tsetupSlot(light, rect) {\n\t\tlight.atlasViewport.copy(rect);\n\t\tconst faceCount = light.numShadowFaces;\n\t\tfor (let face = 0; face < faceCount; face++) {\n\t\t\tif (light.castShadows || light._cookie) {\n\t\t\t\t_viewport.copy(rect);\n\t\t\t\t_scissor.copy(rect);\n\t\t\t\tif (light._type === LIGHTTYPE_SPOT) {\n\t\t\t\t\t_viewport.add(this.scissorVec);\n\t\t\t\t}\n\t\t\t\tif (light._type === LIGHTTYPE_OMNI) {\n\t\t\t\t\tconst smallSize = _viewport.z / 3;\n\t\t\t\t\tconst offset = this.cubeSlotsOffsets[face];\n\t\t\t\t\t_viewport.x += smallSize * offset.x;\n\t\t\t\t\t_viewport.y += smallSize * offset.y;\n\t\t\t\t\t_viewport.z = smallSize;\n\t\t\t\t\t_viewport.w = smallSize;\n\t\t\t\t\t_scissor.copy(_viewport);\n\t\t\t\t}\n\t\t\t\tif (light.castShadows) {\n\t\t\t\t\tconst lightRenderData = light.getRenderData(null, face);\n\t\t\t\t\tlightRenderData.shadowViewport.copy(_viewport);\n\t\t\t\t\tlightRenderData.shadowScissor.copy(_scissor);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tassignSlot(light, slotIndex, slotReassigned) {\n\t\tlight.atlasViewportAllocated = true;\n\t\tconst slot = this.slots[slotIndex];\n\t\tslot.lightId = light.id;\n\t\tslot.used = true;\n\t\tif (slotReassigned) {\n\t\t\tlight.atlasSlotUpdated = true;\n\t\t\tlight.atlasVersion = this.version;\n\t\t\tlight.atlasSlotIndex = slotIndex;\n\t\t}\n\t}\n\tupdate(localLights, lightingParams) {\n\t\tthis.shadowAtlasResolution = lightingParams.shadowAtlasResolution;\n\t\tthis.cookieAtlasResolution = lightingParams.cookieAtlasResolution;\n\t\tconst lights = this.collectLights(localLights, lightingParams);\n\t\tif (lights.length > 0) {\n\t\t\tconst slots = this.slots;\n\t\t\tfor (let i = 0; i < slots.length; i++) {\n\t\t\t\tslots[i].used = false;\n\t\t\t}\n\t\t\tconst assignCount = Math.min(lights.length, slots.length);\n\t\t\tfor (let i = 0; i < assignCount; i++) {\n\t\t\t\tconst light = lights[i];\n\t\t\t\tif (light.castShadows) {\n\t\t\t\t\tlight._shadowMap = this.shadowAtlas;\n\t\t\t\t}\n\t\t\t\tconst previousSlot = slots[light.atlasSlotIndex];\n\t\t\t\tif (light.atlasVersion === this.version && light.id === (previousSlot == null ? void 0 : previousSlot.lightId)) {\n\t\t\t\t\tconst _previousSlot = slots[light.atlasSlotIndex];\n\t\t\t\t\tif (_previousSlot.size === slots[i].size && !_previousSlot.used) {\n\t\t\t\t\t\tthis.assignSlot(light, light.atlasSlotIndex, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet usedCount = 0;\n\t\t\tfor (let i = 0; i < assignCount; i++) {\n\t\t\t\twhile (usedCount < slots.length && slots[usedCount].used) {\n\t\t\t\t\tusedCount++;\n\t\t\t\t}\n\t\t\t\tconst light = lights[i];\n\t\t\t\tif (!light.atlasViewportAllocated) {\n\t\t\t\t\tthis.assignSlot(light, usedCount, true);\n\t\t\t\t}\n\t\t\t\tconst slot = slots[light.atlasSlotIndex];\n\t\t\t\tthis.setupSlot(light, slot.rect);\n\t\t\t}\n\t\t}\n\t\tthis.updateUniforms();\n\t}\n}\n\nexport { LightTextureAtlas };\n","import { math } from '../../core/math/math.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { SHADOW_PCF3 } from '../constants.js';\n\nclass LightingParams {\n\tconstructor(supportsAreaLights, maxTextureSize, dirtyLightsFnc) {\n\t\tthis._areaLightsEnabled = false;\n\t\tthis._cells = new Vec3(10, 3, 10);\n\t\tthis._maxLightsPerCell = 255;\n\t\tthis._shadowsEnabled = true;\n\t\tthis._shadowType = SHADOW_PCF3;\n\t\tthis._shadowAtlasResolution = 2048;\n\t\tthis._cookiesEnabled = false;\n\t\tthis._cookieAtlasResolution = 2048;\n\t\tthis.debugLayer = void 0;\n\t\tthis.atlasSplit = null;\n\t\tthis._supportsAreaLights = supportsAreaLights;\n\t\tthis._maxTextureSize = maxTextureSize;\n\t\tthis._dirtyLightsFnc = dirtyLightsFnc;\n\t}\n\tapplySettings(render) {\n\t\tvar _render$lightingShado, _render$lightingCooki, _render$lightingAreaL, _render$lightingShado2, _render$lightingCooki2, _render$lightingMaxLi, _render$lightingShado3;\n\t\tthis.shadowsEnabled = (_render$lightingShado = render.lightingShadowsEnabled) != null ? _render$lightingShado : this.shadowsEnabled;\n\t\tthis.cookiesEnabled = (_render$lightingCooki = render.lightingCookiesEnabled) != null ? _render$lightingCooki : this.cookiesEnabled;\n\t\tthis.areaLightsEnabled = (_render$lightingAreaL = render.lightingAreaLightsEnabled) != null ? _render$lightingAreaL : this.areaLightsEnabled;\n\t\tthis.shadowAtlasResolution = (_render$lightingShado2 = render.lightingShadowAtlasResolution) != null ? _render$lightingShado2 : this.shadowAtlasResolution;\n\t\tthis.cookieAtlasResolution = (_render$lightingCooki2 = render.lightingCookieAtlasResolution) != null ? _render$lightingCooki2 : this.cookieAtlasResolution;\n\t\tthis.maxLightsPerCell = (_render$lightingMaxLi = render.lightingMaxLightsPerCell) != null ? _render$lightingMaxLi : this.maxLightsPerCell;\n\t\tthis.shadowType = (_render$lightingShado3 = render.lightingShadowType) != null ? _render$lightingShado3 : this.shadowType;\n\t\tif (render.lightingCells) {\n\t\t\tthis.cell = new Vec3(render.lightingCells);\n\t\t}\n\t}\n\tset cells(value) {\n\t\tthis._cells.copy(value);\n\t}\n\tget cells() {\n\t\treturn this._cells;\n\t}\n\tset maxLightsPerCell(value) {\n\t\tthis._maxLightsPerCell = math.clamp(value, 1, 255);\n\t}\n\tget maxLightsPerCell() {\n\t\treturn this._maxLightsPerCell;\n\t}\n\tset cookieAtlasResolution(value) {\n\t\tthis._cookieAtlasResolution = math.clamp(value, 32, this._maxTextureSize);\n\t}\n\tget cookieAtlasResolution() {\n\t\treturn this._cookieAtlasResolution;\n\t}\n\tset shadowAtlasResolution(value) {\n\t\tthis._shadowAtlasResolution = math.clamp(value, 32, this._maxTextureSize);\n\t}\n\tget shadowAtlasResolution() {\n\t\treturn this._shadowAtlasResolution;\n\t}\n\tset shadowType(value) {\n\t\tif (this._shadowType !== value) {\n\t\t\tthis._shadowType = value;\n\t\t\tthis._dirtyLightsFnc();\n\t\t}\n\t}\n\tget shadowType() {\n\t\treturn this._shadowType;\n\t}\n\tset cookiesEnabled(value) {\n\t\tif (this._cookiesEnabled !== value) {\n\t\t\tthis._cookiesEnabled = value;\n\t\t\tthis._dirtyLightsFnc();\n\t\t}\n\t}\n\tget cookiesEnabled() {\n\t\treturn this._cookiesEnabled;\n\t}\n\tset areaLightsEnabled(value) {\n\t\tif (this._supportsAreaLights) {\n\t\t\tif (this._areaLightsEnabled !== value) {\n\t\t\t\tthis._areaLightsEnabled = value;\n\t\t\t\tthis._dirtyLightsFnc();\n\t\t\t}\n\t\t}\n\t}\n\tget areaLightsEnabled() {\n\t\treturn this._areaLightsEnabled;\n\t}\n\tset shadowsEnabled(value) {\n\t\tif (this._shadowsEnabled !== value) {\n\t\t\tthis._shadowsEnabled = value;\n\t\t\tthis._dirtyLightsFnc();\n\t\t}\n\t}\n\tget shadowsEnabled() {\n\t\treturn this._shadowsEnabled;\n\t}\n}\n\nexport { LightingParams };\n","import { Vec3 } from '../../core/math/vec3.js';\nimport { PIXELFORMAT_RGBA8, PIXELFORMAT_RGBA32F, ADDRESS_CLAMP_TO_EDGE, TEXTURETYPE_DEFAULT, FILTER_NEAREST } from '../../platform/graphics/constants.js';\nimport { FloatPacking } from '../../core/math/float-packing.js';\nimport { MASK_AFFECT_DYNAMIC, MASK_AFFECT_LIGHTMAPPED, LIGHTTYPE_SPOT, LIGHTSHAPE_PUNCTUAL } from '../constants.js';\nimport { Texture } from '../../platform/graphics/texture.js';\nimport { DeviceCache } from '../../platform/graphics/device-cache.js';\nimport { LightCamera } from '../renderer/light-camera.js';\n\nconst epsilon = 0.000001;\nconst tempVec3 = new Vec3();\nconst tempAreaLightSizes = new Float32Array(6);\nconst areaHalfAxisWidth = new Vec3(-0.5, 0, 0);\nconst areaHalfAxisHeight = new Vec3(0, 0, 0.5);\nconst TextureIndex8 = {\n\tFLAGS: 0,\n\tCOLOR_A: 1,\n\tCOLOR_B: 2,\n\tSPOT_ANGLES: 3,\n\tSHADOW_BIAS: 4,\n\tCOOKIE_A: 5,\n\tCOOKIE_B: 6,\n\tCOUNT_ALWAYS: 7,\n\tPOSITION_X: 7,\n\tPOSITION_Y: 8,\n\tPOSITION_Z: 9,\n\tRANGE: 10,\n\tSPOT_DIRECTION_X: 11,\n\tSPOT_DIRECTION_Y: 12,\n\tSPOT_DIRECTION_Z: 13,\n\tPROJ_MAT_00: 14,\n\tATLAS_VIEWPORT_A: 14,\n\tPROJ_MAT_01: 15,\n\tATLAS_VIEWPORT_B: 15,\n\tPROJ_MAT_02: 16,\n\tPROJ_MAT_03: 17,\n\tPROJ_MAT_10: 18,\n\tPROJ_MAT_11: 19,\n\tPROJ_MAT_12: 20,\n\tPROJ_MAT_13: 21,\n\tPROJ_MAT_20: 22,\n\tPROJ_MAT_21: 23,\n\tPROJ_MAT_22: 24,\n\tPROJ_MAT_23: 25,\n\tPROJ_MAT_30: 26,\n\tPROJ_MAT_31: 27,\n\tPROJ_MAT_32: 28,\n\tPROJ_MAT_33: 29,\n\tAREA_DATA_WIDTH_X: 30,\n\tAREA_DATA_WIDTH_Y: 31,\n\tAREA_DATA_WIDTH_Z: 32,\n\tAREA_DATA_HEIGHT_X: 33,\n\tAREA_DATA_HEIGHT_Y: 34,\n\tAREA_DATA_HEIGHT_Z: 35,\n\tCOUNT: 36\n};\nconst TextureIndexFloat = {\n\tPOSITION_RANGE: 0,\n\tSPOT_DIRECTION: 1,\n\tPROJ_MAT_0: 2,\n\tATLAS_VIEWPORT: 2,\n\tPROJ_MAT_1: 3,\n\tPROJ_MAT_2: 4,\n\tPROJ_MAT_3: 5,\n\tAREA_DATA_WIDTH: 6,\n\tAREA_DATA_HEIGHT: 7,\n\tCOUNT: 8\n};\nconst FORMAT_FLOAT = 0;\nconst FORMAT_8BIT = 1;\nconst shaderDefinesDeviceCache = new DeviceCache();\nclass LightsBuffer {\n\tstatic getLightTextureFormat(device) {\n\t\treturn device.extTextureFloat && device.maxTextures > 8 ? FORMAT_FLOAT : FORMAT_8BIT;\n\t}\n\tstatic getShaderDefines(device) {\n\t\treturn shaderDefinesDeviceCache.get(device, () => {\n\t\t\tconst buildShaderDefines = (device, object, prefix, floatOffset) => {\n\t\t\t\treturn Object.keys(object).map(key => `#define ${prefix}${key} ${object[key]}${floatOffset}`).join('\\n');\n\t\t\t};\n\t\t\tconst lightTextureFormat = LightsBuffer.getLightTextureFormat(device);\n\t\t\tconst clusterTextureFormat = lightTextureFormat === FORMAT_FLOAT ? 'FLOAT' : '8BIT';\n\t\t\tconst floatOffset = device.supportsTextureFetch ? '' : '.5';\n\t\t\treturn `\n\t\t\t\t\t\t\t\t\\n#define CLUSTER_TEXTURE_${clusterTextureFormat}\n\t\t\t\t\t\t\t\t${buildShaderDefines(device, TextureIndex8, 'CLUSTER_TEXTURE_8_', floatOffset)}\n\t\t\t\t\t\t\t\t${buildShaderDefines(device, TextureIndexFloat, 'CLUSTER_TEXTURE_F_', floatOffset)}\n\t\t\t\t\t\t`;\n\t\t});\n\t}\n\tconstructor(device) {\n\t\tthis.device = device;\n\t\tthis.cookiesEnabled = false;\n\t\tthis.shadowsEnabled = false;\n\t\tthis.areaLightsEnabled = false;\n\t\tthis.maxLights = 255;\n\t\tlet pixelsPerLight8 = TextureIndex8.COUNT_ALWAYS;\n\t\tlet pixelsPerLightFloat = 0;\n\t\tthis.lightTextureFormat = LightsBuffer.getLightTextureFormat(device);\n\t\tif (this.lightTextureFormat === FORMAT_FLOAT) {\n\t\t\tpixelsPerLightFloat = TextureIndexFloat.COUNT;\n\t\t} else {\n\t\t\tpixelsPerLight8 = TextureIndex8.COUNT;\n\t\t}\n\t\tthis.lights8 = new Uint8ClampedArray(4 * pixelsPerLight8 * this.maxLights);\n\t\tthis.lightsTexture8 = this.createTexture(this.device, pixelsPerLight8, this.maxLights, PIXELFORMAT_RGBA8, 'LightsTexture8');\n\t\tthis._lightsTexture8Id = this.device.scope.resolve('lightsTexture8');\n\t\tif (pixelsPerLightFloat) {\n\t\t\tthis.lightsFloat = new Float32Array(4 * pixelsPerLightFloat * this.maxLights);\n\t\t\tthis.lightsTextureFloat = this.createTexture(this.device, pixelsPerLightFloat, this.maxLights, PIXELFORMAT_RGBA32F, 'LightsTextureFloat');\n\t\t\tthis._lightsTextureFloatId = this.device.scope.resolve('lightsTextureFloat');\n\t\t} else {\n\t\t\tthis.lightsFloat = null;\n\t\t\tthis.lightsTextureFloat = null;\n\t\t\tthis._lightsTextureFloatId = undefined;\n\t\t}\n\t\tthis._lightsTextureInvSizeId = this.device.scope.resolve('lightsTextureInvSize');\n\t\tthis._lightsTextureInvSizeData = new Float32Array(4);\n\t\tthis._lightsTextureInvSizeData[0] = pixelsPerLightFloat ? 1.0 / this.lightsTextureFloat.width : 0;\n\t\tthis._lightsTextureInvSizeData[1] = pixelsPerLightFloat ? 1.0 / this.lightsTextureFloat.height : 0;\n\t\tthis._lightsTextureInvSizeData[2] = 1.0 / this.lightsTexture8.width;\n\t\tthis._lightsTextureInvSizeData[3] = 1.0 / this.lightsTexture8.height;\n\t\tthis.invMaxColorValue = 0;\n\t\tthis.invMaxAttenuation = 0;\n\t\tthis.boundsMin = new Vec3();\n\t\tthis.boundsDelta = new Vec3();\n\t}\n\tdestroy() {\n\t\tif (this.lightsTexture8) {\n\t\t\tthis.lightsTexture8.destroy();\n\t\t\tthis.lightsTexture8 = null;\n\t\t}\n\t\tif (this.lightsTextureFloat) {\n\t\t\tthis.lightsTextureFloat.destroy();\n\t\t\tthis.lightsTextureFloat = null;\n\t\t}\n\t}\n\tcreateTexture(device, width, height, format, name) {\n\t\tconst tex = new Texture(device, {\n\t\t\tname: name,\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tmipmaps: false,\n\t\t\tformat: format,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\ttype: TEXTURETYPE_DEFAULT,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tanisotropy: 1\n\t\t});\n\t\treturn tex;\n\t}\n\tsetCompressionRanges(maxAttenuation, maxColorValue) {\n\t\tthis.invMaxColorValue = 1 / maxColorValue;\n\t\tthis.invMaxAttenuation = 1 / maxAttenuation;\n\t}\n\tsetBounds(min, delta) {\n\t\tthis.boundsMin.copy(min);\n\t\tthis.boundsDelta.copy(delta);\n\t}\n\tuploadTextures() {\n\t\tif (this.lightsTextureFloat) {\n\t\t\tthis.lightsTextureFloat.lock().set(this.lightsFloat);\n\t\t\tthis.lightsTextureFloat.unlock();\n\t\t}\n\t\tthis.lightsTexture8.lock().set(this.lights8);\n\t\tthis.lightsTexture8.unlock();\n\t}\n\tupdateUniforms() {\n\t\tthis._lightsTexture8Id.setValue(this.lightsTexture8);\n\t\tif (this.lightTextureFormat === FORMAT_FLOAT) {\n\t\t\tthis._lightsTextureFloatId.setValue(this.lightsTextureFloat);\n\t\t}\n\t\tthis._lightsTextureInvSizeId.setValue(this._lightsTextureInvSizeData);\n\t}\n\tgetSpotDirection(direction, spot) {\n\t\tconst mat = spot._node.getWorldTransform();\n\t\tmat.getY(direction).mulScalar(-1);\n\t\tdirection.normalize();\n\t}\n\tgetLightAreaSizes(light) {\n\t\tconst mat = light._node.getWorldTransform();\n\t\tmat.transformVector(areaHalfAxisWidth, tempVec3);\n\t\ttempAreaLightSizes[0] = tempVec3.x;\n\t\ttempAreaLightSizes[1] = tempVec3.y;\n\t\ttempAreaLightSizes[2] = tempVec3.z;\n\t\tmat.transformVector(areaHalfAxisHeight, tempVec3);\n\t\ttempAreaLightSizes[3] = tempVec3.x;\n\t\ttempAreaLightSizes[4] = tempVec3.y;\n\t\ttempAreaLightSizes[5] = tempVec3.z;\n\t\treturn tempAreaLightSizes;\n\t}\n\taddLightDataFlags(data8, index, light, isSpot, castShadows, shadowIntensity) {\n\t\tdata8[index + 0] = isSpot ? 255 : 0;\n\t\tdata8[index + 1] = light._shape * 64;\n\t\tdata8[index + 2] = light._falloffMode * 255;\n\t\tdata8[index + 3] = castShadows ? shadowIntensity * 255 : 0;\n\t}\n\taddLightDataColor(data8, index, light, gammaCorrection, isCookie) {\n\t\tconst invMaxColorValue = this.invMaxColorValue;\n\t\tconst color = gammaCorrection ? light._linearFinalColor : light._finalColor;\n\t\tFloatPacking.float2Bytes(color[0] * invMaxColorValue, data8, index + 0, 2);\n\t\tFloatPacking.float2Bytes(color[1] * invMaxColorValue, data8, index + 2, 2);\n\t\tFloatPacking.float2Bytes(color[2] * invMaxColorValue, data8, index + 4, 2);\n\t\tdata8[index + 6] = isCookie ? 255 : 0;\n\t\tconst isDynamic = !!(light.mask & MASK_AFFECT_DYNAMIC);\n\t\tconst isLightmapped = !!(light.mask & MASK_AFFECT_LIGHTMAPPED);\n\t\tdata8[index + 7] = isDynamic && isLightmapped ? 127 : isLightmapped ? 255 : 0;\n\t}\n\taddLightDataSpotAngles(data8, index, light) {\n\t\tFloatPacking.float2Bytes(light._innerConeAngleCos * (0.5 - epsilon) + 0.5, data8, index + 0, 2);\n\t\tFloatPacking.float2Bytes(light._outerConeAngleCos * (0.5 - epsilon) + 0.5, data8, index + 2, 2);\n\t}\n\taddLightDataShadowBias(data8, index, light) {\n\t\tconst lightRenderData = light.getRenderData(null, 0);\n\t\tconst biases = light._getUniformBiasValues(lightRenderData);\n\t\tFloatPacking.float2BytesRange(biases.bias, data8, index, -1, 20, 2);\n\t\tFloatPacking.float2Bytes(biases.normalBias, data8, index + 2, 2);\n\t}\n\taddLightDataPositionRange(data8, index, light, pos) {\n\t\tconst normPos = tempVec3.sub2(pos, this.boundsMin).div(this.boundsDelta);\n\t\tFloatPacking.float2Bytes(normPos.x, data8, index + 0, 4);\n\t\tFloatPacking.float2Bytes(normPos.y, data8, index + 4, 4);\n\t\tFloatPacking.float2Bytes(normPos.z, data8, index + 8, 4);\n\t\tFloatPacking.float2Bytes(light.attenuationEnd * this.invMaxAttenuation, data8, index + 12, 4);\n\t}\n\taddLightDataSpotDirection(data8, index, light) {\n\t\tthis.getSpotDirection(tempVec3, light);\n\t\tFloatPacking.float2Bytes(tempVec3.x * (0.5 - epsilon) + 0.5, data8, index + 0, 4);\n\t\tFloatPacking.float2Bytes(tempVec3.y * (0.5 - epsilon) + 0.5, data8, index + 4, 4);\n\t\tFloatPacking.float2Bytes(tempVec3.z * (0.5 - epsilon) + 0.5, data8, index + 8, 4);\n\t}\n\taddLightDataLightProjMatrix(data8, index, lightProjectionMatrix) {\n\t\tconst matData = lightProjectionMatrix.data;\n\t\tfor (let m = 0; m < 12; m++) {\n\t\t\tFloatPacking.float2BytesRange(matData[m], data8, index + 4 * m, -2, 2, 4);\n\t\t}\n\t\tfor (let m = 12; m < 16; m++) {\n\t\t\tFloatPacking.float2MantissaExponent(matData[m], data8, index + 4 * m, 4);\n\t\t}\n\t}\n\taddLightDataCookies(data8, index, light) {\n\t\tconst isRgb = light._cookieChannel === 'rgb';\n\t\tdata8[index + 0] = Math.floor(light.cookieIntensity * 255);\n\t\tdata8[index + 1] = isRgb ? 255 : 0;\n\t\tif (!isRgb) {\n\t\t\tconst channel = light._cookieChannel;\n\t\t\tdata8[index + 4] = channel === 'rrr' ? 255 : 0;\n\t\t\tdata8[index + 5] = channel === 'ggg' ? 255 : 0;\n\t\t\tdata8[index + 6] = channel === 'bbb' ? 255 : 0;\n\t\t\tdata8[index + 7] = channel === 'aaa' ? 255 : 0;\n\t\t}\n\t}\n\taddLightAtlasViewport(data8, index, atlasViewport) {\n\t\tFloatPacking.float2Bytes(atlasViewport.x, data8, index + 0, 2);\n\t\tFloatPacking.float2Bytes(atlasViewport.y, data8, index + 2, 2);\n\t\tFloatPacking.float2Bytes(atlasViewport.z / 3, data8, index + 4, 2);\n\t}\n\taddLightAreaSizes(data8, index, light) {\n\t\tconst areaSizes = this.getLightAreaSizes(light);\n\t\tfor (let i = 0; i < 6; i++) {\n\t\t\tFloatPacking.float2MantissaExponent(areaSizes[i], data8, index + 4 * i, 4);\n\t\t}\n\t}\n\taddLightData(light, lightIndex, gammaCorrection) {\n\t\tconst isSpot = light._type === LIGHTTYPE_SPOT;\n\t\tconst hasAtlasViewport = light.atlasViewportAllocated;\n\t\tconst isCookie = this.cookiesEnabled && !!light._cookie && hasAtlasViewport;\n\t\tconst isArea = this.areaLightsEnabled && light.shape !== LIGHTSHAPE_PUNCTUAL;\n\t\tconst castShadows = this.shadowsEnabled && light.castShadows && hasAtlasViewport;\n\t\tconst pos = light._node.getPosition();\n\t\tlet lightProjectionMatrix = null;\n\t\tlet atlasViewport = null;\n\t\tif (isSpot) {\n\t\t\tif (castShadows) {\n\t\t\t\tconst lightRenderData = light.getRenderData(null, 0);\n\t\t\t\tlightProjectionMatrix = lightRenderData.shadowMatrix;\n\t\t\t} else if (isCookie) {\n\t\t\t\tlightProjectionMatrix = LightCamera.evalSpotCookieMatrix(light);\n\t\t\t}\n\t\t} else {\n\t\t\tif (castShadows || isCookie) {\n\t\t\t\tatlasViewport = light.atlasViewport;\n\t\t\t}\n\t\t}\n\t\tconst data8 = this.lights8;\n\t\tconst data8Start = lightIndex * this.lightsTexture8.width * 4;\n\t\tthis.addLightDataFlags(data8, data8Start + 4 * TextureIndex8.FLAGS, light, isSpot, castShadows, light.shadowIntensity);\n\t\tthis.addLightDataColor(data8, data8Start + 4 * TextureIndex8.COLOR_A, light, gammaCorrection, isCookie);\n\t\tif (isSpot) {\n\t\t\tthis.addLightDataSpotAngles(data8, data8Start + 4 * TextureIndex8.SPOT_ANGLES, light);\n\t\t}\n\t\tif (light.castShadows) {\n\t\t\tthis.addLightDataShadowBias(data8, data8Start + 4 * TextureIndex8.SHADOW_BIAS, light);\n\t\t}\n\t\tif (isCookie) {\n\t\t\tthis.addLightDataCookies(data8, data8Start + 4 * TextureIndex8.COOKIE_A, light);\n\t\t}\n\t\tif (this.lightTextureFormat === FORMAT_FLOAT) {\n\t\t\tconst dataFloat = this.lightsFloat;\n\t\t\tconst dataFloatStart = lightIndex * this.lightsTextureFloat.width * 4;\n\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 0] = pos.x;\n\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 1] = pos.y;\n\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 2] = pos.z;\n\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.POSITION_RANGE + 3] = light.attenuationEnd;\n\t\t\tif (isSpot) {\n\t\t\t\tthis.getSpotDirection(tempVec3, light);\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 0] = tempVec3.x;\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 1] = tempVec3.y;\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.SPOT_DIRECTION + 2] = tempVec3.z;\n\t\t\t}\n\t\t\tif (lightProjectionMatrix) {\n\t\t\t\tconst matData = lightProjectionMatrix.data;\n\t\t\t\tfor (let m = 0; m < 16; m++) {\n\t\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.PROJ_MAT_0 + m] = matData[m];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (atlasViewport) {\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 0] = atlasViewport.x;\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 1] = atlasViewport.y;\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.ATLAS_VIEWPORT + 2] = atlasViewport.z / 3;\n\t\t\t}\n\t\t\tif (isArea) {\n\t\t\t\tconst areaSizes = this.getLightAreaSizes(light);\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 0] = areaSizes[0];\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 1] = areaSizes[1];\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_WIDTH + 2] = areaSizes[2];\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 0] = areaSizes[3];\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 1] = areaSizes[4];\n\t\t\t\tdataFloat[dataFloatStart + 4 * TextureIndexFloat.AREA_DATA_HEIGHT + 2] = areaSizes[5];\n\t\t\t}\n\t\t} else {\n\t\t\tthis.addLightDataPositionRange(data8, data8Start + 4 * TextureIndex8.POSITION_X, light, pos);\n\t\t\tif (isSpot) {\n\t\t\t\tthis.addLightDataSpotDirection(data8, data8Start + 4 * TextureIndex8.SPOT_DIRECTION_X, light);\n\t\t\t}\n\t\t\tif (lightProjectionMatrix) {\n\t\t\t\tthis.addLightDataLightProjMatrix(data8, data8Start + 4 * TextureIndex8.PROJ_MAT_00, lightProjectionMatrix);\n\t\t\t}\n\t\t\tif (atlasViewport) {\n\t\t\t\tthis.addLightAtlasViewport(data8, data8Start + 4 * TextureIndex8.ATLAS_VIEWPORT_A, atlasViewport);\n\t\t\t}\n\t\t\tif (isArea) {\n\t\t\t\tthis.addLightAreaSizes(data8, data8Start + 4 * TextureIndex8.AREA_DATA_WIDTH_X, light);\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { LightsBuffer };\n","import { Vec3 } from '../../core/math/vec3.js';\nimport { math } from '../../core/math/math.js';\nimport { BoundingBox } from '../../core/shape/bounding-box.js';\nimport { PIXELFORMAT_L8 } from '../../platform/graphics/constants.js';\nimport { MASK_AFFECT_DYNAMIC, MASK_AFFECT_LIGHTMAPPED, LIGHTTYPE_SPOT, LIGHTTYPE_DIRECTIONAL } from '../constants.js';\nimport { LightsBuffer } from './lights-buffer.js';\n\nconst tempVec3 = new Vec3();\nconst tempMin3 = new Vec3();\nconst tempMax3 = new Vec3();\nconst tempBox = new BoundingBox();\nconst epsilon = 0.000001;\nclass ClusterLight {\n\tconstructor() {\n\t\tthis.light = null;\n\t\tthis.min = new Vec3();\n\t\tthis.max = new Vec3();\n\t}\n}\nclass WorldClusters {\n\tconstructor(device) {\n\t\tthis.clusterTexture = void 0;\n\t\tthis.device = device;\n\t\tthis.name = 'Untitled';\n\t\tthis.reportCount = 0;\n\t\tthis.boundsMin = new Vec3();\n\t\tthis.boundsMax = new Vec3();\n\t\tthis.boundsDelta = new Vec3();\n\t\tthis._cells = new Vec3(1, 1, 1);\n\t\tthis._cellsLimit = new Vec3();\n\t\tthis.cells = this._cells;\n\t\tthis.maxCellLightCount = 4;\n\t\tthis._maxAttenuation = 0;\n\t\tthis._maxColorValue = 0;\n\t\tthis._usedLights = [];\n\t\tthis._usedLights.push(new ClusterLight());\n\t\tthis.lightsBuffer = new LightsBuffer(device);\n\t\tthis.registerUniforms(device);\n\t}\n\tset maxCellLightCount(count) {\n\t\tif (count !== this._maxCellLightCount) {\n\t\t\tthis._maxCellLightCount = count;\n\t\t\tthis._cellsDirty = true;\n\t\t}\n\t}\n\tget maxCellLightCount() {\n\t\treturn this._maxCellLightCount;\n\t}\n\tset cells(value) {\n\t\ttempVec3.copy(value).floor();\n\t\tif (!this._cells.equals(tempVec3)) {\n\t\t\tthis._cells.copy(tempVec3);\n\t\t\tthis._cellsLimit.copy(tempVec3).sub(Vec3.ONE);\n\t\t\tthis._cellsDirty = true;\n\t\t}\n\t}\n\tget cells() {\n\t\treturn this._cells;\n\t}\n\tdestroy() {\n\t\tthis.lightsBuffer.destroy();\n\t\tthis.releaseClusterTexture();\n\t}\n\treleaseClusterTexture() {\n\t\tif (this.clusterTexture) {\n\t\t\tthis.clusterTexture.destroy();\n\t\t\tthis.clusterTexture = null;\n\t\t}\n\t}\n\tregisterUniforms(device) {\n\t\tthis._clusterSkipId = device.scope.resolve('clusterSkip');\n\t\tthis._clusterMaxCellsId = device.scope.resolve('clusterMaxCells');\n\t\tthis._clusterWorldTextureId = device.scope.resolve('clusterWorldTexture');\n\t\tthis._clusterTextureSizeId = device.scope.resolve('clusterTextureSize');\n\t\tthis._clusterTextureSizeData = new Float32Array(3);\n\t\tthis._clusterBoundsMinId = device.scope.resolve('clusterBoundsMin');\n\t\tthis._clusterBoundsMinData = new Float32Array(3);\n\t\tthis._clusterBoundsDeltaId = device.scope.resolve('clusterBoundsDelta');\n\t\tthis._clusterBoundsDeltaData = new Float32Array(3);\n\t\tthis._clusterCellsCountByBoundsSizeId = device.scope.resolve('clusterCellsCountByBoundsSize');\n\t\tthis._clusterCellsCountByBoundsSizeData = new Float32Array(3);\n\t\tthis._clusterCellsDotId = device.scope.resolve('clusterCellsDot');\n\t\tthis._clusterCellsDotData = new Float32Array(3);\n\t\tthis._clusterCellsMaxId = device.scope.resolve('clusterCellsMax');\n\t\tthis._clusterCellsMaxData = new Float32Array(3);\n\t\tthis._clusterCompressionLimit0Id = device.scope.resolve('clusterCompressionLimit0');\n\t\tthis._clusterCompressionLimit0Data = new Float32Array(2);\n\t}\n\tupdateParams(lightingParams) {\n\t\tif (lightingParams) {\n\t\t\tthis.cells = lightingParams.cells;\n\t\t\tthis.maxCellLightCount = lightingParams.maxLightsPerCell;\n\t\t\tthis.lightsBuffer.cookiesEnabled = lightingParams.cookiesEnabled;\n\t\t\tthis.lightsBuffer.shadowsEnabled = lightingParams.shadowsEnabled;\n\t\t\tthis.lightsBuffer.areaLightsEnabled = lightingParams.areaLightsEnabled;\n\t\t}\n\t}\n\tupdateCells() {\n\t\tif (this._cellsDirty) {\n\t\t\tthis._cellsDirty = false;\n\t\t\tconst cx = this._cells.x;\n\t\t\tconst cy = this._cells.y;\n\t\t\tconst cz = this._cells.z;\n\t\t\tconst numCells = cx * cy * cz;\n\t\t\tconst totalPixels = this.maxCellLightCount * numCells;\n\t\t\tlet width = Math.ceil(Math.sqrt(totalPixels));\n\t\t\twidth = math.roundUp(width, this.maxCellLightCount);\n\t\t\tconst height = Math.ceil(totalPixels / width);\n\t\t\tthis._clusterCellsMaxData[0] = cx;\n\t\t\tthis._clusterCellsMaxData[1] = cy;\n\t\t\tthis._clusterCellsMaxData[2] = cz;\n\t\t\tthis._clusterCellsDotData[0] = this.maxCellLightCount;\n\t\t\tthis._clusterCellsDotData[1] = cx * cz * this.maxCellLightCount;\n\t\t\tthis._clusterCellsDotData[2] = cx * this.maxCellLightCount;\n\t\t\tthis.clusters = new Uint8ClampedArray(totalPixels);\n\t\t\tthis.counts = new Int32Array(numCells);\n\t\t\tthis._clusterTextureSizeData[0] = width;\n\t\t\tthis._clusterTextureSizeData[1] = 1.0 / width;\n\t\t\tthis._clusterTextureSizeData[2] = 1.0 / height;\n\t\t\tthis.releaseClusterTexture();\n\t\t\tthis.clusterTexture = this.lightsBuffer.createTexture(this.device, width, height, PIXELFORMAT_L8, 'ClusterTexture');\n\t\t}\n\t}\n\tuploadTextures() {\n\t\tthis.clusterTexture.lock().set(this.clusters);\n\t\tthis.clusterTexture.unlock();\n\t\tthis.lightsBuffer.uploadTextures();\n\t}\n\tupdateUniforms() {\n\t\tthis._clusterSkipId.setValue(this._usedLights.length > 1 ? 0 : 1);\n\t\tthis.lightsBuffer.updateUniforms();\n\t\tthis._clusterWorldTextureId.setValue(this.clusterTexture);\n\t\tthis._clusterMaxCellsId.setValue(this.maxCellLightCount);\n\t\tconst boundsDelta = this.boundsDelta;\n\t\tthis._clusterCellsCountByBoundsSizeData[0] = this._cells.x / boundsDelta.x;\n\t\tthis._clusterCellsCountByBoundsSizeData[1] = this._cells.y / boundsDelta.y;\n\t\tthis._clusterCellsCountByBoundsSizeData[2] = this._cells.z / boundsDelta.z;\n\t\tthis._clusterCellsCountByBoundsSizeId.setValue(this._clusterCellsCountByBoundsSizeData);\n\t\tthis._clusterBoundsMinData[0] = this.boundsMin.x;\n\t\tthis._clusterBoundsMinData[1] = this.boundsMin.y;\n\t\tthis._clusterBoundsMinData[2] = this.boundsMin.z;\n\t\tthis._clusterBoundsDeltaData[0] = boundsDelta.x;\n\t\tthis._clusterBoundsDeltaData[1] = boundsDelta.y;\n\t\tthis._clusterBoundsDeltaData[2] = boundsDelta.z;\n\t\tthis._clusterCompressionLimit0Data[0] = this._maxAttenuation;\n\t\tthis._clusterCompressionLimit0Data[1] = this._maxColorValue;\n\t\tthis._clusterTextureSizeId.setValue(this._clusterTextureSizeData);\n\t\tthis._clusterBoundsMinId.setValue(this._clusterBoundsMinData);\n\t\tthis._clusterBoundsDeltaId.setValue(this._clusterBoundsDeltaData);\n\t\tthis._clusterCellsDotId.setValue(this._clusterCellsDotData);\n\t\tthis._clusterCellsMaxId.setValue(this._clusterCellsMaxData);\n\t\tthis._clusterCompressionLimit0Id.setValue(this._clusterCompressionLimit0Data);\n\t}\n\tevalLightCellMinMax(clusteredLight, min, max) {\n\t\tmin.copy(clusteredLight.min);\n\t\tmin.sub(this.boundsMin);\n\t\tmin.div(this.boundsDelta);\n\t\tmin.mul2(min, this.cells);\n\t\tmin.floor();\n\t\tmax.copy(clusteredLight.max);\n\t\tmax.sub(this.boundsMin);\n\t\tmax.div(this.boundsDelta);\n\t\tmax.mul2(max, this.cells);\n\t\tmax.ceil();\n\t\tmin.max(Vec3.ZERO);\n\t\tmax.min(this._cellsLimit);\n\t}\n\tcollectLights(lights) {\n\t\tconst maxLights = this.lightsBuffer.maxLights;\n\t\tconst usedLights = this._usedLights;\n\t\tlet lightIndex = 1;\n\t\tlights.forEach(light => {\n\t\t\tconst runtimeLight = !!(light.mask & (MASK_AFFECT_DYNAMIC | MASK_AFFECT_LIGHTMAPPED));\n\t\t\tconst zeroAngleSpotlight = light.type === LIGHTTYPE_SPOT && light._outerConeAngle === 0;\n\t\t\tif (light.enabled && light.type !== LIGHTTYPE_DIRECTIONAL && light.visibleThisFrame && light.intensity > 0 && runtimeLight && !zeroAngleSpotlight) {\n\t\t\t\tif (lightIndex < maxLights) {\n\t\t\t\t\tlet clusteredLight;\n\t\t\t\t\tif (lightIndex < usedLights.length) {\n\t\t\t\t\t\tclusteredLight = usedLights[lightIndex];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclusteredLight = new ClusterLight();\n\t\t\t\t\t\tusedLights.push(clusteredLight);\n\t\t\t\t\t}\n\t\t\t\t\tclusteredLight.light = light;\n\t\t\t\t\tlight.getBoundingBox(tempBox);\n\t\t\t\t\tclusteredLight.min.copy(tempBox.getMin());\n\t\t\t\t\tclusteredLight.max.copy(tempBox.getMax());\n\t\t\t\t\tlightIndex++;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tusedLights.length = lightIndex;\n\t}\n\tevaluateBounds() {\n\t\tconst usedLights = this._usedLights;\n\t\tconst min = this.boundsMin;\n\t\tconst max = this.boundsMax;\n\t\tif (usedLights.length > 1) {\n\t\t\tmin.copy(usedLights[1].min);\n\t\t\tmax.copy(usedLights[1].max);\n\t\t\tfor (let i = 2; i < usedLights.length; i++) {\n\t\t\t\tmin.min(usedLights[i].min);\n\t\t\t\tmax.max(usedLights[i].max);\n\t\t\t}\n\t\t} else {\n\t\t\tmin.set(0, 0, 0);\n\t\t\tmax.set(1, 1, 1);\n\t\t}\n\t\tthis.boundsDelta.sub2(max, min);\n\t\tthis.lightsBuffer.setBounds(min, this.boundsDelta);\n\t}\n\tevaluateCompressionLimits(gammaCorrection) {\n\t\tlet maxAttenuation = 0;\n\t\tlet maxColorValue = 0;\n\t\tconst usedLights = this._usedLights;\n\t\tfor (let i = 1; i < usedLights.length; i++) {\n\t\t\tconst light = usedLights[i].light;\n\t\t\tmaxAttenuation = Math.max(light.attenuationEnd, maxAttenuation);\n\t\t\tconst color = gammaCorrection ? light._linearFinalColor : light._finalColor;\n\t\t\tmaxColorValue = Math.max(color[0], maxColorValue);\n\t\t\tmaxColorValue = Math.max(color[1], maxColorValue);\n\t\t\tmaxColorValue = Math.max(color[2], maxColorValue);\n\t\t}\n\t\tthis._maxAttenuation = maxAttenuation + epsilon;\n\t\tthis._maxColorValue = maxColorValue + epsilon;\n\t\tthis.lightsBuffer.setCompressionRanges(this._maxAttenuation, this._maxColorValue);\n\t}\n\tupdateClusters(gammaCorrection) {\n\t\tthis.counts.fill(0);\n\t\tthis.clusters.fill(0);\n\t\tconst divX = this._cells.x;\n\t\tconst divZ = this._cells.z;\n\t\tconst counts = this.counts;\n\t\tconst limit = this._maxCellLightCount;\n\t\tconst clusters = this.clusters;\n\t\tconst pixelsPerCellCount = this.maxCellLightCount;\n\t\tconst usedLights = this._usedLights;\n\t\tfor (let i = 1; i < usedLights.length; i++) {\n\t\t\tconst clusteredLight = usedLights[i];\n\t\t\tconst light = clusteredLight.light;\n\t\t\tthis.lightsBuffer.addLightData(light, i, gammaCorrection);\n\t\t\tthis.evalLightCellMinMax(clusteredLight, tempMin3, tempMax3);\n\t\t\tconst xStart = tempMin3.x;\n\t\t\tconst xEnd = tempMax3.x;\n\t\t\tconst yStart = tempMin3.y;\n\t\t\tconst yEnd = tempMax3.y;\n\t\t\tconst zStart = tempMin3.z;\n\t\t\tconst zEnd = tempMax3.z;\n\t\t\tfor (let x = xStart; x <= xEnd; x++) {\n\t\t\t\tfor (let z = zStart; z <= zEnd; z++) {\n\t\t\t\t\tfor (let y = yStart; y <= yEnd; y++) {\n\t\t\t\t\t\tconst clusterIndex = x + divX * (z + y * divZ);\n\t\t\t\t\t\tconst count = counts[clusterIndex];\n\t\t\t\t\t\tif (count < limit) {\n\t\t\t\t\t\t\tclusters[pixelsPerCellCount * clusterIndex + count] = i;\n\t\t\t\t\t\t\tcounts[clusterIndex] = count + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tupdate(lights, gammaCorrection, lightingParams) {\n\t\tthis.updateParams(lightingParams);\n\t\tthis.updateCells();\n\t\tthis.collectLights(lights);\n\t\tthis.evaluateBounds();\n\t\tthis.evaluateCompressionLimits(gammaCorrection);\n\t\tthis.updateClusters(gammaCorrection);\n\t\tthis.uploadTextures();\n\t}\n\tactivate() {\n\t\tthis.updateUniforms();\n\t}\n}\n\nexport { WorldClusters };\n","import { Color } from '../../core/math/color.js';\nimport { ShaderProcessorOptions } from '../../platform/graphics/shader-processor-options.js';\nimport { SHADERDEF_SKIN, SHADERDEF_SCREENSPACE, SHADERDEF_INSTANCING, SHADERDEF_MORPH_POSITION, SHADERDEF_MORPH_NORMAL, SHADERDEF_MORPH_TEXTURE_BASED } from '../constants.js';\nimport { getProgramLibrary } from '../shader-lib/get-program-library.js';\nimport { basic } from '../shader-lib/programs/basic.js';\nimport { Material } from './material.js';\n\nclass BasicMaterial extends Material {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.color = new Color(1, 1, 1, 1);\n\t\tthis.colorUniform = new Float32Array(4);\n\t\tthis.colorMap = null;\n\t\tthis.vertexColors = false;\n\t}\n\tcopy(source) {\n\t\tsuper.copy(source);\n\t\tthis.color.copy(source.color);\n\t\tthis.colorMap = source.colorMap;\n\t\tthis.vertexColors = source.vertexColors;\n\t\treturn this;\n\t}\n\tupdateUniforms(device, scene) {\n\t\tthis.clearParameters();\n\t\tthis.colorUniform[0] = this.color.r;\n\t\tthis.colorUniform[1] = this.color.g;\n\t\tthis.colorUniform[2] = this.color.b;\n\t\tthis.colorUniform[3] = this.color.a;\n\t\tthis.setParameter('uColor', this.colorUniform);\n\t\tif (this.colorMap) {\n\t\t\tthis.setParameter('texture_diffuseMap', this.colorMap);\n\t\t}\n\t}\n\tgetShaderVariant(device, scene, objDefs, unused, pass, sortedLights, viewUniformFormat, viewBindGroupFormat, vertexFormat) {\n\t\tconst options = {\n\t\t\tskin: objDefs && (objDefs & SHADERDEF_SKIN) !== 0,\n\t\t\tscreenSpace: objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0,\n\t\t\tuseInstancing: objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0,\n\t\t\tuseMorphPosition: objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0,\n\t\t\tuseMorphNormal: objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0,\n\t\t\tuseMorphTextureBased: objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED) !== 0,\n\t\t\talphaTest: this.alphaTest > 0,\n\t\t\tvertexColors: this.vertexColors,\n\t\t\tdiffuseMap: !!this.colorMap,\n\t\t\tpass: pass\n\t\t};\n\t\tconst processingOptions = new ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat, vertexFormat);\n\t\tconst library = getProgramLibrary(device);\n\t\tlibrary.register('basic', basic);\n\t\treturn library.getProgram('basic', options, processingOptions, this.userId);\n\t}\n}\n\nexport { BasicMaterial };\n","import { DeviceCache } from '../../platform/graphics/device-cache.js';\n\nconst defaultMaterialDeviceCache = new DeviceCache();\nfunction getDefaultMaterial(device) {\n\tconst material = defaultMaterialDeviceCache.get(device);\n\treturn material;\n}\nfunction setDefaultMaterial(device, material) {\n\tdefaultMaterialDeviceCache.get(device, () => {\n\t\treturn material;\n\t});\n}\n\nexport { getDefaultMaterial, setDefaultMaterial };\n","import { SHADER_FORWARDHDR, GAMMA_SRGBHDR, TONEMAP_LINEAR, SHADERDEF_SCREENSPACE, SHADERDEF_SKIN, SHADERDEF_INSTANCING, SHADERDEF_MORPH_POSITION, SHADERDEF_MORPH_NORMAL, SHADERDEF_MORPH_TEXTURE_BASED, SHADERDEF_TANGENTS, SPRITE_RENDERMODE_SIMPLE, CUBEPROJ_NONE, SPECULAR_BLINN, GAMMA_NONE, MASK_AFFECT_DYNAMIC, LIGHTTYPE_DIRECTIONAL, LIGHTTYPE_OMNI, LIGHTTYPE_SPOT, SHADERDEF_NOSHADOW } from '../constants.js';\n\nclass LitMaterialOptionsBuilder {\n\tstatic update(litOptions, material, scene, objDefs, pass, sortedLights) {\n\t\tLitMaterialOptionsBuilder.updateSharedOptions(litOptions, material, scene, objDefs, pass);\n\t\tLitMaterialOptionsBuilder.updateMaterialOptions(litOptions, material);\n\t\tLitMaterialOptionsBuilder.updateEnvOptions(litOptions, material, scene);\n\t\tLitMaterialOptionsBuilder.updateLightingOptions(litOptions, material, objDefs, sortedLights);\n\t\tif (pass === SHADER_FORWARDHDR) {\n\t\t\tlitOptions.gamma = GAMMA_SRGBHDR;\n\t\t\tlitOptions.toneMap = TONEMAP_LINEAR;\n\t\t}\n\t}\n\tstatic updateSharedOptions(litOptions, material, scene, objDefs, pass) {\n\t\tlitOptions.chunks = material.chunks;\n\t\tlitOptions.pass = pass;\n\t\tlitOptions.alphaTest = material.alphaTest > 0;\n\t\tlitOptions.blendType = material.blendType;\n\t\tlitOptions.screenSpace = objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0;\n\t\tlitOptions.skin = objDefs && (objDefs & SHADERDEF_SKIN) !== 0;\n\t\tlitOptions.useInstancing = objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0;\n\t\tlitOptions.useMorphPosition = objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0;\n\t\tlitOptions.useMorphNormal = objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0;\n\t\tlitOptions.useMorphTextureBased = objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED) !== 0;\n\t\tlitOptions.hasTangents = objDefs && (objDefs & SHADERDEF_TANGENTS) !== 0;\n\t\tlitOptions.nineSlicedMode = material.nineSlicedMode || SPRITE_RENDERMODE_SIMPLE;\n\t\tif (material.useLighting && scene.clusteredLightingEnabled) {\n\t\t\tlitOptions.clusteredLightingEnabled = true;\n\t\t\tlitOptions.clusteredLightingCookiesEnabled = scene.lighting.cookiesEnabled;\n\t\t\tlitOptions.clusteredLightingShadowsEnabled = scene.lighting.shadowsEnabled;\n\t\t\tlitOptions.clusteredLightingShadowType = scene.lighting.shadowType;\n\t\t\tlitOptions.clusteredLightingAreaLightsEnabled = scene.lighting.areaLightsEnabled;\n\t\t} else {\n\t\t\tlitOptions.clusteredLightingEnabled = false;\n\t\t\tlitOptions.clusteredLightingCookiesEnabled = false;\n\t\t\tlitOptions.clusteredLightingShadowsEnabled = false;\n\t\t\tlitOptions.clusteredLightingAreaLightsEnabled = false;\n\t\t}\n\t}\n\tstatic updateMaterialOptions(litOptions, material) {\n\t\tlitOptions.useAmbientTint = false;\n\t\tlitOptions.separateAmbient = false;\n\t\tlitOptions.customFragmentShader = null;\n\t\tlitOptions.pixelSnap = material.pixelSnap;\n\t\tlitOptions.shadingModel = material.shadingModel;\n\t\tlitOptions.ambientSH = material.ambientSH;\n\t\tlitOptions.fastTbn = material.fastTbn;\n\t\tlitOptions.twoSidedLighting = material.twoSidedLighting;\n\t\tlitOptions.occludeDirect = material.occludeDirect;\n\t\tlitOptions.occludeSpecular = material.occludeSpecular;\n\t\tlitOptions.occludeSpecularFloat = material.occludeSpecularIntensity !== 1.0;\n\t\tlitOptions.useMsdf = false;\n\t\tlitOptions.msdfTextAttribute = false;\n\t\tlitOptions.alphaToCoverage = material.alphaToCoverage;\n\t\tlitOptions.opacityFadesSpecular = material.opacityFadesSpecular;\n\t\tlitOptions.opacityDither = material.opacityDither;\n\t\tlitOptions.cubeMapProjection = CUBEPROJ_NONE;\n\t\tlitOptions.conserveEnergy = material.conserveEnergy && material.shadingModel === SPECULAR_BLINN;\n\t\tlitOptions.useSpecular = material.hasSpecular;\n\t\tlitOptions.useSpecularityFactor = material.hasSpecularityFactor;\n\t\tlitOptions.enableGGXSpecular = material.ggxSpecular;\n\t\tlitOptions.fresnelModel = material.fresnelModel;\n\t\tlitOptions.useRefraction = material.hasRefraction;\n\t\tlitOptions.useClearCoat = material.hasClearCoat;\n\t\tlitOptions.useSheen = material.hasSheen;\n\t\tlitOptions.useIridescence = material.hasIrridescence;\n\t\tlitOptions.useMetalness = material.hasMetalness;\n\t\tlitOptions.useDynamicRefraction = material.dynamicRefraction;\n\t\tlitOptions.dispersion = material.dispersion > 0;\n\t\tlitOptions.vertexColors = false;\n\t\tlitOptions.lightMapEnabled = material.hasLighting;\n\t\tlitOptions.dirLightMapEnabled = material.dirLightMap;\n\t\tlitOptions.useHeights = material.hasHeights;\n\t\tlitOptions.useNormals = material.hasNormals;\n\t\tlitOptions.useClearCoatNormals = material.hasClearCoatNormals;\n\t\tlitOptions.useAo = material.hasAo;\n\t\tlitOptions.diffuseMapEnabled = material.hasDiffuseMap;\n\t}\n\tstatic updateEnvOptions(litOptions, material, scene) {\n\t\tlitOptions.fog = material.useFog ? scene.fog : 'none';\n\t\tlitOptions.gamma = material.useGammaTonemap ? scene.gammaCorrection : GAMMA_NONE;\n\t\tlitOptions.toneMap = material.useGammaTonemap ? scene.toneMapping : -1;\n\t\tlitOptions.fixSeams = false;\n\t\tif (material.useSkybox && scene.envAtlas && scene.skybox) {\n\t\t\tlitOptions.reflectionSource = 'envAtlasHQ';\n\t\t\tlitOptions.reflectionEncoding = scene.envAtlas.encoding;\n\t\t\tlitOptions.reflectionCubemapEncoding = scene.skybox.encoding;\n\t\t} else if (material.useSkybox && scene.envAtlas) {\n\t\t\tlitOptions.reflectionSource = 'envAtlas';\n\t\t\tlitOptions.reflectionEncoding = scene.envAtlas.encoding;\n\t\t} else if (material.useSkybox && scene.skybox) {\n\t\t\tlitOptions.reflectionSource = 'cubeMap';\n\t\t\tlitOptions.reflectionEncoding = scene.skybox.encoding;\n\t\t} else {\n\t\t\tlitOptions.reflectionSource = null;\n\t\t\tlitOptions.reflectionEncoding = null;\n\t\t}\n\t\tif (material.ambientSH) {\n\t\t\tlitOptions.ambientSource = 'ambientSH';\n\t\t\tlitOptions.ambientEncoding = null;\n\t\t} else if (litOptions.reflectionSource && scene.envAtlas) {\n\t\t\tlitOptions.ambientSource = 'envAtlas';\n\t\t\tlitOptions.ambientEncoding = scene.envAtlas.encoding;\n\t\t} else {\n\t\t\tlitOptions.ambientSource = 'constant';\n\t\t\tlitOptions.ambientEncoding = null;\n\t\t}\n\t\tconst hasSkybox = !!litOptions.reflectionSource;\n\t\tlitOptions.skyboxIntensity = hasSkybox;\n\t\tlitOptions.useCubeMapRotation = hasSkybox && scene._skyboxRotationShaderInclude;\n\t}\n\tstatic updateLightingOptions(litOptions, material, objDefs, sortedLights) {\n\t\tlitOptions.lightMapWithoutAmbient = false;\n\t\tif (material.useLighting) {\n\t\t\tconst lightsFiltered = [];\n\t\t\tconst mask = objDefs ? objDefs >> 16 : MASK_AFFECT_DYNAMIC;\n\t\t\tlitOptions.lightMaskDynamic = !!(mask & MASK_AFFECT_DYNAMIC);\n\t\t\tlitOptions.lightMapWithoutAmbient = false;\n\t\t\tif (sortedLights) {\n\t\t\t\tLitMaterialOptionsBuilder.collectLights(LIGHTTYPE_DIRECTIONAL, sortedLights[LIGHTTYPE_DIRECTIONAL], lightsFiltered, mask);\n\t\t\t\tLitMaterialOptionsBuilder.collectLights(LIGHTTYPE_OMNI, sortedLights[LIGHTTYPE_OMNI], lightsFiltered, mask);\n\t\t\t\tLitMaterialOptionsBuilder.collectLights(LIGHTTYPE_SPOT, sortedLights[LIGHTTYPE_SPOT], lightsFiltered, mask);\n\t\t\t}\n\t\t\tlitOptions.lights = lightsFiltered;\n\t\t} else {\n\t\t\tlitOptions.lights = [];\n\t\t}\n\t\tif (litOptions.lights.length === 0 || (objDefs & SHADERDEF_NOSHADOW) !== 0) {\n\t\t\tlitOptions.noShadow = true;\n\t\t}\n\t}\n\tstatic collectLights(lType, lights, lightsFiltered, mask) {\n\t\tfor (let i = 0; i < lights.length; i++) {\n\t\t\tconst light = lights[i];\n\t\t\tif (light.enabled) {\n\t\t\t\tif (light.mask & mask) {\n\t\t\t\t\tlightsFiltered.push(light);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { LitMaterialOptionsBuilder };\n","import { CULLFACE_BACK, BLENDMODE_ONE, BLENDEQUATION_REVERSE_SUBTRACT, BLENDMODE_ZERO, BLENDEQUATION_ADD, BLENDMODE_SRC_ALPHA, BLENDMODE_ONE_MINUS_SRC_ALPHA, BLENDMODE_DST_COLOR, BLENDMODE_SRC_COLOR, BLENDMODE_ONE_MINUS_DST_COLOR, BLENDEQUATION_MIN, BLENDEQUATION_MAX } from '../../platform/graphics/constants.js';\nimport { BlendState } from '../../platform/graphics/blend-state.js';\nimport { DepthState } from '../../platform/graphics/depth-state.js';\nimport { ShaderProcessorOptions } from '../../platform/graphics/shader-processor-options.js';\nimport { BLEND_NONE, BLEND_NORMAL, BLEND_SUBTRACTIVE, BLEND_PREMULTIPLIED, BLEND_ADDITIVE, BLEND_ADDITIVEALPHA, BLEND_MULTIPLICATIVE2X, BLEND_SCREEN, BLEND_MULTIPLICATIVE, BLEND_MIN, BLEND_MAX } from '../constants.js';\nimport { processShader } from '../shader-lib/utils.js';\nimport { getDefaultMaterial } from './default-material.js';\n\nconst blendModes = [];\nblendModes[BLEND_SUBTRACTIVE] = {\n\tsrc: BLENDMODE_ONE,\n\tdst: BLENDMODE_ONE,\n\top: BLENDEQUATION_REVERSE_SUBTRACT\n};\nblendModes[BLEND_NONE] = {\n\tsrc: BLENDMODE_ONE,\n\tdst: BLENDMODE_ZERO,\n\top: BLENDEQUATION_ADD\n};\nblendModes[BLEND_NORMAL] = {\n\tsrc: BLENDMODE_SRC_ALPHA,\n\tdst: BLENDMODE_ONE_MINUS_SRC_ALPHA,\n\top: BLENDEQUATION_ADD\n};\nblendModes[BLEND_PREMULTIPLIED] = {\n\tsrc: BLENDMODE_ONE,\n\tdst: BLENDMODE_ONE_MINUS_SRC_ALPHA,\n\top: BLENDEQUATION_ADD\n};\nblendModes[BLEND_ADDITIVE] = {\n\tsrc: BLENDMODE_ONE,\n\tdst: BLENDMODE_ONE,\n\top: BLENDEQUATION_ADD\n};\nblendModes[BLEND_ADDITIVEALPHA] = {\n\tsrc: BLENDMODE_SRC_ALPHA,\n\tdst: BLENDMODE_ONE,\n\top: BLENDEQUATION_ADD\n};\nblendModes[BLEND_MULTIPLICATIVE2X] = {\n\tsrc: BLENDMODE_DST_COLOR,\n\tdst: BLENDMODE_SRC_COLOR,\n\top: BLENDEQUATION_ADD\n};\nblendModes[BLEND_SCREEN] = {\n\tsrc: BLENDMODE_ONE_MINUS_DST_COLOR,\n\tdst: BLENDMODE_ONE,\n\top: BLENDEQUATION_ADD\n};\nblendModes[BLEND_MULTIPLICATIVE] = {\n\tsrc: BLENDMODE_DST_COLOR,\n\tdst: BLENDMODE_ZERO,\n\top: BLENDEQUATION_ADD\n};\nblendModes[BLEND_MIN] = {\n\tsrc: BLENDMODE_ONE,\n\tdst: BLENDMODE_ONE,\n\top: BLENDEQUATION_MIN\n};\nblendModes[BLEND_MAX] = {\n\tsrc: BLENDMODE_ONE,\n\tdst: BLENDMODE_ONE,\n\top: BLENDEQUATION_MAX\n};\nlet id = 0;\nclass Material {\n\tconstructor() {\n\t\tthis._shader = null;\n\t\tthis.meshInstances = [];\n\t\tthis.name = 'Untitled';\n\t\tthis.userId = '';\n\t\tthis.id = id++;\n\t\tthis.variants = new Map();\n\t\tthis.parameters = {};\n\t\tthis.alphaTest = 0;\n\t\tthis.alphaToCoverage = false;\n\t\tthis._blendState = new BlendState();\n\t\tthis._depthState = new DepthState();\n\t\tthis.cull = CULLFACE_BACK;\n\t\tthis.stencilFront = null;\n\t\tthis.stencilBack = null;\n\t\tthis._shaderVersion = 0;\n\t\tthis._scene = null;\n\t\tthis.dirty = true;\n\t}\n\tset depthBias(value) {\n\t\tthis._depthState.depthBias = value;\n\t}\n\tget depthBias() {\n\t\treturn this._depthState.depthBias;\n\t}\n\tset slopeDepthBias(value) {\n\t\tthis._depthState.depthBiasSlope = value;\n\t}\n\tget slopeDepthBias() {\n\t\treturn this._depthState.depthBiasSlope;\n\t}\n\tset redWrite(value) {\n\t\tthis._blendState.redWrite = value;\n\t}\n\tget redWrite() {\n\t\treturn this._blendState.redWrite;\n\t}\n\tset greenWrite(value) {\n\t\tthis._blendState.greenWrite = value;\n\t}\n\tget greenWrite() {\n\t\treturn this._blendState.greenWrite;\n\t}\n\tset blueWrite(value) {\n\t\tthis._blendState.blueWrite = value;\n\t}\n\tget blueWrite() {\n\t\treturn this._blendState.blueWrite;\n\t}\n\tset alphaWrite(value) {\n\t\tthis._blendState.alphaWrite = value;\n\t}\n\tget alphaWrite() {\n\t\treturn this._blendState.alphaWrite;\n\t}\n\tset shader(shader) {\n\t\tthis._shader = shader;\n\t}\n\tget shader() {\n\t\treturn this._shader;\n\t}\n\tget transparent() {\n\t\treturn this._blendState.blend;\n\t}\n\t_updateTransparency() {\n\t\tconst transparent = this.transparent;\n\t\tconst meshInstances = this.meshInstances;\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tmeshInstances[i].transparent = transparent;\n\t\t}\n\t}\n\tset blendState(value) {\n\t\tthis._blendState.copy(value);\n\t\tthis._updateTransparency();\n\t}\n\tget blendState() {\n\t\treturn this._blendState;\n\t}\n\tset blendType(type) {\n\t\tconst blendMode = blendModes[type];\n\t\tthis._blendState.setColorBlend(blendMode.op, blendMode.src, blendMode.dst);\n\t\tthis._blendState.setAlphaBlend(blendMode.op, blendMode.src, blendMode.dst);\n\t\tconst blend = type !== BLEND_NONE;\n\t\tif (this._blendState.blend !== blend) {\n\t\t\tthis._blendState.blend = blend;\n\t\t\tthis._updateTransparency();\n\t\t}\n\t\tthis._updateMeshInstanceKeys();\n\t}\n\tget blendType() {\n\t\tif (!this.transparent) {\n\t\t\treturn BLEND_NONE;\n\t\t}\n\t\tconst {\n\t\t\tcolorOp,\n\t\t\tcolorSrcFactor,\n\t\t\tcolorDstFactor,\n\t\t\talphaOp,\n\t\t\talphaSrcFactor,\n\t\t\talphaDstFactor\n\t\t} = this._blendState;\n\t\tfor (let i = 0; i < blendModes.length; i++) {\n\t\t\tconst blendMode = blendModes[i];\n\t\t\tif (blendMode.src === colorSrcFactor && blendMode.dst === colorDstFactor && blendMode.op === colorOp && blendMode.src === alphaSrcFactor && blendMode.dst === alphaDstFactor && blendMode.op === alphaOp) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn BLEND_NORMAL;\n\t}\n\tset depthState(value) {\n\t\tthis._depthState.copy(value);\n\t}\n\tget depthState() {\n\t\treturn this._depthState;\n\t}\n\tset depthTest(value) {\n\t\tthis._depthState.test = value;\n\t}\n\tget depthTest() {\n\t\treturn this._depthState.test;\n\t}\n\tset depthFunc(value) {\n\t\tthis._depthState.func = value;\n\t}\n\tget depthFunc() {\n\t\treturn this._depthState.func;\n\t}\n\tset depthWrite(value) {\n\t\tthis._depthState.write = value;\n\t}\n\tget depthWrite() {\n\t\treturn this._depthState.write;\n\t}\n\tcopy(source) {\n\t\tvar _source$stencilFront;\n\t\tthis.name = source.name;\n\t\tthis._shader = source._shader;\n\t\tthis.alphaTest = source.alphaTest;\n\t\tthis.alphaToCoverage = source.alphaToCoverage;\n\t\tthis._blendState.copy(source._blendState);\n\t\tthis._depthState.copy(source._depthState);\n\t\tthis.cull = source.cull;\n\t\tthis.stencilFront = (_source$stencilFront = source.stencilFront) == null ? void 0 : _source$stencilFront.clone();\n\t\tif (source.stencilBack) {\n\t\t\tthis.stencilBack = source.stencilFront === source.stencilBack ? this.stencilFront : source.stencilBack.clone();\n\t\t}\n\t\treturn this;\n\t}\n\tclone() {\n\t\tconst clone = new this.constructor();\n\t\treturn clone.copy(this);\n\t}\n\t_updateMeshInstanceKeys() {\n\t\tconst meshInstances = this.meshInstances;\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tmeshInstances[i].updateKey();\n\t\t}\n\t}\n\tupdateUniforms(device, scene) {}\n\tgetShaderVariant(device, scene, objDefs, unused, pass, sortedLights, viewUniformFormat, viewBindGroupFormat, vertexFormat) {\n\t\tconst processingOptions = new ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat, vertexFormat);\n\t\treturn processShader(this._shader, processingOptions);\n\t}\n\tupdate() {\n\t\tthis.dirty = true;\n\t\tif (this._shader) this._shader.failed = false;\n\t}\n\tclearParameters() {\n\t\tthis.parameters = {};\n\t}\n\tgetParameters() {\n\t\treturn this.parameters;\n\t}\n\tclearVariants() {\n\t\tthis.variants.clear();\n\t\tconst meshInstances = this.meshInstances;\n\t\tconst count = meshInstances.length;\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tmeshInstances[i].clearShaders();\n\t\t}\n\t}\n\tgetParameter(name) {\n\t\treturn this.parameters[name];\n\t}\n\tsetParameter(name, data) {\n\t\tif (data === undefined && typeof name === 'object') {\n\t\t\tconst uniformObject = name;\n\t\t\tif (uniformObject.length) {\n\t\t\t\tfor (let i = 0; i < uniformObject.length; i++) {\n\t\t\t\t\tthis.setParameter(uniformObject[i]);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tname = uniformObject.name;\n\t\t\tdata = uniformObject.value;\n\t\t}\n\t\tconst param = this.parameters[name];\n\t\tif (param) {\n\t\t\tparam.data = data;\n\t\t} else {\n\t\t\tthis.parameters[name] = {\n\t\t\t\tscopeId: null,\n\t\t\t\tdata: data\n\t\t\t};\n\t\t}\n\t}\n\tdeleteParameter(name) {\n\t\tif (this.parameters[name]) {\n\t\t\tdelete this.parameters[name];\n\t\t}\n\t}\n\tsetParameters(device, names) {\n\t\tconst parameters = this.parameters;\n\t\tif (names === undefined) names = parameters;\n\t\tfor (const paramName in names) {\n\t\t\tconst parameter = parameters[paramName];\n\t\t\tif (parameter) {\n\t\t\t\tif (!parameter.scopeId) {\n\t\t\t\t\tparameter.scopeId = device.scope.resolve(paramName);\n\t\t\t\t}\n\t\t\t\tparameter.scopeId.setValue(parameter.data);\n\t\t\t}\n\t\t}\n\t}\n\tdestroy() {\n\t\tthis.variants.clear();\n\t\tthis._shader = null;\n\t\tfor (let i = 0; i < this.meshInstances.length; i++) {\n\t\t\tconst meshInstance = this.meshInstances[i];\n\t\t\tmeshInstance.clearShaders();\n\t\t\tmeshInstance._material = null;\n\t\t\tif (meshInstance.mesh) {\n\t\t\t\tconst defaultMaterial = getDefaultMaterial(meshInstance.mesh.device);\n\t\t\t\tif (this !== defaultMaterial) {\n\t\t\t\t\tmeshInstance.material = defaultMaterial;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.meshInstances.length = 0;\n\t}\n\taddMeshInstanceRef(meshInstance) {\n\t\tthis.meshInstances.push(meshInstance);\n\t}\n\tremoveMeshInstanceRef(meshInstance) {\n\t\tconst meshInstances = this.meshInstances;\n\t\tconst i = meshInstances.indexOf(meshInstance);\n\t\tif (i !== -1) {\n\t\t\tmeshInstances.splice(i, 1);\n\t\t}\n\t}\n}\n\nexport { Material };\n","import { PIXELFORMAT_DXT5, TEXTURETYPE_SWIZZLEGGGR, PIXELFORMAT_RGBA8 } from '../../platform/graphics/constants.js';\nimport { SHADER_FORWARDHDR, GAMMA_SRGBHDR, TONEMAP_LINEAR, SHADERDEF_TANGENTS, SHADERDEF_SCREENSPACE, SHADERDEF_SKIN, SHADERDEF_INSTANCING, SHADERDEF_MORPH_POSITION, SHADERDEF_MORPH_NORMAL, SHADERDEF_MORPH_TEXTURE_BASED, BLEND_NONE, DITHER_NONE, SPECULAR_PHONG, GAMMA_NONE, SHADERDEF_NOSHADOW, SHADERDEF_LM, SHADERDEF_DIRLM, SHADERDEF_LMAMBIENT, MASK_AFFECT_DYNAMIC, LIGHTTYPE_DIRECTIONAL, LIGHTTYPE_OMNI, LIGHTTYPE_SPOT, SHADERDEF_UV0, SHADERDEF_UV1, SHADERDEF_VCOLOR, SHADER_PREPASS_VELOCITY } from '../constants.js';\nimport { _matTex2D } from '../shader-lib/programs/standard.js';\nimport { LitMaterialOptionsBuilder } from './lit-material-options-builder.js';\n\nconst arraysEqual = (a, b) => {\n\tif (a.length !== b.length) {\n\t\treturn false;\n\t}\n\tfor (let i = 0; i < a.length; ++i) {\n\t\tif (a[i] !== b[i]) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n};\nconst notWhite = color => {\n\treturn color.r !== 1 || color.g !== 1 || color.b !== 1;\n};\nconst notBlack = color => {\n\treturn color.r !== 0 || color.g !== 0 || color.b !== 0;\n};\nclass StandardMaterialOptionsBuilder {\n\tconstructor() {\n\t\tthis._mapXForms = null;\n\t}\n\tupdateMinRef(options, scene, stdMat, objDefs, pass, sortedLights) {\n\t\tthis._updateSharedOptions(options, scene, stdMat, objDefs, pass);\n\t\tthis._updateMinOptions(options, stdMat, pass);\n\t\tthis._updateUVOptions(options, stdMat, objDefs, true);\n\t}\n\tupdateRef(options, scene, stdMat, objDefs, pass, sortedLights) {\n\t\tthis._updateSharedOptions(options, scene, stdMat, objDefs, pass);\n\t\tthis._updateEnvOptions(options, stdMat, scene);\n\t\tthis._updateMaterialOptions(options, stdMat);\n\t\tif (pass === SHADER_FORWARDHDR) {\n\t\t\tif (options.litOptions.gamma) options.litOptions.gamma = GAMMA_SRGBHDR;\n\t\t\toptions.litOptions.toneMap = TONEMAP_LINEAR;\n\t\t}\n\t\toptions.litOptions.hasTangents = objDefs && (objDefs & SHADERDEF_TANGENTS) !== 0;\n\t\tthis._updateLightOptions(options, scene, stdMat, objDefs, sortedLights);\n\t\tthis._updateUVOptions(options, stdMat, objDefs, false);\n\t}\n\t_updateSharedOptions(options, scene, stdMat, objDefs, pass) {\n\t\toptions.forceUv1 = stdMat.forceUv1;\n\t\tif (stdMat.userAttributes) {\n\t\t\toptions.litOptions.userAttributes = Object.fromEntries(stdMat.userAttributes.entries());\n\t\t}\n\t\toptions.litOptions.chunks = stdMat.chunks || {};\n\t\toptions.litOptions.pass = pass;\n\t\toptions.litOptions.alphaTest = stdMat.alphaTest > 0;\n\t\toptions.litOptions.blendType = stdMat.blendType;\n\t\toptions.litOptions.screenSpace = objDefs && (objDefs & SHADERDEF_SCREENSPACE) !== 0;\n\t\toptions.litOptions.skin = objDefs && (objDefs & SHADERDEF_SKIN) !== 0;\n\t\toptions.litOptions.useInstancing = objDefs && (objDefs & SHADERDEF_INSTANCING) !== 0;\n\t\toptions.litOptions.useMorphPosition = objDefs && (objDefs & SHADERDEF_MORPH_POSITION) !== 0;\n\t\toptions.litOptions.useMorphNormal = objDefs && (objDefs & SHADERDEF_MORPH_NORMAL) !== 0;\n\t\toptions.litOptions.useMorphTextureBased = objDefs && (objDefs & SHADERDEF_MORPH_TEXTURE_BASED) !== 0;\n\t\toptions.litOptions.nineSlicedMode = stdMat.nineSlicedMode || 0;\n\t\tif (scene.clusteredLightingEnabled && stdMat.useLighting) {\n\t\t\toptions.litOptions.clusteredLightingEnabled = true;\n\t\t\toptions.litOptions.clusteredLightingCookiesEnabled = scene.lighting.cookiesEnabled;\n\t\t\toptions.litOptions.clusteredLightingShadowsEnabled = scene.lighting.shadowsEnabled;\n\t\t\toptions.litOptions.clusteredLightingShadowType = scene.lighting.shadowType;\n\t\t\toptions.litOptions.clusteredLightingAreaLightsEnabled = scene.lighting.areaLightsEnabled;\n\t\t} else {\n\t\t\toptions.litOptions.clusteredLightingEnabled = false;\n\t\t\toptions.litOptions.clusteredLightingCookiesEnabled = false;\n\t\t\toptions.litOptions.clusteredLightingShadowsEnabled = false;\n\t\t\toptions.litOptions.clusteredLightingAreaLightsEnabled = false;\n\t\t}\n\t}\n\t_updateUVOptions(options, stdMat, objDefs, minimalOptions) {\n\t\tlet hasUv0 = false;\n\t\tlet hasUv1 = false;\n\t\tlet hasVcolor = false;\n\t\tif (objDefs) {\n\t\t\thasUv0 = (objDefs & SHADERDEF_UV0) !== 0;\n\t\t\thasUv1 = (objDefs & SHADERDEF_UV1) !== 0;\n\t\t\thasVcolor = (objDefs & SHADERDEF_VCOLOR) !== 0;\n\t\t}\n\t\toptions.litOptions.vertexColors = false;\n\t\tthis._mapXForms = [];\n\t\tconst uniqueTextureMap = {};\n\t\tfor (const p in _matTex2D) {\n\t\t\tthis._updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions, uniqueTextureMap);\n\t\t}\n\t\tthis._mapXForms = null;\n\t\toptions.litOptions.lightMapEnabled = options.lightMap;\n\t\toptions.litOptions.dirLightMapEnabled = options.dirLightMap;\n\t\toptions.litOptions.useHeights = options.heightMap;\n\t\toptions.litOptions.useNormals = options.normalMap;\n\t\toptions.litOptions.useClearCoatNormals = options.clearCoatNormalMap;\n\t\toptions.litOptions.useAo = options.aoMap || options.aoVertexColor;\n\t\toptions.litOptions.diffuseMapEnabled = options.diffuseMap;\n\t}\n\t_updateTexOptions(options, stdMat, p, hasUv0, hasUv1, hasVcolor, minimalOptions, uniqueTextureMap) {\n\t\tconst isOpacity = p === 'opacity';\n\t\tif (!minimalOptions || isOpacity) {\n\t\t\tconst mname = `${p}Map`;\n\t\t\tconst vname = `${p}VertexColor`;\n\t\t\tconst vcname = `${p}VertexColorChannel`;\n\t\t\tconst cname = `${mname}Channel`;\n\t\t\tconst tname = `${mname}Transform`;\n\t\t\tconst uname = `${mname}Uv`;\n\t\t\tconst iname = `${mname}Identifier`;\n\t\t\tif (p !== 'light') {\n\t\t\t\toptions[mname] = false;\n\t\t\t\toptions[iname] = undefined;\n\t\t\t\toptions[cname] = '';\n\t\t\t\toptions[tname] = 0;\n\t\t\t\toptions[uname] = 0;\n\t\t\t}\n\t\t\toptions[vname] = false;\n\t\t\toptions[vcname] = '';\n\t\t\tif (isOpacity && stdMat.blendType === BLEND_NONE && stdMat.alphaTest === 0.0 && !stdMat.alphaToCoverage && stdMat.opacityDither === DITHER_NONE) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (p !== 'height' && stdMat[vname]) {\n\t\t\t\tif (hasVcolor) {\n\t\t\t\t\toptions[vname] = stdMat[vname];\n\t\t\t\t\toptions[vcname] = stdMat[vcname];\n\t\t\t\t\toptions.litOptions.vertexColors = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (stdMat[mname]) {\n\t\t\t\tlet allow = true;\n\t\t\t\tif (stdMat[uname] === 0 && !hasUv0) allow = false;\n\t\t\t\tif (stdMat[uname] === 1 && !hasUv1) allow = false;\n\t\t\t\tif (allow) {\n\t\t\t\t\tconst mapId = stdMat[mname].id;\n\t\t\t\t\tlet identifier = uniqueTextureMap[mapId];\n\t\t\t\t\tif (identifier === undefined) {\n\t\t\t\t\t\tuniqueTextureMap[mapId] = p;\n\t\t\t\t\t\tidentifier = p;\n\t\t\t\t\t}\n\t\t\t\t\toptions[mname] = !!stdMat[mname];\n\t\t\t\t\toptions[iname] = identifier;\n\t\t\t\t\toptions[tname] = this._getMapTransformID(stdMat.getUniform(tname), stdMat[uname]);\n\t\t\t\t\toptions[cname] = stdMat[cname];\n\t\t\t\t\toptions[uname] = stdMat[uname];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t_updateMinOptions(options, stdMat, pass) {\n\t\toptions.opacityTint = stdMat.blendType !== BLEND_NONE || stdMat.opacityShadowDither !== DITHER_NONE;\n\t\tconst isPrepass = pass === SHADER_PREPASS_VELOCITY;\n\t\toptions.litOptions.opacityShadowDither = isPrepass ? stdMat.opacityDither : stdMat.opacityShadowDither;\n\t\toptions.litOptions.lights = [];\n\t}\n\t_updateMaterialOptions(options, stdMat) {\n\t\tvar _stdMat$diffuseMap, _stdMat$diffuseDetail, _stdMat$emissiveMap, _stdMat$lightMap;\n\t\tconst diffuseTint = stdMat.diffuseTint || !stdMat.diffuseMap && !stdMat.diffuseVertexColor;\n\t\tconst useSpecular = !!(stdMat.useMetalness || stdMat.specularMap || stdMat.sphereMap || stdMat.cubeMap || notBlack(stdMat.specular) || stdMat.specularityFactor > 0 && stdMat.useMetalness || stdMat.enableGGXSpecular || stdMat.clearCoat > 0);\n\t\tconst useSpecularColor = !stdMat.useMetalness || stdMat.useMetalnessSpecularColor;\n\t\tconst specularTint = useSpecular && (stdMat.specularTint || !stdMat.specularMap && !stdMat.specularVertexColor) && notWhite(stdMat.specular);\n\t\tconst specularityFactorTint = useSpecular && stdMat.useMetalnessSpecularColor && (stdMat.specularityFactorTint || stdMat.specularityFactor < 1 && !stdMat.specularityFactorMap);\n\t\tconst emissiveTintColor = !stdMat.emissiveMap || notWhite(stdMat.emissive) && stdMat.emissiveTint;\n\t\tconst emissiveTintIntensity = stdMat.emissiveIntensity !== 1;\n\t\tconst isPackedNormalMap = stdMat.normalMap ? stdMat.normalMap.format === PIXELFORMAT_DXT5 || stdMat.normalMap.type === TEXTURETYPE_SWIZZLEGGGR : false;\n\t\toptions.opacityTint = stdMat.blendType !== BLEND_NONE || stdMat.alphaTest > 0 || stdMat.opacityDither !== DITHER_NONE ? 1 : 0;\n\t\toptions.ambientTint = stdMat.ambientTint;\n\t\toptions.diffuseTint = diffuseTint ? 2 : 0;\n\t\toptions.specularTint = specularTint ? 2 : 0;\n\t\toptions.specularityFactorTint = specularityFactorTint ? 1 : 0;\n\t\toptions.metalnessTint = stdMat.useMetalness && stdMat.metalness < 1 ? 1 : 0;\n\t\toptions.glossTint = 1;\n\t\toptions.emissiveTint = (emissiveTintColor ? 2 : 0) + (emissiveTintIntensity ? 1 : 0);\n\t\toptions.diffuseEncoding = (_stdMat$diffuseMap = stdMat.diffuseMap) == null ? void 0 : _stdMat$diffuseMap.encoding;\n\t\toptions.diffuseDetailEncoding = (_stdMat$diffuseDetail = stdMat.diffuseDetailMap) == null ? void 0 : _stdMat$diffuseDetail.encoding;\n\t\toptions.emissiveEncoding = (_stdMat$emissiveMap = stdMat.emissiveMap) == null ? void 0 : _stdMat$emissiveMap.encoding;\n\t\toptions.lightMapEncoding = (_stdMat$lightMap = stdMat.lightMap) == null ? void 0 : _stdMat$lightMap.encoding;\n\t\toptions.packedNormal = isPackedNormalMap;\n\t\toptions.refractionTint = stdMat.refraction !== 1.0 ? 1 : 0;\n\t\toptions.refractionIndexTint = stdMat.refractionIndex !== 1.0 / 1.5 ? 1 : 0;\n\t\toptions.thicknessTint = stdMat.useDynamicRefraction && stdMat.thickness !== 1.0 ? 1 : 0;\n\t\toptions.specularEncoding = stdMat.specularEncoding || 'linear';\n\t\toptions.sheenEncoding = stdMat.sheenEncoding || 'linear';\n\t\toptions.aoMapUv = stdMat.aoUvSet;\n\t\toptions.aoDetail = !!stdMat.aoMap;\n\t\toptions.diffuseDetail = !!stdMat.diffuseMap;\n\t\toptions.normalDetail = !!stdMat.normalMap;\n\t\toptions.diffuseDetailMode = stdMat.diffuseDetailMode;\n\t\toptions.aoDetailMode = stdMat.aoDetailMode;\n\t\toptions.clearCoatTint = stdMat.clearCoat !== 1.0 ? 1 : 0;\n\t\toptions.clearCoatGloss = !!stdMat.clearCoatGloss;\n\t\toptions.clearCoatGlossTint = stdMat.clearCoatGloss !== 1.0 ? 1 : 0;\n\t\toptions.iorTint = stdMat.refractionIndex !== 1.0 / 1.5 ? 1 : 0;\n\t\toptions.iridescenceTint = stdMat.iridescence !== 1.0 ? 1 : 0;\n\t\toptions.sheenTint = stdMat.useSheen && notWhite(stdMat.sheen) ? 2 : 0;\n\t\toptions.sheenGlossTint = 1;\n\t\toptions.glossInvert = stdMat.glossInvert;\n\t\toptions.sheenGlossInvert = stdMat.sheenGlossInvert;\n\t\toptions.clearCoatGlossInvert = stdMat.clearCoatGlossInvert;\n\t\toptions.useSpecularColor = useSpecularColor;\n\t\toptions.litOptions.separateAmbient = false;\n\t\toptions.litOptions.useAmbientTint = stdMat.ambientTint;\n\t\toptions.litOptions.customFragmentShader = stdMat.customFragmentShader;\n\t\toptions.litOptions.pixelSnap = stdMat.pixelSnap;\n\t\toptions.litOptions.shadingModel = stdMat.shadingModel;\n\t\toptions.litOptions.ambientSH = !!stdMat.ambientSH;\n\t\toptions.litOptions.fastTbn = stdMat.fastTbn;\n\t\toptions.litOptions.twoSidedLighting = stdMat.twoSidedLighting;\n\t\toptions.litOptions.occludeSpecular = stdMat.occludeSpecular;\n\t\toptions.litOptions.occludeSpecularFloat = stdMat.occludeSpecularIntensity !== 1.0;\n\t\toptions.litOptions.useMsdf = !!stdMat.msdfMap;\n\t\toptions.litOptions.msdfTextAttribute = !!stdMat.msdfTextAttribute;\n\t\toptions.litOptions.alphaToCoverage = stdMat.alphaToCoverage;\n\t\toptions.litOptions.opacityFadesSpecular = stdMat.opacityFadesSpecular;\n\t\toptions.litOptions.opacityDither = stdMat.opacityDither;\n\t\toptions.litOptions.cubeMapProjection = stdMat.cubeMapProjection;\n\t\toptions.litOptions.occludeDirect = stdMat.occludeDirect;\n\t\toptions.litOptions.conserveEnergy = stdMat.conserveEnergy && stdMat.shadingModel !== SPECULAR_PHONG;\n\t\toptions.litOptions.useSpecular = useSpecular;\n\t\toptions.litOptions.useSpecularityFactor = (specularityFactorTint || !!stdMat.specularityFactorMap) && stdMat.useMetalnessSpecularColor;\n\t\toptions.litOptions.enableGGXSpecular = stdMat.enableGGXSpecular;\n\t\toptions.litOptions.fresnelModel = stdMat.fresnelModel;\n\t\toptions.litOptions.useRefraction = (stdMat.refraction || !!stdMat.refractionMap) && (stdMat.useDynamicRefraction || !!options.litOptions.reflectionSource);\n\t\toptions.litOptions.useClearCoat = !!stdMat.clearCoat;\n\t\toptions.litOptions.useSheen = stdMat.useSheen;\n\t\toptions.litOptions.useIridescence = stdMat.useIridescence && stdMat.iridescence !== 0.0;\n\t\toptions.litOptions.useMetalness = stdMat.useMetalness;\n\t\toptions.litOptions.useDynamicRefraction = stdMat.useDynamicRefraction;\n\t\toptions.litOptions.dispersion = stdMat.dispersion > 0;\n\t}\n\t_updateEnvOptions(options, stdMat, scene) {\n\t\toptions.litOptions.fog = stdMat.useFog ? scene.fog : 'none';\n\t\toptions.litOptions.gamma = stdMat.useGammaTonemap ? scene.gammaCorrection : GAMMA_NONE;\n\t\toptions.litOptions.toneMap = stdMat.useGammaTonemap ? scene.toneMapping : -1;\n\t\toptions.litOptions.fixSeams = stdMat.cubeMap ? stdMat.cubeMap.fixCubemapSeams : false;\n\t\tconst isPhong = stdMat.shadingModel === SPECULAR_PHONG;\n\t\tlet usingSceneEnv = false;\n\t\tif (stdMat.envAtlas && stdMat.cubeMap && !isPhong) {\n\t\t\toptions.litOptions.reflectionSource = 'envAtlasHQ';\n\t\t\toptions.litOptions.reflectionEncoding = stdMat.envAtlas.encoding;\n\t\t\toptions.litOptions.reflectionCubemapEncoding = stdMat.cubeMap.encoding;\n\t\t} else if (stdMat.envAtlas && !isPhong) {\n\t\t\toptions.litOptions.reflectionSource = 'envAtlas';\n\t\t\toptions.litOptions.reflectionEncoding = stdMat.envAtlas.encoding;\n\t\t} else if (stdMat.cubeMap) {\n\t\t\toptions.litOptions.reflectionSource = 'cubeMap';\n\t\t\toptions.litOptions.reflectionEncoding = stdMat.cubeMap.encoding;\n\t\t} else if (stdMat.sphereMap) {\n\t\t\toptions.litOptions.reflectionSource = 'sphereMap';\n\t\t\toptions.litOptions.reflectionEncoding = stdMat.sphereMap.encoding;\n\t\t} else if (stdMat.useSkybox && scene.envAtlas && scene.skybox && !isPhong) {\n\t\t\toptions.litOptions.reflectionSource = 'envAtlasHQ';\n\t\t\toptions.litOptions.reflectionEncoding = scene.envAtlas.encoding;\n\t\t\toptions.litOptions.reflectionCubemapEncoding = scene.skybox.encoding;\n\t\t\tusingSceneEnv = true;\n\t\t} else if (stdMat.useSkybox && scene.envAtlas && !isPhong) {\n\t\t\toptions.litOptions.reflectionSource = 'envAtlas';\n\t\t\toptions.litOptions.reflectionEncoding = scene.envAtlas.encoding;\n\t\t\tusingSceneEnv = true;\n\t\t} else if (stdMat.useSkybox && scene.skybox) {\n\t\t\toptions.litOptions.reflectionSource = 'cubeMap';\n\t\t\toptions.litOptions.reflectionEncoding = scene.skybox.encoding;\n\t\t\tusingSceneEnv = true;\n\t\t} else {\n\t\t\toptions.litOptions.reflectionSource = null;\n\t\t\toptions.litOptions.reflectionEncoding = null;\n\t\t}\n\t\tif (stdMat.ambientSH && !isPhong) {\n\t\t\toptions.litOptions.ambientSource = 'ambientSH';\n\t\t\toptions.litOptions.ambientEncoding = null;\n\t\t} else {\n\t\t\tconst envAtlas = stdMat.envAtlas || (stdMat.useSkybox && scene.envAtlas ? scene.envAtlas : null);\n\t\t\tif (envAtlas && !isPhong) {\n\t\t\t\toptions.litOptions.ambientSource = 'envAtlas';\n\t\t\t\toptions.litOptions.ambientEncoding = envAtlas.encoding;\n\t\t\t} else {\n\t\t\t\toptions.litOptions.ambientSource = 'constant';\n\t\t\t\toptions.litOptions.ambientEncoding = null;\n\t\t\t}\n\t\t}\n\t\toptions.litOptions.skyboxIntensity = usingSceneEnv;\n\t\toptions.litOptions.useCubeMapRotation = usingSceneEnv && scene._skyboxRotationShaderInclude;\n\t}\n\t_updateLightOptions(options, scene, stdMat, objDefs, sortedLights) {\n\t\toptions.lightMap = false;\n\t\toptions.lightMapChannel = '';\n\t\toptions.lightMapUv = 0;\n\t\toptions.lightMapTransform = 0;\n\t\toptions.litOptions.lightMapWithoutAmbient = false;\n\t\toptions.dirLightMap = false;\n\t\tif (objDefs) {\n\t\t\toptions.litOptions.noShadow = (objDefs & SHADERDEF_NOSHADOW) !== 0;\n\t\t\tif ((objDefs & SHADERDEF_LM) !== 0) {\n\t\t\t\toptions.lightMapEncoding = scene.lightmapPixelFormat === PIXELFORMAT_RGBA8 ? 'rgbm' : 'linear';\n\t\t\t\toptions.lightMap = true;\n\t\t\t\toptions.lightMapChannel = 'rgb';\n\t\t\t\toptions.lightMapUv = 1;\n\t\t\t\toptions.lightMapTransform = 0;\n\t\t\t\toptions.litOptions.lightMapWithoutAmbient = !stdMat.lightMap;\n\t\t\t\tif ((objDefs & SHADERDEF_DIRLM) !== 0) {\n\t\t\t\t\toptions.dirLightMap = true;\n\t\t\t\t}\n\t\t\t\tif ((objDefs & SHADERDEF_LMAMBIENT) !== 0) {\n\t\t\t\t\toptions.litOptions.lightMapWithoutAmbient = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (stdMat.useLighting) {\n\t\t\tconst lightsFiltered = [];\n\t\t\tconst mask = objDefs ? objDefs >> 16 : MASK_AFFECT_DYNAMIC;\n\t\t\toptions.litOptions.lightMaskDynamic = !!(mask & MASK_AFFECT_DYNAMIC);\n\t\t\tif (sortedLights) {\n\t\t\t\tLitMaterialOptionsBuilder.collectLights(LIGHTTYPE_DIRECTIONAL, sortedLights[LIGHTTYPE_DIRECTIONAL], lightsFiltered, mask);\n\t\t\t\tLitMaterialOptionsBuilder.collectLights(LIGHTTYPE_OMNI, sortedLights[LIGHTTYPE_OMNI], lightsFiltered, mask);\n\t\t\t\tLitMaterialOptionsBuilder.collectLights(LIGHTTYPE_SPOT, sortedLights[LIGHTTYPE_SPOT], lightsFiltered, mask);\n\t\t\t}\n\t\t\toptions.litOptions.lights = lightsFiltered;\n\t\t} else {\n\t\t\toptions.litOptions.lights = [];\n\t\t}\n\t\tif (options.litOptions.lights.length === 0) {\n\t\t\toptions.litOptions.noShadow = true;\n\t\t}\n\t}\n\t_getMapTransformID(xform, uv) {\n\t\tif (!xform) return 0;\n\t\tlet xforms = this._mapXForms[uv];\n\t\tif (!xforms) {\n\t\t\txforms = [];\n\t\t\tthis._mapXForms[uv] = xforms;\n\t\t}\n\t\tfor (let i = 0; i < xforms.length; i++) {\n\t\t\tif (arraysEqual(xforms[i][0].value, xform[0].value) && arraysEqual(xforms[i][1].value, xform[1].value)) {\n\t\t\t\treturn i + 1;\n\t\t\t}\n\t\t}\n\t\treturn xforms.push(xform);\n\t}\n}\n\nexport { StandardMaterialOptionsBuilder };\n","import { LitShaderOptions } from '../shader-lib/programs/lit-shader-options.js';\n\nclass StandardMaterialOptions {\n\tconstructor() {\n\t\tthis.forceUv1 = false;\n\t\tthis.ambientTint = false;\n\t\tthis.diffuseTint = false;\n\t\tthis.specularTint = false;\n\t\tthis.metalnessTint = false;\n\t\tthis.glossTint = false;\n\t\tthis.emissiveTint = false;\n\t\tthis.opacityTint = false;\n\t\tthis.emissiveEncoding = 'linear';\n\t\tthis.lightMapEncoding = 'linear';\n\t\tthis.packedNormal = false;\n\t\tthis.glossInvert = false;\n\t\tthis.sheenGlossInvert = false;\n\t\tthis.clearCoatGlossInvert = false;\n\t\tthis.litOptions = new LitShaderOptions();\n\t}\n\tget pass() {\n\t\treturn this.litOptions.pass;\n\t}\n}\n\nexport { StandardMaterialOptions };\n","import { extends as _extends } from '../../../_virtual/_rollupPluginBabelHelpers.js';\nimport { __adjustStandardMaterialParameterTypes } from '../../deprecated/compatibility-v2-utils.js';\n\nfunction _textureParameter(name, channel = true, vertexColor = true) {\n\tconst result = {};\n\tresult[`${name}Map`] = 'texture';\n\tresult[`${name}MapTiling`] = 'vec2';\n\tresult[`${name}MapOffset`] = 'vec2';\n\tresult[`${name}MapRotation`] = 'number';\n\tresult[`${name}MapUv`] = 'number';\n\tif (channel) {\n\t\tresult[`${name}MapChannel`] = 'string';\n\t\tif (vertexColor) {\n\t\t\tresult[`${name}VertexColor`] = 'boolean';\n\t\t\tresult[`${name}VertexColorChannel`] = 'string';\n\t\t}\n\t}\n\treturn result;\n}\nconst standardMaterialParameterTypes = _extends({\n\tname: 'string',\n\tchunks: 'chunks',\n\tmappingFormat: 'string',\n\t_engine: 'boolean',\n\tambient: 'rgb',\n\tambientTint: 'boolean'\n}, _textureParameter('ao'), _textureParameter('aoDetail', true, false), {\n\taoDetailMode: 'string',\n\tdiffuse: 'rgb',\n\tdiffuseTint: 'boolean'\n}, _textureParameter('diffuse'), _textureParameter('diffuseDetail', true, false), {\n\tdiffuseDetailMode: 'string',\n\tspecular: 'rgb',\n\tspecularTint: 'boolean'\n}, _textureParameter('specular'), {\n\toccludeSpecular: 'enum:occludeSpecular',\n\tspecularityFactor: 'number',\n\tspecularityFactorTint: 'boolean'\n}, _textureParameter('specularityFactor'), {\n\tuseMetalness: 'boolean',\n\tmetalness: 'number',\n\tenableGGXSpecular: 'boolean',\n\tanisotropy: 'number',\n\tmetalnessTint: 'boolean'\n}, _textureParameter('metalness'), {\n\tuseMetalnessSpecularColor: 'boolean',\n\tconserveEnergy: 'boolean',\n\tshininess: 'number',\n\tgloss: 'number',\n\tglossInvert: 'boolean'\n}, _textureParameter('gloss'), {\n\tclearCoat: 'number'\n}, _textureParameter('clearCoat'), {\n\tclearCoatGloss: 'number',\n\tclearCoatGlossInvert: 'boolean'\n}, _textureParameter('clearCoatGloss'), {\n\tclearCoatBumpiness: 'number'\n}, _textureParameter('clearCoatNormal', false), {\n\tuseSheen: 'boolean',\n\tsheen: 'rgb',\n\tsheenTint: 'boolean'\n}, _textureParameter('sheen'), {\n\tsheenGloss: 'number',\n\tsheenGlossTint: 'boolean',\n\tsheenGlossInvert: 'boolean'\n}, _textureParameter('sheenGloss'), {\n\tfresnelModel: 'number',\n\temissive: 'rgb',\n\temissiveTint: 'boolean'\n}, _textureParameter('emissive'), {\n\temissiveIntensity: 'number'\n}, _textureParameter('normal', false), {\n\tbumpiness: 'number'\n}, _textureParameter('normalDetail', false), {\n\tnormalDetailMapBumpiness: 'number'\n}, _textureParameter('height', true, false), {\n\theightMapFactor: 'number',\n\talphaToCoverage: 'boolean',\n\talphaTest: 'number',\n\talphaFade: 'number',\n\topacity: 'number'\n}, _textureParameter('opacity'), {\n\topacityFadesSpecular: 'boolean',\n\topacityDither: 'string',\n\topacityShadowDither: 'string',\n\treflectivity: 'number',\n\trefraction: 'number',\n\trefractionTint: 'boolean'\n}, _textureParameter('refraction'), {\n\trefractionIndex: 'number',\n\tdispersion: 'number',\n\tthickness: 'number',\n\tthicknessTint: 'boolean'\n}, _textureParameter('thickness'), {\n\tattenuation: 'rgb',\n\tattenuationDistance: 'number',\n\tuseDynamicRefraction: 'boolean',\n\tsphereMap: 'texture',\n\tcubeMap: 'cubemap',\n\tcubeMapProjection: 'number',\n\tcubeMapProjectionBox: 'boundingbox',\n\tuseIridescence: 'boolean',\n\tiridescence: 'number',\n\tiridescenceTint: 'boolean'\n}, _textureParameter('iridescence'), {\n\tiridescenceThicknessTint: 'boolean',\n\tiridescenceThicknessMin: 'number',\n\tiridescenceThicknessMax: 'number',\n\tiridescenceRefractionIndex: 'number'\n}, _textureParameter('iridescenceThickness'), _textureParameter('light'), {\n\tdepthTest: 'boolean',\n\tdepthFunc: 'enum:depthFunc',\n\tdepthWrite: 'boolean',\n\tdepthBias: 'number',\n\tslopeDepthBias: 'number',\n\tcull: 'enum:cull',\n\tblendType: 'enum:blendType',\n\tshadingModel: 'enum:shadingModel',\n\tuseFog: 'boolean',\n\tuseLighting: 'boolean',\n\tuseSkybox: 'boolean',\n\tuseGammaTonemap: 'boolean',\n\tenvAtlas: 'texture',\n\ttwoSidedLighting: 'boolean'\n});\n__adjustStandardMaterialParameterTypes(standardMaterialParameterTypes);\nconst standardMaterialTextureParameters = [];\nfor (const key in standardMaterialParameterTypes) {\n\tconst type = standardMaterialParameterTypes[key];\n\tif (type === 'texture') {\n\t\tstandardMaterialTextureParameters.push(key);\n\t}\n}\nconst standardMaterialCubemapParameters = [];\nfor (const key in standardMaterialParameterTypes) {\n\tconst type = standardMaterialParameterTypes[key];\n\tif (type === 'cubemap') {\n\t\tstandardMaterialCubemapParameters.push(key);\n\t}\n}\nconst standardMaterialRemovedParameters = {\n\taoMapVertexColor: 'boolean',\n\tdiffuseMapTint: 'boolean',\n\tdiffuseMapVertexColor: 'boolean',\n\temissiveMapTint: 'boolean',\n\temissiveMapVertexColor: 'boolean',\n\tglossMapVertexColor: 'boolean',\n\tmetalnessMapVertexColor: 'boolean',\n\topacityMapVertexColor: 'boolean',\n\tspecularAntialias: 'boolean',\n\tspecularMapTint: 'boolean',\n\tspecularMapVertexColor: 'boolean',\n\tuseTonemap: 'boolean',\n\taoIntensity: 'number'\n};\n\nexport { standardMaterialCubemapParameters, standardMaterialParameterTypes, standardMaterialRemovedParameters, standardMaterialTextureParameters };\n","import { CULLFACE_NONE, CULLFACE_BACK, CULLFACE_FRONT, CULLFACE_FRONTANDBACK, FUNC_NEVER, FUNC_LESS, FUNC_EQUAL, FUNC_LESSEQUAL, FUNC_GREATER, FUNC_NOTEQUAL, FUNC_GREATEREQUAL, FUNC_ALWAYS } from '../../platform/graphics/constants.js';\nimport { Texture } from '../../platform/graphics/texture.js';\nimport { SPECOCC_NONE, SPECOCC_AO, SPECOCC_GLOSSDEPENDENT, BLEND_SUBTRACTIVE, BLEND_ADDITIVE, BLEND_NORMAL, BLEND_NONE, BLEND_PREMULTIPLIED, BLEND_MULTIPLICATIVE, BLEND_ADDITIVEALPHA, BLEND_MULTIPLICATIVE2X, BLEND_SCREEN, BLEND_MIN, BLEND_MAX, SPECULAR_PHONG, SPECULAR_BLINN } from '../constants.js';\nimport { standardMaterialParameterTypes, standardMaterialRemovedParameters } from './standard-material-parameters.js';\n\nclass StandardMaterialValidator {\n\tconstructor() {\n\t\tthis.removeInvalid = true;\n\t\tthis.valid = true;\n\t\tthis.enumValidators = {\n\t\t\toccludeSpecular: this._createEnumValidator([SPECOCC_NONE, SPECOCC_AO, SPECOCC_GLOSSDEPENDENT]),\n\t\t\tcull: this._createEnumValidator([CULLFACE_NONE, CULLFACE_BACK, CULLFACE_FRONT, CULLFACE_FRONTANDBACK]),\n\t\t\tblendType: this._createEnumValidator([BLEND_SUBTRACTIVE, BLEND_ADDITIVE, BLEND_NORMAL, BLEND_NONE, BLEND_PREMULTIPLIED, BLEND_MULTIPLICATIVE, BLEND_ADDITIVEALPHA, BLEND_MULTIPLICATIVE2X, BLEND_SCREEN, BLEND_MIN, BLEND_MAX]),\n\t\t\tdepthFunc: this._createEnumValidator([FUNC_NEVER, FUNC_LESS, FUNC_EQUAL, FUNC_LESSEQUAL, FUNC_GREATER, FUNC_NOTEQUAL, FUNC_GREATEREQUAL, FUNC_ALWAYS]),\n\t\t\tshadingModel: this._createEnumValidator([SPECULAR_PHONG, SPECULAR_BLINN])\n\t\t};\n\t}\n\tsetInvalid(key, data) {\n\t\tthis.valid = false;\n\t\tif (this.removeInvalid) {\n\t\t\tdelete data[key];\n\t\t}\n\t}\n\tvalidate(data) {\n\t\tconst TYPES = standardMaterialParameterTypes;\n\t\tconst REMOVED = standardMaterialRemovedParameters;\n\t\tconst pathMapping = data.mappingFormat === 'path';\n\t\tfor (const key in data) {\n\t\t\tconst type = TYPES[key];\n\t\t\tif (!type) {\n\t\t\t\tif (REMOVED[key]) {\n\t\t\t\t\tdelete data[key];\n\t\t\t\t} else {\n\t\t\t\t\tthis.valid = false;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (type.startsWith('enum')) {\n\t\t\t\tconst enumType = type.split(':')[1];\n\t\t\t\tif (this.enumValidators[enumType]) {\n\t\t\t\t\tif (!this.enumValidators[enumType](data[key])) {\n\t\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (typeof data[key] !== 'number') {\n\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\tif (typeof data[key] !== 'boolean') {\n\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t}\n\t\t\t} else if (type === 'string') {\n\t\t\t\tif (typeof data[key] !== 'string') {\n\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t}\n\t\t\t} else if (type === 'vec2') {\n\t\t\t\tif (!(data[key] instanceof Array && data[key].length === 2)) {\n\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t}\n\t\t\t} else if (type === 'rgb') {\n\t\t\t\tif (!(data[key] instanceof Array && data[key].length === 3)) {\n\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t}\n\t\t\t} else if (type === 'texture') {\n\t\t\t\tif (!pathMapping) {\n\t\t\t\t\tif (!(typeof data[key] === 'number' || data[key] === null)) {\n\t\t\t\t\t\tif (!(data[key] instanceof Texture)) {\n\t\t\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (!(typeof data[key] === 'string' || data[key] === null)) {\n\t\t\t\t\t\tif (!(data[key] instanceof Texture)) {\n\t\t\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boundingbox') {\n\t\t\t\tif (!(data[key].center && data[key].center instanceof Array && data[key].center.length === 3)) {\n\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t}\n\t\t\t\tif (!(data[key].halfExtents && data[key].halfExtents instanceof Array && data[key].halfExtents.length === 3)) {\n\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t}\n\t\t\t} else if (type === 'cubemap') {\n\t\t\t\tif (!(typeof data[key] === 'number' || data[key] === null || data[key] === undefined)) {\n\t\t\t\t\tif (!(data[key] instanceof Texture && data[key].cubemap)) {\n\t\t\t\t\t\tthis.setInvalid(key, data);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'chunks') {\n\t\t\t\tconst chunkNames = Object.keys(data[key]);\n\t\t\t\tfor (let i = 0; i < chunkNames.length; i++) {\n\t\t\t\t\tif (typeof data[key][chunkNames[i]] !== 'string') {\n\t\t\t\t\t\tthis.setInvalid(chunkNames[i], data[key]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconsole.error(`Unknown material type: ${type}`);\n\t\t\t}\n\t\t}\n\t\tdata.validated = true;\n\t\treturn this.valid;\n\t}\n\t_createEnumValidator(values) {\n\t\treturn function (value) {\n\t\t\treturn values.indexOf(value) >= 0;\n\t\t};\n\t}\n}\n\nexport { StandardMaterialValidator };\n","import { Color } from '../../core/math/color.js';\nimport { math } from '../../core/math/math.js';\nimport { Vec2 } from '../../core/math/vec2.js';\nimport { ShaderProcessorOptions } from '../../platform/graphics/shader-processor-options.js';\nimport { CUBEPROJ_BOX, SPECULAR_PHONG, SHADER_DEPTH, SHADER_PICK, SHADER_PREPASS_VELOCITY, SPECOCC_AO, SPECULAR_BLINN, FRESNEL_SCHLICK, CUBEPROJ_NONE, DITHER_NONE, DETAILMODE_MUL } from '../constants.js';\nimport { ShaderPass } from '../shader-pass.js';\nimport { EnvLighting } from '../graphics/env-lighting.js';\nimport { getProgramLibrary } from '../shader-lib/get-program-library.js';\nimport { _matTex2D, standard } from '../shader-lib/programs/standard.js';\nimport { Material } from './material.js';\nimport { StandardMaterialOptionsBuilder } from './standard-material-options-builder.js';\nimport { standardMaterialTextureParameters, standardMaterialCubemapParameters } from './standard-material-parameters.js';\n\nconst _props = {};\nconst _uniforms = {};\nlet _params = new Set();\nclass StandardMaterial extends Material {\n\tconstructor() {\n\t\tsuper();\n\t\tthis.userAttributes = new Map();\n\t\tthis._dirtyShader = true;\n\t\tthis._assetReferences = {};\n\t\tthis._activeParams = new Set();\n\t\tthis._activeLightingParams = new Set();\n\t\tthis.shaderOptBuilder = new StandardMaterialOptionsBuilder();\n\t\tthis.reset();\n\t}\n\treset() {\n\t\tObject.keys(_props).forEach(name => {\n\t\t\tthis[`_${name}`] = _props[name].value();\n\t\t});\n\t\tthis._chunks = {};\n\t\tthis._uniformCache = {};\n\t}\n\tset shader(shader) {}\n\tget shader() {\n\t\treturn null;\n\t}\n\tset chunks(value) {\n\t\tthis._dirtyShader = true;\n\t\tthis._chunks = value;\n\t}\n\tget chunks() {\n\t\tthis._dirtyShader = true;\n\t\treturn this._chunks;\n\t}\n\tcopy(source) {\n\t\tsuper.copy(source);\n\t\tObject.keys(_props).forEach(k => {\n\t\t\tthis[k] = source[k];\n\t\t});\n\t\tfor (const p in source._chunks) {\n\t\t\tif (source._chunks.hasOwnProperty(p)) {\n\t\t\t\tthis._chunks[p] = source._chunks[p];\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\tsetAttribute(name, semantic) {\n\t\tthis.userAttributes.set(semantic, name);\n\t}\n\t_setParameter(name, value) {\n\t\t_params.add(name);\n\t\tthis.setParameter(name, value);\n\t}\n\t_setParameters(parameters) {\n\t\tparameters.forEach(v => {\n\t\t\tthis._setParameter(v.name, v.value);\n\t\t});\n\t}\n\t_processParameters(paramsName) {\n\t\tconst prevParams = this[paramsName];\n\t\tprevParams.forEach(param => {\n\t\t\tif (!_params.has(param)) {\n\t\t\t\tdelete this.parameters[param];\n\t\t\t}\n\t\t});\n\t\tthis[paramsName] = _params;\n\t\t_params = prevParams;\n\t\t_params.clear();\n\t}\n\t_updateMap(p) {\n\t\tconst mname = `${p}Map`;\n\t\tconst map = this[mname];\n\t\tif (map) {\n\t\t\tthis._setParameter(`texture_${mname}`, map);\n\t\t\tconst tname = `${mname}Transform`;\n\t\t\tconst uniform = this.getUniform(tname);\n\t\t\tif (uniform) {\n\t\t\t\tthis._setParameters(uniform);\n\t\t\t}\n\t\t}\n\t}\n\t_allocUniform(name, allocFunc) {\n\t\tlet uniform = this._uniformCache[name];\n\t\tif (!uniform) {\n\t\t\tuniform = allocFunc();\n\t\t\tthis._uniformCache[name] = uniform;\n\t\t}\n\t\treturn uniform;\n\t}\n\tgetUniform(name, device, scene) {\n\t\treturn _uniforms[name](this, device, scene);\n\t}\n\tupdateUniforms(device, scene) {\n\t\tconst getUniform = name => {\n\t\t\treturn this.getUniform(name, device, scene);\n\t\t};\n\t\tthis._setParameter('material_ambient', getUniform('ambient'));\n\t\tif (!this.diffuseMap || this.diffuseTint) {\n\t\t\tthis._setParameter('material_diffuse', getUniform('diffuse'));\n\t\t}\n\t\tif (this.useMetalness) {\n\t\t\tif (!this.metalnessMap || this.metalness < 1) {\n\t\t\t\tthis._setParameter('material_metalness', this.metalness);\n\t\t\t}\n\t\t\tif (!this.specularMap || this.specularTint) {\n\t\t\t\tthis._setParameter('material_specular', getUniform('specular'));\n\t\t\t}\n\t\t\tif (!this.specularityFactorMap || this.specularityFactorTint) {\n\t\t\t\tthis._setParameter('material_specularityFactor', this.specularityFactor);\n\t\t\t}\n\t\t\tif (!this.sheenMap || this.sheenTint) {\n\t\t\t\tthis._setParameter('material_sheen', getUniform('sheen'));\n\t\t\t}\n\t\t\tif (!this.sheenGlossMap || this.sheenGlossTint) {\n\t\t\t\tthis._setParameter('material_sheenGloss', this.sheenGloss);\n\t\t\t}\n\t\t\tthis._setParameter('material_refractionIndex', this.refractionIndex);\n\t\t} else {\n\t\t\tif (!this.specularMap || this.specularTint) {\n\t\t\t\tthis._setParameter('material_specular', getUniform('specular'));\n\t\t\t}\n\t\t}\n\t\tif (this.enableGGXSpecular) {\n\t\t\tthis._setParameter('material_anisotropy', this.anisotropy);\n\t\t}\n\t\tif (this.clearCoat > 0) {\n\t\t\tthis._setParameter('material_clearCoat', this.clearCoat);\n\t\t\tthis._setParameter('material_clearCoatGloss', this.clearCoatGloss);\n\t\t\tthis._setParameter('material_clearCoatBumpiness', this.clearCoatBumpiness);\n\t\t}\n\t\tthis._setParameter('material_gloss', getUniform('gloss'));\n\t\tif (!this.emissiveMap || this.emissiveTint) {\n\t\t\tthis._setParameter('material_emissive', getUniform('emissive'));\n\t\t}\n\t\tif (this.emissiveIntensity !== 1) {\n\t\t\tthis._setParameter('material_emissiveIntensity', this.emissiveIntensity);\n\t\t}\n\t\tif (this.refraction > 0) {\n\t\t\tthis._setParameter('material_refraction', this.refraction);\n\t\t}\n\t\tif (this.dispersion > 0) {\n\t\t\tthis._setParameter('material_dispersion', this.dispersion);\n\t\t}\n\t\tif (this.useDynamicRefraction) {\n\t\t\tthis._setParameter('material_thickness', this.thickness);\n\t\t\tthis._setParameter('material_attenuation', getUniform('attenuation'));\n\t\t\tthis._setParameter('material_invAttenuationDistance', this.attenuationDistance === 0 ? 0 : 1.0 / this.attenuationDistance);\n\t\t}\n\t\tif (this.useIridescence) {\n\t\t\tthis._setParameter('material_iridescence', this.iridescence);\n\t\t\tthis._setParameter('material_iridescenceRefractionIndex', this.iridescenceRefractionIndex);\n\t\t\tthis._setParameter('material_iridescenceThicknessMin', this.iridescenceThicknessMin);\n\t\t\tthis._setParameter('material_iridescenceThicknessMax', this.iridescenceThicknessMax);\n\t\t}\n\t\tthis._setParameter('material_opacity', this.opacity);\n\t\tif (this.opacityFadesSpecular === false) {\n\t\t\tthis._setParameter('material_alphaFade', this.alphaFade);\n\t\t}\n\t\tif (this.occludeSpecular) {\n\t\t\tthis._setParameter('material_occludeSpecularIntensity', this.occludeSpecularIntensity);\n\t\t}\n\t\tif (this.cubeMapProjection === CUBEPROJ_BOX) {\n\t\t\tthis._setParameter(getUniform('cubeMapProjectionBox'));\n\t\t}\n\t\tfor (const p in _matTex2D) {\n\t\t\tthis._updateMap(p);\n\t\t}\n\t\tif (this.ambientSH) {\n\t\t\tthis._setParameter('ambientSH[0]', this.ambientSH);\n\t\t}\n\t\tif (this.normalMap) {\n\t\t\tthis._setParameter('material_bumpiness', this.bumpiness);\n\t\t}\n\t\tif (this.normalMap && this.normalDetailMap) {\n\t\t\tthis._setParameter('material_normalDetailMapBumpiness', this.normalDetailMapBumpiness);\n\t\t}\n\t\tif (this.heightMap) {\n\t\t\tthis._setParameter('material_heightMapFactor', getUniform('heightMapFactor'));\n\t\t}\n\t\tconst isPhong = this.shadingModel === SPECULAR_PHONG;\n\t\tif (this.envAtlas && this.cubeMap && !isPhong) {\n\t\t\tthis._setParameter('texture_envAtlas', this.envAtlas);\n\t\t\tthis._setParameter('texture_cubeMap', this.cubeMap);\n\t\t} else if (this.envAtlas && !isPhong) {\n\t\t\tthis._setParameter('texture_envAtlas', this.envAtlas);\n\t\t} else if (this.cubeMap) {\n\t\t\tthis._setParameter('texture_cubeMap', this.cubeMap);\n\t\t} else if (this.sphereMap) {\n\t\t\tthis._setParameter('texture_sphereMap', this.sphereMap);\n\t\t}\n\t\tthis._setParameter('material_reflectivity', this.reflectivity);\n\t\tthis._processParameters('_activeParams');\n\t\tif (this._dirtyShader) {\n\t\t\tthis.clearVariants();\n\t\t}\n\t}\n\tupdateEnvUniforms(device, scene) {\n\t\tconst isPhong = this.shadingModel === SPECULAR_PHONG;\n\t\tconst hasLocalEnvOverride = this.envAtlas && !isPhong || this.cubeMap || this.sphereMap;\n\t\tif (!hasLocalEnvOverride && this.useSkybox) {\n\t\t\tif (scene.envAtlas && scene.skybox && !isPhong) {\n\t\t\t\tthis._setParameter('texture_envAtlas', scene.envAtlas);\n\t\t\t\tthis._setParameter('texture_cubeMap', scene.skybox);\n\t\t\t} else if (scene.envAtlas && !isPhong) {\n\t\t\t\tthis._setParameter('texture_envAtlas', scene.envAtlas);\n\t\t\t} else if (scene.skybox) {\n\t\t\t\tthis._setParameter('texture_cubeMap', scene.skybox);\n\t\t\t}\n\t\t}\n\t\tthis._processParameters('_activeLightingParams');\n\t}\n\tgetShaderVariant(device, scene, objDefs, unused, pass, sortedLights, viewUniformFormat, viewBindGroupFormat, vertexFormat) {\n\t\tthis.updateEnvUniforms(device, scene);\n\t\tconst shaderPassInfo = ShaderPass.get(device).getByIndex(pass);\n\t\tconst minimalOptions = pass === SHADER_DEPTH || pass === SHADER_PICK || pass === SHADER_PREPASS_VELOCITY || shaderPassInfo.isShadow;\n\t\tlet options = minimalOptions ? standard.optionsContextMin : standard.optionsContext;\n\t\tif (minimalOptions) {\n\t\t\tthis.shaderOptBuilder.updateMinRef(options, scene, this, objDefs, pass, sortedLights);\n\t\t} else {\n\t\t\tthis.shaderOptBuilder.updateRef(options, scene, this, objDefs, pass, sortedLights);\n\t\t}\n\t\tif (this.onUpdateShader) {\n\t\t\toptions = this.onUpdateShader(options);\n\t\t}\n\t\tconst processingOptions = new ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat, vertexFormat);\n\t\tconst library = getProgramLibrary(device);\n\t\tlibrary.register('standard', standard);\n\t\tconst shader = library.getProgram('standard', options, processingOptions, this.userId);\n\t\tthis._dirtyShader = false;\n\t\treturn shader;\n\t}\n\tdestroy() {\n\t\tfor (const asset in this._assetReferences) {\n\t\t\tthis._assetReferences[asset]._unbind();\n\t\t}\n\t\tthis._assetReferences = null;\n\t\tsuper.destroy();\n\t}\n}\nStandardMaterial.TEXTURE_PARAMETERS = standardMaterialTextureParameters;\nStandardMaterial.CUBEMAP_PARAMETERS = standardMaterialCubemapParameters;\nconst defineUniform = (name, getUniformFunc) => {\n\t_uniforms[name] = getUniformFunc;\n};\nconst definePropInternal = (name, constructorFunc, setterFunc, getterFunc) => {\n\tObject.defineProperty(StandardMaterial.prototype, name, {\n\t\tget: getterFunc || function () {\n\t\t\treturn this[`_${name}`];\n\t\t},\n\t\tset: setterFunc\n\t});\n\t_props[name] = {\n\t\tvalue: constructorFunc\n\t};\n};\nconst defineValueProp = prop => {\n\tconst internalName = `_${prop.name}`;\n\tconst dirtyShaderFunc = prop.dirtyShaderFunc || (() => true);\n\tconst setterFunc = function setterFunc(value) {\n\t\tconst oldValue = this[internalName];\n\t\tif (oldValue !== value) {\n\t\t\tthis._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);\n\t\t\tthis[internalName] = value;\n\t\t}\n\t};\n\tdefinePropInternal(prop.name, () => prop.defaultValue, setterFunc, prop.getterFunc);\n};\nconst defineAggProp = prop => {\n\tconst internalName = `_${prop.name}`;\n\tconst dirtyShaderFunc = prop.dirtyShaderFunc || (() => true);\n\tconst setterFunc = function setterFunc(value) {\n\t\tconst oldValue = this[internalName];\n\t\tif (!oldValue.equals(value)) {\n\t\t\tthis._dirtyShader = this._dirtyShader || dirtyShaderFunc(oldValue, value);\n\t\t\tthis[internalName] = oldValue.copy(value);\n\t\t}\n\t};\n\tdefinePropInternal(prop.name, () => prop.defaultValue.clone(), setterFunc, prop.getterFunc);\n};\nconst defineProp = prop => {\n\treturn prop.defaultValue && prop.defaultValue.clone ? defineAggProp(prop) : defineValueProp(prop);\n};\nfunction _defineTex2D(name, channel = 'rgb', vertexColor = true, uv = 0) {\n\t_matTex2D[name] = channel.length || -1;\n\tdefineProp({\n\t\tname: `${name}Map`,\n\t\tdefaultValue: null,\n\t\tdirtyShaderFunc: (oldValue, newValue) => {\n\t\t\treturn !!oldValue !== !!newValue || oldValue && (oldValue.type !== newValue.type || oldValue.fixCubemapSeams !== newValue.fixCubemapSeams || oldValue.format !== newValue.format);\n\t\t}\n\t});\n\tdefineProp({\n\t\tname: `${name}MapTiling`,\n\t\tdefaultValue: new Vec2(1, 1)\n\t});\n\tdefineProp({\n\t\tname: `${name}MapOffset`,\n\t\tdefaultValue: new Vec2(0, 0)\n\t});\n\tdefineProp({\n\t\tname: `${name}MapRotation`,\n\t\tdefaultValue: 0\n\t});\n\tdefineProp({\n\t\tname: `${name}MapUv`,\n\t\tdefaultValue: uv\n\t});\n\tif (channel) {\n\t\tdefineProp({\n\t\t\tname: `${name}MapChannel`,\n\t\t\tdefaultValue: channel\n\t\t});\n\t\tif (vertexColor) {\n\t\t\tdefineProp({\n\t\t\t\tname: `${name}VertexColor`,\n\t\t\t\tdefaultValue: false\n\t\t\t});\n\t\t\tdefineProp({\n\t\t\t\tname: `${name}VertexColorChannel`,\n\t\t\t\tdefaultValue: channel\n\t\t\t});\n\t\t}\n\t}\n\tconst mapTiling = `${name}MapTiling`;\n\tconst mapOffset = `${name}MapOffset`;\n\tconst mapRotation = `${name}MapRotation`;\n\tconst mapTransform = `${name}MapTransform`;\n\tdefineUniform(mapTransform, (material, device, scene) => {\n\t\tconst tiling = material[mapTiling];\n\t\tconst offset = material[mapOffset];\n\t\tconst rotation = material[mapRotation];\n\t\tif (tiling.x === 1 && tiling.y === 1 && offset.x === 0 && offset.y === 0 && rotation === 0) {\n\t\t\treturn null;\n\t\t}\n\t\tconst uniform = material._allocUniform(mapTransform, () => {\n\t\t\treturn [{\n\t\t\t\tname: `texture_${mapTransform}0`,\n\t\t\t\tvalue: new Float32Array(3)\n\t\t\t}, {\n\t\t\t\tname: `texture_${mapTransform}1`,\n\t\t\t\tvalue: new Float32Array(3)\n\t\t\t}];\n\t\t});\n\t\tconst cr = Math.cos(rotation * math.DEG_TO_RAD);\n\t\tconst sr = Math.sin(rotation * math.DEG_TO_RAD);\n\t\tconst uniform0 = uniform[0].value;\n\t\tuniform0[0] = cr * tiling.x;\n\t\tuniform0[1] = -sr * tiling.y;\n\t\tuniform0[2] = offset.x;\n\t\tconst uniform1 = uniform[1].value;\n\t\tuniform1[0] = sr * tiling.x;\n\t\tuniform1[1] = cr * tiling.y;\n\t\tuniform1[2] = 1.0 - tiling.y - offset.y;\n\t\treturn uniform;\n\t});\n}\nfunction _defineColor(name, defaultValue) {\n\tdefineProp({\n\t\tname: name,\n\t\tdefaultValue: defaultValue,\n\t\tgetterFunc: function () {\n\t\t\tthis._dirtyShader = true;\n\t\t\treturn this[`_${name}`];\n\t\t}\n\t});\n\tdefineUniform(name, (material, device, scene) => {\n\t\tconst uniform = material._allocUniform(name, () => new Float32Array(3));\n\t\tconst color = material[name];\n\t\tconst gamma = material.useGammaTonemap && scene.gammaCorrection;\n\t\tif (gamma) {\n\t\t\tuniform[0] = Math.pow(color.r, 2.2);\n\t\t\tuniform[1] = Math.pow(color.g, 2.2);\n\t\t\tuniform[2] = Math.pow(color.b, 2.2);\n\t\t} else {\n\t\t\tuniform[0] = color.r;\n\t\t\tuniform[1] = color.g;\n\t\t\tuniform[2] = color.b;\n\t\t}\n\t\treturn uniform;\n\t});\n}\nfunction _defineFloat(name, defaultValue, getUniformFunc) {\n\tdefineProp({\n\t\tname: name,\n\t\tdefaultValue: defaultValue,\n\t\tdirtyShaderFunc: (oldValue, newValue) => {\n\t\t\treturn (oldValue === 0 || oldValue === 1) !== (newValue === 0 || newValue === 1);\n\t\t}\n\t});\n\tdefineUniform(name, getUniformFunc);\n}\nfunction _defineObject(name, getUniformFunc) {\n\tdefineProp({\n\t\tname: name,\n\t\tdefaultValue: null,\n\t\tdirtyShaderFunc: (oldValue, newValue) => {\n\t\t\treturn !!oldValue === !!newValue;\n\t\t}\n\t});\n\tdefineUniform(name, getUniformFunc);\n}\nfunction _defineFlag(name, defaultValue) {\n\tdefineProp({\n\t\tname: name,\n\t\tdefaultValue: defaultValue\n\t});\n}\nfunction _defineMaterialProps() {\n\t_defineColor('ambient', new Color(0.7, 0.7, 0.7));\n\t_defineColor('diffuse', new Color(1, 1, 1));\n\t_defineColor('specular', new Color(0, 0, 0));\n\t_defineColor('emissive', new Color(0, 0, 0));\n\t_defineColor('sheen', new Color(1, 1, 1));\n\t_defineColor('attenuation', new Color(1, 1, 1));\n\t_defineFloat('emissiveIntensity', 1);\n\t_defineFloat('specularityFactor', 1);\n\t_defineFloat('sheenGloss', 0.0);\n\t_defineFloat('gloss', 0.25, (material, device, scene) => {\n\t\treturn material.shadingModel === SPECULAR_PHONG ? Math.pow(2, material.gloss * 11) : material.gloss;\n\t});\n\t_defineFloat('heightMapFactor', 1, (material, device, scene) => {\n\t\treturn material.heightMapFactor * 0.025;\n\t});\n\t_defineFloat('opacity', 1);\n\t_defineFloat('alphaFade', 1);\n\t_defineFloat('alphaTest', 0);\n\t_defineFloat('bumpiness', 1);\n\t_defineFloat('normalDetailMapBumpiness', 1);\n\t_defineFloat('reflectivity', 1);\n\t_defineFloat('occludeSpecularIntensity', 1);\n\t_defineFloat('refraction', 0);\n\t_defineFloat('refractionIndex', 1.0 / 1.5);\n\t_defineFloat('dispersion', 0);\n\t_defineFloat('thickness', 0);\n\t_defineFloat('attenuationDistance', 0);\n\t_defineFloat('metalness', 1);\n\t_defineFloat('anisotropy', 0);\n\t_defineFloat('clearCoat', 0);\n\t_defineFloat('clearCoatGloss', 1);\n\t_defineFloat('clearCoatBumpiness', 1);\n\t_defineFloat('aoUvSet', 0, null);\n\t_defineFloat('iridescence', 0);\n\t_defineFloat('iridescenceRefractionIndex', 1.0 / 1.5);\n\t_defineFloat('iridescenceThicknessMin', 0);\n\t_defineFloat('iridescenceThicknessMax', 0);\n\t_defineObject('ambientSH');\n\t_defineObject('cubeMapProjectionBox', (material, device, scene) => {\n\t\tconst uniform = material._allocUniform('cubeMapProjectionBox', () => {\n\t\t\treturn [{\n\t\t\t\tname: 'envBoxMin',\n\t\t\t\tvalue: new Float32Array(3)\n\t\t\t}, {\n\t\t\t\tname: 'envBoxMax',\n\t\t\t\tvalue: new Float32Array(3)\n\t\t\t}];\n\t\t});\n\t\tconst bboxMin = material.cubeMapProjectionBox.getMin();\n\t\tconst minUniform = uniform[0].value;\n\t\tminUniform[0] = bboxMin.x;\n\t\tminUniform[1] = bboxMin.y;\n\t\tminUniform[2] = bboxMin.z;\n\t\tconst bboxMax = material.cubeMapProjectionBox.getMax();\n\t\tconst maxUniform = uniform[1].value;\n\t\tmaxUniform[0] = bboxMax.x;\n\t\tmaxUniform[1] = bboxMax.y;\n\t\tmaxUniform[2] = bboxMax.z;\n\t\treturn uniform;\n\t});\n\t_defineFlag('ambientTint', false);\n\t_defineFlag('diffuseTint', false);\n\t_defineFlag('sheenTint', false);\n\t_defineFlag('specularTint', false);\n\t_defineFlag('specularityFactorTint', false);\n\t_defineFlag('emissiveTint', false);\n\t_defineFlag('fastTbn', false);\n\t_defineFlag('useMetalness', false);\n\t_defineFlag('useMetalnessSpecularColor', false);\n\t_defineFlag('useSheen', false);\n\t_defineFlag('enableGGXSpecular', false);\n\t_defineFlag('occludeDirect', false);\n\t_defineFlag('normalizeNormalMap', true);\n\t_defineFlag('conserveEnergy', true);\n\t_defineFlag('opacityFadesSpecular', true);\n\t_defineFlag('occludeSpecular', SPECOCC_AO);\n\t_defineFlag('shadingModel', SPECULAR_BLINN);\n\t_defineFlag('fresnelModel', FRESNEL_SCHLICK);\n\t_defineFlag('useDynamicRefraction', false);\n\t_defineFlag('cubeMapProjection', CUBEPROJ_NONE);\n\t_defineFlag('customFragmentShader', null);\n\t_defineFlag('useFog', true);\n\t_defineFlag('useLighting', true);\n\t_defineFlag('useGammaTonemap', true);\n\t_defineFlag('useSkybox', true);\n\t_defineFlag('forceUv1', false);\n\t_defineFlag('pixelSnap', false);\n\t_defineFlag('twoSidedLighting', false);\n\t_defineFlag('nineSlicedMode', undefined);\n\t_defineFlag('msdfTextAttribute', false);\n\t_defineFlag('useIridescence', false);\n\t_defineFlag('glossInvert', false);\n\t_defineFlag('sheenGlossInvert', false);\n\t_defineFlag('clearCoatGlossInvert', false);\n\t_defineFlag('opacityDither', DITHER_NONE);\n\t_defineFlag('opacityShadowDither', DITHER_NONE);\n\t_defineTex2D('diffuse');\n\t_defineTex2D('specular');\n\t_defineTex2D('emissive');\n\t_defineTex2D('thickness', 'g');\n\t_defineTex2D('specularityFactor', 'g');\n\t_defineTex2D('normal', '');\n\t_defineTex2D('metalness', 'g');\n\t_defineTex2D('gloss', 'g');\n\t_defineTex2D('opacity', 'a');\n\t_defineTex2D('refraction', 'g');\n\t_defineTex2D('height', 'g', false);\n\t_defineTex2D('ao', 'g');\n\t_defineTex2D('light', 'rgb', true, 1);\n\t_defineTex2D('msdf', '');\n\t_defineTex2D('diffuseDetail', 'rgb', false);\n\t_defineTex2D('normalDetail', '');\n\t_defineTex2D('aoDetail', 'g', false);\n\t_defineTex2D('clearCoat', 'g');\n\t_defineTex2D('clearCoatGloss', 'g');\n\t_defineTex2D('clearCoatNormal', '');\n\t_defineTex2D('sheen', 'rgb');\n\t_defineTex2D('sheenGloss', 'g');\n\t_defineTex2D('iridescence', 'g');\n\t_defineTex2D('iridescenceThickness', 'g');\n\t_defineFlag('diffuseDetailMode', DETAILMODE_MUL);\n\t_defineFlag('aoDetailMode', DETAILMODE_MUL);\n\t_defineObject('cubeMap');\n\t_defineObject('sphereMap');\n\t_defineObject('envAtlas');\n\tconst getterFunc = function getterFunc() {\n\t\treturn this._prefilteredCubemaps;\n\t};\n\tconst setterFunc = function setterFunc(value) {\n\t\tconst cubemaps = this._prefilteredCubemaps;\n\t\tvalue = value || [];\n\t\tlet changed = false;\n\t\tlet complete = true;\n\t\tfor (let i = 0; i < 6; ++i) {\n\t\t\tconst v = value[i] || null;\n\t\t\tif (cubemaps[i] !== v) {\n\t\t\t\tcubemaps[i] = v;\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t\tcomplete = complete && !!cubemaps[i];\n\t\t}\n\t\tif (changed) {\n\t\t\tif (complete) {\n\t\t\t\tthis.envAtlas = EnvLighting.generatePrefilteredAtlas(cubemaps, {\n\t\t\t\t\ttarget: this.envAtlas\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (this.envAtlas) {\n\t\t\t\t\tthis.envAtlas.destroy();\n\t\t\t\t\tthis.envAtlas = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._dirtyShader = true;\n\t\t}\n\t};\n\tconst empty = [null, null, null, null, null, null];\n\tdefinePropInternal('prefilteredCubemaps', () => empty.slice(), setterFunc, getterFunc);\n}\n_defineMaterialProps();\n\nexport { StandardMaterial };\n","import { BoundingBox } from '../core/shape/bounding-box.js';\nimport { BoundingSphere } from '../core/shape/bounding-sphere.js';\nimport { BindGroup } from '../platform/graphics/bind-group.js';\nimport { UniformBuffer } from '../platform/graphics/uniform-buffer.js';\nimport { MASK_AFFECT_DYNAMIC, SHADERDEF_UV0, SHADERDEF_UV1, SHADERDEF_VCOLOR, SHADERDEF_TANGENTS, LAYER_WORLD, RENDERSTYLE_SOLID, SHADERDEF_NOSHADOW, SHADERDEF_SKIN, SHADERDEF_MORPH_TEXTURE_BASED, SHADERDEF_MORPH_POSITION, SHADERDEF_MORPH_NORMAL, SHADERDEF_SCREENSPACE, SORTKEY_FORWARD, BLEND_NORMAL, BLEND_NONE, SHADERDEF_INSTANCING, MASK_AFFECT_LIGHTMAPPED, MASK_BAKE, SHADERDEF_LM, SHADERDEF_DIRLM, SHADERDEF_LMAMBIENT } from './constants.js';\nimport { GraphNode } from './graph-node.js';\nimport { getDefaultMaterial } from './materials/default-material.js';\nimport { LightmapCache } from './graphics/lightmap-cache.js';\n\nlet id = 0;\nconst _tmpAabb = new BoundingBox();\nconst _tempBoneAabb = new BoundingBox();\nconst _tempSphere = new BoundingSphere();\nconst _meshSet = new Set();\nclass InstancingData {\n\tconstructor(numObjects) {\n\t\tthis.vertexBuffer = null;\n\t\tthis.count = numObjects;\n\t}\n}\nclass ShaderInstance {\n\tconstructor() {\n\t\tthis.shader = void 0;\n\t\tthis.bindGroup = null;\n\t}\n\tgetBindGroup(device) {\n\t\tif (!this.bindGroup) {\n\t\t\tconst shader = this.shader;\n\t\t\tconst ubFormat = shader.meshUniformBufferFormat;\n\t\t\tconst uniformBuffer = new UniformBuffer(device, ubFormat, false);\n\t\t\tconst bindGroupFormat = shader.meshBindGroupFormat;\n\t\t\tthis.bindGroup = new BindGroup(device, bindGroupFormat, uniformBuffer);\n\t\t}\n\t\treturn this.bindGroup;\n\t}\n\tdestroy() {\n\t\tconst group = this.bindGroup;\n\t\tif (group) {\n\t\t\tvar _group$defaultUniform;\n\t\t\t(_group$defaultUniform = group.defaultUniformBuffer) == null || _group$defaultUniform.destroy();\n\t\t\tgroup.destroy();\n\t\t\tthis.bindGroup = null;\n\t\t}\n\t}\n}\nclass ShaderCacheEntry {\n\tconstructor() {\n\t\tthis.shaderInstances = new Map();\n\t}\n\tdestroy() {\n\t\tthis.shaderInstances.forEach(instance => instance.destroy());\n\t\tthis.shaderInstances.clear();\n\t}\n}\nclass MeshInstance {\n\tconstructor(mesh, material, node = null) {\n\t\tthis.visible = true;\n\t\tthis.castShadow = false;\n\t\tthis.transparent = false;\n\t\tthis._material = null;\n\t\tthis._shaderCache = [];\n\t\tthis.id = id++;\n\t\tthis.pick = true;\n\t\tif (mesh instanceof GraphNode) {\n\t\t\tconst temp = mesh;\n\t\t\tmesh = material;\n\t\t\tmaterial = node;\n\t\t\tnode = temp;\n\t\t}\n\t\tthis._key = [0, 0];\n\t\tthis.node = node;\n\t\tthis._mesh = mesh;\n\t\tmesh.incRefCount();\n\t\tthis.material = material;\n\t\tthis._shaderDefs = MASK_AFFECT_DYNAMIC << 16;\n\t\tif (mesh.vertexBuffer) {\n\t\t\tconst format = mesh.vertexBuffer.format;\n\t\t\tthis._shaderDefs |= format.hasUv0 ? SHADERDEF_UV0 : 0;\n\t\t\tthis._shaderDefs |= format.hasUv1 ? SHADERDEF_UV1 : 0;\n\t\t\tthis._shaderDefs |= format.hasColor ? SHADERDEF_VCOLOR : 0;\n\t\t\tthis._shaderDefs |= format.hasTangents ? SHADERDEF_TANGENTS : 0;\n\t\t}\n\t\tthis.layer = LAYER_WORLD;\n\t\tthis._renderStyle = RENDERSTYLE_SOLID;\n\t\tthis._receiveShadow = true;\n\t\tthis._screenSpace = false;\n\t\tthis.cull = true;\n\t\tthis._updateAabb = true;\n\t\tthis._updateAabbFunc = null;\n\t\tthis._calculateSortDistance = null;\n\t\tthis.updateKey();\n\t\tthis._skinInstance = null;\n\t\tthis._morphInstance = null;\n\t\tthis.gsplatInstance = null;\n\t\tthis.instancingData = null;\n\t\tthis._customAabb = null;\n\t\tthis.aabb = new BoundingBox();\n\t\tthis._aabbVer = -1;\n\t\tthis._aabbMeshVer = -1;\n\t\tthis.drawOrder = 0;\n\t\tthis.visibleThisFrame = false;\n\t\tthis.isVisibleFunc = null;\n\t\tthis.parameters = {};\n\t\tthis.stencilFront = null;\n\t\tthis.stencilBack = null;\n\t\tthis.flipFacesFactor = 1;\n\t}\n\tset renderStyle(renderStyle) {\n\t\tthis._renderStyle = renderStyle;\n\t\tthis.mesh.prepareRenderState(renderStyle);\n\t}\n\tget renderStyle() {\n\t\treturn this._renderStyle;\n\t}\n\tset mesh(mesh) {\n\t\tif (mesh === this._mesh) {\n\t\t\treturn;\n\t\t}\n\t\tif (this._mesh) {\n\t\t\tthis._mesh.decRefCount();\n\t\t}\n\t\tthis._mesh = mesh;\n\t\tif (mesh) {\n\t\t\tmesh.incRefCount();\n\t\t}\n\t}\n\tget mesh() {\n\t\treturn this._mesh;\n\t}\n\tset aabb(aabb) {\n\t\tthis._aabb = aabb;\n\t}\n\tget aabb() {\n\t\tif (!this._updateAabb) {\n\t\t\treturn this._aabb;\n\t\t}\n\t\tif (this._updateAabbFunc) {\n\t\t\treturn this._updateAabbFunc(this._aabb);\n\t\t}\n\t\tlet localAabb = this._customAabb;\n\t\tlet toWorldSpace = !!localAabb;\n\t\tif (!localAabb) {\n\t\t\tlocalAabb = _tmpAabb;\n\t\t\tif (this.skinInstance) {\n\t\t\t\tif (!this.mesh.boneAabb) {\n\t\t\t\t\tconst morphTargets = this._morphInstance ? this._morphInstance.morph._targets : null;\n\t\t\t\t\tthis.mesh._initBoneAabbs(morphTargets);\n\t\t\t\t}\n\t\t\t\tconst boneUsed = this.mesh.boneUsed;\n\t\t\t\tlet first = true;\n\t\t\t\tfor (let i = 0; i < this.mesh.boneAabb.length; i++) {\n\t\t\t\t\tif (boneUsed[i]) {\n\t\t\t\t\t\t_tempBoneAabb.setFromTransformedAabb(this.mesh.boneAabb[i], this.skinInstance.matrices[i]);\n\t\t\t\t\t\tif (first) {\n\t\t\t\t\t\t\tfirst = false;\n\t\t\t\t\t\t\tlocalAabb.center.copy(_tempBoneAabb.center);\n\t\t\t\t\t\t\tlocalAabb.halfExtents.copy(_tempBoneAabb.halfExtents);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlocalAabb.add(_tempBoneAabb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttoWorldSpace = true;\n\t\t\t} else if (this.node._aabbVer !== this._aabbVer || this.mesh._aabbVer !== this._aabbMeshVer) {\n\t\t\t\tif (this.mesh) {\n\t\t\t\t\tlocalAabb.center.copy(this.mesh.aabb.center);\n\t\t\t\t\tlocalAabb.halfExtents.copy(this.mesh.aabb.halfExtents);\n\t\t\t\t} else {\n\t\t\t\t\tlocalAabb.center.set(0, 0, 0);\n\t\t\t\t\tlocalAabb.halfExtents.set(0, 0, 0);\n\t\t\t\t}\n\t\t\t\tif (this.mesh && this.mesh.morph) {\n\t\t\t\t\tconst morphAabb = this.mesh.morph.aabb;\n\t\t\t\t\tlocalAabb._expand(morphAabb.getMin(), morphAabb.getMax());\n\t\t\t\t}\n\t\t\t\ttoWorldSpace = true;\n\t\t\t\tthis._aabbVer = this.node._aabbVer;\n\t\t\t\tthis._aabbMeshVer = this.mesh._aabbVer;\n\t\t\t}\n\t\t}\n\t\tif (toWorldSpace) {\n\t\t\tthis._aabb.setFromTransformedAabb(localAabb, this.node.getWorldTransform());\n\t\t}\n\t\treturn this._aabb;\n\t}\n\tclearShaders() {\n\t\tconst shaderCache = this._shaderCache;\n\t\tfor (let i = 0; i < shaderCache.length; i++) {\n\t\t\tvar _shaderCache$i;\n\t\t\t(_shaderCache$i = shaderCache[i]) == null || _shaderCache$i.destroy();\n\t\t\tshaderCache[i] = null;\n\t\t}\n\t}\n\tgetShaderInstance(shaderPass, lightHash, scene, viewUniformFormat, viewBindGroupFormat, sortedLights) {\n\t\tlet shaderInstance;\n\t\tlet passEntry = this._shaderCache[shaderPass];\n\t\tif (passEntry) {\n\t\t\tshaderInstance = passEntry.shaderInstances.get(lightHash);\n\t\t} else {\n\t\t\tpassEntry = new ShaderCacheEntry();\n\t\t\tthis._shaderCache[shaderPass] = passEntry;\n\t\t}\n\t\tif (!shaderInstance) {\n\t\t\tconst mat = this._material;\n\t\t\tconst shaderDefs = this._shaderDefs;\n\t\t\tconst variantKey = `${shaderPass}_${shaderDefs}_${lightHash}`;\n\t\t\tshaderInstance = new ShaderInstance();\n\t\t\tshaderInstance.shader = mat.variants.get(variantKey);\n\t\t\tif (!shaderInstance.shader) {\n\t\t\t\tvar _this$_mesh$vertexBuf;\n\t\t\t\tconst shader = mat.getShaderVariant(this.mesh.device, scene, shaderDefs, null, shaderPass, sortedLights, viewUniformFormat, viewBindGroupFormat, (_this$_mesh$vertexBuf = this._mesh.vertexBuffer) == null ? void 0 : _this$_mesh$vertexBuf.format);\n\t\t\t\tmat.variants.set(variantKey, shader);\n\t\t\t\tshaderInstance.shader = shader;\n\t\t\t}\n\t\t\tpassEntry.shaderInstances.set(lightHash, shaderInstance);\n\t\t}\n\t\treturn shaderInstance;\n\t}\n\tset material(material) {\n\t\tthis.clearShaders();\n\t\tconst prevMat = this._material;\n\t\tif (prevMat) {\n\t\t\tprevMat.removeMeshInstanceRef(this);\n\t\t}\n\t\tthis._material = material;\n\t\tif (material) {\n\t\t\tmaterial.addMeshInstanceRef(this);\n\t\t\tthis.transparent = material.transparent;\n\t\t\tthis.updateKey();\n\t\t}\n\t}\n\tget material() {\n\t\treturn this._material;\n\t}\n\tset layer(layer) {\n\t\tthis._layer = layer;\n\t\tthis.updateKey();\n\t}\n\tget layer() {\n\t\treturn this._layer;\n\t}\n\t_updateShaderDefs(shaderDefs) {\n\t\tif (shaderDefs !== this._shaderDefs) {\n\t\t\tthis._shaderDefs = shaderDefs;\n\t\t\tthis.clearShaders();\n\t\t}\n\t}\n\tset calculateSortDistance(calculateSortDistance) {\n\t\tthis._calculateSortDistance = calculateSortDistance;\n\t}\n\tget calculateSortDistance() {\n\t\treturn this._calculateSortDistance;\n\t}\n\tset receiveShadow(val) {\n\t\tif (this._receiveShadow !== val) {\n\t\t\tthis._receiveShadow = val;\n\t\t\tthis._updateShaderDefs(val ? this._shaderDefs & ~SHADERDEF_NOSHADOW : this._shaderDefs | SHADERDEF_NOSHADOW);\n\t\t}\n\t}\n\tget receiveShadow() {\n\t\treturn this._receiveShadow;\n\t}\n\tset skinInstance(val) {\n\t\tthis._skinInstance = val;\n\t\tthis._updateShaderDefs(val ? this._shaderDefs | SHADERDEF_SKIN : this._shaderDefs & ~SHADERDEF_SKIN);\n\t\tthis._setupSkinUpdate();\n\t}\n\tget skinInstance() {\n\t\treturn this._skinInstance;\n\t}\n\tset morphInstance(val) {\n\t\tvar _this$_morphInstance;\n\t\t(_this$_morphInstance = this._morphInstance) == null || _this$_morphInstance.destroy();\n\t\tthis._morphInstance = val;\n\t\tlet shaderDefs = this._shaderDefs;\n\t\tshaderDefs = val && val.morph.useTextureMorph ? shaderDefs | SHADERDEF_MORPH_TEXTURE_BASED : shaderDefs & ~SHADERDEF_MORPH_TEXTURE_BASED;\n\t\tshaderDefs = val && val.morph.morphPositions ? shaderDefs | SHADERDEF_MORPH_POSITION : shaderDefs & ~SHADERDEF_MORPH_POSITION;\n\t\tshaderDefs = val && val.morph.morphNormals ? shaderDefs | SHADERDEF_MORPH_NORMAL : shaderDefs & ~SHADERDEF_MORPH_NORMAL;\n\t\tthis._updateShaderDefs(shaderDefs);\n\t}\n\tget morphInstance() {\n\t\treturn this._morphInstance;\n\t}\n\tset screenSpace(val) {\n\t\tif (this._screenSpace !== val) {\n\t\t\tthis._screenSpace = val;\n\t\t\tthis._updateShaderDefs(val ? this._shaderDefs | SHADERDEF_SCREENSPACE : this._shaderDefs & ~SHADERDEF_SCREENSPACE);\n\t\t}\n\t}\n\tget screenSpace() {\n\t\treturn this._screenSpace;\n\t}\n\tset key(val) {\n\t\tthis._key[SORTKEY_FORWARD] = val;\n\t}\n\tget key() {\n\t\treturn this._key[SORTKEY_FORWARD];\n\t}\n\tset mask(val) {\n\t\tconst toggles = this._shaderDefs & 0x0000FFFF;\n\t\tthis._updateShaderDefs(toggles | val << 16);\n\t}\n\tget mask() {\n\t\treturn this._shaderDefs >> 16;\n\t}\n\tset instancingCount(value) {\n\t\tif (this.instancingData) {\n\t\t\tthis.instancingData.count = value;\n\t\t}\n\t}\n\tget instancingCount() {\n\t\treturn this.instancingData ? this.instancingData.count : 0;\n\t}\n\tdestroy() {\n\t\tvar _this$_skinInstance, _this$morphInstance;\n\t\tconst mesh = this.mesh;\n\t\tif (mesh) {\n\t\t\tthis.mesh = null;\n\t\t\tif (mesh.refCount < 1) {\n\t\t\t\tmesh.destroy();\n\t\t\t}\n\t\t}\n\t\tthis.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);\n\t\tthis.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);\n\t\t(_this$_skinInstance = this._skinInstance) == null || _this$_skinInstance.destroy();\n\t\tthis._skinInstance = null;\n\t\t(_this$morphInstance = this.morphInstance) == null || _this$morphInstance.destroy();\n\t\tthis.morphInstance = null;\n\t\tthis.clearShaders();\n\t\tthis.material = null;\n\t}\n\tstatic _prepareRenderStyleForArray(meshInstances, renderStyle) {\n\t\tif (meshInstances) {\n\t\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\t\tmeshInstances[i]._renderStyle = renderStyle;\n\t\t\t\tconst mesh = meshInstances[i].mesh;\n\t\t\t\tif (!_meshSet.has(mesh)) {\n\t\t\t\t\t_meshSet.add(mesh);\n\t\t\t\t\tmesh.prepareRenderState(renderStyle);\n\t\t\t\t}\n\t\t\t}\n\t\t\t_meshSet.clear();\n\t\t}\n\t}\n\t_isVisible(camera) {\n\t\tif (this.visible) {\n\t\t\tif (this.isVisibleFunc) {\n\t\t\t\treturn this.isVisibleFunc(camera);\n\t\t\t}\n\t\t\t_tempSphere.center = this.aabb.center;\n\t\t\t_tempSphere.radius = this._aabb.halfExtents.length();\n\t\t\treturn camera.frustum.containsSphere(_tempSphere);\n\t\t}\n\t\treturn false;\n\t}\n\tupdateKey() {\n\t\tconst material = this.material;\n\t\tconst blendType = material.alphaToCoverage || material.alphaTest ? BLEND_NORMAL : material.blendType;\n\t\tthis._key[SORTKEY_FORWARD] = (this.layer & 0x0f) << 27 | (blendType === BLEND_NONE ? 1 : 0) << 26 | (material.id & 0x1ffffff) << 0;\n\t}\n\tsetInstancing(vertexBuffer, cull = false) {\n\t\tif (vertexBuffer) {\n\t\t\tthis.instancingData = new InstancingData(vertexBuffer.numVertices);\n\t\t\tthis.instancingData.vertexBuffer = vertexBuffer;\n\t\t\tvertexBuffer.format.instancing = true;\n\t\t\tthis.cull = cull;\n\t\t} else {\n\t\t\tthis.instancingData = null;\n\t\t\tthis.cull = true;\n\t\t}\n\t\tthis._updateShaderDefs(vertexBuffer ? this._shaderDefs | SHADERDEF_INSTANCING : this._shaderDefs & ~SHADERDEF_INSTANCING);\n\t}\n\tensureMaterial(device) {\n\t\tif (!this.material) {\n\t\t\tthis.material = getDefaultMaterial(device);\n\t\t}\n\t}\n\tclearParameters() {\n\t\tthis.parameters = {};\n\t}\n\tgetParameters() {\n\t\treturn this.parameters;\n\t}\n\tgetParameter(name) {\n\t\treturn this.parameters[name];\n\t}\n\tsetParameter(name, data, passFlags = -262141) {\n\t\tif (data === undefined && typeof name === 'object') {\n\t\t\tconst uniformObject = name;\n\t\t\tif (uniformObject.length) {\n\t\t\t\tfor (let i = 0; i < uniformObject.length; i++) {\n\t\t\t\t\tthis.setParameter(uniformObject[i]);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tname = uniformObject.name;\n\t\t\tdata = uniformObject.value;\n\t\t}\n\t\tconst param = this.parameters[name];\n\t\tif (param) {\n\t\t\tparam.data = data;\n\t\t\tparam.passFlags = passFlags;\n\t\t} else {\n\t\t\tthis.parameters[name] = {\n\t\t\t\tscopeId: null,\n\t\t\t\tdata: data,\n\t\t\t\tpassFlags: passFlags\n\t\t\t};\n\t\t}\n\t}\n\tsetRealtimeLightmap(name, texture) {\n\t\tconst old = this.getParameter(name);\n\t\tif (old === texture) {\n\t\t\treturn;\n\t\t}\n\t\tif (old) {\n\t\t\tLightmapCache.decRef(old.data);\n\t\t}\n\t\tif (texture) {\n\t\t\tLightmapCache.incRef(texture);\n\t\t\tthis.setParameter(name, texture);\n\t\t} else {\n\t\t\tthis.deleteParameter(name);\n\t\t}\n\t}\n\tdeleteParameter(name) {\n\t\tif (this.parameters[name]) {\n\t\t\tdelete this.parameters[name];\n\t\t}\n\t}\n\tsetParameters(device, passFlag) {\n\t\tconst parameters = this.parameters;\n\t\tfor (const paramName in parameters) {\n\t\t\tconst parameter = parameters[paramName];\n\t\t\tif (parameter.passFlags & passFlag) {\n\t\t\t\tif (!parameter.scopeId) {\n\t\t\t\t\tparameter.scopeId = device.scope.resolve(paramName);\n\t\t\t\t}\n\t\t\t\tparameter.scopeId.setValue(parameter.data);\n\t\t\t}\n\t\t}\n\t}\n\tsetLightmapped(value) {\n\t\tif (value) {\n\t\t\tthis.mask = (this.mask | MASK_AFFECT_LIGHTMAPPED) & ~(MASK_AFFECT_DYNAMIC | MASK_BAKE);\n\t\t} else {\n\t\t\tthis.setRealtimeLightmap(MeshInstance.lightmapParamNames[0], null);\n\t\t\tthis.setRealtimeLightmap(MeshInstance.lightmapParamNames[1], null);\n\t\t\tthis._shaderDefs &= ~(SHADERDEF_LM | SHADERDEF_DIRLM | SHADERDEF_LMAMBIENT);\n\t\t\tthis.mask = (this.mask | MASK_AFFECT_DYNAMIC) & ~(MASK_AFFECT_LIGHTMAPPED | MASK_BAKE);\n\t\t}\n\t}\n\tsetCustomAabb(aabb) {\n\t\tif (aabb) {\n\t\t\tif (this._customAabb) {\n\t\t\t\tthis._customAabb.copy(aabb);\n\t\t\t} else {\n\t\t\t\tthis._customAabb = aabb.clone();\n\t\t\t}\n\t\t} else {\n\t\t\tthis._customAabb = null;\n\t\t\tthis._aabbVer = -1;\n\t\t}\n\t\tthis._setupSkinUpdate();\n\t}\n\t_setupSkinUpdate() {\n\t\tif (this._skinInstance) {\n\t\t\tthis._skinInstance._updateBeforeCull = !this._customAabb;\n\t\t}\n\t}\n}\nMeshInstance.lightmapParamNames = ['texture_lightMap', 'texture_dirLightMap'];\n\nexport { MeshInstance };\n","import { RefCountedObject } from '../core/ref-counted-object.js';\nimport { Vec3 } from '../core/math/vec3.js';\nimport { BoundingBox } from '../core/shape/bounding-box.js';\nimport { SEMANTIC_TANGENT, SEMANTIC_BLENDINDICES, TYPE_UINT8, SEMANTIC_BLENDWEIGHT, SEMANTIC_POSITION, TYPE_UINT16, TYPE_INT16, TYPE_INT8, BUFFER_STATIC, BUFFER_DYNAMIC, TYPE_FLOAT32, SEMANTIC_NORMAL, SEMANTIC_TEXCOORD, SEMANTIC_COLOR, PRIMITIVE_TRIANGLES, PRIMITIVE_POINTS, typedArrayIndexFormats, PRIMITIVE_LINES, INDEXFORMAT_UINT32, INDEXFORMAT_UINT16 } from '../platform/graphics/constants.js';\nimport { IndexBuffer } from '../platform/graphics/index-buffer.js';\nimport { VertexBuffer } from '../platform/graphics/vertex-buffer.js';\nimport { VertexFormat } from '../platform/graphics/vertex-format.js';\nimport { VertexIterator } from '../platform/graphics/vertex-iterator.js';\nimport { RENDERSTYLE_WIREFRAME, RENDERSTYLE_POINTS, RENDERSTYLE_SOLID } from './constants.js';\n\nlet id = 0;\nclass GeometryData {\n\tconstructor() {\n\t\tthis.initDefaults();\n\t}\n\tinitDefaults() {\n\t\tthis.recreate = false;\n\t\tthis.verticesUsage = BUFFER_STATIC;\n\t\tthis.indicesUsage = BUFFER_STATIC;\n\t\tthis.maxVertices = 0;\n\t\tthis.maxIndices = 0;\n\t\tthis.vertexCount = 0;\n\t\tthis.indexCount = 0;\n\t\tthis.vertexStreamsUpdated = false;\n\t\tthis.indexStreamUpdated = false;\n\t\tthis.vertexStreamDictionary = {};\n\t\tthis.indices = null;\n\t}\n\t_changeVertexCount(count, semantic) {\n\t\tif (!this.vertexCount) {\n\t\t\tthis.vertexCount = count;\n\t\t}\n\t}\n}\nGeometryData.DEFAULT_COMPONENTS_POSITION = 3;\nGeometryData.DEFAULT_COMPONENTS_NORMAL = 3;\nGeometryData.DEFAULT_COMPONENTS_UV = 2;\nGeometryData.DEFAULT_COMPONENTS_COLORS = 4;\nclass GeometryVertexStream {\n\tconstructor(data, componentCount, dataType, dataTypeNormalize, asInt) {\n\t\tthis.data = data;\n\t\tthis.componentCount = componentCount;\n\t\tthis.dataType = dataType;\n\t\tthis.dataTypeNormalize = dataTypeNormalize;\n\t\tthis.asInt = asInt;\n\t}\n}\nclass Mesh extends RefCountedObject {\n\tconstructor(graphicsDevice, options) {\n\t\tsuper();\n\t\tthis._aabbVer = 0;\n\t\tthis._aabb = new BoundingBox();\n\t\tthis._storageVertex = false;\n\t\tthis._storageIndex = false;\n\t\tthis.id = id++;\n\t\tthis.device = graphicsDevice;\n\t\tthis._storageIndex = (options == null ? void 0 : options.storageIndex) || false;\n\t\tthis._storageVertex = (options == null ? void 0 : options.storageVertex) || false;\n\t\tthis.vertexBuffer = null;\n\t\tthis.indexBuffer = [null];\n\t\tthis.primitive = [{\n\t\t\ttype: 0,\n\t\t\tbase: 0,\n\t\t\tcount: 0\n\t\t}];\n\t\tthis.skin = null;\n\t\tthis._morph = null;\n\t\tthis._geometryData = null;\n\t\tthis.boneAabb = null;\n\t}\n\tstatic fromGeometry(graphicsDevice, geometry, options = {}) {\n\t\tconst mesh = new Mesh(graphicsDevice, options);\n\t\tconst {\n\t\t\tpositions,\n\t\t\tnormals,\n\t\t\ttangents,\n\t\t\tcolors,\n\t\t\tuvs,\n\t\t\tuvs1,\n\t\t\tblendIndices,\n\t\t\tblendWeights,\n\t\t\tindices\n\t\t} = geometry;\n\t\tif (positions) {\n\t\t\tmesh.setPositions(positions);\n\t\t}\n\t\tif (normals) {\n\t\t\tmesh.setNormals(normals);\n\t\t}\n\t\tif (tangents) {\n\t\t\tmesh.setVertexStream(SEMANTIC_TANGENT, tangents, 4);\n\t\t}\n\t\tif (colors) {\n\t\t\tmesh.setColors32(colors);\n\t\t}\n\t\tif (uvs) {\n\t\t\tmesh.setUvs(0, uvs);\n\t\t}\n\t\tif (uvs1) {\n\t\t\tmesh.setUvs(1, uvs1);\n\t\t}\n\t\tif (blendIndices) {\n\t\t\tmesh.setVertexStream(SEMANTIC_BLENDINDICES, blendIndices, 4, blendIndices.length / 4, TYPE_UINT8);\n\t\t}\n\t\tif (blendWeights) {\n\t\t\tmesh.setVertexStream(SEMANTIC_BLENDWEIGHT, blendWeights, 4);\n\t\t}\n\t\tif (indices) {\n\t\t\tmesh.setIndices(indices);\n\t\t}\n\t\tmesh.update();\n\t\treturn mesh;\n\t}\n\tset morph(morph) {\n\t\tif (morph !== this._morph) {\n\t\t\tif (this._morph) {\n\t\t\t\tthis._morph.decRefCount();\n\t\t\t}\n\t\t\tthis._morph = morph;\n\t\t\tif (morph) {\n\t\t\t\tmorph.incRefCount();\n\t\t\t}\n\t\t}\n\t}\n\tget morph() {\n\t\treturn this._morph;\n\t}\n\tset aabb(aabb) {\n\t\tthis._aabb = aabb;\n\t\tthis._aabbVer++;\n\t}\n\tget aabb() {\n\t\treturn this._aabb;\n\t}\n\tdestroy() {\n\t\tconst morph = this.morph;\n\t\tif (morph) {\n\t\t\tthis.morph = null;\n\t\t\tif (morph.refCount < 1) {\n\t\t\t\tmorph.destroy();\n\t\t\t}\n\t\t}\n\t\tif (this.vertexBuffer) {\n\t\t\tthis.vertexBuffer.destroy();\n\t\t\tthis.vertexBuffer = null;\n\t\t}\n\t\tfor (let j = 0; j < this.indexBuffer.length; j++) {\n\t\t\tthis._destroyIndexBuffer(j);\n\t\t}\n\t\tthis.indexBuffer.length = 0;\n\t\tthis._geometryData = null;\n\t}\n\t_destroyIndexBuffer(index) {\n\t\tif (this.indexBuffer[index]) {\n\t\t\tthis.indexBuffer[index].destroy();\n\t\t\tthis.indexBuffer[index] = null;\n\t\t}\n\t}\n\t_initBoneAabbs(morphTargets) {\n\t\tthis.boneAabb = [];\n\t\tthis.boneUsed = [];\n\t\tlet x, y, z;\n\t\tlet bMax, bMin;\n\t\tconst boneMin = [];\n\t\tconst boneMax = [];\n\t\tconst boneUsed = this.boneUsed;\n\t\tconst numBones = this.skin.boneNames.length;\n\t\tlet maxMorphX, maxMorphY, maxMorphZ;\n\t\tfor (let i = 0; i < numBones; i++) {\n\t\t\tboneMin[i] = new Vec3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n\t\t\tboneMax[i] = new Vec3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n\t\t}\n\t\tconst iterator = new VertexIterator(this.vertexBuffer);\n\t\tconst posElement = iterator.element[SEMANTIC_POSITION];\n\t\tconst weightsElement = iterator.element[SEMANTIC_BLENDWEIGHT];\n\t\tconst indicesElement = iterator.element[SEMANTIC_BLENDINDICES];\n\t\tconst numVerts = this.vertexBuffer.numVertices;\n\t\tfor (let j = 0; j < numVerts; j++) {\n\t\t\tfor (let k = 0; k < 4; k++) {\n\t\t\t\tconst boneWeight = weightsElement.array[weightsElement.index + k];\n\t\t\t\tif (boneWeight > 0) {\n\t\t\t\t\tconst boneIndex = indicesElement.array[indicesElement.index + k];\n\t\t\t\t\tboneUsed[boneIndex] = true;\n\t\t\t\t\tx = posElement.array[posElement.index];\n\t\t\t\t\ty = posElement.array[posElement.index + 1];\n\t\t\t\t\tz = posElement.array[posElement.index + 2];\n\t\t\t\t\tbMax = boneMax[boneIndex];\n\t\t\t\t\tbMin = boneMin[boneIndex];\n\t\t\t\t\tif (bMin.x > x) bMin.x = x;\n\t\t\t\t\tif (bMin.y > y) bMin.y = y;\n\t\t\t\t\tif (bMin.z > z) bMin.z = z;\n\t\t\t\t\tif (bMax.x < x) bMax.x = x;\n\t\t\t\t\tif (bMax.y < y) bMax.y = y;\n\t\t\t\t\tif (bMax.z < z) bMax.z = z;\n\t\t\t\t\tif (morphTargets) {\n\t\t\t\t\t\tlet minMorphX = maxMorphX = x;\n\t\t\t\t\t\tlet minMorphY = maxMorphY = y;\n\t\t\t\t\t\tlet minMorphZ = maxMorphZ = z;\n\t\t\t\t\t\tfor (let l = 0; l < morphTargets.length; l++) {\n\t\t\t\t\t\t\tconst target = morphTargets[l];\n\t\t\t\t\t\t\tconst dx = target.deltaPositions[j * 3];\n\t\t\t\t\t\t\tconst dy = target.deltaPositions[j * 3 + 1];\n\t\t\t\t\t\t\tconst dz = target.deltaPositions[j * 3 + 2];\n\t\t\t\t\t\t\tif (dx < 0) {\n\t\t\t\t\t\t\t\tminMorphX += dx;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmaxMorphX += dx;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (dy < 0) {\n\t\t\t\t\t\t\t\tminMorphY += dy;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmaxMorphY += dy;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (dz < 0) {\n\t\t\t\t\t\t\t\tminMorphZ += dz;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tmaxMorphZ += dz;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (bMin.x > minMorphX) bMin.x = minMorphX;\n\t\t\t\t\t\tif (bMin.y > minMorphY) bMin.y = minMorphY;\n\t\t\t\t\t\tif (bMin.z > minMorphZ) bMin.z = minMorphZ;\n\t\t\t\t\t\tif (bMax.x < maxMorphX) bMax.x = maxMorphX;\n\t\t\t\t\t\tif (bMax.y < maxMorphY) bMax.y = maxMorphY;\n\t\t\t\t\t\tif (bMax.z < maxMorphZ) bMax.z = maxMorphZ;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\titerator.next();\n\t\t}\n\t\tconst positionElement = this.vertexBuffer.getFormat().elements.find(e => e.name === SEMANTIC_POSITION);\n\t\tif (positionElement && positionElement.normalize) {\n\t\t\tconst func = (() => {\n\t\t\t\tswitch (positionElement.dataType) {\n\t\t\t\t\tcase TYPE_INT8:\n\t\t\t\t\t\treturn x => Math.max(x / 127.0, -1.0);\n\t\t\t\t\tcase TYPE_UINT8:\n\t\t\t\t\t\treturn x => x / 255.0;\n\t\t\t\t\tcase TYPE_INT16:\n\t\t\t\t\t\treturn x => Math.max(x / 32767.0, -1.0);\n\t\t\t\t\tcase TYPE_UINT16:\n\t\t\t\t\t\treturn x => x / 65535.0;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\treturn x => x;\n\t\t\t\t}\n\t\t\t})();\n\t\t\tfor (let i = 0; i < numBones; i++) {\n\t\t\t\tif (boneUsed[i]) {\n\t\t\t\t\tconst min = boneMin[i];\n\t\t\t\t\tconst max = boneMax[i];\n\t\t\t\t\tmin.set(func(min.x), func(min.y), func(min.z));\n\t\t\t\t\tmax.set(func(max.x), func(max.y), func(max.z));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < numBones; i++) {\n\t\t\tconst aabb = new BoundingBox();\n\t\t\taabb.setMinMax(boneMin[i], boneMax[i]);\n\t\t\tthis.boneAabb.push(aabb);\n\t\t}\n\t}\n\t_initGeometryData() {\n\t\tif (!this._geometryData) {\n\t\t\tthis._geometryData = new GeometryData();\n\t\t\tif (this.vertexBuffer) {\n\t\t\t\tthis._geometryData.vertexCount = this.vertexBuffer.numVertices;\n\t\t\t\tthis._geometryData.maxVertices = this.vertexBuffer.numVertices;\n\t\t\t}\n\t\t\tif (this.indexBuffer.length > 0 && this.indexBuffer[0]) {\n\t\t\t\tthis._geometryData.indexCount = this.indexBuffer[0].numIndices;\n\t\t\t\tthis._geometryData.maxIndices = this.indexBuffer[0].numIndices;\n\t\t\t}\n\t\t}\n\t}\n\tclear(verticesDynamic, indicesDynamic, maxVertices = 0, maxIndices = 0) {\n\t\tthis._initGeometryData();\n\t\tthis._geometryData.initDefaults();\n\t\tthis._geometryData.recreate = true;\n\t\tthis._geometryData.maxVertices = maxVertices;\n\t\tthis._geometryData.maxIndices = maxIndices;\n\t\tthis._geometryData.verticesUsage = verticesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;\n\t\tthis._geometryData.indicesUsage = indicesDynamic ? BUFFER_STATIC : BUFFER_DYNAMIC;\n\t}\n\tsetVertexStream(semantic, data, componentCount, numVertices, dataType = TYPE_FLOAT32, dataTypeNormalize = false, asInt = false) {\n\t\tthis._initGeometryData();\n\t\tconst vertexCount = numVertices || data.length / componentCount;\n\t\tthis._geometryData._changeVertexCount(vertexCount, semantic);\n\t\tthis._geometryData.vertexStreamsUpdated = true;\n\t\tthis._geometryData.vertexStreamDictionary[semantic] = new GeometryVertexStream(data, componentCount, dataType, dataTypeNormalize, asInt);\n\t}\n\tgetVertexStream(semantic, data) {\n\t\tlet count = 0;\n\t\tlet done = false;\n\t\tif (this._geometryData) {\n\t\t\tconst stream = this._geometryData.vertexStreamDictionary[semantic];\n\t\t\tif (stream) {\n\t\t\t\tdone = true;\n\t\t\t\tcount = this._geometryData.vertexCount;\n\t\t\t\tif (ArrayBuffer.isView(data)) {\n\t\t\t\t\tdata.set(stream.data);\n\t\t\t\t} else {\n\t\t\t\t\tdata.length = 0;\n\t\t\t\t\tdata.push(stream.data);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!done) {\n\t\t\tif (this.vertexBuffer) {\n\t\t\t\tconst iterator = new VertexIterator(this.vertexBuffer);\n\t\t\t\tcount = iterator.readData(semantic, data);\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tsetPositions(positions, componentCount = GeometryData.DEFAULT_COMPONENTS_POSITION, numVertices) {\n\t\tthis.setVertexStream(SEMANTIC_POSITION, positions, componentCount, numVertices, TYPE_FLOAT32, false);\n\t}\n\tsetNormals(normals, componentCount = GeometryData.DEFAULT_COMPONENTS_NORMAL, numVertices) {\n\t\tthis.setVertexStream(SEMANTIC_NORMAL, normals, componentCount, numVertices, TYPE_FLOAT32, false);\n\t}\n\tsetUvs(channel, uvs, componentCount = GeometryData.DEFAULT_COMPONENTS_UV, numVertices) {\n\t\tthis.setVertexStream(SEMANTIC_TEXCOORD + channel, uvs, componentCount, numVertices, TYPE_FLOAT32, false);\n\t}\n\tsetColors(colors, componentCount = GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices) {\n\t\tthis.setVertexStream(SEMANTIC_COLOR, colors, componentCount, numVertices, TYPE_FLOAT32, false);\n\t}\n\tsetColors32(colors, numVertices) {\n\t\tthis.setVertexStream(SEMANTIC_COLOR, colors, GeometryData.DEFAULT_COMPONENTS_COLORS, numVertices, TYPE_UINT8, true);\n\t}\n\tsetIndices(indices, numIndices) {\n\t\tthis._initGeometryData();\n\t\tthis._geometryData.indexStreamUpdated = true;\n\t\tthis._geometryData.indices = indices;\n\t\tthis._geometryData.indexCount = numIndices || indices.length;\n\t}\n\tgetPositions(positions) {\n\t\treturn this.getVertexStream(SEMANTIC_POSITION, positions);\n\t}\n\tgetNormals(normals) {\n\t\treturn this.getVertexStream(SEMANTIC_NORMAL, normals);\n\t}\n\tgetUvs(channel, uvs) {\n\t\treturn this.getVertexStream(SEMANTIC_TEXCOORD + channel, uvs);\n\t}\n\tgetColors(colors) {\n\t\treturn this.getVertexStream(SEMANTIC_COLOR, colors);\n\t}\n\tgetIndices(indices) {\n\t\tlet count = 0;\n\t\tif (this._geometryData && this._geometryData.indices) {\n\t\t\tconst streamIndices = this._geometryData.indices;\n\t\t\tcount = this._geometryData.indexCount;\n\t\t\tif (ArrayBuffer.isView(indices)) {\n\t\t\t\tindices.set(streamIndices);\n\t\t\t} else {\n\t\t\t\tindices.length = 0;\n\t\t\t\tfor (let i = 0, il = streamIndices.length; i < il; i++) {\n\t\t\t\t\tindices.push(streamIndices[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (this.indexBuffer.length > 0 && this.indexBuffer[0]) {\n\t\t\t\tconst indexBuffer = this.indexBuffer[0];\n\t\t\t\tcount = indexBuffer.readData(indices);\n\t\t\t}\n\t\t}\n\t\treturn count;\n\t}\n\tupdate(primitiveType = PRIMITIVE_TRIANGLES, updateBoundingBox = true) {\n\t\tif (this._geometryData) {\n\t\t\tif (updateBoundingBox) {\n\t\t\t\tconst stream = this._geometryData.vertexStreamDictionary[SEMANTIC_POSITION];\n\t\t\t\tif (stream) {\n\t\t\t\t\tif (stream.componentCount === 3) {\n\t\t\t\t\t\tthis._aabb.compute(stream.data, this._geometryData.vertexCount);\n\t\t\t\t\t\tthis._aabbVer++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet destroyVB = this._geometryData.recreate;\n\t\t\tif (this._geometryData.vertexCount > this._geometryData.maxVertices) {\n\t\t\t\tdestroyVB = true;\n\t\t\t\tthis._geometryData.maxVertices = this._geometryData.vertexCount;\n\t\t\t}\n\t\t\tif (destroyVB) {\n\t\t\t\tif (this.vertexBuffer) {\n\t\t\t\t\tthis.vertexBuffer.destroy();\n\t\t\t\t\tthis.vertexBuffer = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet destroyIB = this._geometryData.recreate;\n\t\t\tif (this._geometryData.indexCount > this._geometryData.maxIndices) {\n\t\t\t\tdestroyIB = true;\n\t\t\t\tthis._geometryData.maxIndices = this._geometryData.indexCount;\n\t\t\t}\n\t\t\tif (destroyIB) {\n\t\t\t\tif (this.indexBuffer.length > 0 && this.indexBuffer[0]) {\n\t\t\t\t\tthis.indexBuffer[0].destroy();\n\t\t\t\t\tthis.indexBuffer[0] = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._geometryData.vertexStreamsUpdated) {\n\t\t\t\tthis._updateVertexBuffer();\n\t\t\t}\n\t\t\tif (this._geometryData.indexStreamUpdated) {\n\t\t\t\tthis._updateIndexBuffer();\n\t\t\t}\n\t\t\tthis.primitive[0].type = primitiveType;\n\t\t\tif (this.indexBuffer.length > 0 && this.indexBuffer[0]) {\n\t\t\t\tif (this._geometryData.indexStreamUpdated) {\n\t\t\t\t\tthis.primitive[0].count = this._geometryData.indexCount;\n\t\t\t\t\tthis.primitive[0].indexed = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (this._geometryData.vertexStreamsUpdated) {\n\t\t\t\t\tthis.primitive[0].count = this._geometryData.vertexCount;\n\t\t\t\t\tthis.primitive[0].indexed = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._geometryData.vertexCount = 0;\n\t\t\tthis._geometryData.indexCount = 0;\n\t\t\tthis._geometryData.vertexStreamsUpdated = false;\n\t\t\tthis._geometryData.indexStreamUpdated = false;\n\t\t\tthis._geometryData.recreate = false;\n\t\t\tthis.updateRenderStates();\n\t\t}\n\t}\n\t_buildVertexFormat(vertexCount) {\n\t\tconst vertexDesc = [];\n\t\tfor (const semantic in this._geometryData.vertexStreamDictionary) {\n\t\t\tconst stream = this._geometryData.vertexStreamDictionary[semantic];\n\t\t\tvertexDesc.push({\n\t\t\t\tsemantic: semantic,\n\t\t\t\tcomponents: stream.componentCount,\n\t\t\t\ttype: stream.dataType,\n\t\t\t\tnormalize: stream.dataTypeNormalize,\n\t\t\t\tasInt: stream.asInt\n\t\t\t});\n\t\t}\n\t\treturn new VertexFormat(this.device, vertexDesc, vertexCount);\n\t}\n\t_updateVertexBuffer() {\n\t\tif (!this.vertexBuffer) {\n\t\t\tconst allocateVertexCount = this._geometryData.maxVertices;\n\t\t\tconst format = this._buildVertexFormat(allocateVertexCount);\n\t\t\tthis.vertexBuffer = new VertexBuffer(this.device, format, allocateVertexCount, {\n\t\t\t\tusage: this._geometryData.verticesUsage,\n\t\t\t\tstorage: this._storageVertex\n\t\t\t});\n\t\t}\n\t\tconst iterator = new VertexIterator(this.vertexBuffer);\n\t\tconst numVertices = this._geometryData.vertexCount;\n\t\tfor (const semantic in this._geometryData.vertexStreamDictionary) {\n\t\t\tconst stream = this._geometryData.vertexStreamDictionary[semantic];\n\t\t\titerator.writeData(semantic, stream.data, numVertices);\n\t\t\tdelete this._geometryData.vertexStreamDictionary[semantic];\n\t\t}\n\t\titerator.end();\n\t}\n\t_updateIndexBuffer() {\n\t\tif (this.indexBuffer.length <= 0 || !this.indexBuffer[0]) {\n\t\t\tconst maxVertices = this._geometryData.maxVertices;\n\t\t\tconst createFormat = maxVertices > 0xffff || maxVertices === 0 ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;\n\t\t\tconst options = this._storageIndex ? {\n\t\t\t\tstorage: true\n\t\t\t} : undefined;\n\t\t\tthis.indexBuffer[0] = new IndexBuffer(this.device, createFormat, this._geometryData.maxIndices, this._geometryData.indicesUsage, undefined, options);\n\t\t}\n\t\tconst srcIndices = this._geometryData.indices;\n\t\tif (srcIndices) {\n\t\t\tconst indexBuffer = this.indexBuffer[0];\n\t\t\tindexBuffer.writeData(srcIndices, this._geometryData.indexCount);\n\t\t\tthis._geometryData.indices = null;\n\t\t}\n\t}\n\tprepareRenderState(renderStyle) {\n\t\tif (renderStyle === RENDERSTYLE_WIREFRAME) {\n\t\t\tthis.generateWireframe();\n\t\t} else if (renderStyle === RENDERSTYLE_POINTS) {\n\t\t\tthis.primitive[RENDERSTYLE_POINTS] = {\n\t\t\t\ttype: PRIMITIVE_POINTS,\n\t\t\t\tbase: 0,\n\t\t\t\tcount: this.vertexBuffer ? this.vertexBuffer.numVertices : 0,\n\t\t\t\tindexed: false\n\t\t\t};\n\t\t}\n\t}\n\tupdateRenderStates() {\n\t\tif (this.primitive[RENDERSTYLE_POINTS]) {\n\t\t\tthis.prepareRenderState(RENDERSTYLE_POINTS);\n\t\t}\n\t\tif (this.primitive[RENDERSTYLE_WIREFRAME]) {\n\t\t\tthis.prepareRenderState(RENDERSTYLE_WIREFRAME);\n\t\t}\n\t}\n\tgenerateWireframe() {\n\t\tthis._destroyIndexBuffer(RENDERSTYLE_WIREFRAME);\n\t\tconst numVertices = this.vertexBuffer.numVertices;\n\t\tconst lines = [];\n\t\tlet format;\n\t\tif (this.indexBuffer.length > 0 && this.indexBuffer[0]) {\n\t\t\tconst offsets = [[0, 1], [1, 2], [2, 0]];\n\t\t\tconst base = this.primitive[RENDERSTYLE_SOLID].base;\n\t\t\tconst count = this.primitive[RENDERSTYLE_SOLID].count;\n\t\t\tconst indexBuffer = this.indexBuffer[RENDERSTYLE_SOLID];\n\t\t\tconst srcIndices = new typedArrayIndexFormats[indexBuffer.format](indexBuffer.storage);\n\t\t\tconst seen = new Set();\n\t\t\tfor (let j = base; j < base + count; j += 3) {\n\t\t\t\tfor (let k = 0; k < 3; k++) {\n\t\t\t\t\tconst i1 = srcIndices[j + offsets[k][0]];\n\t\t\t\t\tconst i2 = srcIndices[j + offsets[k][1]];\n\t\t\t\t\tconst hash = i1 > i2 ? i2 * numVertices + i1 : i1 * numVertices + i2;\n\t\t\t\t\tif (!seen.has(hash)) {\n\t\t\t\t\t\tseen.add(hash);\n\t\t\t\t\t\tlines.push(i1, i2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tformat = indexBuffer.format;\n\t\t} else {\n\t\t\tfor (let i = 0; i < numVertices; i += 3) {\n\t\t\t\tlines.push(i, i + 1, i + 1, i + 2, i + 2, i);\n\t\t\t}\n\t\t\tformat = lines.length > 65535 ? INDEXFORMAT_UINT32 : INDEXFORMAT_UINT16;\n\t\t}\n\t\tconst wireBuffer = new IndexBuffer(this.vertexBuffer.device, format, lines.length);\n\t\tconst dstIndices = new typedArrayIndexFormats[wireBuffer.format](wireBuffer.storage);\n\t\tdstIndices.set(lines);\n\t\twireBuffer.unlock();\n\t\tthis.primitive[RENDERSTYLE_WIREFRAME] = {\n\t\t\ttype: PRIMITIVE_LINES,\n\t\t\tbase: 0,\n\t\t\tcount: lines.length,\n\t\t\tindexed: true\n\t\t};\n\t\tthis.indexBuffer[RENDERSTYLE_WIREFRAME] = wireBuffer;\n\t}\n}\n\nexport { Mesh };\n","import { RENDERSTYLE_WIREFRAME } from './constants.js';\nimport { MeshInstance } from './mesh-instance.js';\nimport { MorphInstance } from './morph-instance.js';\nimport { SkinInstance } from './skin-instance.js';\n\nclass Model {\n\tconstructor() {\n\t\tthis.graph = null;\n\t\tthis.meshInstances = [];\n\t\tthis.skinInstances = [];\n\t\tthis.morphInstances = [];\n\t\tthis.cameras = [];\n\t\tthis.lights = [];\n\t\tthis._shadersVersion = 0;\n\t\tthis._immutable = false;\n\t}\n\tgetGraph() {\n\t\treturn this.graph;\n\t}\n\tsetGraph(graph) {\n\t\tthis.graph = graph;\n\t}\n\tgetCameras() {\n\t\treturn this.cameras;\n\t}\n\tsetCameras(cameras) {\n\t\tthis.cameras = cameras;\n\t}\n\tgetLights() {\n\t\treturn this.lights;\n\t}\n\tsetLights(lights) {\n\t\tthis.lights = lights;\n\t}\n\tgetMaterials() {\n\t\tconst materials = [];\n\t\tfor (let i = 0; i < this.meshInstances.length; i++) {\n\t\t\tconst meshInstance = this.meshInstances[i];\n\t\t\tif (materials.indexOf(meshInstance.material) === -1) {\n\t\t\t\tmaterials.push(meshInstance.material);\n\t\t\t}\n\t\t}\n\t\treturn materials;\n\t}\n\tclone() {\n\t\tconst srcNodes = [];\n\t\tconst cloneNodes = [];\n\t\tconst _duplicate = function _duplicate(node) {\n\t\t\tconst newNode = node.clone();\n\t\t\tsrcNodes.push(node);\n\t\t\tcloneNodes.push(newNode);\n\t\t\tfor (let idx = 0; idx < node._children.length; idx++) {\n\t\t\t\tnewNode.addChild(_duplicate(node._children[idx]));\n\t\t\t}\n\t\t\treturn newNode;\n\t\t};\n\t\tconst cloneGraph = _duplicate(this.graph);\n\t\tconst cloneMeshInstances = [];\n\t\tconst cloneSkinInstances = [];\n\t\tconst cloneMorphInstances = [];\n\t\tfor (let i = 0; i < this.skinInstances.length; i++) {\n\t\t\tconst skin = this.skinInstances[i].skin;\n\t\t\tconst cloneSkinInstance = new SkinInstance(skin);\n\t\t\tconst bones = [];\n\t\t\tfor (let j = 0; j < skin.boneNames.length; j++) {\n\t\t\t\tconst boneName = skin.boneNames[j];\n\t\t\t\tconst bone = cloneGraph.findByName(boneName);\n\t\t\t\tbones.push(bone);\n\t\t\t}\n\t\t\tcloneSkinInstance.bones = bones;\n\t\t\tcloneSkinInstances.push(cloneSkinInstance);\n\t\t}\n\t\tfor (let i = 0; i < this.morphInstances.length; i++) {\n\t\t\tconst morph = this.morphInstances[i].morph;\n\t\t\tconst cloneMorphInstance = new MorphInstance(morph);\n\t\t\tcloneMorphInstances.push(cloneMorphInstance);\n\t\t}\n\t\tfor (let i = 0; i < this.meshInstances.length; i++) {\n\t\t\tconst meshInstance = this.meshInstances[i];\n\t\t\tconst nodeIndex = srcNodes.indexOf(meshInstance.node);\n\t\t\tconst cloneMeshInstance = new MeshInstance(meshInstance.mesh, meshInstance.material, cloneNodes[nodeIndex]);\n\t\t\tif (meshInstance.skinInstance) {\n\t\t\t\tconst skinInstanceIndex = this.skinInstances.indexOf(meshInstance.skinInstance);\n\t\t\t\tcloneMeshInstance.skinInstance = cloneSkinInstances[skinInstanceIndex];\n\t\t\t}\n\t\t\tif (meshInstance.morphInstance) {\n\t\t\t\tconst morphInstanceIndex = this.morphInstances.indexOf(meshInstance.morphInstance);\n\t\t\t\tcloneMeshInstance.morphInstance = cloneMorphInstances[morphInstanceIndex];\n\t\t\t}\n\t\t\tcloneMeshInstances.push(cloneMeshInstance);\n\t\t}\n\t\tconst clone = new Model();\n\t\tclone.graph = cloneGraph;\n\t\tclone.meshInstances = cloneMeshInstances;\n\t\tclone.skinInstances = cloneSkinInstances;\n\t\tclone.morphInstances = cloneMorphInstances;\n\t\tclone.getGraph().syncHierarchy();\n\t\treturn clone;\n\t}\n\tdestroy() {\n\t\tconst meshInstances = this.meshInstances;\n\t\tfor (let i = 0; i < meshInstances.length; i++) {\n\t\t\tmeshInstances[i].destroy();\n\t\t}\n\t\tthis.meshInstances.length = 0;\n\t}\n\tgenerateWireframe() {\n\t\tMeshInstance._prepareRenderStyleForArray(this.meshInstances, RENDERSTYLE_WIREFRAME);\n\t}\n}\n\nexport { Model };\n","import { BLENDEQUATION_ADD, BLENDMODE_ONE } from '../platform/graphics/constants.js';\nimport { drawQuadWithShader } from './graphics/quad-render-utils.js';\nimport { RenderTarget } from '../platform/graphics/render-target.js';\nimport { createShaderFromCode } from './shader-lib/utils.js';\nimport { BlendState } from '../platform/graphics/blend-state.js';\n\nconst textureMorphVertexShader = `\n\tattribute vec2 vertex_position;\n\tvarying vec2 uv0;\n\tvoid main(void) {\n\t\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\t\tuv0 = vertex_position.xy * 0.5 + 0.5;\n\t}\n\t`;\nconst blendStateAdditive = new BlendState(true, BLENDEQUATION_ADD, BLENDMODE_ONE, BLENDMODE_ONE);\nclass MorphInstance {\n\tconstructor(morph) {\n\t\tthis.morph = morph;\n\t\tmorph.incRefCount();\n\t\tthis.device = morph.device;\n\t\tthis._weights = [];\n\t\tthis._weightMap = new Map();\n\t\tfor (let v = 0; v < morph._targets.length; v++) {\n\t\t\tconst target = morph._targets[v];\n\t\t\tif (target.name) {\n\t\t\t\tthis._weightMap.set(target.name, v);\n\t\t\t}\n\t\t\tthis.setWeight(v, target.defaultWeight);\n\t\t}\n\t\tthis._activeTargets = [];\n\t\tif (morph.useTextureMorph) {\n\t\t\tthis.shaderCache = {};\n\t\t\tthis.maxSubmitCount = this.device.maxTextures;\n\t\t\tthis._shaderMorphWeights = new Float32Array(this.maxSubmitCount);\n\t\t\tconst createRT = (name, textureVar) => {\n\t\t\t\tthis[textureVar] = morph._createTexture(name, morph._renderTextureFormat);\n\t\t\t\treturn new RenderTarget({\n\t\t\t\t\tcolorBuffer: this[textureVar],\n\t\t\t\t\tdepth: false\n\t\t\t\t});\n\t\t\t};\n\t\t\tif (morph.morphPositions) {\n\t\t\t\tthis.rtPositions = createRT('MorphRTPos', 'texturePositions');\n\t\t\t}\n\t\t\tif (morph.morphNormals) {\n\t\t\t\tthis.rtNormals = createRT('MorphRTNrm', 'textureNormals');\n\t\t\t}\n\t\t\tthis._textureParams = new Float32Array([morph.morphTextureWidth, morph.morphTextureHeight, 1 / morph.morphTextureWidth, 1 / morph.morphTextureHeight]);\n\t\t\tfor (let i = 0; i < this.maxSubmitCount; i++) {\n\t\t\t\tthis[`morphBlendTex${i}`] = this.device.scope.resolve(`morphBlendTex${i}`);\n\t\t\t}\n\t\t\tthis.morphFactor = this.device.scope.resolve('morphFactor[0]');\n\t\t\tthis.zeroTextures = false;\n\t\t} else {\n\t\t\tthis.maxSubmitCount = 8;\n\t\t\tthis._shaderMorphWeights = new Float32Array(this.maxSubmitCount);\n\t\t\tthis._shaderMorphWeightsA = new Float32Array(this._shaderMorphWeights.buffer, 0, 4);\n\t\t\tthis._shaderMorphWeightsB = new Float32Array(this._shaderMorphWeights.buffer, 4 * 4, 4);\n\t\t\tthis._activeVertexBuffers = new Array(this.maxSubmitCount);\n\t\t}\n\t}\n\tdestroy() {\n\t\tthis.shader = null;\n\t\tconst morph = this.morph;\n\t\tif (morph) {\n\t\t\tthis.morph = null;\n\t\t\tmorph.decRefCount();\n\t\t\tif (morph.refCount < 1) {\n\t\t\t\tmorph.destroy();\n\t\t\t}\n\t\t}\n\t\tif (this.rtPositions) {\n\t\t\tthis.rtPositions.destroy();\n\t\t\tthis.rtPositions = null;\n\t\t}\n\t\tif (this.texturePositions) {\n\t\t\tthis.texturePositions.destroy();\n\t\t\tthis.texturePositions = null;\n\t\t}\n\t\tif (this.rtNormals) {\n\t\t\tthis.rtNormals.destroy();\n\t\t\tthis.rtNormals = null;\n\t\t}\n\t\tif (this.textureNormals) {\n\t\t\tthis.textureNormals.destroy();\n\t\t\tthis.textureNormals = null;\n\t\t}\n\t}\n\tclone() {\n\t\treturn new MorphInstance(this.morph);\n\t}\n\t_getWeightIndex(key) {\n\t\tif (typeof key === 'string') {\n\t\t\tconst index = this._weightMap.get(key);\n\t\t\treturn index;\n\t\t}\n\t\treturn key;\n\t}\n\tgetWeight(key) {\n\t\tconst index = this._getWeightIndex(key);\n\t\treturn this._weights[index];\n\t}\n\tsetWeight(key, weight) {\n\t\tconst index = this._getWeightIndex(key);\n\t\tthis._weights[index] = weight;\n\t\tthis._dirty = true;\n\t}\n\t_getFragmentShader(numTextures) {\n\t\tlet fragmentShader = '';\n\t\tif (numTextures > 0) {\n\t\t\tfragmentShader += 'varying vec2 uv0;\\n' + `uniform highp float morphFactor[${numTextures}];\\n`;\n\t\t}\n\t\tfor (let i = 0; i < numTextures; i++) {\n\t\t\tfragmentShader += `uniform highp sampler2D morphBlendTex${i};\\n`;\n\t\t}\n\t\tfragmentShader += 'void main (void) {\\n' + '    highp vec4 color = vec4(0, 0, 0, 1);\\n';\n\t\tfor (let i = 0; i < numTextures; i++) {\n\t\t\tfragmentShader += `    color.xyz += morphFactor[${i}] * texture2D(morphBlendTex${i}, uv0).xyz;\\n`;\n\t\t}\n\t\tfragmentShader += '    gl_FragColor = color;\\n' + '}\\n';\n\t\treturn fragmentShader;\n\t}\n\t_getShader(count) {\n\t\tlet shader = this.shaderCache[count];\n\t\tif (!shader) {\n\t\t\tconst fs = this._getFragmentShader(count);\n\t\t\tshader = createShaderFromCode(this.device, textureMorphVertexShader, fs, `textureMorph${count}`);\n\t\t\tthis.shaderCache[count] = shader;\n\t\t}\n\t\treturn shader;\n\t}\n\t_updateTextureRenderTarget(renderTarget, srcTextureName) {\n\t\tconst device = this.device;\n\t\tconst submitBatch = (usedCount, blending) => {\n\t\t\tthis.morphFactor.setValue(this._shaderMorphWeights);\n\t\t\tdevice.setBlendState(blending ? blendStateAdditive : BlendState.NOBLEND);\n\t\t\tconst shader = this._getShader(usedCount);\n\t\t\tdrawQuadWithShader(device, renderTarget, shader);\n\t\t};\n\t\tlet usedCount = 0;\n\t\tlet blending = false;\n\t\tconst count = this._activeTargets.length;\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst activeTarget = this._activeTargets[i];\n\t\t\tconst tex = activeTarget.target[srcTextureName];\n\t\t\tif (tex) {\n\t\t\t\tthis[`morphBlendTex${usedCount}`].setValue(tex);\n\t\t\t\tthis._shaderMorphWeights[usedCount] = activeTarget.weight;\n\t\t\t\tusedCount++;\n\t\t\t\tif (usedCount >= this.maxSubmitCount) {\n\t\t\t\t\tsubmitBatch(usedCount, blending);\n\t\t\t\t\tusedCount = 0;\n\t\t\t\t\tblending = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (usedCount > 0 || count === 0 && !this.zeroTextures) {\n\t\t\tsubmitBatch(usedCount, blending);\n\t\t}\n\t}\n\t_updateTextureMorph() {\n\t\tthis.device;\n\t\tif (this._activeTargets.length > 0 || !this.zeroTextures) {\n\t\t\tif (this.rtPositions) {\n\t\t\t\tthis._updateTextureRenderTarget(this.rtPositions, 'texturePositions');\n\t\t\t}\n\t\t\tif (this.rtNormals) {\n\t\t\t\tthis._updateTextureRenderTarget(this.rtNormals, 'textureNormals');\n\t\t\t}\n\t\t\tthis.zeroTextures = this._activeTargets.length === 0;\n\t\t}\n\t}\n\t_updateVertexMorph() {\n\t\tconst count = this.maxSubmitCount;\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tthis._shaderMorphWeights[i] = 0;\n\t\t\tthis._activeVertexBuffers[i] = null;\n\t\t}\n\t\tlet posIndex = 0;\n\t\tlet nrmIndex = this.morph.morphPositions ? 4 : 0;\n\t\tfor (let i = 0; i < this._activeTargets.length; i++) {\n\t\t\tconst target = this._activeTargets[i].target;\n\t\t\tif (target._vertexBufferPositions) {\n\t\t\t\tthis._activeVertexBuffers[posIndex] = target._vertexBufferPositions;\n\t\t\t\tthis._shaderMorphWeights[posIndex] = this._activeTargets[i].weight;\n\t\t\t\tposIndex++;\n\t\t\t}\n\t\t\tif (target._vertexBufferNormals) {\n\t\t\t\tthis._activeVertexBuffers[nrmIndex] = target._vertexBufferNormals;\n\t\t\t\tthis._shaderMorphWeights[nrmIndex] = this._activeTargets[i].weight;\n\t\t\t\tnrmIndex++;\n\t\t\t}\n\t\t}\n\t}\n\tupdate() {\n\t\tthis._dirty = false;\n\t\tconst targets = this.morph._targets;\n\t\tlet activeCount = 0;\n\t\tconst epsilon = 0.00001;\n\t\tfor (let i = 0; i < targets.length; i++) {\n\t\t\tconst absWeight = Math.abs(this.getWeight(i));\n\t\t\tif (absWeight > epsilon) {\n\t\t\t\tif (this._activeTargets.length <= activeCount) {\n\t\t\t\t\tthis._activeTargets[activeCount] = {};\n\t\t\t\t}\n\t\t\t\tconst activeTarget = this._activeTargets[activeCount++];\n\t\t\t\tactiveTarget.absWeight = absWeight;\n\t\t\t\tactiveTarget.weight = this.getWeight(i);\n\t\t\t\tactiveTarget.target = targets[i];\n\t\t\t}\n\t\t}\n\t\tthis._activeTargets.length = activeCount;\n\t\tconst maxActiveTargets = this.morph.maxActiveTargets;\n\t\tif (this._activeTargets.length > maxActiveTargets) {\n\t\t\tthis._activeTargets.sort((l, r) => {\n\t\t\t\treturn l.absWeight < r.absWeight ? 1 : r.absWeight < l.absWeight ? -1 : 0;\n\t\t\t});\n\t\t\tthis._activeTargets.length = maxActiveTargets;\n\t\t}\n\t\tif (this.morph.useTextureMorph) {\n\t\t\tthis._updateTextureMorph();\n\t\t} else {\n\t\t\tthis._updateVertexMorph();\n\t\t}\n\t}\n}\n\nexport { MorphInstance };\n","import { BoundingBox } from '../core/shape/bounding-box.js';\nimport { TYPE_FLOAT32, SEMANTIC_ATTR0 } from '../platform/graphics/constants.js';\nimport { VertexBuffer } from '../platform/graphics/vertex-buffer.js';\nimport { VertexFormat } from '../platform/graphics/vertex-format.js';\n\nclass MorphTarget {\n\tconstructor(options) {\n\t\tthis.used = false;\n\t\tif (arguments.length === 2) {\n\t\t\toptions = arguments[1];\n\t\t}\n\t\tthis.options = options;\n\t\tthis._name = options.name;\n\t\tthis._defaultWeight = options.defaultWeight || 0;\n\t\tthis._aabb = options.aabb;\n\t\tthis.deltaPositions = options.deltaPositions;\n\t}\n\tdestroy() {\n\t\tvar _this$_vertexBufferPo, _this$_vertexBufferNo, _this$texturePosition, _this$textureNormals;\n\t\t(_this$_vertexBufferPo = this._vertexBufferPositions) == null || _this$_vertexBufferPo.destroy();\n\t\tthis._vertexBufferPositions = null;\n\t\t(_this$_vertexBufferNo = this._vertexBufferNormals) == null || _this$_vertexBufferNo.destroy();\n\t\tthis._vertexBufferNormals = null;\n\t\t(_this$texturePosition = this.texturePositions) == null || _this$texturePosition.destroy();\n\t\tthis.texturePositions = null;\n\t\t(_this$textureNormals = this.textureNormals) == null || _this$textureNormals.destroy();\n\t\tthis.textureNormals = null;\n\t}\n\tget name() {\n\t\treturn this._name;\n\t}\n\tget defaultWeight() {\n\t\treturn this._defaultWeight;\n\t}\n\tget aabb() {\n\t\tif (!this._aabb) {\n\t\t\tthis._aabb = new BoundingBox();\n\t\t\tif (this.deltaPositions) {\n\t\t\t\tthis._aabb.compute(this.deltaPositions);\n\t\t\t}\n\t\t}\n\t\treturn this._aabb;\n\t}\n\tget morphPositions() {\n\t\treturn !!this._vertexBufferPositions || !!this.texturePositions;\n\t}\n\tget morphNormals() {\n\t\treturn !!this._vertexBufferNormals || !!this.textureNormals;\n\t}\n\tclone() {\n\t\treturn new MorphTarget(this.options);\n\t}\n\t_postInit() {\n\t\tif (!this.options.preserveData) {\n\t\t\tthis.options = null;\n\t\t}\n\t\tthis.used = true;\n\t}\n\t_initVertexBuffers(graphicsDevice) {\n\t\tconst options = this.options;\n\t\tthis._vertexBufferPositions = this._createVertexBuffer(graphicsDevice, options.deltaPositions, options.deltaPositionsType);\n\t\tthis._vertexBufferNormals = this._createVertexBuffer(graphicsDevice, options.deltaNormals, options.deltaNormalsType);\n\t\tif (this._vertexBufferPositions) {\n\t\t\tthis.deltaPositions = this._vertexBufferPositions.lock();\n\t\t}\n\t}\n\t_createVertexBuffer(device, data, dataType = TYPE_FLOAT32) {\n\t\tif (data) {\n\t\t\tconst formatDesc = [{\n\t\t\t\tsemantic: SEMANTIC_ATTR0,\n\t\t\t\tcomponents: 3,\n\t\t\t\ttype: dataType\n\t\t\t}];\n\t\t\treturn new VertexBuffer(device, new VertexFormat(device, formatDesc), data.length / 3, {\n\t\t\t\tdata: data\n\t\t\t});\n\t\t}\n\t\treturn null;\n\t}\n\t_setTexture(name, texture) {\n\t\tthis[name] = texture;\n\t}\n}\n\nexport { MorphTarget };\n","import { RefCountedObject } from '../core/ref-counted-object.js';\nimport { Vec3 } from '../core/math/vec3.js';\nimport { FloatPacking } from '../core/math/float-packing.js';\nimport { BoundingBox } from '../core/shape/bounding-box.js';\nimport { Texture } from '../platform/graphics/texture.js';\nimport { VertexBuffer } from '../platform/graphics/vertex-buffer.js';\nimport { VertexFormat } from '../platform/graphics/vertex-format.js';\nimport { PIXELFORMAT_RGBA16F, PIXELFORMAT_RGBA32F, PIXELFORMAT_RGB32F, FILTER_NEAREST, ADDRESS_CLAMP_TO_EDGE, SEMANTIC_ATTR15, TYPE_UINT32, TYPE_FLOAT32 } from '../platform/graphics/constants.js';\n\nclass Morph extends RefCountedObject {\n\tconstructor(targets, graphicsDevice, {\n\t\tpreferHighPrecision = false\n\t} = {}) {\n\t\tsuper();\n\t\tthis._aabb = void 0;\n\t\tthis.preferHighPrecision = void 0;\n\t\tthis.device = graphicsDevice;\n\t\tthis.preferHighPrecision = preferHighPrecision;\n\t\tthis._targets = targets.slice();\n\t\tconst device = this.device;\n\t\tif (device.supportsMorphTargetTexturesCore) {\n\t\t\tconst renderableHalf = device.extTextureHalfFloat && device.textureHalfFloatRenderable ? PIXELFORMAT_RGBA16F : undefined;\n\t\t\tconst renderableFloat = device.extTextureFloat && device.textureFloatRenderable ? PIXELFORMAT_RGBA32F : undefined;\n\t\t\tthis._renderTextureFormat = this.preferHighPrecision ? renderableFloat != null ? renderableFloat : renderableHalf : renderableHalf != null ? renderableHalf : renderableFloat;\n\t\t\tconst textureHalf = device.extTextureHalfFloat && device.textureHalfFloatUpdatable ? PIXELFORMAT_RGBA16F : undefined;\n\t\t\tconst textureFloat = device.extTextureFloat ? PIXELFORMAT_RGB32F : undefined;\n\t\t\tthis._textureFormat = this.preferHighPrecision ? textureFloat != null ? textureFloat : textureHalf : textureHalf != null ? textureHalf : textureFloat;\n\t\t\tif (this._renderTextureFormat !== undefined && this._textureFormat !== undefined) {\n\t\t\t\tthis._useTextureMorph = true;\n\t\t\t}\n\t\t}\n\t\tthis._init();\n\t\tthis._updateMorphFlags();\n\t}\n\tget aabb() {\n\t\tif (!this._aabb) {\n\t\t\tconst min = new Vec3();\n\t\t\tconst max = new Vec3();\n\t\t\tfor (let i = 0; i < this._targets.length; i++) {\n\t\t\t\tconst targetAabb = this._targets[i].aabb;\n\t\t\t\tmin.min(targetAabb.getMin());\n\t\t\t\tmax.max(targetAabb.getMax());\n\t\t\t}\n\t\t\tthis._aabb = new BoundingBox();\n\t\t\tthis._aabb.setMinMax(min, max);\n\t\t}\n\t\treturn this._aabb;\n\t}\n\tget morphPositions() {\n\t\treturn this._morphPositions;\n\t}\n\tget morphNormals() {\n\t\treturn this._morphNormals;\n\t}\n\tget maxActiveTargets() {\n\t\tif (this._useTextureMorph) {\n\t\t\treturn this._targets.length;\n\t\t}\n\t\treturn this._morphPositions && this._morphNormals ? 4 : 8;\n\t}\n\tget useTextureMorph() {\n\t\treturn this._useTextureMorph;\n\t}\n\t_init() {\n\t\tif (this._useTextureMorph) {\n\t\t\tthis._useTextureMorph = this._initTextureBased();\n\t\t}\n\t\tif (!this._useTextureMorph) {\n\t\t\tfor (let i = 0; i < this._targets.length; i++) {\n\t\t\t\tthis._targets[i]._initVertexBuffers(this.device);\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < this._targets.length; i++) {\n\t\t\tthis._targets[i]._postInit();\n\t\t}\n\t}\n\t_findSparseSet(deltaArrays, ids, usedDataIndices, floatRounding) {\n\t\tlet freeIndex = 1;\n\t\tconst dataCount = deltaArrays[0].length;\n\t\tfor (let v = 0; v < dataCount; v += 3) {\n\t\t\tlet vertexUsed = false;\n\t\t\tfor (let i = 0; i < deltaArrays.length; i++) {\n\t\t\t\tconst data = deltaArrays[i];\n\t\t\t\tif (data[v] !== 0 || data[v + 1] !== 0 || data[v + 2] !== 0) {\n\t\t\t\t\tvertexUsed = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (vertexUsed) {\n\t\t\t\tids.push(freeIndex + floatRounding);\n\t\t\t\tusedDataIndices.push(v / 3);\n\t\t\t\tfreeIndex++;\n\t\t\t} else {\n\t\t\t\tids.push(0 + floatRounding);\n\t\t\t}\n\t\t}\n\t\treturn freeIndex;\n\t}\n\t_initTextureBased() {\n\t\tconst useUintIds = this.device.isWebGPU;\n\t\tconst floatRounding = useUintIds ? 0 : 0.2;\n\t\tconst deltaArrays = [],\n\t\t\tdeltaInfos = [];\n\t\tfor (let i = 0; i < this._targets.length; i++) {\n\t\t\tconst target = this._targets[i];\n\t\t\tif (target.options.deltaPositions) {\n\t\t\t\tdeltaArrays.push(target.options.deltaPositions);\n\t\t\t\tdeltaInfos.push({\n\t\t\t\t\ttarget: target,\n\t\t\t\t\tname: 'texturePositions'\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (target.options.deltaNormals) {\n\t\t\t\tdeltaArrays.push(target.options.deltaNormals);\n\t\t\t\tdeltaInfos.push({\n\t\t\t\t\ttarget: target,\n\t\t\t\t\tname: 'textureNormals'\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tconst ids = [],\n\t\t\tusedDataIndices = [];\n\t\tconst freeIndex = this._findSparseSet(deltaArrays, ids, usedDataIndices, floatRounding);\n\t\tconst maxTextureSize = Math.min(this.device.maxTextureSize, 4096);\n\t\tlet morphTextureWidth = Math.ceil(Math.sqrt(freeIndex));\n\t\tmorphTextureWidth = Math.min(morphTextureWidth, maxTextureSize);\n\t\tconst morphTextureHeight = Math.ceil(freeIndex / morphTextureWidth);\n\t\tif (morphTextureHeight > maxTextureSize) {\n\t\t\treturn false;\n\t\t}\n\t\tthis.morphTextureWidth = morphTextureWidth;\n\t\tthis.morphTextureHeight = morphTextureHeight;\n\t\tlet halfFloat = false;\n\t\tlet numComponents = 3;\n\t\tconst float2Half = FloatPacking.float2Half;\n\t\tif (this._textureFormat === PIXELFORMAT_RGBA16F) {\n\t\t\thalfFloat = true;\n\t\t\tnumComponents = 4;\n\t\t}\n\t\tconst textures = [];\n\t\tfor (let i = 0; i < deltaArrays.length; i++) {\n\t\t\ttextures.push(this._createTexture('MorphTarget', this._textureFormat));\n\t\t}\n\t\tfor (let i = 0; i < deltaArrays.length; i++) {\n\t\t\tconst data = deltaArrays[i];\n\t\t\tconst texture = textures[i];\n\t\t\tconst textureData = texture.lock();\n\t\t\tif (halfFloat) {\n\t\t\t\tfor (let v = 0; v < usedDataIndices.length; v++) {\n\t\t\t\t\tconst index = usedDataIndices[v] * 3;\n\t\t\t\t\tconst dstIndex = v * numComponents + numComponents;\n\t\t\t\t\ttextureData[dstIndex] = float2Half(data[index]);\n\t\t\t\t\ttextureData[dstIndex + 1] = float2Half(data[index + 1]);\n\t\t\t\t\ttextureData[dstIndex + 2] = float2Half(data[index + 2]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (let v = 0; v < usedDataIndices.length; v++) {\n\t\t\t\t\tconst index = usedDataIndices[v] * 3;\n\t\t\t\t\tconst dstIndex = v * numComponents + numComponents;\n\t\t\t\t\ttextureData[dstIndex] = data[index];\n\t\t\t\t\ttextureData[dstIndex + 1] = data[index + 1];\n\t\t\t\t\ttextureData[dstIndex + 2] = data[index + 2];\n\t\t\t\t}\n\t\t\t}\n\t\t\ttexture.unlock();\n\t\t\tconst target = deltaInfos[i].target;\n\t\t\ttarget._setTexture(deltaInfos[i].name, texture);\n\t\t}\n\t\tconst formatDesc = [{\n\t\t\tsemantic: SEMANTIC_ATTR15,\n\t\t\tcomponents: 1,\n\t\t\ttype: useUintIds ? TYPE_UINT32 : TYPE_FLOAT32\n\t\t}];\n\t\tthis.vertexBufferIds = new VertexBuffer(this.device, new VertexFormat(this.device, formatDesc, ids.length), ids.length, {\n\t\t\tdata: useUintIds ? new Uint32Array(ids) : new Float32Array(ids)\n\t\t});\n\t\treturn true;\n\t}\n\tdestroy() {\n\t\tvar _this$vertexBufferIds;\n\t\t(_this$vertexBufferIds = this.vertexBufferIds) == null || _this$vertexBufferIds.destroy();\n\t\tthis.vertexBufferIds = null;\n\t\tfor (let i = 0; i < this._targets.length; i++) {\n\t\t\tthis._targets[i].destroy();\n\t\t}\n\t\tthis._targets.length = 0;\n\t}\n\tget targets() {\n\t\treturn this._targets;\n\t}\n\t_updateMorphFlags() {\n\t\tthis._morphPositions = false;\n\t\tthis._morphNormals = false;\n\t\tfor (let i = 0; i < this._targets.length; i++) {\n\t\t\tconst target = this._targets[i];\n\t\t\tif (target.morphPositions) {\n\t\t\t\tthis._morphPositions = true;\n\t\t\t}\n\t\t\tif (target.morphNormals) {\n\t\t\t\tthis._morphNormals = true;\n\t\t\t}\n\t\t}\n\t}\n\t_createTexture(name, format) {\n\t\treturn new Texture(this.device, {\n\t\t\twidth: this.morphTextureWidth,\n\t\t\theight: this.morphTextureHeight,\n\t\t\tformat: format,\n\t\t\tcubemap: false,\n\t\t\tmipmaps: false,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\tname: name\n\t\t});\n\t}\n}\n\nexport { Morph };\n","import { math } from '../../core/math/math.js';\nimport { Mat4 } from '../../core/math/mat4.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { EMITTERSHAPE_BOX, EMITTERSHAPE_SPHERE, PARTICLESORT_NONE } from '../constants.js';\n\nlet nonUniformScale;\nlet uniformScale = 1;\nconst particleTexChannels = 4;\nconst rotMat = new Mat4();\nconst rotMatInv = new Mat4();\nconst randomPosTformed = new Vec3();\nconst randomPos = new Vec3();\nconst rndFactor3Vec = new Vec3();\nconst particlePosPrev = new Vec3();\nconst velocityVec = new Vec3();\nconst localVelocityVec = new Vec3();\nconst velocityVec2 = new Vec3();\nconst localVelocityVec2 = new Vec3();\nconst radialVelocityVec = new Vec3();\nconst particlePos = new Vec3();\nconst particleFinalPos = new Vec3();\nconst moveDirVec = new Vec3();\nconst tmpVec3 = new Vec3();\nfunction frac(f) {\n\treturn f - Math.floor(f);\n}\nfunction saturate(x) {\n\treturn Math.max(Math.min(x, 1), 0);\n}\nfunction glMod(x, y) {\n\treturn x - y * Math.floor(x / y);\n}\nfunction encodeFloatRGBA(v) {\n\tlet encX = frac(v);\n\tlet encY = frac(255.0 * v);\n\tlet encZ = frac(65025.0 * v);\n\tlet encW = frac(160581375.0 * v);\n\tencX -= encY / 255.0;\n\tencY -= encZ / 255.0;\n\tencZ -= encW / 255.0;\n\tencW -= encW / 255.0;\n\treturn [encX, encY, encZ, encW];\n}\nfunction encodeFloatRG(v) {\n\tlet encX = frac(v);\n\tlet encY = frac(255.0 * v);\n\tencX -= encY / 255.0;\n\tencY -= encY / 255.0;\n\treturn [encX, encY];\n}\nclass ParticleCPUUpdater {\n\tconstructor(emitter) {\n\t\tthis._emitter = emitter;\n\t}\n\tcalcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i) {\n\t\tconst emitter = this._emitter;\n\t\tconst rX = Math.random();\n\t\tconst rY = Math.random();\n\t\tconst rZ = Math.random();\n\t\tconst rW = Math.random();\n\t\tif (emitter.useCpu) {\n\t\t\tparticleTex[i * particleTexChannels + 0 + emitter.numParticlesPot * 2 * particleTexChannels] = rX;\n\t\t\tparticleTex[i * particleTexChannels + 1 + emitter.numParticlesPot * 2 * particleTexChannels] = rY;\n\t\t\tparticleTex[i * particleTexChannels + 2 + emitter.numParticlesPot * 2 * particleTexChannels] = rZ;\n\t\t}\n\t\trandomPos.x = rX - 0.5;\n\t\trandomPos.y = rY - 0.5;\n\t\trandomPos.z = rZ - 0.5;\n\t\tif (emitter.emitterShape === EMITTERSHAPE_BOX) {\n\t\t\tconst max = Math.max(Math.abs(randomPos.x), Math.max(Math.abs(randomPos.y), Math.abs(randomPos.z)));\n\t\t\tconst edgeX = max + (0.5 - max) * extentsInnerRatioUniform[0];\n\t\t\tconst edgeY = max + (0.5 - max) * extentsInnerRatioUniform[1];\n\t\t\tconst edgeZ = max + (0.5 - max) * extentsInnerRatioUniform[2];\n\t\t\trandomPos.x = edgeX * (max === Math.abs(randomPos.x) ? Math.sign(randomPos.x) : 2 * randomPos.x);\n\t\t\trandomPos.y = edgeY * (max === Math.abs(randomPos.y) ? Math.sign(randomPos.y) : 2 * randomPos.y);\n\t\t\trandomPos.z = edgeZ * (max === Math.abs(randomPos.z) ? Math.sign(randomPos.z) : 2 * randomPos.z);\n\t\t\tif (!emitter.localSpace) {\n\t\t\t\trandomPosTformed.copy(emitterPos).add(spawnMatrix.transformPoint(randomPos));\n\t\t\t} else {\n\t\t\t\trandomPosTformed.copy(spawnMatrix.transformPoint(randomPos));\n\t\t\t}\n\t\t} else {\n\t\t\trandomPos.normalize();\n\t\t\tconst spawnBoundsSphereInnerRatio = emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius;\n\t\t\tconst r = rW * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;\n\t\t\tif (!emitter.localSpace) {\n\t\t\t\trandomPosTformed.copy(emitterPos).add(randomPos.mulScalar(r * emitter.emitterRadius));\n\t\t\t} else {\n\t\t\t\trandomPosTformed.copy(randomPos.mulScalar(r * emitter.emitterRadius));\n\t\t\t}\n\t\t}\n\t\tconst particleRate = math.lerp(emitter.rate, emitter.rate2, rX);\n\t\tlet startSpawnTime = -particleRate * i;\n\t\tif (emitter.pack8) {\n\t\t\tconst packX = (randomPosTformed.x - emitter.worldBounds.center.x) / emitter.worldBoundsSize.x + 0.5;\n\t\t\tconst packY = (randomPosTformed.y - emitter.worldBounds.center.y) / emitter.worldBoundsSize.y + 0.5;\n\t\t\tconst packZ = (randomPosTformed.z - emitter.worldBounds.center.z) / emitter.worldBoundsSize.z + 0.5;\n\t\t\tlet packA = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);\n\t\t\tpackA = packA % (Math.PI * 2) / (Math.PI * 2);\n\t\t\tconst rg0 = encodeFloatRG(packX);\n\t\t\tparticleTex[i * particleTexChannels] = rg0[0];\n\t\t\tparticleTex[i * particleTexChannels + 1] = rg0[1];\n\t\t\tconst ba0 = encodeFloatRG(packY);\n\t\t\tparticleTex[i * particleTexChannels + 2] = ba0[0];\n\t\t\tparticleTex[i * particleTexChannels + 3] = ba0[1];\n\t\t\tconst rg1 = encodeFloatRG(packZ);\n\t\t\tparticleTex[i * particleTexChannels + 0 + emitter.numParticlesPot * particleTexChannels] = rg1[0];\n\t\t\tparticleTex[i * particleTexChannels + 1 + emitter.numParticlesPot * particleTexChannels] = rg1[1];\n\t\t\tconst ba1 = encodeFloatRG(packA);\n\t\t\tparticleTex[i * particleTexChannels + 2 + emitter.numParticlesPot * particleTexChannels] = ba1[0];\n\t\t\tparticleTex[i * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels] = ba1[1];\n\t\t\tconst a2 = 1.0;\n\t\t\tparticleTex[i * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels * 2] = a2;\n\t\t\tconst maxNegLife = Math.max(emitter.lifetime, (emitter.numParticles - 1.0) * Math.max(emitter.rate, emitter.rate2));\n\t\t\tconst maxPosLife = emitter.lifetime + 1.0;\n\t\t\tstartSpawnTime = (startSpawnTime + maxNegLife) / (maxNegLife + maxPosLife);\n\t\t\tconst rgba3 = encodeFloatRGBA(startSpawnTime);\n\t\t\tparticleTex[i * particleTexChannels + 0 + emitter.numParticlesPot * particleTexChannels * 3] = rgba3[0];\n\t\t\tparticleTex[i * particleTexChannels + 1 + emitter.numParticlesPot * particleTexChannels * 3] = rgba3[1];\n\t\t\tparticleTex[i * particleTexChannels + 2 + emitter.numParticlesPot * particleTexChannels * 3] = rgba3[2];\n\t\t\tparticleTex[i * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels * 3] = rgba3[3];\n\t\t} else {\n\t\t\tparticleTex[i * particleTexChannels] = randomPosTformed.x;\n\t\t\tparticleTex[i * particleTexChannels + 1] = randomPosTformed.y;\n\t\t\tparticleTex[i * particleTexChannels + 2] = randomPosTformed.z;\n\t\t\tparticleTex[i * particleTexChannels + 3] = math.lerp(emitter.startAngle * math.DEG_TO_RAD, emitter.startAngle2 * math.DEG_TO_RAD, rX);\n\t\t\tparticleTex[i * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels] = startSpawnTime;\n\t\t}\n\t}\n\tupdate(data, vbToSort, particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop) {\n\t\tlet a, b, c;\n\t\tconst emitter = this._emitter;\n\t\tif (emitter.meshInstance.node) {\n\t\t\tconst fullMat = emitter.meshInstance.node.worldTransform;\n\t\t\tfor (let j = 0; j < 12; j++) {\n\t\t\t\trotMat.data[j] = fullMat.data[j];\n\t\t\t}\n\t\t\trotMatInv.copy(rotMat);\n\t\t\trotMatInv.invert();\n\t\t\tnonUniformScale = emitter.meshInstance.node.localScale;\n\t\t\tuniformScale = Math.max(Math.max(nonUniformScale.x, nonUniformScale.y), nonUniformScale.z);\n\t\t}\n\t\temitterPos = emitter.meshInstance.node === null || emitter.localSpace ? Vec3.ZERO : emitter.meshInstance.node.getPosition();\n\t\tconst posCam = emitter.camera ? emitter.camera._node.getPosition() : Vec3.ZERO;\n\t\tconst vertSize = !emitter.useMesh ? 15 : 17;\n\t\tlet cf, cc;\n\t\tlet rotSpeed, rotSpeed2, scale2, alpha, alpha2, radialSpeed, radialSpeed2;\n\t\tconst precision1 = emitter.precision - 1;\n\t\tfor (let i = 0; i < emitter.numParticles; i++) {\n\t\t\tconst id = Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * (emitter.useMesh ? 6 : 4) + 3]);\n\t\t\tconst rndFactor = particleTex[id * particleTexChannels + 0 + emitter.numParticlesPot * 2 * particleTexChannels];\n\t\t\trndFactor3Vec.x = rndFactor;\n\t\t\trndFactor3Vec.y = particleTex[id * particleTexChannels + 1 + emitter.numParticlesPot * 2 * particleTexChannels];\n\t\t\trndFactor3Vec.z = particleTex[id * particleTexChannels + 2 + emitter.numParticlesPot * 2 * particleTexChannels];\n\t\t\tconst particleRate = emitter.rate + (emitter.rate2 - emitter.rate) * rndFactor;\n\t\t\tconst particleLifetime = emitter.lifetime;\n\t\t\tlet life = particleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels] + delta;\n\t\t\tconst nlife = saturate(life / particleLifetime);\n\t\t\tlet scale = 0;\n\t\t\tlet alphaDiv = 0;\n\t\t\tconst angle = 0;\n\t\t\tconst respawn = life - delta <= 0.0 || life >= particleLifetime;\n\t\t\tif (respawn) {\n\t\t\t\tthis.calcSpawnPosition(particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, id);\n\t\t\t}\n\t\t\tlet particleEnabled = life > 0.0 && life < particleLifetime;\n\t\t\tif (particleEnabled) {\n\t\t\t\tc = nlife * precision1;\n\t\t\t\tcf = Math.floor(c);\n\t\t\t\tcc = Math.ceil(c);\n\t\t\t\tc %= 1;\n\t\t\t\ta = emitter.qRotSpeed[cf];\n\t\t\t\tb = emitter.qRotSpeed[cc];\n\t\t\t\trotSpeed = a + (b - a) * c;\n\t\t\t\ta = emitter.qRotSpeed2[cf];\n\t\t\t\tb = emitter.qRotSpeed2[cc];\n\t\t\t\trotSpeed2 = a + (b - a) * c;\n\t\t\t\ta = emitter.qScale[cf];\n\t\t\t\tb = emitter.qScale[cc];\n\t\t\t\tscale = a + (b - a) * c;\n\t\t\t\ta = emitter.qScale2[cf];\n\t\t\t\tb = emitter.qScale2[cc];\n\t\t\t\tscale2 = a + (b - a) * c;\n\t\t\t\ta = emitter.qAlpha[cf];\n\t\t\t\tb = emitter.qAlpha[cc];\n\t\t\t\talpha = a + (b - a) * c;\n\t\t\t\ta = emitter.qAlpha2[cf];\n\t\t\t\tb = emitter.qAlpha2[cc];\n\t\t\t\talpha2 = a + (b - a) * c;\n\t\t\t\ta = emitter.qRadialSpeed[cf];\n\t\t\t\tb = emitter.qRadialSpeed[cc];\n\t\t\t\tradialSpeed = a + (b - a) * c;\n\t\t\t\ta = emitter.qRadialSpeed2[cf];\n\t\t\t\tb = emitter.qRadialSpeed2[cc];\n\t\t\t\tradialSpeed2 = a + (b - a) * c;\n\t\t\t\tradialSpeed += (radialSpeed2 - radialSpeed) * (rndFactor * 100.0 % 1.0);\n\t\t\t\tparticlePosPrev.x = particleTex[id * particleTexChannels];\n\t\t\t\tparticlePosPrev.y = particleTex[id * particleTexChannels + 1];\n\t\t\t\tparticlePosPrev.z = particleTex[id * particleTexChannels + 2];\n\t\t\t\tif (!emitter.localSpace) {\n\t\t\t\t\tradialVelocityVec.copy(particlePosPrev).sub(emitterPos);\n\t\t\t\t} else {\n\t\t\t\t\tradialVelocityVec.copy(particlePosPrev);\n\t\t\t\t}\n\t\t\t\tradialVelocityVec.normalize().mulScalar(radialSpeed);\n\t\t\t\tcf *= 3;\n\t\t\t\tcc *= 3;\n\t\t\t\ta = emitter.qLocalVelocity[cf];\n\t\t\t\tb = emitter.qLocalVelocity[cc];\n\t\t\t\tlocalVelocityVec.x = a + (b - a) * c;\n\t\t\t\ta = emitter.qLocalVelocity[cf + 1];\n\t\t\t\tb = emitter.qLocalVelocity[cc + 1];\n\t\t\t\tlocalVelocityVec.y = a + (b - a) * c;\n\t\t\t\ta = emitter.qLocalVelocity[cf + 2];\n\t\t\t\tb = emitter.qLocalVelocity[cc + 2];\n\t\t\t\tlocalVelocityVec.z = a + (b - a) * c;\n\t\t\t\ta = emitter.qLocalVelocity2[cf];\n\t\t\t\tb = emitter.qLocalVelocity2[cc];\n\t\t\t\tlocalVelocityVec2.x = a + (b - a) * c;\n\t\t\t\ta = emitter.qLocalVelocity2[cf + 1];\n\t\t\t\tb = emitter.qLocalVelocity2[cc + 1];\n\t\t\t\tlocalVelocityVec2.y = a + (b - a) * c;\n\t\t\t\ta = emitter.qLocalVelocity2[cf + 2];\n\t\t\t\tb = emitter.qLocalVelocity2[cc + 2];\n\t\t\t\tlocalVelocityVec2.z = a + (b - a) * c;\n\t\t\t\ta = emitter.qVelocity[cf];\n\t\t\t\tb = emitter.qVelocity[cc];\n\t\t\t\tvelocityVec.x = a + (b - a) * c;\n\t\t\t\ta = emitter.qVelocity[cf + 1];\n\t\t\t\tb = emitter.qVelocity[cc + 1];\n\t\t\t\tvelocityVec.y = a + (b - a) * c;\n\t\t\t\ta = emitter.qVelocity[cf + 2];\n\t\t\t\tb = emitter.qVelocity[cc + 2];\n\t\t\t\tvelocityVec.z = a + (b - a) * c;\n\t\t\t\ta = emitter.qVelocity2[cf];\n\t\t\t\tb = emitter.qVelocity2[cc];\n\t\t\t\tvelocityVec2.x = a + (b - a) * c;\n\t\t\t\ta = emitter.qVelocity2[cf + 1];\n\t\t\t\tb = emitter.qVelocity2[cc + 1];\n\t\t\t\tvelocityVec2.y = a + (b - a) * c;\n\t\t\t\ta = emitter.qVelocity2[cf + 2];\n\t\t\t\tb = emitter.qVelocity2[cc + 2];\n\t\t\t\tvelocityVec2.z = a + (b - a) * c;\n\t\t\t\tlocalVelocityVec.x += (localVelocityVec2.x - localVelocityVec.x) * rndFactor3Vec.x;\n\t\t\t\tlocalVelocityVec.y += (localVelocityVec2.y - localVelocityVec.y) * rndFactor3Vec.y;\n\t\t\t\tlocalVelocityVec.z += (localVelocityVec2.z - localVelocityVec.z) * rndFactor3Vec.z;\n\t\t\t\tif (emitter.initialVelocity > 0) {\n\t\t\t\t\tif (emitter.emitterShape === EMITTERSHAPE_SPHERE) {\n\t\t\t\t\t\trandomPos.copy(rndFactor3Vec).mulScalar(2).sub(Vec3.ONE).normalize();\n\t\t\t\t\t\tlocalVelocityVec.add(randomPos.mulScalar(emitter.initialVelocity));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlocalVelocityVec.add(Vec3.FORWARD.mulScalar(emitter.initialVelocity));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvelocityVec.x += (velocityVec2.x - velocityVec.x) * rndFactor3Vec.x;\n\t\t\t\tvelocityVec.y += (velocityVec2.y - velocityVec.y) * rndFactor3Vec.y;\n\t\t\t\tvelocityVec.z += (velocityVec2.z - velocityVec.z) * rndFactor3Vec.z;\n\t\t\t\trotSpeed += (rotSpeed2 - rotSpeed) * rndFactor3Vec.y;\n\t\t\t\tscale = (scale + (scale2 - scale) * (rndFactor * 10000.0 % 1.0)) * uniformScale;\n\t\t\t\talphaDiv = (alpha2 - alpha) * (rndFactor * 1000.0 % 1.0);\n\t\t\t\tif (emitter.meshInstance.node) {\n\t\t\t\t\tif (!emitter.localSpace) {\n\t\t\t\t\t\trotMat.transformPoint(localVelocityVec, localVelocityVec);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlocalVelocityVec.x /= nonUniformScale.x;\n\t\t\t\t\t\tlocalVelocityVec.y /= nonUniformScale.y;\n\t\t\t\t\t\tlocalVelocityVec.z /= nonUniformScale.z;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!emitter.localSpace) {\n\t\t\t\t\tlocalVelocityVec.add(velocityVec.mul(nonUniformScale));\n\t\t\t\t\tlocalVelocityVec.add(radialVelocityVec.mul(nonUniformScale));\n\t\t\t\t} else {\n\t\t\t\t\trotMatInv.transformPoint(velocityVec, velocityVec);\n\t\t\t\t\tlocalVelocityVec.add(velocityVec).add(radialVelocityVec);\n\t\t\t\t}\n\t\t\t\tmoveDirVec.copy(localVelocityVec);\n\t\t\t\tparticlePos.copy(particlePosPrev).add(localVelocityVec.mulScalar(delta));\n\t\t\t\tparticleFinalPos.copy(particlePos);\n\t\t\t\tparticleTex[id * particleTexChannels] = particleFinalPos.x;\n\t\t\t\tparticleTex[id * particleTexChannels + 1] = particleFinalPos.y;\n\t\t\t\tparticleTex[id * particleTexChannels + 2] = particleFinalPos.z;\n\t\t\t\tparticleTex[id * particleTexChannels + 3] += rotSpeed * delta;\n\t\t\t\tif (emitter.wrap && emitter.wrapBounds) {\n\t\t\t\t\tif (!emitter.localSpace) {\n\t\t\t\t\t\tparticleFinalPos.sub(emitterPos);\n\t\t\t\t\t}\n\t\t\t\t\tparticleFinalPos.x = glMod(particleFinalPos.x, emitter.wrapBounds.x) - emitter.wrapBounds.x * 0.5;\n\t\t\t\t\tparticleFinalPos.y = glMod(particleFinalPos.y, emitter.wrapBounds.y) - emitter.wrapBounds.y * 0.5;\n\t\t\t\t\tparticleFinalPos.z = glMod(particleFinalPos.z, emitter.wrapBounds.z) - emitter.wrapBounds.z * 0.5;\n\t\t\t\t\tif (!emitter.localSpace) {\n\t\t\t\t\t\tparticleFinalPos.add(emitterPos);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (emitter.sort > 0) {\n\t\t\t\t\tif (emitter.sort === 1) {\n\t\t\t\t\t\ttmpVec3.copy(particleFinalPos).sub(posCam);\n\t\t\t\t\t\temitter.particleDistance[id] = -(tmpVec3.x * tmpVec3.x + tmpVec3.y * tmpVec3.y + tmpVec3.z * tmpVec3.z);\n\t\t\t\t\t} else if (emitter.sort === 2) {\n\t\t\t\t\t\temitter.particleDistance[id] = life;\n\t\t\t\t\t} else if (emitter.sort === 3) {\n\t\t\t\t\t\temitter.particleDistance[id] = -life;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isOnStop) {\n\t\t\t\tif (life < 0) {\n\t\t\t\t\tparticleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * 2 * particleTexChannels] = -1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (life >= particleLifetime) {\n\t\t\t\t\tlife -= Math.max(particleLifetime, (emitter.numParticles - 1) * particleRate);\n\t\t\t\t\tparticleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * 2 * particleTexChannels] = emitter.loop ? 1 : -1;\n\t\t\t\t}\n\t\t\t\tif (life < 0 && emitter.loop) {\n\t\t\t\t\tparticleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * 2 * particleTexChannels] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (particleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * 2 * particleTexChannels] < 0) {\n\t\t\t\tparticleEnabled = false;\n\t\t\t}\n\t\t\tparticleTex[id * particleTexChannels + 3 + emitter.numParticlesPot * particleTexChannels] = life;\n\t\t\tfor (let v = 0; v < emitter.numParticleVerts; v++) {\n\t\t\t\tconst vbOffset = (i * emitter.numParticleVerts + v) * (emitter.useMesh ? 6 : 4);\n\t\t\t\tlet quadX = emitter.vbCPU[vbOffset];\n\t\t\t\tlet quadY = emitter.vbCPU[vbOffset + 1];\n\t\t\t\tlet quadZ = emitter.vbCPU[vbOffset + 2];\n\t\t\t\tif (!particleEnabled) {\n\t\t\t\t\tquadX = quadY = quadZ = 0;\n\t\t\t\t}\n\t\t\t\tconst w = i * emitter.numParticleVerts * vertSize + v * vertSize;\n\t\t\t\tdata[w] = particleFinalPos.x;\n\t\t\t\tdata[w + 1] = particleFinalPos.y;\n\t\t\t\tdata[w + 2] = particleFinalPos.z;\n\t\t\t\tdata[w + 3] = nlife;\n\t\t\t\tdata[w + 4] = emitter.alignToMotion ? angle : particleTex[id * particleTexChannels + 3];\n\t\t\t\tdata[w + 5] = scale;\n\t\t\t\tdata[w + 6] = alphaDiv;\n\t\t\t\tdata[w + 7] = moveDirVec.x;\n\t\t\t\tdata[w + 8] = quadX;\n\t\t\t\tdata[w + 9] = quadY;\n\t\t\t\tdata[w + 10] = quadZ;\n\t\t\t\tdata[w + 11] = moveDirVec.y;\n\t\t\t\tdata[w + 12] = id;\n\t\t\t\tdata[w + 13] = moveDirVec.z;\n\t\t\t\tdata[w + 14] = emitter.vbCPU[vbOffset + 3];\n\t\t\t\tif (emitter.useMesh) {\n\t\t\t\t\tdata[w + 15] = emitter.vbCPU[vbOffset + 4];\n\t\t\t\t\tdata[w + 16] = emitter.vbCPU[vbOffset + 5];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (emitter.sort > PARTICLESORT_NONE && emitter.camera) {\n\t\t\tconst vbStride = emitter.useMesh ? 6 : 4;\n\t\t\tconst particleDistance = emitter.particleDistance;\n\t\t\tfor (let i = 0; i < emitter.numParticles; i++) {\n\t\t\t\tvbToSort[i][0] = i;\n\t\t\t\tvbToSort[i][1] = particleDistance[Math.floor(emitter.vbCPU[i * emitter.numParticleVerts * vbStride + 3])];\n\t\t\t}\n\t\t\temitter.vbOld.set(emitter.vbCPU);\n\t\t\tvbToSort.sort((p1, p2) => {\n\t\t\t\treturn p1[1] - p2[1];\n\t\t\t});\n\t\t\tfor (let i = 0; i < emitter.numParticles; i++) {\n\t\t\t\tconst src = vbToSort[i][0] * emitter.numParticleVerts * vbStride;\n\t\t\t\tconst dest = i * emitter.numParticleVerts * vbStride;\n\t\t\t\tfor (let j = 0; j < emitter.numParticleVerts * vbStride; j++) {\n\t\t\t\t\temitter.vbCPU[dest + j] = emitter.vbOld[src + j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { ParticleCPUUpdater };\n","import { math } from '../../core/math/math.js';\nimport { Mat3 } from '../../core/math/mat3.js';\nimport { Mat4 } from '../../core/math/mat4.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { CULLFACE_NONE } from '../../platform/graphics/constants.js';\nimport { BlendState } from '../../platform/graphics/blend-state.js';\nimport { DepthState } from '../../platform/graphics/depth-state.js';\nimport { drawQuadWithShader } from '../graphics/quad-render-utils.js';\nimport { EMITTERSHAPE_BOX } from '../constants.js';\n\nconst spawnMatrix3 = new Mat3();\nconst emitterMatrix3 = new Mat3();\nconst emitterMatrix3Inv = new Mat3();\nclass ParticleGPUUpdater {\n\tconstructor(emitter, gd) {\n\t\tthis._emitter = emitter;\n\t\tthis.frameRandomUniform = new Float32Array(3);\n\t\tthis.emitterPosUniform = new Float32Array(3);\n\t\tthis.emitterScaleUniform = new Float32Array([1, 1, 1]);\n\t\tthis.worldBoundsMulUniform = new Float32Array(3);\n\t\tthis.worldBoundsAddUniform = new Float32Array(3);\n\t\tthis.inBoundsSizeUniform = new Float32Array(3);\n\t\tthis.inBoundsCenterUniform = new Float32Array(3);\n\t\tthis.constantParticleTexIN = gd.scope.resolve('particleTexIN');\n\t\tthis.constantParticleTexOUT = gd.scope.resolve('particleTexOUT');\n\t\tthis.constantEmitterPos = gd.scope.resolve('emitterPos');\n\t\tthis.constantEmitterScale = gd.scope.resolve('emitterScale');\n\t\tthis.constantSpawnBounds = gd.scope.resolve('spawnBounds');\n\t\tthis.constantSpawnPosInnerRatio = gd.scope.resolve('spawnPosInnerRatio');\n\t\tthis.constantSpawnBoundsSphere = gd.scope.resolve('spawnBoundsSphere');\n\t\tthis.constantSpawnBoundsSphereInnerRatio = gd.scope.resolve('spawnBoundsSphereInnerRatio');\n\t\tthis.constantInitialVelocity = gd.scope.resolve('initialVelocity');\n\t\tthis.constantFrameRandom = gd.scope.resolve('frameRandom');\n\t\tthis.constantDelta = gd.scope.resolve('delta');\n\t\tthis.constantRate = gd.scope.resolve('rate');\n\t\tthis.constantRateDiv = gd.scope.resolve('rateDiv');\n\t\tthis.constantLifetime = gd.scope.resolve('lifetime');\n\t\tthis.constantGraphSampleSize = gd.scope.resolve('graphSampleSize');\n\t\tthis.constantGraphNumSamples = gd.scope.resolve('graphNumSamples');\n\t\tthis.constantInternalTex0 = gd.scope.resolve('internalTex0');\n\t\tthis.constantInternalTex1 = gd.scope.resolve('internalTex1');\n\t\tthis.constantInternalTex2 = gd.scope.resolve('internalTex2');\n\t\tthis.constantInternalTex3 = gd.scope.resolve('internalTex3');\n\t\tthis.constantEmitterMatrix = gd.scope.resolve('emitterMatrix');\n\t\tthis.constantEmitterMatrixInv = gd.scope.resolve('emitterMatrixInv');\n\t\tthis.constantNumParticles = gd.scope.resolve('numParticles');\n\t\tthis.constantNumParticlesPot = gd.scope.resolve('numParticlesPot');\n\t\tthis.constantLocalVelocityDivMult = gd.scope.resolve('localVelocityDivMult');\n\t\tthis.constantVelocityDivMult = gd.scope.resolve('velocityDivMult');\n\t\tthis.constantRotSpeedDivMult = gd.scope.resolve('rotSpeedDivMult');\n\t\tthis.constantSeed = gd.scope.resolve('seed');\n\t\tthis.constantStartAngle = gd.scope.resolve('startAngle');\n\t\tthis.constantStartAngle2 = gd.scope.resolve('startAngle2');\n\t\tthis.constantOutBoundsMul = gd.scope.resolve('outBoundsMul');\n\t\tthis.constantOutBoundsAdd = gd.scope.resolve('outBoundsAdd');\n\t\tthis.constantInBoundsSize = gd.scope.resolve('inBoundsSize');\n\t\tthis.constantInBoundsCenter = gd.scope.resolve('inBoundsCenter');\n\t\tthis.constantMaxVel = gd.scope.resolve('maxVel');\n\t\tthis.constantFaceTangent = gd.scope.resolve('faceTangent');\n\t\tthis.constantFaceBinorm = gd.scope.resolve('faceBinorm');\n\t}\n\t_setInputBounds() {\n\t\tthis.inBoundsSizeUniform[0] = this._emitter.prevWorldBoundsSize.x;\n\t\tthis.inBoundsSizeUniform[1] = this._emitter.prevWorldBoundsSize.y;\n\t\tthis.inBoundsSizeUniform[2] = this._emitter.prevWorldBoundsSize.z;\n\t\tthis.constantInBoundsSize.setValue(this.inBoundsSizeUniform);\n\t\tthis.inBoundsCenterUniform[0] = this._emitter.prevWorldBoundsCenter.x;\n\t\tthis.inBoundsCenterUniform[1] = this._emitter.prevWorldBoundsCenter.y;\n\t\tthis.inBoundsCenterUniform[2] = this._emitter.prevWorldBoundsCenter.z;\n\t\tthis.constantInBoundsCenter.setValue(this.inBoundsCenterUniform);\n\t}\n\trandomize() {\n\t\tthis.frameRandomUniform[0] = Math.random();\n\t\tthis.frameRandomUniform[1] = Math.random();\n\t\tthis.frameRandomUniform[2] = Math.random();\n\t}\n\tupdate(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop) {\n\t\tconst emitter = this._emitter;\n\t\tdevice.setBlendState(BlendState.NOBLEND);\n\t\tdevice.setDepthState(DepthState.NODEPTH);\n\t\tdevice.setCullMode(CULLFACE_NONE);\n\t\tthis.randomize();\n\t\tthis.constantGraphSampleSize.setValue(1.0 / emitter.precision);\n\t\tthis.constantGraphNumSamples.setValue(emitter.precision);\n\t\tthis.constantNumParticles.setValue(emitter.numParticles);\n\t\tthis.constantNumParticlesPot.setValue(emitter.numParticlesPot);\n\t\tthis.constantInternalTex0.setValue(emitter.internalTex0);\n\t\tthis.constantInternalTex1.setValue(emitter.internalTex1);\n\t\tthis.constantInternalTex2.setValue(emitter.internalTex2);\n\t\tthis.constantInternalTex3.setValue(emitter.internalTex3);\n\t\tconst node = emitter.meshInstance.node;\n\t\tconst emitterScale = node === null ? Vec3.ONE : node.localScale;\n\t\tif (emitter.pack8) {\n\t\t\tthis.worldBoundsMulUniform[0] = emitter.worldBoundsMul.x;\n\t\t\tthis.worldBoundsMulUniform[1] = emitter.worldBoundsMul.y;\n\t\t\tthis.worldBoundsMulUniform[2] = emitter.worldBoundsMul.z;\n\t\t\tthis.constantOutBoundsMul.setValue(this.worldBoundsMulUniform);\n\t\t\tthis.worldBoundsAddUniform[0] = emitter.worldBoundsAdd.x;\n\t\t\tthis.worldBoundsAddUniform[1] = emitter.worldBoundsAdd.y;\n\t\t\tthis.worldBoundsAddUniform[2] = emitter.worldBoundsAdd.z;\n\t\t\tthis.constantOutBoundsAdd.setValue(this.worldBoundsAddUniform);\n\t\t\tthis._setInputBounds();\n\t\t\tlet maxVel = emitter.maxVel * Math.max(Math.max(emitterScale.x, emitterScale.y), emitterScale.z);\n\t\t\tmaxVel = Math.max(maxVel, 1);\n\t\t\tthis.constantMaxVel.setValue(maxVel);\n\t\t}\n\t\tconst emitterPos = node === null || emitter.localSpace ? Vec3.ZERO : node.getPosition();\n\t\tconst emitterMatrix = node === null ? Mat4.IDENTITY : node.getWorldTransform();\n\t\tif (emitter.emitterShape === EMITTERSHAPE_BOX) {\n\t\t\tspawnMatrix3.setFromMat4(spawnMatrix);\n\t\t\tthis.constantSpawnBounds.setValue(spawnMatrix3.data);\n\t\t\tthis.constantSpawnPosInnerRatio.setValue(extentsInnerRatioUniform);\n\t\t} else {\n\t\t\tthis.constantSpawnBoundsSphere.setValue(emitter.emitterRadius);\n\t\t\tthis.constantSpawnBoundsSphereInnerRatio.setValue(emitter.emitterRadius === 0 ? 0 : emitter.emitterRadiusInner / emitter.emitterRadius);\n\t\t}\n\t\tthis.constantInitialVelocity.setValue(emitter.initialVelocity);\n\t\temitterMatrix3.setFromMat4(emitterMatrix);\n\t\temitterMatrix3Inv.invertMat4(emitterMatrix);\n\t\tthis.emitterPosUniform[0] = emitterPos.x;\n\t\tthis.emitterPosUniform[1] = emitterPos.y;\n\t\tthis.emitterPosUniform[2] = emitterPos.z;\n\t\tthis.constantEmitterPos.setValue(this.emitterPosUniform);\n\t\tthis.constantFrameRandom.setValue(this.frameRandomUniform);\n\t\tthis.constantDelta.setValue(delta);\n\t\tthis.constantRate.setValue(emitter.rate);\n\t\tthis.constantRateDiv.setValue(emitter.rate2 - emitter.rate);\n\t\tthis.constantStartAngle.setValue(emitter.startAngle * math.DEG_TO_RAD);\n\t\tthis.constantStartAngle2.setValue(emitter.startAngle2 * math.DEG_TO_RAD);\n\t\tthis.constantSeed.setValue(emitter.seed);\n\t\tthis.constantLifetime.setValue(emitter.lifetime);\n\t\tthis.emitterScaleUniform[0] = emitterScale.x;\n\t\tthis.emitterScaleUniform[1] = emitterScale.y;\n\t\tthis.emitterScaleUniform[2] = emitterScale.z;\n\t\tthis.constantEmitterScale.setValue(this.emitterScaleUniform);\n\t\tthis.constantEmitterMatrix.setValue(emitterMatrix3.data);\n\t\tthis.constantEmitterMatrixInv.setValue(emitterMatrix3Inv.data);\n\t\tthis.constantLocalVelocityDivMult.setValue(emitter.localVelocityUMax);\n\t\tthis.constantVelocityDivMult.setValue(emitter.velocityUMax);\n\t\tthis.constantRotSpeedDivMult.setValue(emitter.rotSpeedUMax[0]);\n\t\tlet texIN = emitter.swapTex ? emitter.particleTexOUT : emitter.particleTexIN;\n\t\ttexIN = emitter.beenReset ? emitter.particleTexStart : texIN;\n\t\tconst texOUT = emitter.swapTex ? emitter.particleTexIN : emitter.particleTexOUT;\n\t\tthis.constantParticleTexIN.setValue(texIN);\n\t\tdrawQuadWithShader(device, emitter.swapTex ? emitter.rtParticleTexIN : emitter.rtParticleTexOUT, !isOnStop ? emitter.loop ? emitter.shaderParticleUpdateRespawn : emitter.shaderParticleUpdateNoRespawn : emitter.shaderParticleUpdateOnStop);\n\t\temitter.material.setParameter('particleTexOUT', texIN);\n\t\temitter.material.setParameter('particleTexIN', texOUT);\n\t\temitter.beenReset = false;\n\t\temitter.swapTex = !emitter.swapTex;\n\t\temitter.prevWorldBoundsSize.copy(emitter.worldBoundsSize);\n\t\temitter.prevWorldBoundsCenter.copy(emitter.worldBounds.center);\n\t\tif (emitter.pack8) {\n\t\t\tthis._setInputBounds();\n\t\t}\n\t}\n}\n\nexport { ParticleGPUUpdater };\n","import { Curve } from '../../core/math/curve.js';\nimport { CurveSet } from '../../core/math/curve-set.js';\nimport { Mat4 } from '../../core/math/mat4.js';\nimport { math } from '../../core/math/math.js';\nimport { Quat } from '../../core/math/quat.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { BoundingBox } from '../../core/shape/bounding-box.js';\nimport { FILTER_LINEAR, PRIMITIVE_TRIANGLES, CULLFACE_NONE, BUFFER_DYNAMIC, INDEXFORMAT_UINT16, SEMANTIC_ATTR0, TYPE_FLOAT32, SEMANTIC_ATTR1, SEMANTIC_ATTR2, SEMANTIC_ATTR3, SEMANTIC_ATTR4, SEMANTIC_TEXCOORD0, ADDRESS_CLAMP_TO_EDGE, PIXELFORMAT_RGBA8, PIXELFORMAT_RGBA32F, FILTER_NEAREST } from '../../platform/graphics/constants.js';\nimport { DeviceCache } from '../../platform/graphics/device-cache.js';\nimport { IndexBuffer } from '../../platform/graphics/index-buffer.js';\nimport { RenderTarget } from '../../platform/graphics/render-target.js';\nimport { Texture } from '../../platform/graphics/texture.js';\nimport { VertexBuffer } from '../../platform/graphics/vertex-buffer.js';\nimport { VertexFormat } from '../../platform/graphics/vertex-format.js';\nimport { ShaderProcessorOptions } from '../../platform/graphics/shader-processor-options.js';\nimport { EMITTERSHAPE_BOX, PARTICLESORT_NONE, SHADER_FORWARD, PARTICLEORIENTATION_SCREEN, PARTICLEORIENTATION_WORLD, PARTICLEMODE_GPU, BLEND_NORMAL } from '../constants.js';\nimport { Mesh } from '../mesh.js';\nimport { MeshInstance } from '../mesh-instance.js';\nimport { Material } from '../materials/material.js';\nimport { getProgramLibrary } from '../shader-lib/get-program-library.js';\nimport { createShaderFromCode } from '../shader-lib/utils.js';\nimport { shaderChunks } from '../shader-lib/chunks/chunks.js';\nimport { particle } from '../shader-lib/programs/particle.js';\nimport { ParticleCPUUpdater } from './cpu-updater.js';\nimport { ParticleGPUUpdater } from './gpu-updater.js';\n\nconst particleVerts = [[-1, -1], [1, -1], [1, 1], [-1, 1]];\nfunction _createTexture(device, width, height, pixelData, format = PIXELFORMAT_RGBA32F, mult8Bit, filter) {\n\tlet mipFilter = FILTER_NEAREST;\n\tif (filter && format === PIXELFORMAT_RGBA8) {\n\t\tmipFilter = FILTER_LINEAR;\n\t}\n\tconst texture = new Texture(device, {\n\t\twidth: width,\n\t\theight: height,\n\t\tformat: format,\n\t\tcubemap: false,\n\t\tmipmaps: false,\n\t\tminFilter: mipFilter,\n\t\tmagFilter: mipFilter,\n\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\tname: 'ParticleSystemTexture'\n\t});\n\tconst pixels = texture.lock();\n\tif (format === PIXELFORMAT_RGBA8) {\n\t\tconst temp = new Uint8Array(pixelData.length);\n\t\tfor (let i = 0; i < pixelData.length; i++) {\n\t\t\ttemp[i] = pixelData[i] * mult8Bit * 255;\n\t\t}\n\t\tpixelData = temp;\n\t}\n\tpixels.set(pixelData);\n\ttexture.unlock();\n\treturn texture;\n}\nfunction saturate(x) {\n\treturn Math.max(Math.min(x, 1), 0);\n}\nconst default0Curve = new Curve([0, 0, 1, 0]);\nconst default1Curve = new Curve([0, 1, 1, 1]);\nconst default0Curve3 = new CurveSet([0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]);\nconst default1Curve3 = new CurveSet([0, 1, 1, 1], [0, 1, 1, 1], [0, 1, 1, 1]);\nlet particleTexHeight = 2;\nconst particleTexChannels = 4;\nconst extentsInnerRatioUniform = new Float32Array(3);\nconst spawnMatrix = new Mat4();\nconst tmpVec3 = new Vec3();\nconst bMin = new Vec3();\nconst bMax = new Vec3();\nlet setPropertyTarget;\nlet setPropertyOptions;\nfunction setProperty(pName, defaultVal) {\n\tif (setPropertyOptions[pName] !== undefined && setPropertyOptions[pName] !== null) {\n\t\tsetPropertyTarget[pName] = setPropertyOptions[pName];\n\t} else {\n\t\tsetPropertyTarget[pName] = defaultVal;\n\t}\n}\nfunction pack3NFloats(a, b, c) {\n\tconst packed = a * 255 << 16 | b * 255 << 8 | c * 255;\n\treturn packed / (1 << 24);\n}\nfunction packTextureXYZ_NXYZ(qXYZ, qXYZ2) {\n\tconst num = qXYZ.length / 3;\n\tconst colors = new Array(num * 4);\n\tfor (let i = 0; i < num; i++) {\n\t\tcolors[i * 4] = qXYZ[i * 3];\n\t\tcolors[i * 4 + 1] = qXYZ[i * 3 + 1];\n\t\tcolors[i * 4 + 2] = qXYZ[i * 3 + 2];\n\t\tcolors[i * 4 + 3] = pack3NFloats(qXYZ2[i * 3], qXYZ2[i * 3 + 1], qXYZ2[i * 3 + 2]);\n\t}\n\treturn colors;\n}\nfunction packTextureRGBA(qRGB, qA) {\n\tconst colors = new Array(qA.length * 4);\n\tfor (let i = 0; i < qA.length; i++) {\n\t\tcolors[i * 4] = qRGB[i * 3];\n\t\tcolors[i * 4 + 1] = qRGB[i * 3 + 1];\n\t\tcolors[i * 4 + 2] = qRGB[i * 3 + 2];\n\t\tcolors[i * 4 + 3] = qA[i];\n\t}\n\treturn colors;\n}\nfunction packTexture5Floats(qA, qB, qC, qD, qE) {\n\tconst colors = new Array(qA.length * 4);\n\tfor (let i = 0; i < qA.length; i++) {\n\t\tcolors[i * 4] = qA[i];\n\t\tcolors[i * 4 + 1] = qB[i];\n\t\tcolors[i * 4 + 2] = 0;\n\t\tcolors[i * 4 + 3] = pack3NFloats(qC[i], qD[i], qE[i]);\n\t}\n\treturn colors;\n}\nfunction packTexture2Floats(qA, qB) {\n\tconst colors = new Array(qA.length * 4);\n\tfor (let i = 0; i < qA.length; i++) {\n\t\tcolors[i * 4] = qA[i];\n\t\tcolors[i * 4 + 1] = qB[i];\n\t\tcolors[i * 4 + 2] = 0;\n\t\tcolors[i * 4 + 3] = 0;\n\t}\n\treturn colors;\n}\nfunction calcEndTime(emitter) {\n\tconst interval = Math.max(emitter.rate, emitter.rate2) * emitter.numParticles + emitter.lifetime;\n\treturn Date.now() + interval * 1000;\n}\nfunction subGraph(A, B) {\n\tconst r = new Float32Array(A.length);\n\tfor (let i = 0; i < A.length; i++) {\n\t\tr[i] = A[i] - B[i];\n\t}\n\treturn r;\n}\nfunction maxUnsignedGraphValue(A, outUMax) {\n\tconst chans = outUMax.length;\n\tconst values = A.length / chans;\n\tfor (let i = 0; i < values; i++) {\n\t\tfor (let j = 0; j < chans; j++) {\n\t\t\tconst a = Math.abs(A[i * chans + j]);\n\t\t\toutUMax[j] = Math.max(outUMax[j], a);\n\t\t}\n\t}\n}\nfunction normalizeGraph(A, uMax) {\n\tconst chans = uMax.length;\n\tconst values = A.length / chans;\n\tfor (let i = 0; i < values; i++) {\n\t\tfor (let j = 0; j < chans; j++) {\n\t\t\tA[i * chans + j] /= uMax[j] === 0 ? 1 : uMax[j];\n\t\t\tA[i * chans + j] *= 0.5;\n\t\t\tA[i * chans + j] += 0.5;\n\t\t}\n\t}\n}\nfunction divGraphFrom2Curves(curve1, curve2, outUMax) {\n\tconst sub = subGraph(curve2, curve1);\n\tmaxUnsignedGraphValue(sub, outUMax);\n\tnormalizeGraph(sub, outUMax);\n\treturn sub;\n}\nconst particleEmitterDeviceCache = new DeviceCache();\nclass ParticleEmitter {\n\tconstructor(graphicsDevice, options) {\n\t\tthis.graphicsDevice = graphicsDevice;\n\t\tconst gd = graphicsDevice;\n\t\tconst precision = 32;\n\t\tthis.precision = precision;\n\t\tthis._addTimeTime = 0;\n\t\tsetPropertyTarget = this;\n\t\tsetPropertyOptions = options;\n\t\tsetProperty('numParticles', 1);\n\t\tif (this.numParticles > graphicsDevice.maxTextureSize) {\n\t\t\tthis.numParticles = graphicsDevice.maxTextureSize;\n\t\t}\n\t\tsetProperty('rate', 1);\n\t\tsetProperty('rate2', this.rate);\n\t\tsetProperty('lifetime', 50);\n\t\tsetProperty('emitterExtents', new Vec3(0, 0, 0));\n\t\tsetProperty('emitterExtentsInner', new Vec3(0, 0, 0));\n\t\tsetProperty('emitterRadius', 0);\n\t\tsetProperty('emitterRadiusInner', 0);\n\t\tsetProperty('emitterShape', EMITTERSHAPE_BOX);\n\t\tsetProperty('initialVelocity', 1);\n\t\tsetProperty('wrap', false);\n\t\tsetProperty('localSpace', false);\n\t\tsetProperty('screenSpace', false);\n\t\tsetProperty('wrapBounds', null);\n\t\tsetProperty('colorMap', this.defaultParamTexture);\n\t\tsetProperty('normalMap', null);\n\t\tsetProperty('loop', true);\n\t\tsetProperty('preWarm', false);\n\t\tsetProperty('sort', PARTICLESORT_NONE);\n\t\tsetProperty('mode', PARTICLEMODE_GPU);\n\t\tsetProperty('scene', null);\n\t\tsetProperty('lighting', false);\n\t\tsetProperty('halfLambert', false);\n\t\tsetProperty('intensity', 1.0);\n\t\tsetProperty('stretch', 0.0);\n\t\tsetProperty('alignToMotion', false);\n\t\tsetProperty('depthSoftening', 0);\n\t\tsetProperty('mesh', null);\n\t\tsetProperty('particleNormal', new Vec3(0, 1, 0));\n\t\tsetProperty('orientation', PARTICLEORIENTATION_SCREEN);\n\t\tsetProperty('depthWrite', false);\n\t\tsetProperty('noFog', false);\n\t\tsetProperty('blendType', BLEND_NORMAL);\n\t\tsetProperty('node', null);\n\t\tsetProperty('startAngle', 0);\n\t\tsetProperty('startAngle2', this.startAngle);\n\t\tsetProperty('animTilesX', 1);\n\t\tsetProperty('animTilesY', 1);\n\t\tsetProperty('animStartFrame', 0);\n\t\tsetProperty('animNumFrames', 1);\n\t\tsetProperty('animNumAnimations', 1);\n\t\tsetProperty('animIndex', 0);\n\t\tsetProperty('randomizeAnimIndex', false);\n\t\tsetProperty('animSpeed', 1);\n\t\tsetProperty('animLoop', true);\n\t\tthis._gpuUpdater = new ParticleGPUUpdater(this, gd);\n\t\tthis._cpuUpdater = new ParticleCPUUpdater(this);\n\t\tthis.emitterPosUniform = new Float32Array(3);\n\t\tthis.wrapBoundsUniform = new Float32Array(3);\n\t\tthis.emitterScaleUniform = new Float32Array([1, 1, 1]);\n\t\tsetProperty('colorGraph', default1Curve3);\n\t\tsetProperty('colorGraph2', this.colorGraph);\n\t\tsetProperty('scaleGraph', default1Curve);\n\t\tsetProperty('scaleGraph2', this.scaleGraph);\n\t\tsetProperty('alphaGraph', default1Curve);\n\t\tsetProperty('alphaGraph2', this.alphaGraph);\n\t\tsetProperty('localVelocityGraph', default0Curve3);\n\t\tsetProperty('localVelocityGraph2', this.localVelocityGraph);\n\t\tsetProperty('velocityGraph', default0Curve3);\n\t\tsetProperty('velocityGraph2', this.velocityGraph);\n\t\tsetProperty('rotationSpeedGraph', default0Curve);\n\t\tsetProperty('rotationSpeedGraph2', this.rotationSpeedGraph);\n\t\tsetProperty('radialSpeedGraph', default0Curve);\n\t\tsetProperty('radialSpeedGraph2', this.radialSpeedGraph);\n\t\tthis.animTilesParams = new Float32Array(2);\n\t\tthis.animParams = new Float32Array(4);\n\t\tthis.animIndexParams = new Float32Array(2);\n\t\tthis.internalTex0 = null;\n\t\tthis.internalTex1 = null;\n\t\tthis.internalTex2 = null;\n\t\tthis.colorParam = null;\n\t\tthis.vbToSort = null;\n\t\tthis.vbOld = null;\n\t\tthis.particleDistance = null;\n\t\tthis.camera = null;\n\t\tthis.swapTex = false;\n\t\tthis.useMesh = true;\n\t\tthis.useCpu = !graphicsDevice.supportsGpuParticles;\n\t\tthis.pack8 = true;\n\t\tthis.localBounds = new BoundingBox();\n\t\tthis.worldBoundsNoTrail = new BoundingBox();\n\t\tthis.worldBoundsTrail = [new BoundingBox(), new BoundingBox()];\n\t\tthis.worldBounds = new BoundingBox();\n\t\tthis.worldBoundsSize = new Vec3();\n\t\tthis.prevWorldBoundsSize = new Vec3();\n\t\tthis.prevWorldBoundsCenter = new Vec3();\n\t\tthis.prevEmitterExtents = this.emitterExtents;\n\t\tthis.prevEmitterRadius = this.emitterRadius;\n\t\tthis.worldBoundsMul = new Vec3();\n\t\tthis.worldBoundsAdd = new Vec3();\n\t\tthis.timeToSwitchBounds = 0;\n\t\tthis.shaderParticleUpdateRespawn = null;\n\t\tthis.shaderParticleUpdateNoRespawn = null;\n\t\tthis.shaderParticleUpdateOnStop = null;\n\t\tthis.numParticleVerts = 0;\n\t\tthis.numParticleIndices = 0;\n\t\tthis.material = null;\n\t\tthis.meshInstance = null;\n\t\tthis.drawOrder = 0;\n\t\tthis.seed = Math.random();\n\t\tthis.fixedTimeStep = 1.0 / 60;\n\t\tthis.maxSubSteps = 10;\n\t\tthis.simTime = 0;\n\t\tthis.simTimeTotal = 0;\n\t\tthis.beenReset = false;\n\t\tthis._layer = null;\n\t\tthis.rebuild();\n\t}\n\tget defaultParamTexture() {\n\t\treturn particleEmitterDeviceCache.get(this.graphicsDevice, () => {\n\t\t\tconst resolution = 16;\n\t\t\tconst centerPoint = resolution * 0.5 + 0.5;\n\t\t\tconst dtex = new Float32Array(resolution * resolution * 4);\n\t\t\tfor (let y = 0; y < resolution; y++) {\n\t\t\t\tfor (let x = 0; x < resolution; x++) {\n\t\t\t\t\tconst xgrad = x + 1 - centerPoint;\n\t\t\t\t\tconst ygrad = y + 1 - centerPoint;\n\t\t\t\t\tconst c = saturate(1 - saturate(Math.sqrt(xgrad * xgrad + ygrad * ygrad) / resolution) - 0.5);\n\t\t\t\t\tconst p = y * resolution + x;\n\t\t\t\t\tdtex[p * 4] = 1;\n\t\t\t\t\tdtex[p * 4 + 1] = 1;\n\t\t\t\t\tdtex[p * 4 + 2] = 1;\n\t\t\t\t\tdtex[p * 4 + 3] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst texture = _createTexture(this.graphicsDevice, resolution, resolution, dtex, PIXELFORMAT_RGBA8, 1.0, true);\n\t\t\ttexture.minFilter = FILTER_LINEAR;\n\t\t\ttexture.magFilter = FILTER_LINEAR;\n\t\t\treturn texture;\n\t\t});\n\t}\n\tonChangeCamera() {\n\t\tthis.regenShader();\n\t\tthis.resetMaterial();\n\t}\n\tcalculateBoundsMad() {\n\t\tthis.worldBoundsMul.x = 1.0 / this.worldBoundsSize.x;\n\t\tthis.worldBoundsMul.y = 1.0 / this.worldBoundsSize.y;\n\t\tthis.worldBoundsMul.z = 1.0 / this.worldBoundsSize.z;\n\t\tthis.worldBoundsAdd.copy(this.worldBounds.center).mul(this.worldBoundsMul).mulScalar(-1);\n\t\tthis.worldBoundsAdd.x += 0.5;\n\t\tthis.worldBoundsAdd.y += 0.5;\n\t\tthis.worldBoundsAdd.z += 0.5;\n\t}\n\tcalculateWorldBounds() {\n\t\tif (!this.node) return;\n\t\tthis.prevWorldBoundsSize.copy(this.worldBoundsSize);\n\t\tthis.prevWorldBoundsCenter.copy(this.worldBounds.center);\n\t\tif (!this.useCpu) {\n\t\t\tlet recalculateLocalBounds = false;\n\t\t\tif (this.emitterShape === EMITTERSHAPE_BOX) {\n\t\t\t\trecalculateLocalBounds = !this.emitterExtents.equals(this.prevEmitterExtents);\n\t\t\t} else {\n\t\t\t\trecalculateLocalBounds = !(this.emitterRadius === this.prevEmitterRadius);\n\t\t\t}\n\t\t\tif (recalculateLocalBounds) {\n\t\t\t\tthis.calculateLocalBounds();\n\t\t\t}\n\t\t}\n\t\tconst nodeWT = this.node.getWorldTransform();\n\t\tif (this.localSpace) {\n\t\t\tthis.worldBoundsNoTrail.copy(this.localBounds);\n\t\t} else {\n\t\t\tthis.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, nodeWT);\n\t\t}\n\t\tthis.worldBoundsTrail[0].add(this.worldBoundsNoTrail);\n\t\tthis.worldBoundsTrail[1].add(this.worldBoundsNoTrail);\n\t\tconst now = this.simTimeTotal;\n\t\tif (now >= this.timeToSwitchBounds) {\n\t\t\tthis.worldBoundsTrail[0].copy(this.worldBoundsTrail[1]);\n\t\t\tthis.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);\n\t\t\tthis.timeToSwitchBounds = now + this.lifetime;\n\t\t}\n\t\tthis.worldBounds.copy(this.worldBoundsTrail[0]);\n\t\tthis.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);\n\t\tif (this.localSpace) {\n\t\t\tthis.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);\n\t\t\tthis.meshInstance.mesh.aabb.setFromTransformedAabb(this.worldBounds, nodeWT);\n\t\t} else {\n\t\t\tthis.meshInstance.aabb.copy(this.worldBounds);\n\t\t\tthis.meshInstance.mesh.aabb.copy(this.worldBounds);\n\t\t}\n\t\tthis.meshInstance._aabbVer = 1 - this.meshInstance._aabbVer;\n\t\tif (this.pack8) this.calculateBoundsMad();\n\t}\n\tresetWorldBounds() {\n\t\tif (!this.node) return;\n\t\tthis.worldBoundsNoTrail.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());\n\t\tthis.worldBoundsTrail[0].copy(this.worldBoundsNoTrail);\n\t\tthis.worldBoundsTrail[1].copy(this.worldBoundsNoTrail);\n\t\tthis.worldBounds.copy(this.worldBoundsTrail[0]);\n\t\tthis.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);\n\t\tthis.prevWorldBoundsSize.copy(this.worldBoundsSize);\n\t\tthis.prevWorldBoundsCenter.copy(this.worldBounds.center);\n\t\tthis.simTimeTotal = 0;\n\t\tthis.timeToSwitchBounds = 0;\n\t}\n\tcalculateLocalBounds() {\n\t\tlet minx = Number.MAX_VALUE;\n\t\tlet miny = Number.MAX_VALUE;\n\t\tlet minz = Number.MAX_VALUE;\n\t\tlet maxx = -Number.MAX_VALUE;\n\t\tlet maxy = -Number.MAX_VALUE;\n\t\tlet maxz = -Number.MAX_VALUE;\n\t\tlet maxR = 0;\n\t\tlet maxScale = 0;\n\t\tconst stepWeight = this.lifetime / this.precision;\n\t\tconst wVels = [this.qVelocity, this.qVelocity2];\n\t\tconst lVels = [this.qLocalVelocity, this.qLocalVelocity2];\n\t\tconst accumX = [0, 0];\n\t\tconst accumY = [0, 0];\n\t\tconst accumZ = [0, 0];\n\t\tconst accumR = [0, 0];\n\t\tconst accumW = [0, 0];\n\t\tlet x, y, z;\n\t\tfor (let i = 0; i < this.precision + 1; i++) {\n\t\t\tconst index = Math.min(i, this.precision - 1);\n\t\t\tfor (let j = 0; j < 2; j++) {\n\t\t\t\tx = lVels[j][index * 3 + 0] * stepWeight + accumX[j];\n\t\t\t\ty = lVels[j][index * 3 + 1] * stepWeight + accumY[j];\n\t\t\t\tz = lVels[j][index * 3 + 2] * stepWeight + accumZ[j];\n\t\t\t\tminx = Math.min(x, minx);\n\t\t\t\tminy = Math.min(y, miny);\n\t\t\t\tminz = Math.min(z, minz);\n\t\t\t\tmaxx = Math.max(x, maxx);\n\t\t\t\tmaxy = Math.max(y, maxy);\n\t\t\t\tmaxz = Math.max(z, maxz);\n\t\t\t\taccumX[j] = x;\n\t\t\t\taccumY[j] = y;\n\t\t\t\taccumZ[j] = z;\n\t\t\t}\n\t\t\tfor (let j = 0; j < 2; j++) {\n\t\t\t\taccumW[j] += stepWeight * Math.sqrt(wVels[j][index * 3 + 0] * wVels[j][index * 3 + 0] + wVels[j][index * 3 + 1] * wVels[j][index * 3 + 1] + wVels[j][index * 3 + 2] * wVels[j][index * 3 + 2]);\n\t\t\t}\n\t\t\taccumR[0] += this.qRadialSpeed[index] * stepWeight;\n\t\t\taccumR[1] += this.qRadialSpeed2[index] * stepWeight;\n\t\t\tmaxR = Math.max(maxR, Math.max(Math.abs(accumR[0]), Math.abs(accumR[1])));\n\t\t\tmaxScale = Math.max(maxScale, this.qScale[index]);\n\t\t}\n\t\tif (this.emitterShape === EMITTERSHAPE_BOX) {\n\t\t\tx = this.emitterExtents.x * 0.5;\n\t\t\ty = this.emitterExtents.y * 0.5;\n\t\t\tz = this.emitterExtents.z * 0.5;\n\t\t} else {\n\t\t\tx = this.emitterRadius;\n\t\t\ty = this.emitterRadius;\n\t\t\tz = this.emitterRadius;\n\t\t}\n\t\tconst w = Math.max(accumW[0], accumW[1]);\n\t\tbMin.x = minx - maxScale - x - maxR - w;\n\t\tbMin.y = miny - maxScale - y - maxR - w;\n\t\tbMin.z = minz - maxScale - z - maxR - w;\n\t\tbMax.x = maxx + maxScale + x + maxR + w;\n\t\tbMax.y = maxy + maxScale + y + maxR + w;\n\t\tbMax.z = maxz + maxScale + z + maxR + w;\n\t\tthis.localBounds.setMinMax(bMin, bMax);\n\t}\n\trebuild() {\n\t\tconst gd = this.graphicsDevice;\n\t\tif (this.colorMap === null) this.colorMap = this.defaultParamTexture;\n\t\tthis.spawnBounds = this.emitterShape === EMITTERSHAPE_BOX ? this.emitterExtents : this.emitterRadius;\n\t\tthis.useCpu = this.useCpu || this.sort > PARTICLESORT_NONE || gd.maxVertexTextures <= 1 || gd.fragmentUniformsCount < 64 || gd.forceCpuParticles || !gd.extTextureFloat;\n\t\tthis._destroyResources();\n\t\tthis.pack8 = (this.pack8 || !gd.textureFloatRenderable) && !this.useCpu;\n\t\tparticleTexHeight = this.useCpu || this.pack8 ? 4 : 2;\n\t\tthis.useMesh = false;\n\t\tif (this.mesh) {\n\t\t\tconst totalVertCount = this.numParticles * this.mesh.vertexBuffer.numVertices;\n\t\t\tif (totalVertCount > 65535) ; else {\n\t\t\t\tthis.useMesh = true;\n\t\t\t}\n\t\t}\n\t\tthis.numParticlesPot = math.nextPowerOfTwo(this.numParticles);\n\t\tthis.rebuildGraphs();\n\t\tthis.calculateLocalBounds();\n\t\tthis.resetWorldBounds();\n\t\tif (this.node) {\n\t\t\tthis.worldBounds.setFromTransformedAabb(this.localBounds, this.localSpace ? Mat4.IDENTITY : this.node.getWorldTransform());\n\t\t\tthis.worldBoundsTrail[0].copy(this.worldBounds);\n\t\t\tthis.worldBoundsTrail[1].copy(this.worldBounds);\n\t\t\tthis.worldBoundsSize.copy(this.worldBounds.halfExtents).mulScalar(2);\n\t\t\tthis.prevWorldBoundsSize.copy(this.worldBoundsSize);\n\t\t\tthis.prevWorldBoundsCenter.copy(this.worldBounds.center);\n\t\t\tif (this.pack8) this.calculateBoundsMad();\n\t\t}\n\t\tthis.vbToSort = new Array(this.numParticles);\n\t\tfor (let iSort = 0; iSort < this.numParticles; iSort++) this.vbToSort[iSort] = [0, 0];\n\t\tthis.particleDistance = new Float32Array(this.numParticles);\n\t\tthis._gpuUpdater.randomize();\n\t\tthis.particleTex = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);\n\t\tconst emitterPos = this.node === null || this.localSpace ? Vec3.ZERO : this.node.getPosition();\n\t\tif (this.emitterShape === EMITTERSHAPE_BOX) {\n\t\t\tif (this.node === null || this.localSpace) {\n\t\t\t\tspawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.spawnBounds);\n\t\t\t} else {\n\t\t\t\tspawnMatrix.setTRS(Vec3.ZERO, this.node.getRotation(), tmpVec3.copy(this.spawnBounds).mul(this.node.localScale));\n\t\t\t}\n\t\t\textentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;\n\t\t\textentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;\n\t\t\textentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;\n\t\t}\n\t\tfor (let i = 0; i < this.numParticles; i++) {\n\t\t\tthis._cpuUpdater.calcSpawnPosition(this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, i);\n\t\t\tif (this.useCpu) this.particleTex[i * particleTexChannels + 3 + this.numParticlesPot * 2 * particleTexChannels] = 1;\n\t\t}\n\t\tthis.particleTexStart = new Float32Array(this.numParticlesPot * particleTexHeight * particleTexChannels);\n\t\tfor (let i = 0; i < this.particleTexStart.length; i++) {\n\t\t\tthis.particleTexStart[i] = this.particleTex[i];\n\t\t}\n\t\tif (!this.useCpu) {\n\t\t\tif (this.pack8) {\n\t\t\t\tthis.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_RGBA8, 1, false);\n\t\t\t\tthis.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex, PIXELFORMAT_RGBA8, 1, false);\n\t\t\t\tthis.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart, PIXELFORMAT_RGBA8, 1, false);\n\t\t\t} else {\n\t\t\t\tthis.particleTexIN = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);\n\t\t\t\tthis.particleTexOUT = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTex);\n\t\t\t\tthis.particleTexStart = _createTexture(gd, this.numParticlesPot, particleTexHeight, this.particleTexStart);\n\t\t\t}\n\t\t\tthis.rtParticleTexIN = new RenderTarget({\n\t\t\t\tcolorBuffer: this.particleTexIN,\n\t\t\t\tdepth: false\n\t\t\t});\n\t\t\tthis.rtParticleTexOUT = new RenderTarget({\n\t\t\t\tcolorBuffer: this.particleTexOUT,\n\t\t\t\tdepth: false\n\t\t\t});\n\t\t\tthis.swapTex = false;\n\t\t}\n\t\tconst shaderCodeStart = (this.localSpace ? '#define LOCAL_SPACE\\n' : '') + shaderChunks.particleUpdaterInitPS + (this.pack8 ? shaderChunks.particleInputRgba8PS + shaderChunks.particleOutputRgba8PS : shaderChunks.particleInputFloatPS + shaderChunks.particleOutputFloatPS) + (this.emitterShape === EMITTERSHAPE_BOX ? shaderChunks.particleUpdaterAABBPS : shaderChunks.particleUpdaterSpherePS) + shaderChunks.particleUpdaterStartPS;\n\t\tconst shaderCodeRespawn = shaderCodeStart + shaderChunks.particleUpdaterRespawnPS + shaderChunks.particleUpdaterEndPS;\n\t\tconst shaderCodeNoRespawn = shaderCodeStart + shaderChunks.particleUpdaterNoRespawnPS + shaderChunks.particleUpdaterEndPS;\n\t\tconst shaderCodeOnStop = shaderCodeStart + shaderChunks.particleUpdaterOnStopPS + shaderChunks.particleUpdaterEndPS;\n\t\tconst params = `${this.emitterShape}${this.pack8}${this.localSpace}`;\n\t\tthis.shaderParticleUpdateRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeRespawn, `fsQuad0${params}`);\n\t\tthis.shaderParticleUpdateNoRespawn = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeNoRespawn, `fsQuad1${params}`);\n\t\tthis.shaderParticleUpdateOnStop = createShaderFromCode(gd, shaderChunks.fullscreenQuadVS, shaderCodeOnStop, `fsQuad2${params}`);\n\t\tthis.numParticleVerts = this.useMesh ? this.mesh.vertexBuffer.numVertices : 4;\n\t\tthis.numParticleIndices = this.useMesh ? this.mesh.indexBuffer[0].numIndices : 6;\n\t\tthis._allocate(this.numParticles);\n\t\tconst mesh = new Mesh(gd);\n\t\tmesh.vertexBuffer = this.vertexBuffer;\n\t\tmesh.indexBuffer[0] = this.indexBuffer;\n\t\tmesh.primitive[0].type = PRIMITIVE_TRIANGLES;\n\t\tmesh.primitive[0].base = 0;\n\t\tmesh.primitive[0].count = this.numParticles * this.numParticleIndices;\n\t\tmesh.primitive[0].indexed = true;\n\t\tthis.material = new Material();\n\t\tthis.material.name = this.node.name;\n\t\tthis.material.cull = CULLFACE_NONE;\n\t\tthis.material.alphaWrite = false;\n\t\tthis.material.blendType = this.blendType;\n\t\tthis.material.depthWrite = this.depthWrite;\n\t\tthis.material.emitter = this;\n\t\tthis.regenShader();\n\t\tthis.resetMaterial();\n\t\tconst wasVisible = this.meshInstance ? this.meshInstance.visible : true;\n\t\tthis.meshInstance = new MeshInstance(mesh, this.material, this.node);\n\t\tthis.meshInstance.pick = false;\n\t\tthis.meshInstance.updateKey();\n\t\tthis.meshInstance.cull = true;\n\t\tif (this.localSpace) {\n\t\t\tthis.meshInstance.aabb.setFromTransformedAabb(this.worldBounds, this.node.getWorldTransform());\n\t\t} else {\n\t\t\tthis.meshInstance.aabb.copy(this.worldBounds);\n\t\t}\n\t\tthis.meshInstance._updateAabb = false;\n\t\tthis.meshInstance.visible = wasVisible;\n\t\tthis._initializeTextures();\n\t\tthis.resetTime();\n\t\tthis.addTime(0, false);\n\t\tif (this.preWarm) this.prewarm(this.lifetime);\n\t}\n\t_isAnimated() {\n\t\treturn this.animNumFrames >= 1 && (this.animTilesX > 1 || this.animTilesY > 1) && (this.colorMap && this.colorMap !== this.defaultParamTexture || this.normalMap);\n\t}\n\trebuildGraphs() {\n\t\tconst precision = this.precision;\n\t\tconst gd = this.graphicsDevice;\n\t\tthis.qLocalVelocity = this.localVelocityGraph.quantize(precision);\n\t\tthis.qVelocity = this.velocityGraph.quantize(precision);\n\t\tthis.qColor = this.colorGraph.quantizeClamped(precision, 0, 1);\n\t\tthis.qRotSpeed = this.rotationSpeedGraph.quantize(precision);\n\t\tthis.qScale = this.scaleGraph.quantize(precision);\n\t\tthis.qAlpha = this.alphaGraph.quantize(precision);\n\t\tthis.qRadialSpeed = this.radialSpeedGraph.quantize(precision);\n\t\tthis.qLocalVelocity2 = this.localVelocityGraph2.quantize(precision);\n\t\tthis.qVelocity2 = this.velocityGraph2.quantize(precision);\n\t\tthis.qColor2 = this.colorGraph2.quantizeClamped(precision, 0, 1);\n\t\tthis.qRotSpeed2 = this.rotationSpeedGraph2.quantize(precision);\n\t\tthis.qScale2 = this.scaleGraph2.quantize(precision);\n\t\tthis.qAlpha2 = this.alphaGraph2.quantize(precision);\n\t\tthis.qRadialSpeed2 = this.radialSpeedGraph2.quantize(precision);\n\t\tfor (let i = 0; i < precision; i++) {\n\t\t\tthis.qRotSpeed[i] *= math.DEG_TO_RAD;\n\t\t\tthis.qRotSpeed2[i] *= math.DEG_TO_RAD;\n\t\t}\n\t\tthis.localVelocityUMax = new Float32Array(3);\n\t\tthis.velocityUMax = new Float32Array(3);\n\t\tthis.colorUMax = new Float32Array(3);\n\t\tthis.rotSpeedUMax = [0];\n\t\tthis.scaleUMax = [0];\n\t\tthis.alphaUMax = [0];\n\t\tthis.radialSpeedUMax = [0];\n\t\tthis.qLocalVelocityDiv = divGraphFrom2Curves(this.qLocalVelocity, this.qLocalVelocity2, this.localVelocityUMax);\n\t\tthis.qVelocityDiv = divGraphFrom2Curves(this.qVelocity, this.qVelocity2, this.velocityUMax);\n\t\tthis.qColorDiv = divGraphFrom2Curves(this.qColor, this.qColor2, this.colorUMax);\n\t\tthis.qRotSpeedDiv = divGraphFrom2Curves(this.qRotSpeed, this.qRotSpeed2, this.rotSpeedUMax);\n\t\tthis.qScaleDiv = divGraphFrom2Curves(this.qScale, this.qScale2, this.scaleUMax);\n\t\tthis.qAlphaDiv = divGraphFrom2Curves(this.qAlpha, this.qAlpha2, this.alphaUMax);\n\t\tthis.qRadialSpeedDiv = divGraphFrom2Curves(this.qRadialSpeed, this.qRadialSpeed2, this.radialSpeedUMax);\n\t\tif (this.pack8) {\n\t\t\tconst umax = [0, 0, 0];\n\t\t\tmaxUnsignedGraphValue(this.qVelocity, umax);\n\t\t\tconst umax2 = [0, 0, 0];\n\t\t\tmaxUnsignedGraphValue(this.qVelocity2, umax2);\n\t\t\tconst lumax = [0, 0, 0];\n\t\t\tmaxUnsignedGraphValue(this.qLocalVelocity, lumax);\n\t\t\tconst lumax2 = [0, 0, 0];\n\t\t\tmaxUnsignedGraphValue(this.qLocalVelocity2, lumax2);\n\t\t\tconst rumax = [0];\n\t\t\tmaxUnsignedGraphValue(this.qRadialSpeed, rumax);\n\t\t\tconst rumax2 = [0];\n\t\t\tmaxUnsignedGraphValue(this.qRadialSpeed2, rumax2);\n\t\t\tlet maxVel = Math.max(umax[0], umax2[0]);\n\t\t\tmaxVel = Math.max(maxVel, umax[1]);\n\t\t\tmaxVel = Math.max(maxVel, umax2[1]);\n\t\t\tmaxVel = Math.max(maxVel, umax[2]);\n\t\t\tmaxVel = Math.max(maxVel, umax2[2]);\n\t\t\tlet lmaxVel = Math.max(lumax[0], lumax2[0]);\n\t\t\tlmaxVel = Math.max(lmaxVel, lumax[1]);\n\t\t\tlmaxVel = Math.max(lmaxVel, lumax2[1]);\n\t\t\tlmaxVel = Math.max(lmaxVel, lumax[2]);\n\t\t\tlmaxVel = Math.max(lmaxVel, lumax2[2]);\n\t\t\tconst maxRad = Math.max(rumax[0], rumax2[0]);\n\t\t\tthis.maxVel = maxVel + lmaxVel + maxRad;\n\t\t}\n\t\tif (!this.useCpu) {\n\t\t\tthis.internalTex0 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qLocalVelocity, this.qLocalVelocityDiv));\n\t\t\tthis.internalTex1 = _createTexture(gd, precision, 1, packTextureXYZ_NXYZ(this.qVelocity, this.qVelocityDiv));\n\t\t\tthis.internalTex2 = _createTexture(gd, precision, 1, packTexture5Floats(this.qRotSpeed, this.qScale, this.qScaleDiv, this.qRotSpeedDiv, this.qAlphaDiv));\n\t\t\tthis.internalTex3 = _createTexture(gd, precision, 1, packTexture2Floats(this.qRadialSpeed, this.qRadialSpeedDiv));\n\t\t}\n\t\tthis.colorParam = _createTexture(gd, precision, 1, packTextureRGBA(this.qColor, this.qAlpha), PIXELFORMAT_RGBA8, 1.0, true);\n\t}\n\t_initializeTextures() {\n\t\tif (this.colorMap) {\n\t\t\tthis.material.setParameter('colorMap', this.colorMap);\n\t\t\tif (this.lighting && this.normalMap) {\n\t\t\t\tthis.material.setParameter('normalMap', this.normalMap);\n\t\t\t}\n\t\t}\n\t}\n\tregenShader() {\n\t\tconst programLib = getProgramLibrary(this.graphicsDevice);\n\t\tprogramLib.register('particle', particle);\n\t\tconst hasNormal = this.normalMap !== null;\n\t\tthis.normalOption = 0;\n\t\tif (this.lighting) {\n\t\t\tthis.normalOption = hasNormal ? 2 : 1;\n\t\t}\n\t\tthis.material.getShaderVariant = function (dev, sc, defs, unused, pass, sortedLights, viewUniformFormat, viewBindGroupFormat) {\n\t\t\tif (this.emitter.scene) {\n\t\t\t\tif (this.emitter.camera !== this.emitter.scene._activeCamera) {\n\t\t\t\t\tthis.emitter.camera = this.emitter.scene._activeCamera;\n\t\t\t\t\tthis.emitter.onChangeCamera();\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst inTools = this.emitter.inTools;\n\t\t\tconst processingOptions = new ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat);\n\t\t\tconst shader = programLib.getProgram('particle', {\n\t\t\t\tpass: SHADER_FORWARD,\n\t\t\t\tuseCpu: this.emitter.useCpu,\n\t\t\t\tnormal: this.emitter.normalOption,\n\t\t\t\thalflambert: this.emitter.halfLambert,\n\t\t\t\tstretch: this.emitter.stretch,\n\t\t\t\talignToMotion: this.emitter.alignToMotion,\n\t\t\t\tsoft: this.emitter.depthSoftening,\n\t\t\t\tmesh: this.emitter.useMesh,\n\t\t\t\tgamma: this.emitter.scene ? this.emitter.scene.gammaCorrection : 0,\n\t\t\t\ttoneMap: this.emitter.scene ? this.emitter.scene.toneMapping : 0,\n\t\t\t\tfog: this.emitter.scene && !this.emitter.noFog ? this.emitter.scene.fog : 'none',\n\t\t\t\twrap: this.emitter.wrap && this.emitter.wrapBounds,\n\t\t\t\tlocalSpace: this.emitter.localSpace,\n\t\t\t\tscreenSpace: inTools ? false : this.emitter.screenSpace,\n\t\t\t\tblend: this.blendType,\n\t\t\t\tanimTex: this.emitter._isAnimated(),\n\t\t\t\tanimTexLoop: this.emitter.animLoop,\n\t\t\t\tpack8: this.emitter.pack8,\n\t\t\t\tcustomFace: this.emitter.orientation !== PARTICLEORIENTATION_SCREEN\n\t\t\t}, processingOptions);\n\t\t\treturn shader;\n\t\t};\n\t\tthis.material.shader = this.material.getShaderVariant();\n\t}\n\tresetMaterial() {\n\t\tconst material = this.material;\n\t\tmaterial.setParameter('stretch', this.stretch);\n\t\tif (this._isAnimated()) {\n\t\t\tmaterial.setParameter('animTexTilesParams', this.animTilesParams);\n\t\t\tmaterial.setParameter('animTexParams', this.animParams);\n\t\t\tmaterial.setParameter('animTexIndexParams', this.animIndexParams);\n\t\t}\n\t\tmaterial.setParameter('colorMult', this.intensity);\n\t\tif (!this.useCpu) {\n\t\t\tmaterial.setParameter('internalTex0', this.internalTex0);\n\t\t\tmaterial.setParameter('internalTex1', this.internalTex1);\n\t\t\tmaterial.setParameter('internalTex2', this.internalTex2);\n\t\t\tmaterial.setParameter('internalTex3', this.internalTex3);\n\t\t}\n\t\tmaterial.setParameter('colorParam', this.colorParam);\n\t\tmaterial.setParameter('numParticles', this.numParticles);\n\t\tmaterial.setParameter('numParticlesPot', this.numParticlesPot);\n\t\tmaterial.setParameter('lifetime', this.lifetime);\n\t\tmaterial.setParameter('rate', this.rate);\n\t\tmaterial.setParameter('rateDiv', this.rate2 - this.rate);\n\t\tmaterial.setParameter('seed', this.seed);\n\t\tmaterial.setParameter('scaleDivMult', this.scaleUMax[0]);\n\t\tmaterial.setParameter('alphaDivMult', this.alphaUMax[0]);\n\t\tmaterial.setParameter('radialSpeedDivMult', this.radialSpeedUMax[0]);\n\t\tmaterial.setParameter('graphNumSamples', this.precision);\n\t\tmaterial.setParameter('graphSampleSize', 1.0 / this.precision);\n\t\tmaterial.setParameter('emitterScale', new Float32Array([1, 1, 1]));\n\t\tif (this.pack8) {\n\t\t\tthis._gpuUpdater._setInputBounds();\n\t\t\tmaterial.setParameter('inBoundsSize', this._gpuUpdater.inBoundsSizeUniform);\n\t\t\tmaterial.setParameter('inBoundsCenter', this._gpuUpdater.inBoundsCenterUniform);\n\t\t\tmaterial.setParameter('maxVel', this.maxVel);\n\t\t}\n\t\tif (this.wrap && this.wrapBounds) {\n\t\t\tthis.wrapBoundsUniform[0] = this.wrapBounds.x;\n\t\t\tthis.wrapBoundsUniform[1] = this.wrapBounds.y;\n\t\t\tthis.wrapBoundsUniform[2] = this.wrapBounds.z;\n\t\t\tmaterial.setParameter('wrapBounds', this.wrapBoundsUniform);\n\t\t}\n\t\tif (this.colorMap) {\n\t\t\tmaterial.setParameter('colorMap', this.colorMap);\n\t\t}\n\t\tif (this.lighting) {\n\t\t\tif (this.normalMap) {\n\t\t\t\tmaterial.setParameter('normalMap', this.normalMap);\n\t\t\t}\n\t\t}\n\t\tif (this.depthSoftening > 0) {\n\t\t\tmaterial.setParameter('softening', 1.0 / (this.depthSoftening * this.depthSoftening * 100));\n\t\t}\n\t\tif (this.stretch > 0.0) material.cull = CULLFACE_NONE;\n\t\tthis._compParticleFaceParams();\n\t}\n\t_compParticleFaceParams() {\n\t\tlet tangent, binormal;\n\t\tif (this.orientation === PARTICLEORIENTATION_SCREEN) {\n\t\t\ttangent = new Float32Array([1, 0, 0]);\n\t\t\tbinormal = new Float32Array([0, 0, 1]);\n\t\t} else {\n\t\t\tlet n;\n\t\t\tif (this.orientation === PARTICLEORIENTATION_WORLD) {\n\t\t\t\tn = this.particleNormal.normalize();\n\t\t\t} else {\n\t\t\t\tconst emitterMat = this.node === null ? Mat4.IDENTITY : this.node.getWorldTransform();\n\t\t\t\tn = emitterMat.transformVector(this.particleNormal).normalize();\n\t\t\t}\n\t\t\tconst t = new Vec3(1, 0, 0);\n\t\t\tif (Math.abs(t.dot(n)) === 1) {\n\t\t\t\tt.set(0, 0, 1);\n\t\t\t}\n\t\t\tconst b = new Vec3().cross(n, t).normalize();\n\t\t\tt.cross(b, n).normalize();\n\t\t\ttangent = new Float32Array([t.x, t.y, t.z]);\n\t\t\tbinormal = new Float32Array([b.x, b.y, b.z]);\n\t\t}\n\t\tthis.material.setParameter('faceTangent', tangent);\n\t\tthis.material.setParameter('faceBinorm', binormal);\n\t}\n\t_allocate(numParticles) {\n\t\tconst psysVertCount = numParticles * this.numParticleVerts;\n\t\tconst psysIndexCount = numParticles * this.numParticleIndices;\n\t\tif (this.vertexBuffer === undefined || this.vertexBuffer.getNumVertices() !== psysVertCount) {\n\t\t\tif (!this.useCpu) {\n\t\t\t\tconst elements = [{\n\t\t\t\t\tsemantic: SEMANTIC_ATTR0,\n\t\t\t\t\tcomponents: 4,\n\t\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t\t}];\n\t\t\t\tif (this.useMesh) {\n\t\t\t\t\telements.push({\n\t\t\t\t\t\tsemantic: SEMANTIC_ATTR1,\n\t\t\t\t\t\tcomponents: 2,\n\t\t\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tconst particleFormat = new VertexFormat(this.graphicsDevice, elements);\n\t\t\t\tthis.vertexBuffer = new VertexBuffer(this.graphicsDevice, particleFormat, psysVertCount, {\n\t\t\t\t\tusage: BUFFER_DYNAMIC\n\t\t\t\t});\n\t\t\t\tthis.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT16, psysIndexCount);\n\t\t\t} else {\n\t\t\t\tconst elements = [{\n\t\t\t\t\tsemantic: SEMANTIC_ATTR0,\n\t\t\t\t\tcomponents: 4,\n\t\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t\t}, {\n\t\t\t\t\tsemantic: SEMANTIC_ATTR1,\n\t\t\t\t\tcomponents: 4,\n\t\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t\t}, {\n\t\t\t\t\tsemantic: SEMANTIC_ATTR2,\n\t\t\t\t\tcomponents: 4,\n\t\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t\t}, {\n\t\t\t\t\tsemantic: SEMANTIC_ATTR3,\n\t\t\t\t\tcomponents: 1,\n\t\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t\t}, {\n\t\t\t\t\tsemantic: SEMANTIC_ATTR4,\n\t\t\t\t\tcomponents: this.useMesh ? 4 : 2,\n\t\t\t\t\ttype: TYPE_FLOAT32\n\t\t\t\t}];\n\t\t\t\tconst particleFormat = new VertexFormat(this.graphicsDevice, elements);\n\t\t\t\tthis.vertexBuffer = new VertexBuffer(this.graphicsDevice, particleFormat, psysVertCount, {\n\t\t\t\t\tusage: BUFFER_DYNAMIC\n\t\t\t\t});\n\t\t\t\tthis.indexBuffer = new IndexBuffer(this.graphicsDevice, INDEXFORMAT_UINT16, psysIndexCount);\n\t\t\t}\n\t\t\tconst data = new Float32Array(this.vertexBuffer.lock());\n\t\t\tlet meshData, stride, texCoordOffset;\n\t\t\tif (this.useMesh) {\n\t\t\t\tmeshData = new Float32Array(this.mesh.vertexBuffer.lock());\n\t\t\t\tstride = meshData.length / this.mesh.vertexBuffer.numVertices;\n\t\t\t\tfor (let elem = 0; elem < this.mesh.vertexBuffer.format.elements.length; elem++) {\n\t\t\t\t\tif (this.mesh.vertexBuffer.format.elements[elem].name === SEMANTIC_TEXCOORD0) {\n\t\t\t\t\t\ttexCoordOffset = this.mesh.vertexBuffer.format.elements[elem].offset / 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i = 0; i < psysVertCount; i++) {\n\t\t\t\tconst id = Math.floor(i / this.numParticleVerts);\n\t\t\t\tif (!this.useMesh) {\n\t\t\t\t\tconst vertID = i % 4;\n\t\t\t\t\tdata[i * 4] = particleVerts[vertID][0];\n\t\t\t\t\tdata[i * 4 + 1] = particleVerts[vertID][1];\n\t\t\t\t\tdata[i * 4 + 2] = 0;\n\t\t\t\t\tdata[i * 4 + 3] = id;\n\t\t\t\t} else {\n\t\t\t\t\tconst vert = i % this.numParticleVerts;\n\t\t\t\t\tdata[i * 6] = meshData[vert * stride];\n\t\t\t\t\tdata[i * 6 + 1] = meshData[vert * stride + 1];\n\t\t\t\t\tdata[i * 6 + 2] = meshData[vert * stride + 2];\n\t\t\t\t\tdata[i * 6 + 3] = id;\n\t\t\t\t\tdata[i * 6 + 4] = meshData[vert * stride + texCoordOffset + 0];\n\t\t\t\t\tdata[i * 6 + 5] = 1.0 - meshData[vert * stride + texCoordOffset + 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this.useCpu) {\n\t\t\t\tthis.vbCPU = new Float32Array(data);\n\t\t\t\tthis.vbOld = new Float32Array(this.vbCPU.length);\n\t\t\t}\n\t\t\tthis.vertexBuffer.unlock();\n\t\t\tif (this.useMesh) {\n\t\t\t\tthis.mesh.vertexBuffer.unlock();\n\t\t\t}\n\t\t\tlet dst = 0;\n\t\t\tconst indices = new Uint16Array(this.indexBuffer.lock());\n\t\t\tif (this.useMesh) meshData = new Uint16Array(this.mesh.indexBuffer[0].lock());\n\t\t\tfor (let i = 0; i < numParticles; i++) {\n\t\t\t\tif (!this.useMesh) {\n\t\t\t\t\tconst baseIndex = i * 4;\n\t\t\t\t\tindices[dst++] = baseIndex;\n\t\t\t\t\tindices[dst++] = baseIndex + 1;\n\t\t\t\t\tindices[dst++] = baseIndex + 2;\n\t\t\t\t\tindices[dst++] = baseIndex;\n\t\t\t\t\tindices[dst++] = baseIndex + 2;\n\t\t\t\t\tindices[dst++] = baseIndex + 3;\n\t\t\t\t} else {\n\t\t\t\t\tfor (let j = 0; j < this.numParticleIndices; j++) {\n\t\t\t\t\t\tindices[i * this.numParticleIndices + j] = meshData[j] + i * this.numParticleVerts;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.indexBuffer.unlock();\n\t\t\tif (this.useMesh) this.mesh.indexBuffer[0].unlock();\n\t\t}\n\t}\n\treset() {\n\t\tthis.beenReset = true;\n\t\tthis.seed = Math.random();\n\t\tthis.material.setParameter('seed', this.seed);\n\t\tif (this.useCpu) {\n\t\t\tfor (let i = 0; i < this.particleTexStart.length; i++) {\n\t\t\t\tthis.particleTex[i] = this.particleTexStart[i];\n\t\t\t}\n\t\t} else {\n\t\t\tthis._initializeTextures();\n\t\t}\n\t\tthis.resetWorldBounds();\n\t\tthis.resetTime();\n\t\tconst origLoop = this.loop;\n\t\tthis.loop = true;\n\t\tthis.addTime(0, false);\n\t\tthis.loop = origLoop;\n\t\tif (this.preWarm) {\n\t\t\tthis.prewarm(this.lifetime);\n\t\t}\n\t}\n\tprewarm(time) {\n\t\tconst lifetimeFraction = time / this.lifetime;\n\t\tconst iterations = Math.min(Math.floor(lifetimeFraction * this.precision), this.precision);\n\t\tconst stepDelta = time / iterations;\n\t\tfor (let i = 0; i < iterations; i++) {\n\t\t\tthis.addTime(stepDelta, false);\n\t\t}\n\t}\n\tresetTime() {\n\t\tthis.endTime = calcEndTime(this);\n\t}\n\tfinishFrame() {\n\t\tif (this.useCpu) this.vertexBuffer.unlock();\n\t}\n\taddTime(delta, isOnStop) {\n\t\tconst device = this.graphicsDevice;\n\t\tthis.simTimeTotal += delta;\n\t\tthis.calculateWorldBounds();\n\t\tif (this._isAnimated()) {\n\t\t\tconst tilesParams = this.animTilesParams;\n\t\t\ttilesParams[0] = 1.0 / this.animTilesX;\n\t\t\ttilesParams[1] = 1.0 / this.animTilesY;\n\t\t\tconst params = this.animParams;\n\t\t\tparams[0] = this.animStartFrame;\n\t\t\tparams[1] = this.animNumFrames * this.animSpeed;\n\t\t\tparams[2] = this.animNumFrames - 1;\n\t\t\tparams[3] = this.animNumAnimations - 1;\n\t\t\tconst animIndexParams = this.animIndexParams;\n\t\t\tanimIndexParams[0] = this.animIndex;\n\t\t\tanimIndexParams[1] = this.randomizeAnimIndex;\n\t\t}\n\t\tif (this.scene) {\n\t\t\tif (this.camera !== this.scene._activeCamera) {\n\t\t\t\tthis.camera = this.scene._activeCamera;\n\t\t\t\tthis.onChangeCamera();\n\t\t\t}\n\t\t}\n\t\tif (this.emitterShape === EMITTERSHAPE_BOX) {\n\t\t\textentsInnerRatioUniform[0] = this.emitterExtents.x !== 0 ? this.emitterExtentsInner.x / this.emitterExtents.x : 0;\n\t\t\textentsInnerRatioUniform[1] = this.emitterExtents.y !== 0 ? this.emitterExtentsInner.y / this.emitterExtents.y : 0;\n\t\t\textentsInnerRatioUniform[2] = this.emitterExtents.z !== 0 ? this.emitterExtentsInner.z / this.emitterExtents.z : 0;\n\t\t\tif (this.meshInstance.node === null) {\n\t\t\t\tspawnMatrix.setTRS(Vec3.ZERO, Quat.IDENTITY, this.emitterExtents);\n\t\t\t} else {\n\t\t\t\tspawnMatrix.setTRS(Vec3.ZERO, this.meshInstance.node.getRotation(), tmpVec3.copy(this.emitterExtents).mul(this.meshInstance.node.localScale));\n\t\t\t}\n\t\t}\n\t\tlet emitterPos;\n\t\tconst emitterScale = this.meshInstance.node === null ? Vec3.ONE : this.meshInstance.node.localScale;\n\t\tthis.emitterScaleUniform[0] = emitterScale.x;\n\t\tthis.emitterScaleUniform[1] = emitterScale.y;\n\t\tthis.emitterScaleUniform[2] = emitterScale.z;\n\t\tthis.material.setParameter('emitterScale', this.emitterScaleUniform);\n\t\tif (this.localSpace && this.meshInstance.node) {\n\t\t\temitterPos = this.meshInstance.node.getPosition();\n\t\t\tthis.emitterPosUniform[0] = emitterPos.x;\n\t\t\tthis.emitterPosUniform[1] = emitterPos.y;\n\t\t\tthis.emitterPosUniform[2] = emitterPos.z;\n\t\t\tthis.material.setParameter('emitterPos', this.emitterPosUniform);\n\t\t}\n\t\tthis._compParticleFaceParams();\n\t\tif (!this.useCpu) {\n\t\t\tthis._gpuUpdater.update(device, spawnMatrix, extentsInnerRatioUniform, delta, isOnStop);\n\t\t} else {\n\t\t\tconst data = new Float32Array(this.vertexBuffer.lock());\n\t\t\tthis._cpuUpdater.update(data, this.vbToSort, this.particleTex, spawnMatrix, extentsInnerRatioUniform, emitterPos, delta, isOnStop);\n\t\t}\n\t\tif (!this.loop) {\n\t\t\tif (Date.now() > this.endTime) {\n\t\t\t\tif (this.onFinished) this.onFinished();\n\t\t\t\tthis.meshInstance.visible = false;\n\t\t\t}\n\t\t}\n\t\tif (this.meshInstance) {\n\t\t\tthis.meshInstance.drawOrder = this.drawOrder;\n\t\t}\n\t}\n\t_destroyResources() {\n\t\tif (this.particleTexIN) {\n\t\t\tthis.particleTexIN.destroy();\n\t\t\tthis.particleTexIN = null;\n\t\t}\n\t\tif (this.particleTexOUT) {\n\t\t\tthis.particleTexOUT.destroy();\n\t\t\tthis.particleTexOUT = null;\n\t\t}\n\t\tif (this.particleTexStart && this.particleTexStart.destroy) {\n\t\t\tthis.particleTexStart.destroy();\n\t\t\tthis.particleTexStart = null;\n\t\t}\n\t\tif (this.rtParticleTexIN) {\n\t\t\tthis.rtParticleTexIN.destroy();\n\t\t\tthis.rtParticleTexIN = null;\n\t\t}\n\t\tif (this.rtParticleTexOUT) {\n\t\t\tthis.rtParticleTexOUT.destroy();\n\t\t\tthis.rtParticleTexOUT = null;\n\t\t}\n\t\tif (this.internalTex0) {\n\t\t\tthis.internalTex0.destroy();\n\t\t\tthis.internalTex0 = null;\n\t\t}\n\t\tif (this.internalTex1) {\n\t\t\tthis.internalTex1.destroy();\n\t\t\tthis.internalTex1 = null;\n\t\t}\n\t\tif (this.internalTex2) {\n\t\t\tthis.internalTex2.destroy();\n\t\t\tthis.internalTex2 = null;\n\t\t}\n\t\tif (this.internalTex3) {\n\t\t\tthis.internalTex3.destroy();\n\t\t\tthis.internalTex3 = null;\n\t\t}\n\t\tif (this.colorParam) {\n\t\t\tthis.colorParam.destroy();\n\t\t\tthis.colorParam = null;\n\t\t}\n\t\tif (this.vertexBuffer) {\n\t\t\tthis.vertexBuffer.destroy();\n\t\t\tthis.vertexBuffer = undefined;\n\t\t}\n\t\tif (this.indexBuffer) {\n\t\t\tthis.indexBuffer.destroy();\n\t\t\tthis.indexBuffer = undefined;\n\t\t}\n\t\tif (this.material) {\n\t\t\tthis.material.destroy();\n\t\t\tthis.material = null;\n\t\t}\n\t}\n\tdestroy() {\n\t\tthis.camera = null;\n\t\tthis._destroyResources();\n\t}\n}\n\nexport { ParticleEmitter };\n","import { EventHandler } from '../core/event-handler.js';\n\nclass Render extends EventHandler {\n\tconstructor() {\n\t\tsuper();\n\t\tthis._meshes = null;\n\t}\n\tset meshes(value) {\n\t\tthis.decRefMeshes();\n\t\tthis._meshes = value;\n\t\tthis.incRefMeshes();\n\t\tthis.fire('set:meshes', value);\n\t}\n\tget meshes() {\n\t\treturn this._meshes;\n\t}\n\tdestroy() {\n\t\tthis.meshes = null;\n\t}\n\tdecRefMeshes() {\n\t\tif (this._meshes) {\n\t\t\tconst count = this._meshes.length;\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst mesh = this._meshes[i];\n\t\t\t\tif (mesh) {\n\t\t\t\t\tmesh.decRefCount();\n\t\t\t\t\tif (mesh.refCount < 1) {\n\t\t\t\t\t\tmesh.destroy();\n\t\t\t\t\t\tthis._meshes[i] = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tincRefMeshes() {\n\t\tif (this._meshes) {\n\t\t\tconst count = this._meshes.length;\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tif (this._meshes[i]) {\n\t\t\t\t\tthis._meshes[i].incRefCount();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nRender.EVENT_SETMESHES = 'set:meshes';\n\nexport { Render };\n","import { Vec3 } from '../../core/math/vec3.js';\nimport { LIGHTSHAPE_PUNCTUAL, LIGHTTYPE_OMNI, LIGHTTYPE_SPOT, LIGHTTYPE_DIRECTIONAL, FOG_NONE, FOG_LINEAR, LAYERID_DEPTH } from '../constants.js';\nimport { Renderer } from './renderer.js';\nimport { LightCamera } from './light-camera.js';\nimport { RenderPassForward } from './render-pass-forward.js';\nimport { RenderPassPostprocessing } from './render-pass-postprocessing.js';\n\nconst _noLights = [[], [], []];\nconst _drawCallList = {\n\tdrawCalls: [],\n\tshaderInstances: [],\n\tisNewMaterial: [],\n\tlightMaskChanged: [],\n\tclear: function () {\n\t\tthis.drawCalls.length = 0;\n\t\tthis.shaderInstances.length = 0;\n\t\tthis.isNewMaterial.length = 0;\n\t\tthis.lightMaskChanged.length = 0;\n\t}\n};\nfunction vogelDiskPrecalculationSamples(numSamples) {\n\tconst samples = [];\n\tfor (let i = 0; i < numSamples; ++i) {\n\t\tconst r = Math.sqrt(i + 0.5) / Math.sqrt(numSamples);\n\t\tsamples.push(r);\n\t}\n\treturn samples;\n}\nfunction vogelSpherePrecalculationSamples(numSamples) {\n\tconst samples = [];\n\tfor (let i = 0; i < numSamples; i++) {\n\t\tconst weight = i / numSamples;\n\t\tconst radius = Math.sqrt(1.0 - weight * weight);\n\t\tsamples.push(radius);\n\t}\n\treturn samples;\n}\nclass ForwardRenderer extends Renderer {\n\tconstructor(graphicsDevice) {\n\t\tsuper(graphicsDevice);\n\t\tconst device = this.device;\n\t\tthis._forwardDrawCalls = 0;\n\t\tthis._materialSwitches = 0;\n\t\tthis._depthMapTime = 0;\n\t\tthis._forwardTime = 0;\n\t\tthis._sortTime = 0;\n\t\tconst scope = device.scope;\n\t\tthis.fogColorId = scope.resolve('fog_color');\n\t\tthis.fogStartId = scope.resolve('fog_start');\n\t\tthis.fogEndId = scope.resolve('fog_end');\n\t\tthis.fogDensityId = scope.resolve('fog_density');\n\t\tthis.ambientId = scope.resolve('light_globalAmbient');\n\t\tthis.skyboxIntensityId = scope.resolve('skyboxIntensity');\n\t\tthis.cubeMapRotationMatrixId = scope.resolve('cubeMapRotationMatrix');\n\t\tthis.pcssDiskSamplesId = scope.resolve('pcssDiskSamples[0]');\n\t\tthis.pcssSphereSamplesId = scope.resolve('pcssSphereSamples[0]');\n\t\tthis.lightColorId = [];\n\t\tthis.lightDir = [];\n\t\tthis.lightDirId = [];\n\t\tthis.lightShadowMapId = [];\n\t\tthis.lightShadowMatrixId = [];\n\t\tthis.lightShadowParamsId = [];\n\t\tthis.lightShadowIntensity = [];\n\t\tthis.lightRadiusId = [];\n\t\tthis.lightPos = [];\n\t\tthis.lightPosId = [];\n\t\tthis.lightWidth = [];\n\t\tthis.lightWidthId = [];\n\t\tthis.lightHeight = [];\n\t\tthis.lightHeightId = [];\n\t\tthis.lightInAngleId = [];\n\t\tthis.lightOutAngleId = [];\n\t\tthis.lightCookieId = [];\n\t\tthis.lightCookieIntId = [];\n\t\tthis.lightCookieMatrixId = [];\n\t\tthis.lightCookieOffsetId = [];\n\t\tthis.lightShadowSearchAreaId = [];\n\t\tthis.lightCameraParamsId = [];\n\t\tthis.shadowMatrixPaletteId = [];\n\t\tthis.shadowCascadeDistancesId = [];\n\t\tthis.shadowCascadeCountId = [];\n\t\tthis.screenSizeId = scope.resolve('uScreenSize');\n\t\tthis._screenSize = new Float32Array(4);\n\t\tthis.fogColor = new Float32Array(3);\n\t\tthis.ambientColor = new Float32Array(3);\n\t\tthis.pcssDiskSamples = vogelDiskPrecalculationSamples(16);\n\t\tthis.pcssSphereSamples = vogelSpherePrecalculationSamples(16);\n\t}\n\tdestroy() {\n\t\tsuper.destroy();\n\t}\n\tdispatchGlobalLights(scene) {\n\t\tthis.ambientColor[0] = scene.ambientLight.r;\n\t\tthis.ambientColor[1] = scene.ambientLight.g;\n\t\tthis.ambientColor[2] = scene.ambientLight.b;\n\t\tif (scene.gammaCorrection) {\n\t\t\tfor (let i = 0; i < 3; i++) {\n\t\t\t\tthis.ambientColor[i] = Math.pow(this.ambientColor[i], 2.2);\n\t\t\t}\n\t\t}\n\t\tif (scene.physicalUnits) {\n\t\t\tfor (let i = 0; i < 3; i++) {\n\t\t\t\tthis.ambientColor[i] *= scene.ambientLuminance;\n\t\t\t}\n\t\t}\n\t\tthis.ambientId.setValue(this.ambientColor);\n\t\tthis.skyboxIntensityId.setValue(scene.physicalUnits ? scene.skyboxLuminance : scene.skyboxIntensity);\n\t\tthis.cubeMapRotationMatrixId.setValue(scene._skyboxRotationMat3.data);\n\t}\n\t_resolveLight(scope, i) {\n\t\tconst light = `light${i}`;\n\t\tthis.lightColorId[i] = scope.resolve(`${light}_color`);\n\t\tthis.lightDir[i] = new Float32Array(3);\n\t\tthis.lightDirId[i] = scope.resolve(`${light}_direction`);\n\t\tthis.lightShadowMapId[i] = scope.resolve(`${light}_shadowMap`);\n\t\tthis.lightShadowMatrixId[i] = scope.resolve(`${light}_shadowMatrix`);\n\t\tthis.lightShadowParamsId[i] = scope.resolve(`${light}_shadowParams`);\n\t\tthis.lightShadowIntensity[i] = scope.resolve(`${light}_shadowIntensity`);\n\t\tthis.lightShadowSearchAreaId[i] = scope.resolve(`${light}_shadowSearchArea`);\n\t\tthis.lightRadiusId[i] = scope.resolve(`${light}_radius`);\n\t\tthis.lightPos[i] = new Float32Array(3);\n\t\tthis.lightPosId[i] = scope.resolve(`${light}_position`);\n\t\tthis.lightWidth[i] = new Float32Array(3);\n\t\tthis.lightWidthId[i] = scope.resolve(`${light}_halfWidth`);\n\t\tthis.lightHeight[i] = new Float32Array(3);\n\t\tthis.lightHeightId[i] = scope.resolve(`${light}_halfHeight`);\n\t\tthis.lightInAngleId[i] = scope.resolve(`${light}_innerConeAngle`);\n\t\tthis.lightOutAngleId[i] = scope.resolve(`${light}_outerConeAngle`);\n\t\tthis.lightCookieId[i] = scope.resolve(`${light}_cookie`);\n\t\tthis.lightCookieIntId[i] = scope.resolve(`${light}_cookieIntensity`);\n\t\tthis.lightCookieMatrixId[i] = scope.resolve(`${light}_cookieMatrix`);\n\t\tthis.lightCookieOffsetId[i] = scope.resolve(`${light}_cookieOffset`);\n\t\tthis.lightCameraParamsId[i] = scope.resolve(`${light}_cameraParams`);\n\t\tthis.shadowMatrixPaletteId[i] = scope.resolve(`${light}_shadowMatrixPalette[0]`);\n\t\tthis.shadowCascadeDistancesId[i] = scope.resolve(`${light}_shadowCascadeDistances[0]`);\n\t\tthis.shadowCascadeCountId[i] = scope.resolve(`${light}_shadowCascadeCount`);\n\t}\n\tsetLTCDirectionalLight(wtm, cnt, dir, campos, far) {\n\t\tthis.lightPos[cnt][0] = campos.x - dir.x * far;\n\t\tthis.lightPos[cnt][1] = campos.y - dir.y * far;\n\t\tthis.lightPos[cnt][2] = campos.z - dir.z * far;\n\t\tthis.lightPosId[cnt].setValue(this.lightPos[cnt]);\n\t\tconst hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));\n\t\tthis.lightWidth[cnt][0] = hWidth.x * far;\n\t\tthis.lightWidth[cnt][1] = hWidth.y * far;\n\t\tthis.lightWidth[cnt][2] = hWidth.z * far;\n\t\tthis.lightWidthId[cnt].setValue(this.lightWidth[cnt]);\n\t\tconst hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));\n\t\tthis.lightHeight[cnt][0] = hHeight.x * far;\n\t\tthis.lightHeight[cnt][1] = hHeight.y * far;\n\t\tthis.lightHeight[cnt][2] = hHeight.z * far;\n\t\tthis.lightHeightId[cnt].setValue(this.lightHeight[cnt]);\n\t}\n\tdispatchDirectLights(dirs, scene, mask, camera) {\n\t\tlet cnt = 0;\n\t\tconst scope = this.device.scope;\n\t\tfor (let i = 0; i < dirs.length; i++) {\n\t\t\tif (!(dirs[i].mask & mask)) continue;\n\t\t\tconst directional = dirs[i];\n\t\t\tconst wtm = directional._node.getWorldTransform();\n\t\t\tif (!this.lightColorId[cnt]) {\n\t\t\t\tthis._resolveLight(scope, cnt);\n\t\t\t}\n\t\t\tthis.lightColorId[cnt].setValue(scene.gammaCorrection ? directional._linearFinalColor : directional._finalColor);\n\t\t\twtm.getY(directional._direction).mulScalar(-1);\n\t\t\tdirectional._direction.normalize();\n\t\t\tthis.lightDir[cnt][0] = directional._direction.x;\n\t\t\tthis.lightDir[cnt][1] = directional._direction.y;\n\t\t\tthis.lightDir[cnt][2] = directional._direction.z;\n\t\t\tthis.lightDirId[cnt].setValue(this.lightDir[cnt]);\n\t\t\tif (directional.shape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\t\tthis.setLTCDirectionalLight(wtm, cnt, directional._direction, camera._node.getPosition(), camera.farClip);\n\t\t\t}\n\t\t\tif (directional.castShadows) {\n\t\t\t\tconst lightRenderData = directional.getRenderData(camera, 0);\n\t\t\t\tconst biases = directional._getUniformBiasValues(lightRenderData);\n\t\t\t\tthis.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);\n\t\t\t\tthis.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);\n\t\t\t\tthis.shadowMatrixPaletteId[cnt].setValue(directional._shadowMatrixPalette);\n\t\t\t\tthis.shadowCascadeDistancesId[cnt].setValue(directional._shadowCascadeDistances);\n\t\t\t\tthis.shadowCascadeCountId[cnt].setValue(directional.numCascades);\n\t\t\t\tthis.lightShadowIntensity[cnt].setValue(directional.shadowIntensity);\n\t\t\t\tconst projectionCompensation = 50.0 / lightRenderData.projectionCompensation;\n\t\t\t\tconst shadowRT = lightRenderData.shadowCamera.renderTarget;\n\t\t\t\tif (shadowRT) {\n\t\t\t\t\tconst pixelsPerMeter = directional.penumbraSize / shadowRT.width;\n\t\t\t\t\tthis.lightShadowSearchAreaId[cnt].setValue(pixelsPerMeter * projectionCompensation);\n\t\t\t\t}\n\t\t\t\tconst cameraParams = directional._shadowCameraParams;\n\t\t\t\tcameraParams.length = 4;\n\t\t\t\tcameraParams[0] = lightRenderData.depthRangeCompensation;\n\t\t\t\tcameraParams[1] = lightRenderData.shadowCamera._farClip;\n\t\t\t\tcameraParams[2] = lightRenderData.shadowCamera._nearClip;\n\t\t\t\tcameraParams[3] = 1;\n\t\t\t\tthis.lightCameraParamsId[cnt].setValue(cameraParams);\n\t\t\t\tconst params = directional._shadowRenderParams;\n\t\t\t\tparams.length = 4;\n\t\t\t\tparams[0] = directional._shadowResolution;\n\t\t\t\tparams[1] = biases.normalBias;\n\t\t\t\tparams[2] = biases.bias;\n\t\t\t\tparams[3] = 0;\n\t\t\t\tthis.lightShadowParamsId[cnt].setValue(params);\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t\treturn cnt;\n\t}\n\tsetLTCPositionalLight(wtm, cnt) {\n\t\tconst hWidth = wtm.transformVector(new Vec3(-0.5, 0, 0));\n\t\tthis.lightWidth[cnt][0] = hWidth.x;\n\t\tthis.lightWidth[cnt][1] = hWidth.y;\n\t\tthis.lightWidth[cnt][2] = hWidth.z;\n\t\tthis.lightWidthId[cnt].setValue(this.lightWidth[cnt]);\n\t\tconst hHeight = wtm.transformVector(new Vec3(0, 0, 0.5));\n\t\tthis.lightHeight[cnt][0] = hHeight.x;\n\t\tthis.lightHeight[cnt][1] = hHeight.y;\n\t\tthis.lightHeight[cnt][2] = hHeight.z;\n\t\tthis.lightHeightId[cnt].setValue(this.lightHeight[cnt]);\n\t}\n\tdispatchOmniLight(scene, scope, omni, cnt) {\n\t\tconst wtm = omni._node.getWorldTransform();\n\t\tif (!this.lightColorId[cnt]) {\n\t\t\tthis._resolveLight(scope, cnt);\n\t\t}\n\t\tthis.lightRadiusId[cnt].setValue(omni.attenuationEnd);\n\t\tthis.lightColorId[cnt].setValue(scene.gammaCorrection ? omni._linearFinalColor : omni._finalColor);\n\t\twtm.getTranslation(omni._position);\n\t\tthis.lightPos[cnt][0] = omni._position.x;\n\t\tthis.lightPos[cnt][1] = omni._position.y;\n\t\tthis.lightPos[cnt][2] = omni._position.z;\n\t\tthis.lightPosId[cnt].setValue(this.lightPos[cnt]);\n\t\tif (omni.shape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\tthis.setLTCPositionalLight(wtm, cnt);\n\t\t}\n\t\tif (omni.castShadows) {\n\t\t\tconst lightRenderData = omni.getRenderData(null, 0);\n\t\t\tthis.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);\n\t\t\tconst biases = omni._getUniformBiasValues(lightRenderData);\n\t\t\tconst params = omni._shadowRenderParams;\n\t\t\tparams.length = 4;\n\t\t\tparams[0] = omni._shadowResolution;\n\t\t\tparams[1] = biases.normalBias;\n\t\t\tparams[2] = biases.bias;\n\t\t\tparams[3] = 1.0 / omni.attenuationEnd;\n\t\t\tthis.lightShadowParamsId[cnt].setValue(params);\n\t\t\tthis.lightShadowIntensity[cnt].setValue(omni.shadowIntensity);\n\t\t\tconst pixelsPerMeter = omni.penumbraSize / lightRenderData.shadowCamera.renderTarget.width;\n\t\t\tthis.lightShadowSearchAreaId[cnt].setValue(pixelsPerMeter);\n\t\t\tconst cameraParams = omni._shadowCameraParams;\n\t\t\tcameraParams.length = 4;\n\t\t\tcameraParams[0] = lightRenderData.depthRangeCompensation;\n\t\t\tcameraParams[1] = lightRenderData.shadowCamera._farClip;\n\t\t\tcameraParams[2] = lightRenderData.shadowCamera._nearClip;\n\t\t\tcameraParams[3] = 0;\n\t\t\tthis.lightCameraParamsId[cnt].setValue(cameraParams);\n\t\t}\n\t\tif (omni._cookie) {\n\t\t\tthis.lightCookieId[cnt].setValue(omni._cookie);\n\t\t\tthis.lightShadowMatrixId[cnt].setValue(wtm.data);\n\t\t\tthis.lightCookieIntId[cnt].setValue(omni.cookieIntensity);\n\t\t}\n\t}\n\tdispatchSpotLight(scene, scope, spot, cnt) {\n\t\tconst wtm = spot._node.getWorldTransform();\n\t\tif (!this.lightColorId[cnt]) {\n\t\t\tthis._resolveLight(scope, cnt);\n\t\t}\n\t\tthis.lightInAngleId[cnt].setValue(spot._innerConeAngleCos);\n\t\tthis.lightOutAngleId[cnt].setValue(spot._outerConeAngleCos);\n\t\tthis.lightRadiusId[cnt].setValue(spot.attenuationEnd);\n\t\tthis.lightColorId[cnt].setValue(scene.gammaCorrection ? spot._linearFinalColor : spot._finalColor);\n\t\twtm.getTranslation(spot._position);\n\t\tthis.lightPos[cnt][0] = spot._position.x;\n\t\tthis.lightPos[cnt][1] = spot._position.y;\n\t\tthis.lightPos[cnt][2] = spot._position.z;\n\t\tthis.lightPosId[cnt].setValue(this.lightPos[cnt]);\n\t\tif (spot.shape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\tthis.setLTCPositionalLight(wtm, cnt);\n\t\t}\n\t\twtm.getY(spot._direction).mulScalar(-1);\n\t\tspot._direction.normalize();\n\t\tthis.lightDir[cnt][0] = spot._direction.x;\n\t\tthis.lightDir[cnt][1] = spot._direction.y;\n\t\tthis.lightDir[cnt][2] = spot._direction.z;\n\t\tthis.lightDirId[cnt].setValue(this.lightDir[cnt]);\n\t\tif (spot.castShadows) {\n\t\t\tconst lightRenderData = spot.getRenderData(null, 0);\n\t\t\tthis.lightShadowMapId[cnt].setValue(lightRenderData.shadowBuffer);\n\t\t\tthis.lightShadowMatrixId[cnt].setValue(lightRenderData.shadowMatrix.data);\n\t\t\tconst biases = spot._getUniformBiasValues(lightRenderData);\n\t\t\tconst params = spot._shadowRenderParams;\n\t\t\tparams.length = 4;\n\t\t\tparams[0] = spot._shadowResolution;\n\t\t\tparams[1] = biases.normalBias;\n\t\t\tparams[2] = biases.bias;\n\t\t\tparams[3] = 1.0 / spot.attenuationEnd;\n\t\t\tthis.lightShadowParamsId[cnt].setValue(params);\n\t\t\tthis.lightShadowIntensity[cnt].setValue(spot.shadowIntensity);\n\t\t\tconst pixelsPerMeter = spot.penumbraSize / lightRenderData.shadowCamera.renderTarget.width;\n\t\t\tconst fov = lightRenderData.shadowCamera._fov * Math.PI / 180.0;\n\t\t\tconst fovRatio = 1.0 / Math.tan(fov / 2.0);\n\t\t\tthis.lightShadowSearchAreaId[cnt].setValue(pixelsPerMeter * fovRatio);\n\t\t\tconst cameraParams = spot._shadowCameraParams;\n\t\t\tcameraParams.length = 4;\n\t\t\tcameraParams[0] = lightRenderData.depthRangeCompensation;\n\t\t\tcameraParams[1] = lightRenderData.shadowCamera._farClip;\n\t\t\tcameraParams[2] = lightRenderData.shadowCamera._nearClip;\n\t\t\tcameraParams[3] = 0;\n\t\t\tthis.lightCameraParamsId[cnt].setValue(cameraParams);\n\t\t}\n\t\tif (spot._cookie) {\n\t\t\tif (!spot.castShadows) {\n\t\t\t\tconst cookieMatrix = LightCamera.evalSpotCookieMatrix(spot);\n\t\t\t\tthis.lightShadowMatrixId[cnt].setValue(cookieMatrix.data);\n\t\t\t}\n\t\t\tthis.lightCookieId[cnt].setValue(spot._cookie);\n\t\t\tthis.lightCookieIntId[cnt].setValue(spot.cookieIntensity);\n\t\t\tif (spot._cookieTransform) {\n\t\t\t\tspot._cookieTransformUniform[0] = spot._cookieTransform.x;\n\t\t\t\tspot._cookieTransformUniform[1] = spot._cookieTransform.y;\n\t\t\t\tspot._cookieTransformUniform[2] = spot._cookieTransform.z;\n\t\t\t\tspot._cookieTransformUniform[3] = spot._cookieTransform.w;\n\t\t\t\tthis.lightCookieMatrixId[cnt].setValue(spot._cookieTransformUniform);\n\t\t\t\tspot._cookieOffsetUniform[0] = spot._cookieOffset.x;\n\t\t\t\tspot._cookieOffsetUniform[1] = spot._cookieOffset.y;\n\t\t\t\tthis.lightCookieOffsetId[cnt].setValue(spot._cookieOffsetUniform);\n\t\t\t}\n\t\t}\n\t}\n\tdispatchLocalLights(sortedLights, scene, mask, usedDirLights) {\n\t\tlet cnt = usedDirLights;\n\t\tconst scope = this.device.scope;\n\t\tconst omnis = sortedLights[LIGHTTYPE_OMNI];\n\t\tconst numOmnis = omnis.length;\n\t\tfor (let i = 0; i < numOmnis; i++) {\n\t\t\tconst omni = omnis[i];\n\t\t\tif (!(omni.mask & mask)) continue;\n\t\t\tthis.dispatchOmniLight(scene, scope, omni, cnt);\n\t\t\tcnt++;\n\t\t}\n\t\tconst spts = sortedLights[LIGHTTYPE_SPOT];\n\t\tconst numSpts = spts.length;\n\t\tfor (let i = 0; i < numSpts; i++) {\n\t\t\tconst spot = spts[i];\n\t\t\tif (!(spot.mask & mask)) continue;\n\t\t\tthis.dispatchSpotLight(scene, scope, spot, cnt);\n\t\t\tcnt++;\n\t\t}\n\t}\n\trenderForwardPrepareMaterials(camera, drawCalls, sortedLights, layer, pass) {\n\t\tvar _layer$getLightHash;\n\t\tconst addCall = (drawCall, shaderInstance, isNewMaterial, lightMaskChanged) => {\n\t\t\t_drawCallList.drawCalls.push(drawCall);\n\t\t\t_drawCallList.shaderInstances.push(shaderInstance);\n\t\t\t_drawCallList.isNewMaterial.push(isNewMaterial);\n\t\t\t_drawCallList.lightMaskChanged.push(lightMaskChanged);\n\t\t};\n\t\t_drawCallList.clear();\n\t\tconst device = this.device;\n\t\tconst scene = this.scene;\n\t\tconst clusteredLightingEnabled = scene.clusteredLightingEnabled;\n\t\tconst lightHash = (_layer$getLightHash = layer == null ? void 0 : layer.getLightHash(clusteredLightingEnabled)) != null ? _layer$getLightHash : 0;\n\t\tlet prevMaterial = null,\n\t\t\tprevObjDefs,\n\t\t\tprevLightMask;\n\t\tconst drawCallsCount = drawCalls.length;\n\t\tfor (let i = 0; i < drawCallsCount; i++) {\n\t\t\tconst drawCall = drawCalls[i];\n\t\t\tdrawCall.ensureMaterial(device);\n\t\t\tconst material = drawCall.material;\n\t\t\tconst objDefs = drawCall._shaderDefs;\n\t\t\tconst lightMask = drawCall.mask;\n\t\t\tif (material && material === prevMaterial && objDefs !== prevObjDefs) {\n\t\t\t\tprevMaterial = null;\n\t\t\t}\n\t\t\tif (material !== prevMaterial) {\n\t\t\t\tthis._materialSwitches++;\n\t\t\t\tmaterial._scene = scene;\n\t\t\t\tif (material.dirty) {\n\t\t\t\t\tmaterial.updateUniforms(device, scene);\n\t\t\t\t\tmaterial.dirty = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst shaderInstance = drawCall.getShaderInstance(pass, lightHash, scene, this.viewUniformFormat, this.viewBindGroupFormat, sortedLights);\n\t\t\taddCall(drawCall, shaderInstance, material !== prevMaterial, !prevMaterial || lightMask !== prevLightMask);\n\t\t\tprevMaterial = material;\n\t\t\tprevObjDefs = objDefs;\n\t\t\tprevLightMask = lightMask;\n\t\t}\n\t\treturn _drawCallList;\n\t}\n\trenderForwardInternal(camera, preparedCalls, sortedLights, pass, drawCallback, flipFaces) {\n\t\tconst device = this.device;\n\t\tconst scene = this.scene;\n\t\tconst passFlag = 1 << pass;\n\t\tconst flipFactor = flipFaces ? -1 : 1;\n\t\tconst clusteredLightingEnabled = this.scene.clusteredLightingEnabled;\n\t\tconst preparedCallsCount = preparedCalls.drawCalls.length;\n\t\tfor (let i = 0; i < preparedCallsCount; i++) {\n\t\t\tvar _drawCall$stencilFron, _drawCall$stencilBack;\n\t\t\tconst drawCall = preparedCalls.drawCalls[i];\n\t\t\tconst newMaterial = preparedCalls.isNewMaterial[i];\n\t\t\tconst lightMaskChanged = preparedCalls.lightMaskChanged[i];\n\t\t\tconst shaderInstance = preparedCalls.shaderInstances[i];\n\t\t\tconst material = drawCall.material;\n\t\t\tconst lightMask = drawCall.mask;\n\t\t\tif (newMaterial) {\n\t\t\t\tconst asyncCompile = false;\n\t\t\t\tdevice.setShader(shaderInstance.shader, asyncCompile);\n\t\t\t\tmaterial.setParameters(device);\n\t\t\t\tif (lightMaskChanged) {\n\t\t\t\t\tconst usedDirLights = this.dispatchDirectLights(sortedLights[LIGHTTYPE_DIRECTIONAL], scene, lightMask, camera);\n\t\t\t\t\tif (!clusteredLightingEnabled) {\n\t\t\t\t\t\tthis.dispatchLocalLights(sortedLights, scene, lightMask, usedDirLights);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.alphaTestId.setValue(material.alphaTest);\n\t\t\t\tdevice.setBlendState(material.blendState);\n\t\t\t\tdevice.setDepthState(material.depthState);\n\t\t\t\tdevice.setAlphaToCoverage(material.alphaToCoverage);\n\t\t\t}\n\t\t\tthis.setupCullMode(camera._cullFaces, flipFactor, drawCall);\n\t\t\tconst stencilFront = (_drawCall$stencilFron = drawCall.stencilFront) != null ? _drawCall$stencilFron : material.stencilFront;\n\t\t\tconst stencilBack = (_drawCall$stencilBack = drawCall.stencilBack) != null ? _drawCall$stencilBack : material.stencilBack;\n\t\t\tdevice.setStencilState(stencilFront, stencilBack);\n\t\t\tconst mesh = drawCall.mesh;\n\t\t\tdrawCall.setParameters(device, passFlag);\n\t\t\tthis.setVertexBuffers(device, mesh);\n\t\t\tthis.setMorphing(device, drawCall.morphInstance);\n\t\t\tthis.setSkinning(device, drawCall);\n\t\t\tthis.setupMeshUniformBuffers(shaderInstance, drawCall);\n\t\t\tconst style = drawCall.renderStyle;\n\t\t\tdevice.setIndexBuffer(mesh.indexBuffer[style]);\n\t\t\tdrawCallback == null || drawCallback(drawCall, i);\n\t\t\tif (camera.xr && camera.xr.session && camera.xr.views.list.length) {\n\t\t\t\tconst views = camera.xr.views;\n\t\t\t\tfor (let v = 0; v < views.list.length; v++) {\n\t\t\t\t\tconst view = views.list[v];\n\t\t\t\t\tdevice.setViewport(view.viewport.x, view.viewport.y, view.viewport.z, view.viewport.w);\n\t\t\t\t\tthis.projId.setValue(view.projMat.data);\n\t\t\t\t\tthis.projSkyboxId.setValue(view.projMat.data);\n\t\t\t\t\tthis.viewId.setValue(view.viewOffMat.data);\n\t\t\t\t\tthis.viewInvId.setValue(view.viewInvOffMat.data);\n\t\t\t\t\tthis.viewId3.setValue(view.viewMat3.data);\n\t\t\t\t\tthis.viewProjId.setValue(view.projViewOffMat.data);\n\t\t\t\t\tthis.viewPosId.setValue(view.positionData);\n\t\t\t\t\tthis.viewIndexId.setValue(v);\n\t\t\t\t\tif (v === 0) {\n\t\t\t\t\t\tthis.drawInstance(device, drawCall, mesh, style, true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.drawInstance2(device, drawCall, mesh, style);\n\t\t\t\t\t}\n\t\t\t\t\tthis._forwardDrawCalls++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.drawInstance(device, drawCall, mesh, style, true);\n\t\t\t\tthis._forwardDrawCalls++;\n\t\t\t}\n\t\t\tif (i < preparedCallsCount - 1 && !preparedCalls.isNewMaterial[i + 1]) {\n\t\t\t\tmaterial.setParameters(device, drawCall.parameters);\n\t\t\t}\n\t\t}\n\t}\n\trenderForward(camera, allDrawCalls, sortedLights, pass, drawCallback, layer, flipFaces) {\n\t\tconst preparedCalls = this.renderForwardPrepareMaterials(camera, allDrawCalls, sortedLights, layer, pass);\n\t\tthis.renderForwardInternal(camera, preparedCalls, sortedLights, pass, drawCallback, flipFaces);\n\t\t_drawCallList.clear();\n\t}\n\trenderForwardLayer(camera, renderTarget, layer, transparent, shaderPass, viewBindGroups, options = {}) {\n\t\tvar _options$clearColor, _options$clearDepth, _options$clearStencil;\n\t\tconst {\n\t\t\tscene,\n\t\t\tdevice\n\t\t} = this;\n\t\tconst clusteredLightingEnabled = scene.clusteredLightingEnabled;\n\t\tthis.setupViewport(camera, renderTarget);\n\t\tconst clearColor = (_options$clearColor = options.clearColor) != null ? _options$clearColor : false;\n\t\tconst clearDepth = (_options$clearDepth = options.clearDepth) != null ? _options$clearDepth : false;\n\t\tconst clearStencil = (_options$clearStencil = options.clearStencil) != null ? _options$clearStencil : false;\n\t\tif (clearColor || clearDepth || clearStencil) {\n\t\t\tthis.clear(camera, clearColor, clearDepth, clearStencil);\n\t\t}\n\t\tlet visible, splitLights;\n\t\tif (layer) {\n\t\t\tlayer.sortVisible(camera, transparent);\n\t\t\tconst culledInstances = layer.getCulledInstances(camera);\n\t\t\tvisible = transparent ? culledInstances.transparent : culledInstances.opaque;\n\t\t\tscene.immediate.onPreRenderLayer(layer, visible, transparent);\n\t\t\tif (layer.requiresLightCube) {\n\t\t\t\tthis.lightCube.update(scene.ambientLight, layer._lights);\n\t\t\t\tthis.constantLightCube.setValue(this.lightCube.colors);\n\t\t\t}\n\t\t\tsplitLights = layer.splitLights;\n\t\t} else {\n\t\t\tvar _options$splitLights;\n\t\t\tvisible = options.meshInstances;\n\t\t\tsplitLights = (_options$splitLights = options.splitLights) != null ? _options$splitLights : _noLights;\n\t\t}\n\t\tif (clusteredLightingEnabled) {\n\t\t\tvar _options$lightCluster;\n\t\t\tconst lightClusters = (_options$lightCluster = options.lightClusters) != null ? _options$lightCluster : this.worldClustersAllocator.empty;\n\t\t\tlightClusters.activate();\n\t\t\tif (layer) {\n\t\t\t\tif (!this.clustersDebugRendered && scene.lighting.debugLayer === layer.id) {\n\t\t\t\t\tthis.clustersDebugRendered = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscene._activeCamera = camera;\n\t\tconst viewCount = this.setCameraUniforms(camera, renderTarget);\n\t\tif (device.supportsUniformBuffers) {\n\t\t\tthis.setupViewUniformBuffers(viewBindGroups, this.viewUniformFormat, this.viewBindGroupFormat, viewCount);\n\t\t}\n\t\tconst flipFaces = !!(camera._flipFaces ^ (renderTarget == null ? void 0 : renderTarget.flipY));\n\t\tconst forwardDrawCalls = this._forwardDrawCalls;\n\t\tthis.renderForward(camera, visible, splitLights, shaderPass, layer == null ? void 0 : layer.onDrawCall, layer, flipFaces);\n\t\tif (layer) {\n\t\t\tlayer._forwardDrawCalls += this._forwardDrawCalls - forwardDrawCalls;\n\t\t}\n\t}\n\tsetSceneConstants() {\n\t\tconst scene = this.scene;\n\t\tthis.dispatchGlobalLights(scene);\n\t\tif (scene.fog !== FOG_NONE) {\n\t\t\tthis.fogColor[0] = scene.fogColor.r;\n\t\t\tthis.fogColor[1] = scene.fogColor.g;\n\t\t\tthis.fogColor[2] = scene.fogColor.b;\n\t\t\tif (scene.gammaCorrection) {\n\t\t\t\tfor (let i = 0; i < 3; i++) {\n\t\t\t\t\tthis.fogColor[i] = Math.pow(this.fogColor[i], 2.2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.fogColorId.setValue(this.fogColor);\n\t\t\tif (scene.fog === FOG_LINEAR) {\n\t\t\t\tthis.fogStartId.setValue(scene.fogStart);\n\t\t\t\tthis.fogEndId.setValue(scene.fogEnd);\n\t\t\t} else {\n\t\t\t\tthis.fogDensityId.setValue(scene.fogDensity);\n\t\t\t}\n\t\t}\n\t\tconst device = this.device;\n\t\tthis._screenSize[0] = device.width;\n\t\tthis._screenSize[1] = device.height;\n\t\tthis._screenSize[2] = 1 / device.width;\n\t\tthis._screenSize[3] = 1 / device.height;\n\t\tthis.screenSizeId.setValue(this._screenSize);\n\t\tthis.pcssDiskSamplesId.setValue(this.pcssDiskSamples);\n\t\tthis.pcssSphereSamplesId.setValue(this.pcssSphereSamples);\n\t}\n\tbuildFrameGraph(frameGraph, layerComposition) {\n\t\tconst scene = this.scene;\n\t\tconst webgl1 = this.device.isWebGL1;\n\t\tframeGraph.reset();\n\t\tthis.update(layerComposition);\n\t\tif (scene.clusteredLightingEnabled) {\n\t\t\tconst {\n\t\t\t\tshadowsEnabled,\n\t\t\t\tcookiesEnabled\n\t\t\t} = scene.lighting;\n\t\t\tthis._renderPassUpdateClustered.update(frameGraph, shadowsEnabled, cookiesEnabled, this.lights, this.localLights);\n\t\t\tframeGraph.addRenderPass(this._renderPassUpdateClustered);\n\t\t} else {\n\t\t\tthis._shadowRendererLocal.buildNonClusteredRenderPasses(frameGraph, this.localLights);\n\t\t}\n\t\tlet startIndex = 0;\n\t\tlet newStart = true;\n\t\tlet renderTarget = null;\n\t\tconst renderActions = layerComposition._renderActions;\n\t\tfor (let i = startIndex; i < renderActions.length; i++) {\n\t\t\tconst renderAction = renderActions[i];\n\t\t\tconst {\n\t\t\t\tlayer,\n\t\t\t\tcamera\n\t\t\t} = renderAction;\n\t\t\tif (renderAction.useCameraPasses) {\n\t\t\t\tcamera.camera.renderPasses.forEach(renderPass => {\n\t\t\t\t\tframeGraph.addRenderPass(renderPass);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconst depthPass = camera.camera.renderPassDepthGrab;\n\t\t\t\tif (depthPass && webgl1 && renderAction.firstCameraUse) {\n\t\t\t\t\tdepthPass.options.resizeSource = camera.camera.renderTarget;\n\t\t\t\t\tdepthPass.update(this.scene);\n\t\t\t\t\tframeGraph.addRenderPass(depthPass);\n\t\t\t\t}\n\t\t\t\tconst isDepthLayer = layer.id === LAYERID_DEPTH;\n\t\t\t\tif (webgl1 && isDepthLayer && !camera.renderSceneColorMap) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tconst isGrabPass = isDepthLayer && (camera.renderSceneColorMap || camera.renderSceneDepthMap);\n\t\t\t\tif (newStart) {\n\t\t\t\t\tnewStart = false;\n\t\t\t\t\tstartIndex = i;\n\t\t\t\t\trenderTarget = renderAction.renderTarget;\n\t\t\t\t}\n\t\t\t\tconst nextRenderAction = renderActions[i + 1];\n\t\t\t\tconst isNextLayerDepth = nextRenderAction ? nextRenderAction.layer.id === LAYERID_DEPTH : false;\n\t\t\t\tconst isNextLayerGrabPass = isNextLayerDepth && (camera.renderSceneColorMap || camera.renderSceneDepthMap) && !webgl1;\n\t\t\t\tconst nextNeedDirShadows = nextRenderAction ? nextRenderAction.firstCameraUse && this.cameraDirShadowLights.has(nextRenderAction.camera.camera) : false;\n\t\t\t\tif (!nextRenderAction || nextRenderAction.renderTarget !== renderTarget || nextNeedDirShadows || isNextLayerGrabPass || isGrabPass) {\n\t\t\t\t\tconst isDepthOnly = isDepthLayer && startIndex === i;\n\t\t\t\t\tif (!isDepthOnly) {\n\t\t\t\t\t\tthis.addMainRenderPass(frameGraph, layerComposition, renderTarget, startIndex, i);\n\t\t\t\t\t}\n\t\t\t\t\tif (isDepthLayer) {\n\t\t\t\t\t\tif (camera.renderSceneColorMap) {\n\t\t\t\t\t\t\tconst colorGrabPass = camera.camera.renderPassColorGrab;\n\t\t\t\t\t\t\tcolorGrabPass.source = camera.renderTarget;\n\t\t\t\t\t\t\tframeGraph.addRenderPass(colorGrabPass);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (camera.renderSceneDepthMap && !webgl1) {\n\t\t\t\t\t\t\tframeGraph.addRenderPass(camera.camera.renderPassDepthGrab);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (renderAction.triggerPostprocess && camera != null && camera.onPostprocessing) {\n\t\t\t\t\t\tconst renderPass = new RenderPassPostprocessing(this.device, this, renderAction);\n\t\t\t\t\t\tframeGraph.addRenderPass(renderPass);\n\t\t\t\t\t}\n\t\t\t\t\tnewStart = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\taddMainRenderPass(frameGraph, layerComposition, renderTarget, startIndex, endIndex) {\n\t\tconst renderPass = new RenderPassForward(this.device, layerComposition, this.scene, this);\n\t\trenderPass.init(renderTarget);\n\t\tconst renderActions = layerComposition._renderActions;\n\t\tfor (let i = startIndex; i <= endIndex; i++) {\n\t\t\trenderPass.addRenderAction(renderActions[i]);\n\t\t}\n\t\tframeGraph.addRenderPass(renderPass);\n\t}\n\tupdate(comp) {\n\t\tthis.frameUpdate();\n\t\tthis.shadowRenderer.frameUpdate();\n\t\tthis.scene._updateSkyMesh();\n\t\tthis.updateLayerComposition(comp);\n\t\tthis.collectLights(comp);\n\t\tthis.beginFrame(comp);\n\t\tthis.setSceneConstants();\n\t\tthis.cullComposition(comp);\n\t\tthis.gpuUpdate(this.processingMeshInstances);\n\t}\n}\n\nexport { ForwardRenderer };\n","import { Quat } from '../../core/math/quat.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { Mat4 } from '../../core/math/mat4.js';\nimport { ASPECT_MANUAL, LIGHTTYPE_DIRECTIONAL, PROJECTION_ORTHOGRAPHIC, LIGHTTYPE_SPOT, PROJECTION_PERSPECTIVE, LIGHTTYPE_OMNI } from '../constants.js';\nimport { Camera } from '../camera.js';\nimport { GraphNode } from '../graph-node.js';\n\nconst _viewMat = new Mat4();\nconst _viewProjMat = new Mat4();\nconst _viewportMatrix = new Mat4();\nclass LightCamera {\n\tstatic create(name, lightType, face) {\n\t\tconst camera = new Camera();\n\t\tcamera.node = new GraphNode(name);\n\t\tcamera.aspectRatio = 1;\n\t\tcamera.aspectRatioMode = ASPECT_MANUAL;\n\t\tcamera._scissorRectClear = true;\n\t\tswitch (lightType) {\n\t\t\tcase LIGHTTYPE_OMNI:\n\t\t\t\tcamera.node.setRotation(LightCamera.pointLightRotations[face]);\n\t\t\t\tcamera.fov = 90;\n\t\t\t\tcamera.projection = PROJECTION_PERSPECTIVE;\n\t\t\t\tbreak;\n\t\t\tcase LIGHTTYPE_SPOT:\n\t\t\t\tcamera.projection = PROJECTION_PERSPECTIVE;\n\t\t\t\tbreak;\n\t\t\tcase LIGHTTYPE_DIRECTIONAL:\n\t\t\t\tcamera.projection = PROJECTION_ORTHOGRAPHIC;\n\t\t\t\tbreak;\n\t\t}\n\t\treturn camera;\n\t}\n\tstatic evalSpotCookieMatrix(light) {\n\t\tlet cookieCamera = LightCamera._spotCookieCamera;\n\t\tif (!cookieCamera) {\n\t\t\tcookieCamera = LightCamera.create('SpotCookieCamera', LIGHTTYPE_SPOT);\n\t\t\tLightCamera._spotCookieCamera = cookieCamera;\n\t\t}\n\t\tcookieCamera.fov = light._outerConeAngle * 2;\n\t\tconst cookieNode = cookieCamera._node;\n\t\tcookieNode.setPosition(light._node.getPosition());\n\t\tcookieNode.setRotation(light._node.getRotation());\n\t\tcookieNode.rotateLocal(-90, 0, 0);\n\t\t_viewMat.setTRS(cookieNode.getPosition(), cookieNode.getRotation(), Vec3.ONE).invert();\n\t\t_viewProjMat.mul2(cookieCamera.projectionMatrix, _viewMat);\n\t\tconst cookieMatrix = light.cookieMatrix;\n\t\tconst rectViewport = light.atlasViewport;\n\t\t_viewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);\n\t\tcookieMatrix.mul2(_viewportMatrix, _viewProjMat);\n\t\treturn cookieMatrix;\n\t}\n}\nLightCamera.pointLightRotations = [new Quat().setFromEulerAngles(0, 90, 180), new Quat().setFromEulerAngles(0, -90, 180), new Quat().setFromEulerAngles(90, 0, 0), new Quat().setFromEulerAngles(-90, 0, 0), new Quat().setFromEulerAngles(0, 180, 180), new Quat().setFromEulerAngles(0, 0, 180)];\nLightCamera._spotCookieCamera = null;\n\nexport { LightCamera };\n","import { Vec4 } from '../../core/math/vec4.js';\nimport { Mat4 } from '../../core/math/mat4.js';\nimport { CULLFACE_NONE } from '../../platform/graphics/constants.js';\nimport { LIGHTTYPE_DIRECTIONAL, LIGHTTYPE_OMNI } from '../constants.js';\nimport { createShaderFromCode } from '../shader-lib/utils.js';\nimport { LightCamera } from './light-camera.js';\nimport { BlendState } from '../../platform/graphics/blend-state.js';\nimport { QuadRender } from '../graphics/quad-render.js';\nimport { DepthState } from '../../platform/graphics/depth-state.js';\nimport { RenderPass } from '../../platform/graphics/render-pass.js';\n\nconst textureBlitVertexShader = `\n\tattribute vec2 vertex_position;\n\tvarying vec2 uv0;\n\tvoid main(void) {\n\t\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\t\tuv0 = vertex_position.xy * 0.5 + 0.5;\n\t\t#ifndef WEBGPU\n\t\t\tuv0.y = 1.0 - uv0.y;\n\t\t#endif\n\t}`;\nconst textureBlitFragmentShader = `\n\tvarying vec2 uv0;\n\tuniform sampler2D blitTexture;\n\tvoid main(void) {\n\t\tgl_FragColor = texture2D(blitTexture, uv0);\n\t}`;\nconst textureCubeBlitFragmentShader = `\n\tvarying vec2 uv0;\n\tuniform samplerCube blitTexture;\n\tuniform mat4 invViewProj;\n\tvoid main(void) {\n\t\tvec4 projPos = vec4(uv0 * 2.0 - 1.0, 0.5, 1.0);\n\t\tvec4 worldPos = invViewProj * projPos;\n\t\tgl_FragColor = textureCube(blitTexture, worldPos.xyz);\n\t}`;\nconst _viewport = new Vec4();\nconst _invViewProjMatrices = [];\nclass RenderPassCookieRenderer extends RenderPass {\n\tconstructor(device, cubeSlotsOffsets) {\n\t\tsuper(device);\n\t\tthis._quadRenderer2D = null;\n\t\tthis._quadRendererCube = null;\n\t\tthis._filteredLights = [];\n\t\tthis._cubeSlotsOffsets = cubeSlotsOffsets;\n\t\tthis.requiresCubemaps = false;\n\t\tthis.blitTextureId = device.scope.resolve('blitTexture');\n\t\tthis.invViewProjId = device.scope.resolve('invViewProj');\n\t}\n\tdestroy() {\n\t\tvar _this$_quadRenderer2D, _this$_quadRendererCu;\n\t\t(_this$_quadRenderer2D = this._quadRenderer2D) == null || _this$_quadRenderer2D.destroy();\n\t\tthis._quadRenderer2D = null;\n\t\t(_this$_quadRendererCu = this._quadRendererCube) == null || _this$_quadRendererCu.destroy();\n\t\tthis._quadRendererCube = null;\n\t}\n\tstatic create(renderTarget, cubeSlotsOffsets) {\n\t\tconst renderPass = new RenderPassCookieRenderer(renderTarget.device, cubeSlotsOffsets);\n\t\trenderPass.init(renderTarget);\n\t\trenderPass.colorOps.clear = false;\n\t\trenderPass.depthStencilOps.clearDepth = false;\n\t\treturn renderPass;\n\t}\n\tupdate(lights) {\n\t\tconst filteredLights = this._filteredLights;\n\t\tthis.filter(lights, filteredLights);\n\t\tthis.executeEnabled = filteredLights.length > 0;\n\t}\n\tfilter(lights, filteredLights) {\n\t\tfor (let i = 0; i < lights.length; i++) {\n\t\t\tconst light = lights[i];\n\t\t\tif (light._type === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!light.atlasViewportAllocated) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!light.atlasSlotUpdated) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (light.enabled && light.cookie && light.visibleThisFrame) {\n\t\t\t\tfilteredLights.push(light);\n\t\t\t}\n\t\t}\n\t}\n\tinitInvViewProjMatrices() {\n\t\tif (!_invViewProjMatrices.length) {\n\t\t\tfor (let face = 0; face < 6; face++) {\n\t\t\t\tconst camera = LightCamera.create(null, LIGHTTYPE_OMNI, face);\n\t\t\t\tconst projMat = camera.projectionMatrix;\n\t\t\t\tconst viewMat = camera.node.getLocalTransform().clone().invert();\n\t\t\t\t_invViewProjMatrices[face] = new Mat4().mul2(projMat, viewMat).invert();\n\t\t\t}\n\t\t}\n\t}\n\tget quadRenderer2D() {\n\t\tif (!this._quadRenderer2D) {\n\t\t\tconst shader = createShaderFromCode(this.device, textureBlitVertexShader, textureBlitFragmentShader, 'cookieRenderer2d');\n\t\t\tthis._quadRenderer2D = new QuadRender(shader);\n\t\t}\n\t\treturn this._quadRenderer2D;\n\t}\n\tget quadRendererCube() {\n\t\tif (!this._quadRendererCube) {\n\t\t\tconst shader = createShaderFromCode(this.device, textureBlitVertexShader, textureCubeBlitFragmentShader, 'cookieRendererCube');\n\t\t\tthis._quadRendererCube = new QuadRender(shader);\n\t\t}\n\t\treturn this._quadRendererCube;\n\t}\n\texecute() {\n\t\tconst device = this.device;\n\t\tdevice.setBlendState(BlendState.NOBLEND);\n\t\tdevice.setCullMode(CULLFACE_NONE);\n\t\tdevice.setDepthState(DepthState.NODEPTH);\n\t\tdevice.setStencilState();\n\t\tconst renderTargetWidth = this.renderTarget.colorBuffer.width;\n\t\tconst cubeSlotsOffsets = this._cubeSlotsOffsets;\n\t\tconst filteredLights = this._filteredLights;\n\t\tfor (let i = 0; i < filteredLights.length; i++) {\n\t\t\tconst light = filteredLights[i];\n\t\t\tconst faceCount = light.numShadowFaces;\n\t\t\tconst quad = faceCount > 1 ? this.quadRendererCube : this.quadRenderer2D;\n\t\t\tif (faceCount > 1) {\n\t\t\t\tthis.initInvViewProjMatrices();\n\t\t\t}\n\t\t\tthis.blitTextureId.setValue(light.cookie);\n\t\t\tfor (let face = 0; face < faceCount; face++) {\n\t\t\t\t_viewport.copy(light.atlasViewport);\n\t\t\t\tif (faceCount > 1) {\n\t\t\t\t\tconst smallSize = _viewport.z / 3;\n\t\t\t\t\tconst offset = cubeSlotsOffsets[face];\n\t\t\t\t\t_viewport.x += smallSize * offset.x;\n\t\t\t\t\t_viewport.y += smallSize * offset.y;\n\t\t\t\t\t_viewport.z = smallSize;\n\t\t\t\t\t_viewport.w = smallSize;\n\t\t\t\t\tthis.invViewProjId.setValue(_invViewProjMatrices[face].data);\n\t\t\t\t}\n\t\t\t\t_viewport.mulScalar(renderTargetWidth);\n\t\t\t\tquad.render(_viewport);\n\t\t\t}\n\t\t}\n\t\tfilteredLights.length = 0;\n\t}\n}\n\nexport { RenderPassCookieRenderer };\n","import { BlendState } from '../../platform/graphics/blend-state.js';\nimport { RenderPass } from '../../platform/graphics/render-pass.js';\nimport { RenderAction } from '../composition/render-action.js';\n\nclass RenderPassForward extends RenderPass {\n\tconstructor(device, layerComposition, scene, renderer) {\n\t\tsuper(device);\n\t\tthis.layerComposition = void 0;\n\t\tthis.scene = void 0;\n\t\tthis.renderer = void 0;\n\t\tthis.renderActions = [];\n\t\tthis.noDepthClear = false;\n\t\tthis.layerComposition = layerComposition;\n\t\tthis.scene = scene;\n\t\tthis.renderer = renderer;\n\t}\n\taddRenderAction(renderAction) {\n\t\tthis.renderActions.push(renderAction);\n\t}\n\taddLayer(cameraComponent, layer, transparent, autoClears = true) {\n\t\tconst ra = new RenderAction();\n\t\tra.renderTarget = this.renderTarget;\n\t\tra.camera = cameraComponent;\n\t\tra.layer = layer;\n\t\tra.transparent = transparent;\n\t\tif (autoClears) {\n\t\t\tconst firstRa = this.renderActions.length === 0;\n\t\t\tra.setupClears(firstRa ? cameraComponent : undefined, layer);\n\t\t}\n\t\tthis.addRenderAction(ra);\n\t}\n\taddLayers(composition, cameraComponent, startIndex, firstLayerClears, lastLayerId, lastLayerIsTransparent = true) {\n\t\tconst {\n\t\t\tlayerList,\n\t\t\tsubLayerEnabled,\n\t\t\tsubLayerList\n\t\t} = composition;\n\t\tlet clearRenderTarget = firstLayerClears;\n\t\tlet index = startIndex;\n\t\twhile (index < layerList.length) {\n\t\t\tconst layer = layerList[index];\n\t\t\tconst isTransparent = subLayerList[index];\n\t\t\tconst enabled = layer.enabled && subLayerEnabled[index];\n\t\t\tconst renderedbyCamera = cameraComponent.camera.layersSet.has(layer.id);\n\t\t\tif (enabled && renderedbyCamera) {\n\t\t\t\tthis.addLayer(cameraComponent, layer, isTransparent, clearRenderTarget);\n\t\t\t\tclearRenderTarget = false;\n\t\t\t}\n\t\t\tindex++;\n\t\t\tif (layer.id === lastLayerId && isTransparent === lastLayerIsTransparent) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tupdateDirectionalShadows() {\n\t\tconst {\n\t\t\trenderer,\n\t\t\trenderActions\n\t\t} = this;\n\t\tfor (let i = 0; i < renderActions.length; i++) {\n\t\t\tconst renderAction = renderActions[i];\n\t\t\tconst cameraComp = renderAction.camera;\n\t\t\tconst camera = cameraComp.camera;\n\t\t\tconst shadowDirLights = this.renderer.cameraDirShadowLights.get(camera);\n\t\t\tif (shadowDirLights) {\n\t\t\t\tfor (let l = 0; l < shadowDirLights.length; l++) {\n\t\t\t\t\tconst light = shadowDirLights[l];\n\t\t\t\t\tif (renderer.dirLightShadows.get(light) !== camera) {\n\t\t\t\t\t\trenderer.dirLightShadows.set(light, camera);\n\t\t\t\t\t\tconst shadowPass = renderer._shadowRendererDirectional.getLightRenderPass(light, camera);\n\t\t\t\t\t\tif (shadowPass) {\n\t\t\t\t\t\t\tthis.beforePasses.push(shadowPass);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tupdateClears() {\n\t\tconst renderAction = this.renderActions[0];\n\t\tif (renderAction) {\n\t\t\tconst cameraComponent = renderAction.camera;\n\t\t\tconst camera = cameraComponent.camera;\n\t\t\tconst fullSizeClearRect = camera.fullSizeClearRect;\n\t\t\tthis.setClearColor(fullSizeClearRect && renderAction.clearColor ? camera.clearColor : undefined);\n\t\t\tthis.setClearDepth(fullSizeClearRect && renderAction.clearDepth && !this.noDepthClear ? camera.clearDepth : undefined);\n\t\t\tthis.setClearStencil(fullSizeClearRect && renderAction.clearStencil ? camera.clearStencil : undefined);\n\t\t}\n\t}\n\tframeUpdate() {\n\t\tsuper.frameUpdate();\n\t\tthis.updateDirectionalShadows();\n\t\tthis.updateClears();\n\t}\n\tbefore() {\n\t\tconst {\n\t\t\trenderActions\n\t\t} = this;\n\t\tif (renderActions.length) {\n\t\t\tconst ra = renderActions[0];\n\t\t\tif (ra.camera.onPreRender && ra.firstCameraUse) {\n\t\t\t\tra.camera.onPreRender();\n\t\t\t}\n\t\t}\n\t}\n\texecute() {\n\t\tconst {\n\t\t\tlayerComposition,\n\t\t\trenderActions\n\t\t} = this;\n\t\tfor (let i = 0; i < renderActions.length; i++) {\n\t\t\tconst ra = renderActions[i];\n\t\t\tif (layerComposition.isEnabled(ra.layer, ra.transparent)) {\n\t\t\t\tthis.renderRenderAction(ra, i === 0);\n\t\t\t}\n\t\t}\n\t}\n\tafter() {\n\t\tconst {\n\t\t\trenderActions\n\t\t} = this;\n\t\tif (renderActions.length) {\n\t\t\tconst ra = renderActions[renderActions.length - 1];\n\t\t\tif (ra.camera.onPostRender && ra.lastCameraUse) {\n\t\t\t\tra.camera.onPostRender();\n\t\t\t}\n\t\t}\n\t\tthis.beforePasses.length = 0;\n\t}\n\trenderRenderAction(renderAction, firstRenderAction) {\n\t\tconst {\n\t\t\trenderer,\n\t\t\tlayerComposition\n\t\t} = this;\n\t\tconst device = renderer.device;\n\t\tconst {\n\t\t\tlayer,\n\t\t\ttransparent,\n\t\t\tcamera\n\t\t} = renderAction;\n\t\tconst cameraPass = layerComposition.camerasMap.get(camera);\n\t\tif (!transparent && layer.onPreRenderOpaque) {\n\t\t\tlayer.onPreRenderOpaque(cameraPass);\n\t\t} else if (transparent && layer.onPreRenderTransparent) {\n\t\t\tlayer.onPreRenderTransparent(cameraPass);\n\t\t}\n\t\tif (!(layer._preRenderCalledForCameras & 1 << cameraPass)) {\n\t\t\tif (layer.onPreRender) {\n\t\t\t\tlayer.onPreRender(cameraPass);\n\t\t\t}\n\t\t\tlayer._preRenderCalledForCameras |= 1 << cameraPass;\n\t\t}\n\t\tif (camera) {\n\t\t\tvar _camera$camera$shader, _camera$camera$shader2;\n\t\t\tconst options = {\n\t\t\t\tlightClusters: renderAction.lightClusters\n\t\t\t};\n\t\t\tconst shaderPass = (_camera$camera$shader = (_camera$camera$shader2 = camera.camera.shaderPassInfo) == null ? void 0 : _camera$camera$shader2.index) != null ? _camera$camera$shader : layer.shaderPass;\n\t\t\tif (!firstRenderAction || !camera.camera.fullSizeClearRect) {\n\t\t\t\toptions.clearColor = renderAction.clearColor;\n\t\t\t\toptions.clearDepth = renderAction.clearDepth;\n\t\t\t\toptions.clearStencil = renderAction.clearStencil;\n\t\t\t}\n\t\t\trenderer.renderForwardLayer(camera.camera, renderAction.renderTarget, layer, transparent, shaderPass, renderAction.viewBindGroups, options);\n\t\t\tdevice.setBlendState(BlendState.NOBLEND);\n\t\t\tdevice.setStencilState(null, null);\n\t\t\tdevice.setAlphaToCoverage(false);\n\t\t}\n\t\tif (!transparent && layer.onPostRenderOpaque) {\n\t\t\tlayer.onPostRenderOpaque(cameraPass);\n\t\t} else if (transparent && layer.onPostRenderTransparent) {\n\t\t\tlayer.onPostRenderTransparent(cameraPass);\n\t\t}\n\t\tif (layer.onPostRender && !(layer._postRenderCalledForCameras & 1 << cameraPass)) {\n\t\t\tlayer._postRenderCounter &= ~(transparent ? 2 : 1);\n\t\t\tif (layer._postRenderCounter === 0) {\n\t\t\t\tlayer.onPostRender(cameraPass);\n\t\t\t\tlayer._postRenderCalledForCameras |= 1 << cameraPass;\n\t\t\t\tlayer._postRenderCounter = layer._postRenderCounterMax;\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { RenderPassForward };\n","import { RenderPass } from '../../platform/graphics/render-pass.js';\n\nclass RenderPassPostprocessing extends RenderPass {\n\tconstructor(device, renderer, renderAction) {\n\t\tsuper(device);\n\t\tthis.renderer = renderer;\n\t\tthis.renderAction = renderAction;\n\t\tthis.requiresCubemaps = false;\n\t}\n\texecute() {\n\t\tconst renderAction = this.renderAction;\n\t\tconst camera = renderAction.camera;\n\t\tcamera.onPostprocessing();\n\t}\n}\n\nexport { RenderPassPostprocessing };\n","import { RenderPass } from '../../platform/graphics/render-pass.js';\nimport { SHADOWUPDATE_NONE, SHADOWUPDATE_THISFRAME } from '../constants.js';\n\nclass RenderPassShadowDirectional extends RenderPass {\n\tconstructor(device, shadowRenderer, light, camera, allCascadesRendering) {\n\t\tsuper(device);\n\t\tthis.shadowRenderer = shadowRenderer;\n\t\tthis.light = light;\n\t\tthis.camera = camera;\n\t\tthis.allCascadesRendering = allCascadesRendering;\n\t}\n\texecute() {\n\t\tconst {\n\t\t\tlight,\n\t\t\tcamera,\n\t\t\tshadowRenderer,\n\t\t\tallCascadesRendering\n\t\t} = this;\n\t\tconst faceCount = light.numShadowFaces;\n\t\tconst shadowUpdateOverrides = light.shadowUpdateOverrides;\n\t\tfor (let face = 0; face < faceCount; face++) {\n\t\t\tif ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[face]) !== SHADOWUPDATE_NONE) {\n\t\t\t\tshadowRenderer.renderFace(light, camera, face, !allCascadesRendering);\n\t\t\t}\n\t\t\tif ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[face]) === SHADOWUPDATE_THISFRAME) {\n\t\t\t\tshadowUpdateOverrides[face] = SHADOWUPDATE_NONE;\n\t\t\t}\n\t\t}\n\t}\n\tafter() {\n\t\tthis.shadowRenderer.renderVsm(this.light, this.camera);\n\t}\n}\n\nexport { RenderPassShadowDirectional };\n","import { RenderPass } from '../../platform/graphics/render-pass.js';\n\nclass RenderPassShadowLocalClustered extends RenderPass {\n\tconstructor(device, shadowRenderer, shadowRendererLocal) {\n\t\tsuper(device);\n\t\tthis.requiresCubemaps = false;\n\t\tthis.shadowRenderer = shadowRenderer;\n\t\tthis.shadowRendererLocal = shadowRendererLocal;\n\t}\n\tupdate(localLights) {\n\t\tconst shadowLights = this.shadowRendererLocal.shadowLights;\n\t\tconst shadowCamera = this.shadowRendererLocal.prepareLights(shadowLights, localLights);\n\t\tconst count = shadowLights.length;\n\t\tthis.enabled = count > 0;\n\t\tif (count) {\n\t\t\tthis.shadowRenderer.setupRenderPass(this, shadowCamera, false);\n\t\t}\n\t}\n\texecute() {\n\t\tconst shadowLights = this.shadowRendererLocal.shadowLights;\n\t\tconst count = shadowLights.length;\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst light = shadowLights[i];\n\t\t\tfor (let face = 0; face < light.numShadowFaces; face++) {\n\t\t\t\tthis.shadowRenderer.renderFace(light, null, face, true);\n\t\t\t}\n\t\t}\n\t\tshadowLights.length = 0;\n\t}\n}\n\nexport { RenderPassShadowLocalClustered };\n","import { RenderPass } from '../../platform/graphics/render-pass.js';\n\nclass RenderPassShadowLocalNonClustered extends RenderPass {\n\tconstructor(device, shadowRenderer, light, face, applyVsm) {\n\t\tsuper(device);\n\t\tthis.requiresCubemaps = false;\n\t\tthis.shadowRenderer = shadowRenderer;\n\t\tthis.light = light;\n\t\tthis.face = face;\n\t\tthis.applyVsm = applyVsm;\n\t\tthis.shadowCamera = shadowRenderer.prepareFace(light, null, face);\n\t\tshadowRenderer.setupRenderPass(this, this.shadowCamera, true);\n\t}\n\texecute() {\n\t\tthis.shadowRenderer.renderFace(this.light, null, this.face, false);\n\t}\n\tafter() {\n\t\tif (this.applyVsm) {\n\t\t\tthis.shadowRenderer.renderVsm(this.light, this.shadowCamera);\n\t\t}\n\t}\n}\n\nexport { RenderPassShadowLocalNonClustered };\n","import { RenderPass } from '../../platform/graphics/render-pass.js';\nimport { RenderPassCookieRenderer } from './render-pass-cookie-renderer.js';\nimport { RenderPassShadowLocalClustered } from './render-pass-shadow-local-clustered.js';\n\nclass RenderPassUpdateClustered extends RenderPass {\n\tconstructor(device, renderer, shadowRenderer, shadowRendererLocal, lightTextureAtlas) {\n\t\tsuper(device);\n\t\tthis.renderer = renderer;\n\t\tthis.frameGraph = null;\n\t\tthis.cookiesRenderPass = RenderPassCookieRenderer.create(lightTextureAtlas.cookieRenderTarget, lightTextureAtlas.cubeSlotsOffsets);\n\t\tthis.beforePasses.push(this.cookiesRenderPass);\n\t\tthis.shadowRenderPass = new RenderPassShadowLocalClustered(device, shadowRenderer, shadowRendererLocal);\n\t\tthis.beforePasses.push(this.shadowRenderPass);\n\t}\n\tupdate(frameGraph, shadowsEnabled, cookiesEnabled, lights, localLights) {\n\t\tthis.frameGraph = frameGraph;\n\t\tthis.cookiesRenderPass.enabled = cookiesEnabled;\n\t\tif (cookiesEnabled) {\n\t\t\tthis.cookiesRenderPass.update(lights);\n\t\t}\n\t\tthis.shadowRenderPass.enabled = shadowsEnabled;\n\t\tif (shadowsEnabled) {\n\t\t\tthis.shadowRenderPass.update(localLights);\n\t\t}\n\t}\n\tdestroy() {\n\t\tthis.cookiesRenderPass.destroy();\n\t\tthis.cookiesRenderPass = null;\n\t}\n\texecute() {\n\t\tconst {\n\t\t\trenderer\n\t\t} = this;\n\t\tconst {\n\t\t\tscene\n\t\t} = renderer;\n\t\trenderer.worldClustersAllocator.update(this.frameGraph.renderPasses, scene.gammaCorrection, scene.lighting);\n\t}\n}\n\nexport { RenderPassUpdateClustered };\n","import { Vec2 } from '../../core/math/vec2.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { Vec4 } from '../../core/math/vec4.js';\nimport { Mat3 } from '../../core/math/mat3.js';\nimport { Mat4 } from '../../core/math/mat4.js';\nimport { BoundingSphere } from '../../core/shape/bounding-sphere.js';\nimport { SORTKEY_FORWARD, SORTKEY_DEPTH, VIEW_CENTER, PROJECTION_ORTHOGRAPHIC, LIGHTTYPE_DIRECTIONAL, SHADOWUPDATE_NONE, SHADOWUPDATE_THISFRAME } from '../constants.js';\nimport { LightTextureAtlas } from '../lighting/light-texture-atlas.js';\nimport { Material } from '../materials/material.js';\nimport { LightCube } from '../graphics/light-cube.js';\nimport { CLEARFLAG_COLOR, CLEARFLAG_DEPTH, CLEARFLAG_STENCIL, CULLFACE_FRONT, CULLFACE_BACK, CULLFACE_NONE, UNIFORMTYPE_MAT4, UNIFORMTYPE_MAT3, UNIFORMTYPE_VEC3, UNIFORMTYPE_FLOAT, UNIFORMTYPE_VEC2, UNIFORMTYPE_INT, UNIFORM_BUFFER_DEFAULT_SLOT_NAME, SHADERSTAGE_VERTEX, SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_UNFILTERABLE_FLOAT, SAMPLETYPE_DEPTH, SAMPLETYPE_FLOAT, BINDGROUP_VIEW, BINDGROUP_MESH, SEMANTIC_ATTR } from '../../platform/graphics/constants.js';\nimport { UniformBuffer } from '../../platform/graphics/uniform-buffer.js';\nimport { BindGroup } from '../../platform/graphics/bind-group.js';\nimport { UniformFormat, UniformBufferFormat } from '../../platform/graphics/uniform-buffer-format.js';\nimport { BindUniformBufferFormat, BindTextureFormat, BindGroupFormat } from '../../platform/graphics/bind-group-format.js';\nimport { ShadowMapCache } from './shadow-map-cache.js';\nimport { ShadowRendererLocal } from './shadow-renderer-local.js';\nimport { ShadowRendererDirectional } from './shadow-renderer-directional.js';\nimport { ShadowRenderer } from './shadow-renderer.js';\nimport { WorldClustersAllocator } from './world-clusters-allocator.js';\nimport { RenderPassUpdateClustered } from './render-pass-update-clustered.js';\nimport { getBlueNoiseTexture } from '../graphics/noise-textures.js';\nimport { BlueNoise } from '../../core/math/blue-noise.js';\n\nlet _skinUpdateIndex = 0;\nconst viewProjMat = new Mat4();\nconst viewInvMat = new Mat4();\nconst viewMat = new Mat4();\nconst viewMat3 = new Mat3();\nconst tempSphere = new BoundingSphere();\nconst _flipYMat = new Mat4().setScale(1, -1, 1);\nconst _tempLightSet = new Set();\nconst _tempLayerSet = new Set();\nconst _fixProjRangeMat = new Mat4().set([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1]);\nconst _haltonSequence = [new Vec2(0.5, 0.333333), new Vec2(0.25, 0.666667), new Vec2(0.75, 0.111111), new Vec2(0.125, 0.444444), new Vec2(0.625, 0.777778), new Vec2(0.375, 0.222222), new Vec2(0.875, 0.555556), new Vec2(0.0625, 0.888889), new Vec2(0.5625, 0.037037), new Vec2(0.3125, 0.370370), new Vec2(0.8125, 0.703704), new Vec2(0.1875, 0.148148), new Vec2(0.6875, 0.481481), new Vec2(0.4375, 0.814815), new Vec2(0.9375, 0.259259), new Vec2(0.03125, 0.592593)];\nconst _tempProjMat0 = new Mat4();\nconst _tempProjMat1 = new Mat4();\nconst _tempProjMat2 = new Mat4();\nconst _tempProjMat3 = new Mat4();\nconst _tempProjMat4 = new Mat4();\nconst _tempProjMat5 = new Mat4();\nconst _tempSet = new Set();\nconst _tempMeshInstances = [];\nconst _tempMeshInstancesSkinned = [];\nclass Renderer {\n\tconstructor(graphicsDevice) {\n\t\tthis.clustersDebugRendered = false;\n\t\tthis.processingMeshInstances = new Set();\n\t\tthis.worldClustersAllocator = void 0;\n\t\tthis.lights = [];\n\t\tthis.localLights = [];\n\t\tthis.cameraDirShadowLights = new Map();\n\t\tthis.dirLightShadows = new Map();\n\t\tthis.blueNoise = new BlueNoise(123);\n\t\tthis.device = graphicsDevice;\n\t\tthis.scene = null;\n\t\tthis.worldClustersAllocator = new WorldClustersAllocator(graphicsDevice);\n\t\tthis.lightTextureAtlas = new LightTextureAtlas(graphicsDevice);\n\t\tthis.shadowMapCache = new ShadowMapCache();\n\t\tthis.shadowRenderer = new ShadowRenderer(this, this.lightTextureAtlas);\n\t\tthis._shadowRendererLocal = new ShadowRendererLocal(this, this.shadowRenderer);\n\t\tthis._shadowRendererDirectional = new ShadowRendererDirectional(this, this.shadowRenderer);\n\t\tthis._renderPassUpdateClustered = new RenderPassUpdateClustered(this.device, this, this.shadowRenderer, this._shadowRendererLocal, this.lightTextureAtlas);\n\t\tthis.viewUniformFormat = null;\n\t\tthis.viewBindGroupFormat = null;\n\t\tthis._skinTime = 0;\n\t\tthis._morphTime = 0;\n\t\tthis._cullTime = 0;\n\t\tthis._shadowMapTime = 0;\n\t\tthis._lightClustersTime = 0;\n\t\tthis._layerCompositionUpdateTime = 0;\n\t\tthis._shadowDrawCalls = 0;\n\t\tthis._skinDrawCalls = 0;\n\t\tthis._instancedDrawCalls = 0;\n\t\tthis._shadowMapUpdates = 0;\n\t\tthis._numDrawCallsCulled = 0;\n\t\tthis._camerasRendered = 0;\n\t\tthis._lightClusters = 0;\n\t\tconst scope = graphicsDevice.scope;\n\t\tthis.boneTextureId = scope.resolve('texture_poseMap');\n\t\tthis.boneTextureSizeId = scope.resolve('texture_poseMapSize');\n\t\tthis.poseMatrixId = scope.resolve('matrix_pose[0]');\n\t\tthis.modelMatrixId = scope.resolve('matrix_model');\n\t\tthis.normalMatrixId = scope.resolve('matrix_normal');\n\t\tthis.viewInvId = scope.resolve('matrix_viewInverse');\n\t\tthis.viewPos = new Float32Array(3);\n\t\tthis.viewPosId = scope.resolve('view_position');\n\t\tthis.projId = scope.resolve('matrix_projection');\n\t\tthis.projSkyboxId = scope.resolve('matrix_projectionSkybox');\n\t\tthis.viewId = scope.resolve('matrix_view');\n\t\tthis.viewId3 = scope.resolve('matrix_view3');\n\t\tthis.viewProjId = scope.resolve('matrix_viewProjection');\n\t\tthis.flipYId = scope.resolve('projectionFlipY');\n\t\tthis.tbnBasis = scope.resolve('tbnBasis');\n\t\tthis.nearClipId = scope.resolve('camera_near');\n\t\tthis.farClipId = scope.resolve('camera_far');\n\t\tthis.cameraParams = new Float32Array(4);\n\t\tthis.cameraParamsId = scope.resolve('camera_params');\n\t\tthis.viewIndexId = scope.resolve('view_index');\n\t\tthis.blueNoiseJitterVersion = 0;\n\t\tthis.blueNoiseJitterVec = new Vec4();\n\t\tthis.blueNoiseJitterData = new Float32Array(4);\n\t\tthis.blueNoiseJitterId = scope.resolve('blueNoiseJitter');\n\t\tthis.blueNoiseTextureId = scope.resolve('blueNoiseTex32');\n\t\tthis.alphaTestId = scope.resolve('alpha_ref');\n\t\tthis.opacityMapId = scope.resolve('texture_opacityMap');\n\t\tthis.exposureId = scope.resolve('exposure');\n\t\tthis.twoSidedLightingNegScaleFactorId = scope.resolve('twoSidedLightingNegScaleFactor');\n\t\tthis.twoSidedLightingNegScaleFactorId.setValue(0);\n\t\tthis.morphWeightsA = scope.resolve('morph_weights_a');\n\t\tthis.morphWeightsB = scope.resolve('morph_weights_b');\n\t\tthis.morphPositionTex = scope.resolve('morphPositionTex');\n\t\tthis.morphNormalTex = scope.resolve('morphNormalTex');\n\t\tthis.morphTexParams = scope.resolve('morph_tex_params');\n\t\tthis.lightCube = new LightCube();\n\t\tthis.constantLightCube = scope.resolve('lightCube[0]');\n\t}\n\tdestroy() {\n\t\tthis.shadowRenderer = null;\n\t\tthis._shadowRendererLocal = null;\n\t\tthis._shadowRendererDirectional = null;\n\t\tthis.shadowMapCache.destroy();\n\t\tthis.shadowMapCache = null;\n\t\tthis._renderPassUpdateClustered.destroy();\n\t\tthis._renderPassUpdateClustered = null;\n\t\tthis.lightTextureAtlas.destroy();\n\t\tthis.lightTextureAtlas = null;\n\t}\n\tsortCompare(drawCallA, drawCallB) {\n\t\tif (drawCallA.layer === drawCallB.layer) {\n\t\t\tif (drawCallA.drawOrder && drawCallB.drawOrder) {\n\t\t\t\treturn drawCallA.drawOrder - drawCallB.drawOrder;\n\t\t\t} else if (drawCallA.zdist && drawCallB.zdist) {\n\t\t\t\treturn drawCallB.zdist - drawCallA.zdist;\n\t\t\t} else if (drawCallA.zdist2 && drawCallB.zdist2) {\n\t\t\t\treturn drawCallA.zdist2 - drawCallB.zdist2;\n\t\t\t}\n\t\t}\n\t\treturn drawCallB._key[SORTKEY_FORWARD] - drawCallA._key[SORTKEY_FORWARD];\n\t}\n\tsortCompareMesh(drawCallA, drawCallB) {\n\t\tif (drawCallA.layer === drawCallB.layer) {\n\t\t\tif (drawCallA.drawOrder && drawCallB.drawOrder) {\n\t\t\t\treturn drawCallA.drawOrder - drawCallB.drawOrder;\n\t\t\t} else if (drawCallA.zdist && drawCallB.zdist) {\n\t\t\t\treturn drawCallB.zdist - drawCallA.zdist;\n\t\t\t}\n\t\t}\n\t\tconst keyA = drawCallA._key[SORTKEY_FORWARD];\n\t\tconst keyB = drawCallB._key[SORTKEY_FORWARD];\n\t\tif (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {\n\t\t\treturn drawCallB.mesh.id - drawCallA.mesh.id;\n\t\t}\n\t\treturn keyB - keyA;\n\t}\n\tsortCompareDepth(drawCallA, drawCallB) {\n\t\tconst keyA = drawCallA._key[SORTKEY_DEPTH];\n\t\tconst keyB = drawCallB._key[SORTKEY_DEPTH];\n\t\tif (keyA === keyB && drawCallA.mesh && drawCallB.mesh) {\n\t\t\treturn drawCallB.mesh.id - drawCallA.mesh.id;\n\t\t}\n\t\treturn keyB - keyA;\n\t}\n\tsetupViewport(camera, renderTarget) {\n\t\tconst device = this.device;\n\t\tconst pixelWidth = renderTarget ? renderTarget.width : device.width;\n\t\tconst pixelHeight = renderTarget ? renderTarget.height : device.height;\n\t\tconst rect = camera.rect;\n\t\tlet x = Math.floor(rect.x * pixelWidth);\n\t\tlet y = Math.floor(rect.y * pixelHeight);\n\t\tlet w = Math.floor(rect.z * pixelWidth);\n\t\tlet h = Math.floor(rect.w * pixelHeight);\n\t\tdevice.setViewport(x, y, w, h);\n\t\tif (camera._scissorRectClear) {\n\t\t\tconst scissorRect = camera.scissorRect;\n\t\t\tx = Math.floor(scissorRect.x * pixelWidth);\n\t\t\ty = Math.floor(scissorRect.y * pixelHeight);\n\t\t\tw = Math.floor(scissorRect.z * pixelWidth);\n\t\t\th = Math.floor(scissorRect.w * pixelHeight);\n\t\t}\n\t\tdevice.setScissor(x, y, w, h);\n\t}\n\tsetCameraUniforms(camera, target) {\n\t\tconst flipY = target == null ? void 0 : target.flipY;\n\t\tlet viewCount = 1;\n\t\tif (camera.xr && camera.xr.session) {\n\t\t\tvar _camera$_node;\n\t\t\tconst transform = ((_camera$_node = camera._node) == null || (_camera$_node = _camera$_node.parent) == null ? void 0 : _camera$_node.getWorldTransform()) || null;\n\t\t\tconst views = camera.xr.views;\n\t\t\tviewCount = views.list.length;\n\t\t\tfor (let v = 0; v < viewCount; v++) {\n\t\t\t\tconst view = views.list[v];\n\t\t\t\tview.updateTransforms(transform);\n\t\t\t\tcamera.frustum.setFromMat4(view.projViewOffMat);\n\t\t\t}\n\t\t} else {\n\t\t\tlet projMat = camera.projectionMatrix;\n\t\t\tif (camera.calculateProjection) {\n\t\t\t\tcamera.calculateProjection(projMat, VIEW_CENTER);\n\t\t\t}\n\t\t\tlet projMatSkybox = camera.getProjectionMatrixSkybox();\n\t\t\tif (flipY) {\n\t\t\t\tprojMat = _tempProjMat0.mul2(_flipYMat, projMat);\n\t\t\t\tprojMatSkybox = _tempProjMat1.mul2(_flipYMat, projMatSkybox);\n\t\t\t}\n\t\t\tif (this.device.isWebGPU) {\n\t\t\t\tprojMat = _tempProjMat2.mul2(_fixProjRangeMat, projMat);\n\t\t\t\tprojMatSkybox = _tempProjMat3.mul2(_fixProjRangeMat, projMatSkybox);\n\t\t\t}\n\t\t\tconst {\n\t\t\t\tjitter\n\t\t\t} = camera;\n\t\t\tlet jitterX = 0;\n\t\t\tlet jitterY = 0;\n\t\t\tif (jitter > 0) {\n\t\t\t\tconst targetWidth = target ? target.width : this.device.width;\n\t\t\t\tconst targetHeight = target ? target.height : this.device.height;\n\t\t\t\tconst offset = _haltonSequence[this.device.renderVersion % _haltonSequence.length];\n\t\t\t\tjitterX = jitter * (offset.x * 2 - 1) / targetWidth;\n\t\t\t\tjitterY = jitter * (offset.y * 2 - 1) / targetHeight;\n\t\t\t\tprojMat = _tempProjMat4.copy(projMat);\n\t\t\t\tprojMat.data[8] = jitterX;\n\t\t\t\tprojMat.data[9] = jitterY;\n\t\t\t\tprojMatSkybox = _tempProjMat5.copy(projMatSkybox);\n\t\t\t\tprojMatSkybox.data[8] = jitterX;\n\t\t\t\tprojMatSkybox.data[9] = jitterY;\n\t\t\t\tif (this.blueNoiseJitterVersion !== this.device.renderVersion) {\n\t\t\t\t\tthis.blueNoiseJitterVersion = this.device.renderVersion;\n\t\t\t\t\tthis.blueNoise.vec4(this.blueNoiseJitterVec);\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst jitterVec = jitter > 0 ? this.blueNoiseJitterVec : Vec4.ZERO;\n\t\t\tthis.blueNoiseJitterData[0] = jitterVec.x;\n\t\t\tthis.blueNoiseJitterData[1] = jitterVec.y;\n\t\t\tthis.blueNoiseJitterData[2] = jitterVec.z;\n\t\t\tthis.blueNoiseJitterData[3] = jitterVec.w;\n\t\t\tthis.blueNoiseJitterId.setValue(this.blueNoiseJitterData);\n\t\t\tthis.projId.setValue(projMat.data);\n\t\t\tthis.projSkyboxId.setValue(projMatSkybox.data);\n\t\t\tif (camera.calculateTransform) {\n\t\t\t\tcamera.calculateTransform(viewInvMat, VIEW_CENTER);\n\t\t\t} else {\n\t\t\t\tconst pos = camera._node.getPosition();\n\t\t\t\tconst rot = camera._node.getRotation();\n\t\t\t\tviewInvMat.setTRS(pos, rot, Vec3.ONE);\n\t\t\t}\n\t\t\tthis.viewInvId.setValue(viewInvMat.data);\n\t\t\tviewMat.copy(viewInvMat).invert();\n\t\t\tthis.viewId.setValue(viewMat.data);\n\t\t\tviewMat3.setFromMat4(viewMat);\n\t\t\tthis.viewId3.setValue(viewMat3.data);\n\t\t\tviewProjMat.mul2(projMat, viewMat);\n\t\t\tthis.viewProjId.setValue(viewProjMat.data);\n\t\t\tcamera._storeShaderMatrices(viewProjMat, jitterX, jitterY, this.device.renderVersion);\n\t\t\tthis.flipYId.setValue(flipY ? -1 : 1);\n\t\t\tthis.dispatchViewPos(camera._node.getPosition());\n\t\t\tcamera.frustum.setFromMat4(viewProjMat);\n\t\t}\n\t\tthis.tbnBasis.setValue(flipY ? -1 : 1);\n\t\tconst n = camera._nearClip;\n\t\tconst f = camera._farClip;\n\t\tthis.nearClipId.setValue(n);\n\t\tthis.farClipId.setValue(f);\n\t\tthis.cameraParams[0] = 1 / f;\n\t\tthis.cameraParams[1] = f;\n\t\tthis.cameraParams[2] = n;\n\t\tthis.cameraParams[3] = camera.projection === PROJECTION_ORTHOGRAPHIC ? 1 : 0;\n\t\tthis.cameraParamsId.setValue(this.cameraParams);\n\t\tthis.exposureId.setValue(this.scene.physicalUnits ? camera.getExposure() : this.scene.exposure);\n\t\treturn viewCount;\n\t}\n\tclear(camera, clearColor, clearDepth, clearStencil) {\n\t\tconst flags = ((clearColor != null ? clearColor : camera._clearColorBuffer) ? CLEARFLAG_COLOR : 0) | ((clearDepth != null ? clearDepth : camera._clearDepthBuffer) ? CLEARFLAG_DEPTH : 0) | ((clearStencil != null ? clearStencil : camera._clearStencilBuffer) ? CLEARFLAG_STENCIL : 0);\n\t\tif (flags) {\n\t\t\tconst device = this.device;\n\t\t\tdevice.clear({\n\t\t\t\tcolor: [camera._clearColor.r, camera._clearColor.g, camera._clearColor.b, camera._clearColor.a],\n\t\t\t\tdepth: camera._clearDepth,\n\t\t\t\tstencil: camera._clearStencil,\n\t\t\t\tflags: flags\n\t\t\t});\n\t\t}\n\t}\n\tsetCamera(camera, target, clear, renderAction = null) {\n\t\tthis.setCameraUniforms(camera, target);\n\t\tthis.clearView(camera, target, clear, false);\n\t}\n\tclearView(camera, target, clear, forceWrite) {\n\t\tconst device = this.device;\n\t\tdevice.setRenderTarget(target);\n\t\tdevice.updateBegin();\n\t\tif (forceWrite) {\n\t\t\tdevice.setColorWrite(true, true, true, true);\n\t\t\tdevice.setDepthWrite(true);\n\t\t}\n\t\tthis.setupViewport(camera, target);\n\t\tif (clear) {\n\t\t\tconst options = camera._clearOptions;\n\t\t\tdevice.clear(options ? options : {\n\t\t\t\tcolor: [camera._clearColor.r, camera._clearColor.g, camera._clearColor.b, camera._clearColor.a],\n\t\t\t\tdepth: camera._clearDepth,\n\t\t\t\tflags: (camera._clearColorBuffer ? CLEARFLAG_COLOR : 0) | (camera._clearDepthBuffer ? CLEARFLAG_DEPTH : 0) | (camera._clearStencilBuffer ? CLEARFLAG_STENCIL : 0),\n\t\t\t\tstencil: camera._clearStencil\n\t\t\t});\n\t\t}\n\t}\n\tsetupCullMode(cullFaces, flipFactor, drawCall) {\n\t\tconst material = drawCall.material;\n\t\tlet mode = CULLFACE_NONE;\n\t\tif (cullFaces) {\n\t\t\tlet flipFaces = 1;\n\t\t\tif (material.cull === CULLFACE_FRONT || material.cull === CULLFACE_BACK) {\n\t\t\t\tflipFaces = flipFactor * drawCall.flipFacesFactor * drawCall.node.worldScaleSign;\n\t\t\t}\n\t\t\tif (flipFaces < 0) {\n\t\t\t\tmode = material.cull === CULLFACE_FRONT ? CULLFACE_BACK : CULLFACE_FRONT;\n\t\t\t} else {\n\t\t\t\tmode = material.cull;\n\t\t\t}\n\t\t}\n\t\tthis.device.setCullMode(mode);\n\t\tif (mode === CULLFACE_NONE && material.cull === CULLFACE_NONE) {\n\t\t\tthis.twoSidedLightingNegScaleFactorId.setValue(drawCall.node.worldScaleSign);\n\t\t}\n\t}\n\tupdateCameraFrustum(camera) {\n\t\tif (camera.xr && camera.xr.views.list.length) {\n\t\t\tconst view = camera.xr.views.list[0];\n\t\t\tviewProjMat.mul2(view.projMat, view.viewOffMat);\n\t\t\tcamera.frustum.setFromMat4(viewProjMat);\n\t\t\treturn;\n\t\t}\n\t\tconst projMat = camera.projectionMatrix;\n\t\tif (camera.calculateProjection) {\n\t\t\tcamera.calculateProjection(projMat, VIEW_CENTER);\n\t\t}\n\t\tif (camera.calculateTransform) {\n\t\t\tcamera.calculateTransform(viewInvMat, VIEW_CENTER);\n\t\t} else {\n\t\t\tconst pos = camera._node.getPosition();\n\t\t\tconst rot = camera._node.getRotation();\n\t\t\tviewInvMat.setTRS(pos, rot, Vec3.ONE);\n\t\t\tthis.viewInvId.setValue(viewInvMat.data);\n\t\t}\n\t\tviewMat.copy(viewInvMat).invert();\n\t\tviewProjMat.mul2(projMat, viewMat);\n\t\tcamera.frustum.setFromMat4(viewProjMat);\n\t}\n\tsetBaseConstants(device, material) {\n\t\tdevice.setCullMode(material.cull);\n\t\tif (material.opacityMap) {\n\t\t\tthis.opacityMapId.setValue(material.opacityMap);\n\t\t}\n\t\tif (material.opacityMap || material.alphaTest > 0) {\n\t\t\tthis.alphaTestId.setValue(material.alphaTest);\n\t\t}\n\t}\n\tupdateCpuSkinMatrices(drawCalls) {\n\t\t_skinUpdateIndex++;\n\t\tconst drawCallsCount = drawCalls.length;\n\t\tif (drawCallsCount === 0) return;\n\t\tfor (let i = 0; i < drawCallsCount; i++) {\n\t\t\tconst si = drawCalls[i].skinInstance;\n\t\t\tif (si) {\n\t\t\t\tsi.updateMatrices(drawCalls[i].node, _skinUpdateIndex);\n\t\t\t\tsi._dirty = true;\n\t\t\t}\n\t\t}\n\t}\n\tupdateGpuSkinMatrices(drawCalls) {\n\t\tfor (const drawCall of drawCalls) {\n\t\t\tconst skin = drawCall.skinInstance;\n\t\t\tif (skin && skin._dirty) {\n\t\t\t\tskin.updateMatrixPalette(drawCall.node, _skinUpdateIndex);\n\t\t\t\tskin._dirty = false;\n\t\t\t}\n\t\t}\n\t}\n\tupdateMorphing(drawCalls) {\n\t\tfor (const drawCall of drawCalls) {\n\t\t\tconst morphInst = drawCall.morphInstance;\n\t\t\tif (morphInst && morphInst._dirty) {\n\t\t\t\tmorphInst.update();\n\t\t\t}\n\t\t}\n\t}\n\tupdateGSplats(drawCalls) {\n\t\tfor (const drawCall of drawCalls) {\n\t\t\tvar _drawCall$gsplatInsta;\n\t\t\t(_drawCall$gsplatInsta = drawCall.gsplatInstance) == null || _drawCall$gsplatInsta.update();\n\t\t}\n\t}\n\tgpuUpdate(drawCalls) {\n\t\tthis.updateGpuSkinMatrices(drawCalls);\n\t\tthis.updateMorphing(drawCalls);\n\t\tthis.updateGSplats(drawCalls);\n\t}\n\tsetVertexBuffers(device, mesh) {\n\t\tdevice.setVertexBuffer(mesh.vertexBuffer);\n\t}\n\tsetMorphing(device, morphInstance) {\n\t\tif (morphInstance) {\n\t\t\tif (morphInstance.morph.useTextureMorph) {\n\t\t\t\tdevice.setVertexBuffer(morphInstance.morph.vertexBufferIds);\n\t\t\t\tthis.morphPositionTex.setValue(morphInstance.texturePositions);\n\t\t\t\tthis.morphNormalTex.setValue(morphInstance.textureNormals);\n\t\t\t\tthis.morphTexParams.setValue(morphInstance._textureParams);\n\t\t\t} else {\n\t\t\t\tfor (let t = 0; t < morphInstance._activeVertexBuffers.length; t++) {\n\t\t\t\t\tconst vb = morphInstance._activeVertexBuffers[t];\n\t\t\t\t\tif (vb) {\n\t\t\t\t\t\tconst semantic = SEMANTIC_ATTR + (t + 8);\n\t\t\t\t\t\tvb.format.elements[0].name = semantic;\n\t\t\t\t\t\tvb.format.elements[0].scopeId = device.scope.resolve(semantic);\n\t\t\t\t\t\tvb.format.update();\n\t\t\t\t\t\tdevice.setVertexBuffer(vb);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.morphWeightsA.setValue(morphInstance._shaderMorphWeightsA);\n\t\t\t\tthis.morphWeightsB.setValue(morphInstance._shaderMorphWeightsB);\n\t\t\t}\n\t\t}\n\t}\n\tsetSkinning(device, meshInstance) {\n\t\tconst skinInstance = meshInstance.skinInstance;\n\t\tif (skinInstance) {\n\t\t\tthis._skinDrawCalls++;\n\t\t\tif (device.supportsBoneTextures) {\n\t\t\t\tconst boneTexture = skinInstance.boneTexture;\n\t\t\t\tthis.boneTextureId.setValue(boneTexture);\n\t\t\t\tthis.boneTextureSizeId.setValue(skinInstance.boneTextureSize);\n\t\t\t} else {\n\t\t\t\tthis.poseMatrixId.setValue(skinInstance.matrixPalette);\n\t\t\t}\n\t\t}\n\t}\n\tdispatchViewPos(position) {\n\t\tconst vp = this.viewPos;\n\t\tvp[0] = position.x;\n\t\tvp[1] = position.y;\n\t\tvp[2] = position.z;\n\t\tthis.viewPosId.setValue(vp);\n\t}\n\tinitViewBindGroupFormat(isClustered) {\n\t\tif (this.device.supportsUniformBuffers && !this.viewUniformFormat) {\n\t\t\tconst uniforms = [new UniformFormat('matrix_viewProjection', UNIFORMTYPE_MAT4), new UniformFormat('cubeMapRotationMatrix', UNIFORMTYPE_MAT3), new UniformFormat('view_position', UNIFORMTYPE_VEC3), new UniformFormat('skyboxIntensity', UNIFORMTYPE_FLOAT), new UniformFormat('exposure', UNIFORMTYPE_FLOAT), new UniformFormat('textureBias', UNIFORMTYPE_FLOAT)];\n\t\t\tif (isClustered) {\n\t\t\t\tuniforms.push(...[new UniformFormat('clusterCellsCountByBoundsSize', UNIFORMTYPE_VEC3), new UniformFormat('clusterTextureSize', UNIFORMTYPE_VEC3), new UniformFormat('clusterBoundsMin', UNIFORMTYPE_VEC3), new UniformFormat('clusterBoundsDelta', UNIFORMTYPE_VEC3), new UniformFormat('clusterCellsDot', UNIFORMTYPE_VEC3), new UniformFormat('clusterCellsMax', UNIFORMTYPE_VEC3), new UniformFormat('clusterCompressionLimit0', UNIFORMTYPE_VEC2), new UniformFormat('shadowAtlasParams', UNIFORMTYPE_VEC2), new UniformFormat('clusterMaxCells', UNIFORMTYPE_INT), new UniformFormat('clusterSkip', UNIFORMTYPE_FLOAT)]);\n\t\t\t}\n\t\t\tthis.viewUniformFormat = new UniformBufferFormat(this.device, uniforms);\n\t\t\tconst formats = [new BindUniformBufferFormat(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT), new BindTextureFormat('lightsTextureFloat', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_UNFILTERABLE_FLOAT), new BindTextureFormat('lightsTexture8', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_UNFILTERABLE_FLOAT), new BindTextureFormat('shadowAtlasTexture', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_DEPTH), new BindTextureFormat('cookieAtlasTexture', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_FLOAT), new BindTextureFormat('areaLightsLutTex1', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_FLOAT), new BindTextureFormat('areaLightsLutTex2', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_FLOAT)];\n\t\t\tif (isClustered) {\n\t\t\t\tformats.push(...[new BindTextureFormat('clusterWorldTexture', SHADERSTAGE_FRAGMENT, TEXTUREDIMENSION_2D, SAMPLETYPE_UNFILTERABLE_FLOAT)]);\n\t\t\t}\n\t\t\tthis.viewBindGroupFormat = new BindGroupFormat(this.device, formats);\n\t\t}\n\t}\n\tsetupViewUniformBuffers(viewBindGroups, viewUniformFormat, viewBindGroupFormat, viewCount) {\n\t\tconst device = this.device;\n\t\twhile (viewBindGroups.length < viewCount) {\n\t\t\tconst ub = new UniformBuffer(device, viewUniformFormat, false);\n\t\t\tconst bg = new BindGroup(device, viewBindGroupFormat, ub);\n\t\t\tviewBindGroups.push(bg);\n\t\t}\n\t\tconst viewBindGroup = viewBindGroups[0];\n\t\tviewBindGroup.defaultUniformBuffer.update();\n\t\tviewBindGroup.update();\n\t\tdevice.setBindGroup(BINDGROUP_VIEW, viewBindGroup);\n\t}\n\tsetupMeshUniformBuffers(shaderInstance, meshInstance) {\n\t\tconst device = this.device;\n\t\tif (device.supportsUniformBuffers) {\n\t\t\tthis.modelMatrixId.setValue(meshInstance.node.worldTransform.data);\n\t\t\tthis.normalMatrixId.setValue(meshInstance.node.normalMatrix.data);\n\t\t\tconst meshBindGroup = shaderInstance.getBindGroup(device);\n\t\t\tmeshBindGroup.defaultUniformBuffer.update();\n\t\t\tmeshBindGroup.update();\n\t\t\tdevice.setBindGroup(BINDGROUP_MESH, meshBindGroup);\n\t\t}\n\t}\n\tdrawInstance(device, meshInstance, mesh, style, normal) {\n\t\tconst modelMatrix = meshInstance.node.worldTransform;\n\t\tthis.modelMatrixId.setValue(modelMatrix.data);\n\t\tif (normal) {\n\t\t\tthis.normalMatrixId.setValue(meshInstance.node.normalMatrix.data);\n\t\t}\n\t\tconst instancingData = meshInstance.instancingData;\n\t\tif (instancingData) {\n\t\t\tif (instancingData.count > 0) {\n\t\t\t\tthis._instancedDrawCalls++;\n\t\t\t\tdevice.setVertexBuffer(instancingData.vertexBuffer);\n\t\t\t\tdevice.draw(mesh.primitive[style], instancingData.count);\n\t\t\t} else {\n\t\t\t\tdevice.clearVertexBuffer();\n\t\t\t}\n\t\t} else {\n\t\t\tdevice.draw(mesh.primitive[style]);\n\t\t}\n\t}\n\tdrawInstance2(device, meshInstance, mesh, style) {\n\t\tconst instancingData = meshInstance.instancingData;\n\t\tif (instancingData) {\n\t\t\tif (instancingData.count > 0) {\n\t\t\t\tthis._instancedDrawCalls++;\n\t\t\t\tdevice.draw(mesh.primitive[style], instancingData.count, true);\n\t\t\t} else {\n\t\t\t\tdevice.clearVertexBuffer();\n\t\t\t}\n\t\t} else {\n\t\t\tdevice.draw(mesh.primitive[style], undefined, true);\n\t\t}\n\t}\n\tcull(camera, drawCalls, culledInstances) {\n\t\tconst opaque = culledInstances.opaque;\n\t\topaque.length = 0;\n\t\tconst transparent = culledInstances.transparent;\n\t\ttransparent.length = 0;\n\t\tconst doCull = camera.frustumCulling;\n\t\tconst count = drawCalls.length;\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst drawCall = drawCalls[i];\n\t\t\tif (drawCall.visible) {\n\t\t\t\tconst visible = !doCull || !drawCall.cull || drawCall._isVisible(camera);\n\t\t\t\tif (visible) {\n\t\t\t\t\tdrawCall.visibleThisFrame = true;\n\t\t\t\t\tconst bucket = drawCall.transparent ? transparent : opaque;\n\t\t\t\t\tbucket.push(drawCall);\n\t\t\t\t\tif (drawCall.skinInstance || drawCall.morphInstance || drawCall.gsplatInstance) {\n\t\t\t\t\t\tthis.processingMeshInstances.add(drawCall);\n\t\t\t\t\t\tif (drawCall.gsplatInstance) {\n\t\t\t\t\t\t\tdrawCall.gsplatInstance.cameras.push(camera);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcollectLights(comp) {\n\t\tthis.lights.length = 0;\n\t\tthis.localLights.length = 0;\n\t\tconst stats = this.scene._stats;\n\t\tconst count = comp.layerList.length;\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst layer = comp.layerList[i];\n\t\t\tif (!_tempLayerSet.has(layer)) {\n\t\t\t\t_tempLayerSet.add(layer);\n\t\t\t\tconst lights = layer._lights;\n\t\t\t\tfor (let j = 0; j < lights.length; j++) {\n\t\t\t\t\tconst light = lights[j];\n\t\t\t\t\tif (!_tempLightSet.has(light)) {\n\t\t\t\t\t\t_tempLightSet.add(light);\n\t\t\t\t\t\tthis.lights.push(light);\n\t\t\t\t\t\tif (light._type !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\t\t\tthis.localLights.push(light);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstats.lights = this.lights.length;\n\t\t_tempLightSet.clear();\n\t\t_tempLayerSet.clear();\n\t}\n\tcullLights(camera, lights) {\n\t\tconst clusteredLightingEnabled = this.scene.clusteredLightingEnabled;\n\t\tconst physicalUnits = this.scene.physicalUnits;\n\t\tfor (let i = 0; i < lights.length; i++) {\n\t\t\tconst light = lights[i];\n\t\t\tif (light.enabled) {\n\t\t\t\tif (light._type !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tlight.getBoundingSphere(tempSphere);\n\t\t\t\t\tif (camera.frustum.containsSphere(tempSphere)) {\n\t\t\t\t\t\tlight.visibleThisFrame = true;\n\t\t\t\t\t\tlight.usePhysicalUnits = physicalUnits;\n\t\t\t\t\t\tconst screenSize = camera.getScreenSize(tempSphere);\n\t\t\t\t\t\tlight.maxScreenSize = Math.max(light.maxScreenSize, screenSize);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!clusteredLightingEnabled) {\n\t\t\t\t\t\t\tif (light.castShadows && !light.shadowMap) {\n\t\t\t\t\t\t\t\tlight.visibleThisFrame = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlight.usePhysicalUnits = this.scene.physicalUnits;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcullShadowmaps(comp) {\n\t\tconst isClustered = this.scene.clusteredLightingEnabled;\n\t\tfor (let i = 0; i < this.localLights.length; i++) {\n\t\t\tconst light = this.localLights[i];\n\t\t\tif (light._type !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\tif (isClustered) {\n\t\t\t\t\tif (light.atlasSlotUpdated && light.shadowUpdateMode === SHADOWUPDATE_NONE) {\n\t\t\t\t\t\tlight.shadowUpdateMode = SHADOWUPDATE_THISFRAME;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (light.shadowUpdateMode === SHADOWUPDATE_NONE && light.castShadows) {\n\t\t\t\t\t\tif (!light.getRenderData(null, 0).shadowCamera.renderTarget) {\n\t\t\t\t\t\t\tlight.shadowUpdateMode = SHADOWUPDATE_THISFRAME;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (light.visibleThisFrame && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE) {\n\t\t\t\t\tthis._shadowRendererLocal.cull(light, comp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.cameraDirShadowLights.clear();\n\t\tconst cameras = comp.cameras;\n\t\tfor (let i = 0; i < cameras.length; i++) {\n\t\t\tconst cameraComponent = cameras[i];\n\t\t\tif (cameraComponent.enabled) {\n\t\t\t\tconst camera = cameraComponent.camera;\n\t\t\t\tlet lightList;\n\t\t\t\tconst cameraLayers = camera.layers;\n\t\t\t\tfor (let l = 0; l < cameraLayers.length; l++) {\n\t\t\t\t\tconst cameraLayer = comp.getLayerById(cameraLayers[l]);\n\t\t\t\t\tif (cameraLayer) {\n\t\t\t\t\t\tconst layerDirLights = cameraLayer.splitLights[LIGHTTYPE_DIRECTIONAL];\n\t\t\t\t\t\tfor (let j = 0; j < layerDirLights.length; j++) {\n\t\t\t\t\t\t\tconst light = layerDirLights[j];\n\t\t\t\t\t\t\tif (light.castShadows && !_tempSet.has(light)) {\n\t\t\t\t\t\t\t\tvar _lightList;\n\t\t\t\t\t\t\t\t_tempSet.add(light);\n\t\t\t\t\t\t\t\tlightList = (_lightList = lightList) != null ? _lightList : [];\n\t\t\t\t\t\t\t\tlightList.push(light);\n\t\t\t\t\t\t\t\tthis._shadowRendererDirectional.cull(light, comp, camera);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lightList) {\n\t\t\t\t\tthis.cameraDirShadowLights.set(camera, lightList);\n\t\t\t\t}\n\t\t\t\t_tempSet.clear();\n\t\t\t}\n\t\t}\n\t}\n\tcullComposition(comp) {\n\t\tthis.processingMeshInstances.clear();\n\t\tconst numCameras = comp.cameras.length;\n\t\tfor (let i = 0; i < numCameras; i++) {\n\t\t\tconst camera = comp.cameras[i];\n\t\t\tlet currentRenderTarget;\n\t\t\tlet cameraChanged = true;\n\t\t\tthis._camerasRendered++;\n\t\t\tconst layerIds = camera.layers;\n\t\t\tfor (let j = 0; j < layerIds.length; j++) {\n\t\t\t\tconst layer = comp.getLayerById(layerIds[j]);\n\t\t\t\tif (layer && layer.enabled) {\n\t\t\t\t\tvar _camera$renderTarget;\n\t\t\t\t\tconst renderTarget = (_camera$renderTarget = camera.renderTarget) != null ? _camera$renderTarget : layer.renderTarget;\n\t\t\t\t\tif (cameraChanged || renderTarget !== currentRenderTarget) {\n\t\t\t\t\t\tcameraChanged = false;\n\t\t\t\t\t\tcurrentRenderTarget = renderTarget;\n\t\t\t\t\t\tcamera.frameUpdate(renderTarget);\n\t\t\t\t\t\tthis.updateCameraFrustum(camera.camera);\n\t\t\t\t\t}\n\t\t\t\t\tthis.cullLights(camera.camera, layer._lights);\n\t\t\t\t\tlayer.onPreCull == null || layer.onPreCull(comp.camerasMap.get(camera));\n\t\t\t\t\tconst culledInstances = layer.getCulledInstances(camera.camera);\n\t\t\t\t\tthis.cull(camera.camera, layer.meshInstances, culledInstances);\n\t\t\t\t\tlayer.onPostCull == null || layer.onPostCull(comp.camerasMap.get(camera));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (this.scene.clusteredLightingEnabled) {\n\t\t\tthis.updateLightTextureAtlas();\n\t\t}\n\t\tthis.cullShadowmaps(comp);\n\t}\n\tupdateShaders(drawCalls, onlyLitShaders) {\n\t\tconst count = drawCalls.length;\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst mat = drawCalls[i].material;\n\t\t\tif (mat) {\n\t\t\t\tif (!_tempSet.has(mat)) {\n\t\t\t\t\t_tempSet.add(mat);\n\t\t\t\t\tif (mat.getShaderVariant !== Material.prototype.getShaderVariant) {\n\t\t\t\t\t\tif (onlyLitShaders) {\n\t\t\t\t\t\t\tif (!mat.useLighting || mat.emitter && !mat.emitter.lighting) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmat.clearVariants();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_tempSet.clear();\n\t}\n\tupdateFrameUniforms() {\n\t\tthis.blueNoiseTextureId.setValue(getBlueNoiseTexture(this.device));\n\t}\n\tbeginFrame(comp) {\n\t\tconst scene = this.scene;\n\t\tconst updateShaders = scene.updateShaders;\n\t\tconst layers = comp.layerList;\n\t\tconst layerCount = layers.length;\n\t\tfor (let i = 0; i < layerCount; i++) {\n\t\t\tconst layer = layers[i];\n\t\t\tconst meshInstances = layer.meshInstances;\n\t\t\tconst count = meshInstances.length;\n\t\t\tfor (let j = 0; j < count; j++) {\n\t\t\t\tconst meshInst = meshInstances[j];\n\t\t\t\tmeshInst.visibleThisFrame = false;\n\t\t\t\tif (updateShaders) {\n\t\t\t\t\t_tempMeshInstances.push(meshInst);\n\t\t\t\t}\n\t\t\t\tif (meshInst.skinInstance) {\n\t\t\t\t\t_tempMeshInstancesSkinned.push(meshInst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (updateShaders) {\n\t\t\tconst onlyLitShaders = !scene.updateShaders;\n\t\t\tthis.updateShaders(_tempMeshInstances, onlyLitShaders);\n\t\t\tscene.updateShaders = false;\n\t\t\tscene._shaderVersion++;\n\t\t}\n\t\tthis.updateFrameUniforms();\n\t\tthis.updateCpuSkinMatrices(_tempMeshInstancesSkinned);\n\t\t_tempMeshInstances.length = 0;\n\t\t_tempMeshInstancesSkinned.length = 0;\n\t\tconst lights = this.lights;\n\t\tconst lightCount = lights.length;\n\t\tfor (let i = 0; i < lightCount; i++) {\n\t\t\tlights[i].beginFrame();\n\t\t}\n\t}\n\tupdateLightTextureAtlas() {\n\t\tthis.lightTextureAtlas.update(this.localLights, this.scene.lighting);\n\t}\n\tupdateLayerComposition(comp) {\n\t\tconst len = comp.layerList.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tcomp.layerList[i]._postRenderCounter = 0;\n\t\t}\n\t\tconst scene = this.scene;\n\t\tconst shaderVersion = scene._shaderVersion;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst layer = comp.layerList[i];\n\t\t\tlayer._shaderVersion = shaderVersion;\n\t\t\tlayer._preRenderCalledForCameras = 0;\n\t\t\tlayer._postRenderCalledForCameras = 0;\n\t\t\tconst transparent = comp.subLayerList[i];\n\t\t\tif (transparent) {\n\t\t\t\tlayer._postRenderCounter |= 2;\n\t\t\t} else {\n\t\t\t\tlayer._postRenderCounter |= 1;\n\t\t\t}\n\t\t\tlayer._postRenderCounterMax = layer._postRenderCounter;\n\t\t}\n\t\tcomp._update();\n\t}\n\tframeUpdate() {\n\t\tthis.clustersDebugRendered = false;\n\t\tthis.initViewBindGroupFormat(this.scene.clusteredLightingEnabled);\n\t\tthis.dirLightShadows.clear();\n\t}\n}\n\nexport { Renderer };\n","import { LIGHTTYPE_OMNI } from '../constants.js';\nimport { ShadowMap } from './shadow-map.js';\n\nclass ShadowMapCache {\n\tconstructor() {\n\t\tthis.cache = new Map();\n\t}\n\tdestroy() {\n\t\tthis.clear();\n\t\tthis.cache = null;\n\t}\n\tclear() {\n\t\tthis.cache.forEach(shadowMaps => {\n\t\t\tshadowMaps.forEach(shadowMap => {\n\t\t\t\tshadowMap.destroy();\n\t\t\t});\n\t\t});\n\t\tthis.cache.clear();\n\t}\n\tgetKey(light) {\n\t\tconst isCubeMap = light._type === LIGHTTYPE_OMNI;\n\t\tconst shadowType = light._shadowType;\n\t\tconst resolution = light._shadowResolution;\n\t\treturn `${isCubeMap}-${shadowType}-${resolution}`;\n\t}\n\tget(device, light) {\n\t\tconst key = this.getKey(light);\n\t\tconst shadowMaps = this.cache.get(key);\n\t\tif (shadowMaps && shadowMaps.length) {\n\t\t\treturn shadowMaps.pop();\n\t\t}\n\t\tconst shadowMap = ShadowMap.create(device, light);\n\t\tshadowMap.cached = true;\n\t\treturn shadowMap;\n\t}\n\tadd(light, shadowMap) {\n\t\tconst key = this.getKey(light);\n\t\tconst shadowMaps = this.cache.get(key);\n\t\tif (shadowMaps) {\n\t\t\tshadowMaps.push(shadowMap);\n\t\t} else {\n\t\t\tthis.cache.set(key, [shadowMap]);\n\t\t}\n\t}\n}\n\nexport { ShadowMapCache };\n","import { PIXELFORMAT_RGBA32F, PIXELFORMAT_RGBA16F, PIXELFORMAT_DEPTH, PIXELFORMAT_R32F, PIXELFORMAT_RGBA8, FILTER_NEAREST, FILTER_LINEAR, ADDRESS_CLAMP_TO_EDGE, FUNC_LESS } from '../../platform/graphics/constants.js';\nimport { RenderTarget } from '../../platform/graphics/render-target.js';\nimport { Texture } from '../../platform/graphics/texture.js';\nimport { SHADOW_VSM32, SHADOW_VSM16, SHADOW_PCF5, SHADOW_PCF1, SHADOW_PCF3, SHADOW_PCSS, LIGHTTYPE_OMNI } from '../constants.js';\n\nclass ShadowMap {\n\tconstructor(texture, targets) {\n\t\tthis.texture = texture;\n\t\tthis.cached = false;\n\t\tthis.renderTargets = targets;\n\t}\n\tdestroy() {\n\t\tif (this.texture) {\n\t\t\tthis.texture.destroy();\n\t\t\tthis.texture = null;\n\t\t}\n\t\tconst targets = this.renderTargets;\n\t\tfor (let i = 0; i < targets.length; i++) {\n\t\t\ttargets[i].destroy();\n\t\t}\n\t\tthis.renderTargets.length = 0;\n\t}\n\tstatic getShadowFormat(device, shadowType) {\n\t\tif (shadowType === SHADOW_VSM32) {\n\t\t\treturn PIXELFORMAT_RGBA32F;\n\t\t} else if (shadowType === SHADOW_VSM16) {\n\t\t\treturn PIXELFORMAT_RGBA16F;\n\t\t} else if (shadowType === SHADOW_PCF5) {\n\t\t\treturn PIXELFORMAT_DEPTH;\n\t\t} else if ((shadowType === SHADOW_PCF1 || shadowType === SHADOW_PCF3) && device.supportsDepthShadow) {\n\t\t\treturn PIXELFORMAT_DEPTH;\n\t\t} else if (shadowType === SHADOW_PCSS && !device.isWebGL1) {\n\t\t\treturn PIXELFORMAT_R32F;\n\t\t}\n\t\treturn PIXELFORMAT_RGBA8;\n\t}\n\tstatic getShadowFiltering(device, shadowType) {\n\t\tif ((shadowType === SHADOW_PCF1 || shadowType === SHADOW_PCF3 || shadowType === SHADOW_PCSS) && !device.supportsDepthShadow) {\n\t\t\treturn FILTER_NEAREST;\n\t\t} else if (shadowType === SHADOW_VSM32) {\n\t\t\treturn device.extTextureFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;\n\t\t} else if (shadowType === SHADOW_VSM16) {\n\t\t\treturn device.extTextureHalfFloatLinear ? FILTER_LINEAR : FILTER_NEAREST;\n\t\t}\n\t\treturn FILTER_LINEAR;\n\t}\n\tstatic create(device, light) {\n\t\tlet shadowMap = null;\n\t\tif (light._type === LIGHTTYPE_OMNI) {\n\t\t\tshadowMap = this.createCubemap(device, light._shadowResolution, light._shadowType);\n\t\t} else {\n\t\t\tshadowMap = this.create2dMap(device, light._shadowResolution, light._shadowType);\n\t\t}\n\t\treturn shadowMap;\n\t}\n\tstatic createAtlas(device, resolution, shadowType) {\n\t\tconst shadowMap = this.create2dMap(device, resolution, shadowType);\n\t\tconst targets = shadowMap.renderTargets;\n\t\tconst rt = targets[0];\n\t\tfor (let i = 0; i < 5; i++) {\n\t\t\ttargets.push(rt);\n\t\t}\n\t\treturn shadowMap;\n\t}\n\tstatic create2dMap(device, size, shadowType) {\n\t\tconst format = this.getShadowFormat(device, shadowType);\n\t\tconst filter = this.getShadowFiltering(device, shadowType);\n\t\tconst texture = new Texture(device, {\n\t\t\tformat: format,\n\t\t\twidth: size,\n\t\t\theight: size,\n\t\t\tmipmaps: false,\n\t\t\tminFilter: filter,\n\t\t\tmagFilter: filter,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\tname: 'ShadowMap2D'\n\t\t});\n\t\tlet target = null;\n\t\tif (shadowType === SHADOW_PCF5 || (shadowType === SHADOW_PCF1 || shadowType === SHADOW_PCF3) && device.supportsDepthShadow) {\n\t\t\ttexture.compareOnRead = true;\n\t\t\ttexture.compareFunc = FUNC_LESS;\n\t\t\ttarget = new RenderTarget({\n\t\t\t\tdepthBuffer: texture\n\t\t\t});\n\t\t} else {\n\t\t\ttarget = new RenderTarget({\n\t\t\t\tcolorBuffer: texture,\n\t\t\t\tdepth: true\n\t\t\t});\n\t\t}\n\t\tif (device.isWebGPU) {\n\t\t\ttarget.flipY = true;\n\t\t}\n\t\treturn new ShadowMap(texture, [target]);\n\t}\n\tstatic createCubemap(device, size, shadowType) {\n\t\tconst format = shadowType === SHADOW_PCSS && !device.isWebGL1 ? PIXELFORMAT_R32F : PIXELFORMAT_RGBA8;\n\t\tconst cubemap = new Texture(device, {\n\t\t\tformat: format,\n\t\t\twidth: size,\n\t\t\theight: size,\n\t\t\tcubemap: true,\n\t\t\tmipmaps: false,\n\t\t\tminFilter: FILTER_NEAREST,\n\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\taddressU: ADDRESS_CLAMP_TO_EDGE,\n\t\t\taddressV: ADDRESS_CLAMP_TO_EDGE,\n\t\t\tname: 'ShadowMapCube'\n\t\t});\n\t\tconst targets = [];\n\t\tfor (let i = 0; i < 6; i++) {\n\t\t\tconst target = new RenderTarget({\n\t\t\t\tcolorBuffer: cubemap,\n\t\t\t\tface: i,\n\t\t\t\tdepth: true\n\t\t\t});\n\t\t\ttargets.push(target);\n\t\t}\n\t\treturn new ShadowMap(cubemap, targets);\n\t}\n}\n\nexport { ShadowMap };\n","import { math } from '../../core/math/math.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { Mat4 } from '../../core/math/mat4.js';\nimport { BoundingBox } from '../../core/shape/bounding-box.js';\nimport { SHADOWUPDATE_NONE } from '../constants.js';\nimport { ShadowMap } from './shadow-map.js';\nimport { RenderPassShadowDirectional } from './render-pass-shadow-directional.js';\n\nconst visibleSceneAabb = new BoundingBox();\nconst center = new Vec3();\nconst shadowCamView = new Mat4();\nconst aabbPoints = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];\nconst _depthRange = {\n\tmin: 0,\n\tmax: 0\n};\nfunction getDepthRange(cameraViewMatrix, aabbMin, aabbMax) {\n\taabbPoints[0].x = aabbPoints[1].x = aabbPoints[2].x = aabbPoints[3].x = aabbMin.x;\n\taabbPoints[1].y = aabbPoints[3].y = aabbPoints[7].y = aabbPoints[5].y = aabbMin.y;\n\taabbPoints[2].z = aabbPoints[3].z = aabbPoints[6].z = aabbPoints[7].z = aabbMin.z;\n\taabbPoints[4].x = aabbPoints[5].x = aabbPoints[6].x = aabbPoints[7].x = aabbMax.x;\n\taabbPoints[0].y = aabbPoints[2].y = aabbPoints[4].y = aabbPoints[6].y = aabbMax.y;\n\taabbPoints[0].z = aabbPoints[1].z = aabbPoints[4].z = aabbPoints[5].z = aabbMax.z;\n\tlet minz = 9999999999;\n\tlet maxz = -9999999999;\n\tfor (let i = 0; i < 8; ++i) {\n\t\tcameraViewMatrix.transformPoint(aabbPoints[i], aabbPoints[i]);\n\t\tconst z = aabbPoints[i].z;\n\t\tif (z < minz) minz = z;\n\t\tif (z > maxz) maxz = z;\n\t}\n\t_depthRange.min = minz;\n\t_depthRange.max = maxz;\n\treturn _depthRange;\n}\nclass ShadowRendererDirectional {\n\tconstructor(renderer, shadowRenderer) {\n\t\tthis.renderer = void 0;\n\t\tthis.shadowRenderer = void 0;\n\t\tthis.device = void 0;\n\t\tthis.renderer = renderer;\n\t\tthis.shadowRenderer = shadowRenderer;\n\t\tthis.device = renderer.device;\n\t}\n\tcull(light, comp, camera, casters = null) {\n\t\tlight.visibleThisFrame = true;\n\t\tif (!light._shadowMap) {\n\t\t\tlight._shadowMap = ShadowMap.create(this.device, light);\n\t\t}\n\t\tconst nearDist = camera._nearClip;\n\t\tthis.generateSplitDistances(light, nearDist, Math.min(camera._farClip, light.shadowDistance));\n\t\tconst shadowUpdateOverrides = light.shadowUpdateOverrides;\n\t\tfor (let cascade = 0; cascade < light.numCascades; cascade++) {\n\t\t\tif ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[cascade]) === SHADOWUPDATE_NONE) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst lightRenderData = light.getRenderData(camera, cascade);\n\t\t\tconst shadowCam = lightRenderData.shadowCamera;\n\t\t\tshadowCam.renderTarget = light._shadowMap.renderTargets[0];\n\t\t\tlightRenderData.shadowViewport.copy(light.cascades[cascade]);\n\t\t\tlightRenderData.shadowScissor.copy(light.cascades[cascade]);\n\t\t\tconst shadowCamNode = shadowCam._node;\n\t\t\tconst lightNode = light._node;\n\t\t\tshadowCamNode.setPosition(lightNode.getPosition());\n\t\t\tshadowCamNode.setRotation(lightNode.getRotation());\n\t\t\tshadowCamNode.rotateLocal(-90, 0, 0);\n\t\t\tconst frustumNearDist = cascade === 0 ? nearDist : light._shadowCascadeDistances[cascade - 1];\n\t\t\tconst frustumFarDist = light._shadowCascadeDistances[cascade];\n\t\t\tconst frustumPoints = camera.getFrustumCorners(frustumNearDist, frustumFarDist);\n\t\t\tcenter.set(0, 0, 0);\n\t\t\tconst cameraWorldMat = camera.node.getWorldTransform();\n\t\t\tfor (let i = 0; i < 8; i++) {\n\t\t\t\tcameraWorldMat.transformPoint(frustumPoints[i], frustumPoints[i]);\n\t\t\t\tcenter.add(frustumPoints[i]);\n\t\t\t}\n\t\t\tcenter.mulScalar(1 / 8);\n\t\t\tlet radius = 0;\n\t\t\tfor (let i = 0; i < 8; i++) {\n\t\t\t\tconst dist = frustumPoints[i].sub(center).length();\n\t\t\t\tif (dist > radius) {\n\t\t\t\t\tradius = dist;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst right = shadowCamNode.right;\n\t\t\tconst up = shadowCamNode.up;\n\t\t\tconst lightDir = shadowCamNode.forward;\n\t\t\tconst sizeRatio = 0.25 * light._shadowResolution / radius;\n\t\t\tconst x = Math.ceil(center.dot(up) * sizeRatio) / sizeRatio;\n\t\t\tconst y = Math.ceil(center.dot(right) * sizeRatio) / sizeRatio;\n\t\t\tconst scaledUp = up.mulScalar(x);\n\t\t\tconst scaledRight = right.mulScalar(y);\n\t\t\tconst dot = center.dot(lightDir);\n\t\t\tconst scaledDir = lightDir.mulScalar(dot);\n\t\t\tcenter.add2(scaledUp, scaledRight).add(scaledDir);\n\t\t\tshadowCamNode.setPosition(center);\n\t\t\tshadowCamNode.translateLocal(0, 0, 1000000);\n\t\t\tshadowCam.nearClip = 0.01;\n\t\t\tshadowCam.farClip = 2000000;\n\t\t\tshadowCam.orthoHeight = radius;\n\t\t\tthis.renderer.updateCameraFrustum(shadowCam);\n\t\t\tthis.shadowRenderer.cullShadowCasters(comp, light, lightRenderData.visibleCasters, shadowCam, casters);\n\t\t\tlet emptyAabb = true;\n\t\t\tconst visibleCasters = lightRenderData.visibleCasters;\n\t\t\tfor (let i = 0; i < visibleCasters.length; i++) {\n\t\t\t\tconst meshInstance = visibleCasters[i];\n\t\t\t\tif (emptyAabb) {\n\t\t\t\t\temptyAabb = false;\n\t\t\t\t\tvisibleSceneAabb.copy(meshInstance.aabb);\n\t\t\t\t} else {\n\t\t\t\t\tvisibleSceneAabb.add(meshInstance.aabb);\n\t\t\t\t}\n\t\t\t}\n\t\t\tshadowCamView.copy(shadowCamNode.getWorldTransform()).invert();\n\t\t\tconst depthRange = getDepthRange(shadowCamView, visibleSceneAabb.getMin(), visibleSceneAabb.getMax());\n\t\t\tshadowCamNode.translateLocal(0, 0, depthRange.max + 0.1);\n\t\t\tshadowCam.farClip = depthRange.max - depthRange.min + 0.2;\n\t\t\tlightRenderData.depthRangeCompensation = shadowCam.farClip;\n\t\t\tlightRenderData.projectionCompensation = radius;\n\t\t}\n\t}\n\tgenerateSplitDistances(light, nearDist, farDist) {\n\t\tlight._shadowCascadeDistances.fill(farDist);\n\t\tfor (let i = 1; i < light.numCascades; i++) {\n\t\t\tconst fraction = i / light.numCascades;\n\t\t\tconst linearDist = nearDist + (farDist - nearDist) * fraction;\n\t\t\tconst logDist = nearDist * (farDist / nearDist) ** fraction;\n\t\t\tconst dist = math.lerp(linearDist, logDist, light.cascadeDistribution);\n\t\t\tlight._shadowCascadeDistances[i - 1] = dist;\n\t\t}\n\t}\n\tgetLightRenderPass(light, camera) {\n\t\tlet renderPass = null;\n\t\tif (this.shadowRenderer.needsShadowRendering(light)) {\n\t\t\tconst faceCount = light.numShadowFaces;\n\t\t\tconst shadowUpdateOverrides = light.shadowUpdateOverrides;\n\t\t\tlet allCascadesRendering = true;\n\t\t\tlet shadowCamera;\n\t\t\tfor (let face = 0; face < faceCount; face++) {\n\t\t\t\tif ((shadowUpdateOverrides == null ? void 0 : shadowUpdateOverrides[face]) === SHADOWUPDATE_NONE) {\n\t\t\t\t\tallCascadesRendering = false;\n\t\t\t\t}\n\t\t\t\tshadowCamera = this.shadowRenderer.prepareFace(light, camera, face);\n\t\t\t}\n\t\t\trenderPass = new RenderPassShadowDirectional(this.device, this.shadowRenderer, light, camera, allCascadesRendering);\n\t\t\tthis.shadowRenderer.setupRenderPass(renderPass, shadowCamera, allCascadesRendering);\n\t\t}\n\t\treturn renderPass;\n\t}\n}\n\nexport { ShadowRendererDirectional };\n","import { math } from '../../core/math/math.js';\nimport { ShadowMap } from './shadow-map.js';\nimport { LIGHTTYPE_SPOT, LIGHTTYPE_OMNI } from '../constants.js';\nimport { RenderPassShadowLocalNonClustered } from './render-pass-shadow-local-non-clustered.js';\n\nclass ShadowRendererLocal {\n\tconstructor(renderer, shadowRenderer) {\n\t\tthis.shadowLights = [];\n\t\tthis.renderer = void 0;\n\t\tthis.shadowRenderer = void 0;\n\t\tthis.device = void 0;\n\t\tthis.renderer = renderer;\n\t\tthis.shadowRenderer = shadowRenderer;\n\t\tthis.device = renderer.device;\n\t}\n\tcull(light, comp, casters = null) {\n\t\tconst isClustered = this.renderer.scene.clusteredLightingEnabled;\n\t\tlight.visibleThisFrame = true;\n\t\tif (!isClustered) {\n\t\t\tif (!light._shadowMap) {\n\t\t\t\tlight._shadowMap = ShadowMap.create(this.device, light);\n\t\t\t}\n\t\t}\n\t\tconst type = light._type;\n\t\tconst faceCount = type === LIGHTTYPE_SPOT ? 1 : 6;\n\t\tfor (let face = 0; face < faceCount; face++) {\n\t\t\tconst lightRenderData = light.getRenderData(null, face);\n\t\t\tconst shadowCam = lightRenderData.shadowCamera;\n\t\t\tshadowCam.nearClip = light.attenuationEnd / 1000;\n\t\t\tshadowCam.farClip = light.attenuationEnd;\n\t\t\tlightRenderData.depthRangeCompensation = shadowCam.farClip - shadowCam.nearClip;\n\t\t\tconst shadowCamNode = shadowCam._node;\n\t\t\tconst lightNode = light._node;\n\t\t\tshadowCamNode.setPosition(lightNode.getPosition());\n\t\t\tif (type === LIGHTTYPE_SPOT) {\n\t\t\t\tshadowCam.fov = light._outerConeAngle * 2;\n\t\t\t\tshadowCamNode.setRotation(lightNode.getRotation());\n\t\t\t\tshadowCamNode.rotateLocal(-90, 0, 0);\n\t\t\t} else if (type === LIGHTTYPE_OMNI) {\n\t\t\t\tif (isClustered) {\n\t\t\t\t\tconst tileSize = this.shadowRenderer.lightTextureAtlas.shadowAtlasResolution * light.atlasViewport.z / 3;\n\t\t\t\t\tconst texelSize = 2 / tileSize;\n\t\t\t\t\tconst filterSize = texelSize * this.shadowRenderer.lightTextureAtlas.shadowEdgePixels;\n\t\t\t\t\tshadowCam.fov = Math.atan(1 + filterSize) * math.RAD_TO_DEG * 2;\n\t\t\t\t} else {\n\t\t\t\t\tshadowCam.fov = 90;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.renderer.updateCameraFrustum(shadowCam);\n\t\t\tthis.shadowRenderer.cullShadowCasters(comp, light, lightRenderData.visibleCasters, shadowCam, casters);\n\t\t}\n\t}\n\tprepareLights(shadowLights, lights) {\n\t\tlet shadowCamera;\n\t\tfor (let i = 0; i < lights.length; i++) {\n\t\t\tconst light = lights[i];\n\t\t\tif (this.shadowRenderer.needsShadowRendering(light) && light.atlasViewportAllocated) {\n\t\t\t\tshadowLights.push(light);\n\t\t\t\tfor (let face = 0; face < light.numShadowFaces; face++) {\n\t\t\t\t\tshadowCamera = this.shadowRenderer.prepareFace(light, null, face);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn shadowCamera;\n\t}\n\tbuildNonClusteredRenderPasses(frameGraph, localLights) {\n\t\tfor (let i = 0; i < localLights.length; i++) {\n\t\t\tconst light = localLights[i];\n\t\t\tif (this.shadowRenderer.needsShadowRendering(light)) {\n\t\t\t\tconst applyVsm = light._type === LIGHTTYPE_SPOT;\n\t\t\t\tconst faceCount = light.numShadowFaces;\n\t\t\t\tfor (let face = 0; face < faceCount; face++) {\n\t\t\t\t\tconst renderPass = new RenderPassShadowLocalNonClustered(this.device, this.shadowRenderer, light, face, applyVsm);\n\t\t\t\t\tframeGraph.addRenderPass(renderPass);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nexport { ShadowRendererLocal };\n","import { Color } from '../../core/math/color.js';\nimport { Mat4 } from '../../core/math/mat4.js';\nimport { Vec3 } from '../../core/math/vec3.js';\nimport { Vec4 } from '../../core/math/vec4.js';\nimport { UNIFORMTYPE_MAT4, UNIFORM_BUFFER_DEFAULT_SLOT_NAME, SHADERSTAGE_VERTEX, SHADERSTAGE_FRAGMENT } from '../../platform/graphics/constants.js';\nimport { drawQuadWithShader } from '../graphics/quad-render-utils.js';\nimport { SHADOW_VSM8, SHADOW_VSM32, SHADOW_PCF5, SHADOW_PCF1, SHADOW_PCF3, LIGHTTYPE_OMNI, LIGHTTYPE_DIRECTIONAL, SORTKEY_DEPTH, SHADOWUPDATE_NONE, SHADOWUPDATE_THISFRAME, BLUR_GAUSSIAN, SHADER_SHADOW } from '../constants.js';\nimport { ShaderPass } from '../shader-pass.js';\nimport { shaderChunks } from '../shader-lib/chunks/chunks.js';\nimport { createShaderFromCode } from '../shader-lib/utils.js';\nimport { LightCamera } from './light-camera.js';\nimport { UniformBufferFormat, UniformFormat } from '../../platform/graphics/uniform-buffer-format.js';\nimport { BindGroupFormat, BindUniformBufferFormat } from '../../platform/graphics/bind-group-format.js';\nimport { BlendState } from '../../platform/graphics/blend-state.js';\n\nfunction gauss(x, sigma) {\n\treturn Math.exp(-(x * x) / (2.0 * sigma * sigma));\n}\nfunction gaussWeights(kernelSize) {\n\tconst sigma = (kernelSize - 1) / (2 * 3);\n\tconst halfWidth = (kernelSize - 1) * 0.5;\n\tconst values = new Array(kernelSize);\n\tlet sum = 0.0;\n\tfor (let i = 0; i < kernelSize; ++i) {\n\t\tvalues[i] = gauss(i - halfWidth, sigma);\n\t\tsum += values[i];\n\t}\n\tfor (let i = 0; i < kernelSize; ++i) {\n\t\tvalues[i] /= sum;\n\t}\n\treturn values;\n}\nconst tempSet = new Set();\nconst shadowCamView = new Mat4();\nconst shadowCamViewProj = new Mat4();\nconst pixelOffset = new Float32Array(2);\nconst blurScissorRect = new Vec4(1, 1, 0, 0);\nconst viewportMatrix = new Mat4();\nclass ShadowRenderer {\n\tconstructor(renderer, lightTextureAtlas) {\n\t\tthis.shadowPassCache = [];\n\t\tthis.device = renderer.device;\n\t\tthis.renderer = renderer;\n\t\tthis.lightTextureAtlas = lightTextureAtlas;\n\t\tconst scope = this.device.scope;\n\t\tthis.polygonOffsetId = scope.resolve('polygonOffset');\n\t\tthis.polygonOffset = new Float32Array(2);\n\t\tthis.sourceId = scope.resolve('source');\n\t\tthis.pixelOffsetId = scope.resolve('pixelOffset');\n\t\tthis.weightId = scope.resolve('weight[0]');\n\t\tthis.blurVsmShaderCode = [shaderChunks.blurVSMPS, `#define GAUSS\\n${shaderChunks.blurVSMPS}`];\n\t\tconst packed = '#define PACKED\\n';\n\t\tthis.blurPackedVsmShaderCode = [packed + this.blurVsmShaderCode[0], packed + this.blurVsmShaderCode[1]];\n\t\tthis.blurVsmShader = [{}, {}];\n\t\tthis.blurPackedVsmShader = [{}, {}];\n\t\tthis.blurVsmWeights = {};\n\t\tthis.shadowMapLightRadiusId = scope.resolve('light_radius');\n\t\tthis.viewUniformFormat = null;\n\t\tthis.viewBindGroupFormat = null;\n\t\tthis.blendStateWrite = new BlendState();\n\t\tthis.blendStateNoWrite = new BlendState();\n\t\tthis.blendStateNoWrite.setColorWrite(false, false, false, false);\n\t}\n\tstatic createShadowCamera(device, shadowType, type, face) {\n\t\tconst shadowCam = LightCamera.create('ShadowCamera', type, face);\n\t\tif (shadowType >= SHADOW_VSM8 && shadowType <= SHADOW_VSM32) {\n\t\t\tshadowCam.clearColor = new Color(0, 0, 0, 0);\n\t\t} else {\n\t\t\tshadowCam.clearColor = new Color(1, 1, 1, 1);\n\t\t}\n\t\tshadowCam.clearDepthBuffer = true;\n\t\tshadowCam.clearStencilBuffer = false;\n\t\treturn shadowCam;\n\t}\n\tstatic setShadowCameraSettings(shadowCam, device, shadowType, type, isClustered) {\n\t\tlet hwPcf = shadowType === SHADOW_PCF5 || (shadowType === SHADOW_PCF1 || shadowType === SHADOW_PCF3) && device.supportsDepthShadow;\n\t\tif (type === LIGHTTYPE_OMNI && !isClustered) {\n\t\t\thwPcf = false;\n\t\t}\n\t\tshadowCam.clearColorBuffer = !hwPcf;\n\t}\n\t_cullShadowCastersInternal(meshInstances, visible, camera) {\n\t\tconst numInstances = meshInstances.length;\n\t\tfor (let i = 0; i < numInstances; i++) {\n\t\t\tconst meshInstance = meshInstances[i];\n\t\t\tif (meshInstance.castShadow) {\n\t\t\t\tif (!meshInstance.cull || meshInstance._isVisible(camera)) {\n\t\t\t\t\tmeshInstance.visibleThisFrame = true;\n\t\t\t\t\tvisible.push(meshInstance);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcullShadowCasters(comp, light, visible, camera, casters) {\n\t\tvisible.length = 0;\n\t\tif (casters) {\n\t\t\tthis._cullShadowCastersInternal(casters, visible, camera);\n\t\t} else {\n\t\t\tconst layers = comp.layerList;\n\t\t\tconst len = layers.length;\n\t\t\tfor (let i = 0; i < len; i++) {\n\t\t\t\tconst layer = layers[i];\n\t\t\t\tif (layer._lightsSet.has(light)) {\n\t\t\t\t\tif (!tempSet.has(layer)) {\n\t\t\t\t\t\ttempSet.add(layer);\n\t\t\t\t\t\tthis._cullShadowCastersInternal(layer.shadowCasters, visible, camera);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttempSet.clear();\n\t\t}\n\t\tvisible.sort(this.renderer.sortCompareDepth);\n\t}\n\tsetupRenderState(device, light) {\n\t\tif (device.isWebGL1 && device.extStandardDerivatives) {\n\t\t\tif (light._type === LIGHTTYPE_OMNI) {\n\t\t\t\tthis.polygonOffset[0] = 0;\n\t\t\t\tthis.polygonOffset[1] = 0;\n\t\t\t\tthis.polygonOffsetId.setValue(this.polygonOffset);\n\t\t\t} else {\n\t\t\t\tthis.polygonOffset[0] = light.shadowBias * -1000.0;\n\t\t\t\tthis.polygonOffset[1] = light.shadowBias * -1000.0;\n\t\t\t\tthis.polygonOffsetId.setValue(this.polygonOffset);\n\t\t\t}\n\t\t}\n\t\tconst isClustered = this.renderer.scene.clusteredLightingEnabled;\n\t\tconst gpuOrGl2 = device.isWebGL2 || device.isWebGPU;\n\t\tconst useShadowSampler = isClustered ? light._isPcf && gpuOrGl2 : light._isPcf && gpuOrGl2 && light._type !== LIGHTTYPE_OMNI;\n\t\tdevice.setBlendState(useShadowSampler ? this.blendStateNoWrite : this.blendStateWrite);\n\t\tdevice.setDepthState(light.shadowDepthState);\n\t\tdevice.setStencilState(null, null);\n\t}\n\tdispatchUniforms(light, shadowCam, lightRenderData, face) {\n\t\tconst shadowCamNode = shadowCam._node;\n\t\tif (light._type !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\tthis.renderer.dispatchViewPos(shadowCamNode.getPosition());\n\t\t\tthis.shadowMapLightRadiusId.setValue(light.attenuationEnd);\n\t\t}\n\t\tshadowCamView.setTRS(shadowCamNode.getPosition(), shadowCamNode.getRotation(), Vec3.ONE).invert();\n\t\tshadowCamViewProj.mul2(shadowCam.projectionMatrix, shadowCamView);\n\t\tconst rectViewport = lightRenderData.shadowViewport;\n\t\tshadowCam.rect = rectViewport;\n\t\tshadowCam.scissorRect = lightRenderData.shadowScissor;\n\t\tviewportMatrix.setViewport(rectViewport.x, rectViewport.y, rectViewport.z, rectViewport.w);\n\t\tlightRenderData.shadowMatrix.mul2(viewportMatrix, shadowCamViewProj);\n\t\tif (light._type === LIGHTTYPE_DIRECTIONAL) {\n\t\t\tlight._shadowMatrixPalette.set(lightRenderData.shadowMatrix.data, face * 16);\n\t\t}\n\t}\n\tgetShadowPass(light) {\n\t\tvar _this$shadowPassCache;\n\t\tconst lightType = light._type;\n\t\tconst shadowType = light._shadowType;\n\t\tlet shadowPassInfo = (_this$shadowPassCache = this.shadowPassCache[lightType]) == null ? void 0 : _this$shadowPassCache[shadowType];\n\t\tif (!shadowPassInfo) {\n\t\t\tconst shadowPassName = `ShadowPass_${lightType}_${shadowType}`;\n\t\t\tshadowPassInfo = ShaderPass.get(this.device).allocate(shadowPassName, {\n\t\t\t\tisShadow: true,\n\t\t\t\tlightType: lightType,\n\t\t\t\tshadowType: shadowType\n\t\t\t});\n\t\t\tif (!this.shadowPassCache[lightType]) {\n\t\t\t\tthis.shadowPassCache[lightType] = [];\n\t\t\t}\n\t\t\tthis.shadowPassCache[lightType][shadowType] = shadowPassInfo;\n\t\t}\n\t\treturn shadowPassInfo.index;\n\t}\n\tsubmitCasters(visibleCasters, light) {\n\t\tconst device = this.device;\n\t\tconst renderer = this.renderer;\n\t\tconst scene = renderer.scene;\n\t\tconst passFlags = 1 << SHADER_SHADOW;\n\t\tconst shadowPass = this.getShadowPass(light);\n\t\tconst count = visibleCasters.length;\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst meshInstance = visibleCasters[i];\n\t\t\tconst mesh = meshInstance.mesh;\n\t\t\tmeshInstance.ensureMaterial(device);\n\t\t\tconst material = meshInstance.material;\n\t\t\trenderer.setBaseConstants(device, material);\n\t\t\trenderer.setSkinning(device, meshInstance);\n\t\t\tif (material.dirty) {\n\t\t\t\tmaterial.updateUniforms(device, scene);\n\t\t\t\tmaterial.dirty = false;\n\t\t\t}\n\t\t\tif (material.chunks) {\n\t\t\t\trenderer.setupCullMode(true, 1, meshInstance);\n\t\t\t\tmaterial.setParameters(device);\n\t\t\t\tmeshInstance.setParameters(device, passFlags);\n\t\t\t}\n\t\t\tconst shaderInstance = meshInstance.getShaderInstance(shadowPass, 0, scene, this.viewUniformFormat, this.viewBindGroupFormat);\n\t\t\tconst shadowShader = shaderInstance.shader;\n\t\t\tmeshInstance._key[SORTKEY_DEPTH] = shadowShader.id;\n\t\t\tdevice.setShader(shadowShader);\n\t\t\trenderer.setVertexBuffers(device, mesh);\n\t\t\trenderer.setMorphing(device, meshInstance.morphInstance);\n\t\t\tthis.renderer.setupMeshUniformBuffers(shaderInstance, meshInstance);\n\t\t\tconst style = meshInstance.renderStyle;\n\t\t\tdevice.setIndexBuffer(mesh.indexBuffer[style]);\n\t\t\trenderer.drawInstance(device, meshInstance, mesh, style);\n\t\t\trenderer._shadowDrawCalls++;\n\t\t}\n\t}\n\tneedsShadowRendering(light) {\n\t\tconst needs = light.enabled && light.castShadows && light.shadowUpdateMode !== SHADOWUPDATE_NONE && light.visibleThisFrame;\n\t\tif (light.shadowUpdateMode === SHADOWUPDATE_THISFRAME) {\n\t\t\tlight.shadowUpdateMode = SHADOWUPDATE_NONE;\n\t\t}\n\t\tif (needs) {\n\t\t\tthis.renderer._shadowMapUpdates += light.numShadowFaces;\n\t\t}\n\t\treturn needs;\n\t}\n\tgetLightRenderData(light, camera, face) {\n\t\treturn light.getRenderData(light._type === LIGHTTYPE_DIRECTIONAL ? camera : null, face);\n\t}\n\tsetupRenderPass(renderPass, shadowCamera, clearRenderTarget) {\n\t\tconst rt = shadowCamera.renderTarget;\n\t\trenderPass.init(rt);\n\t\trenderPass.depthStencilOps.clearDepthValue = 1;\n\t\trenderPass.depthStencilOps.clearDepth = clearRenderTarget;\n\t\tif (rt.depthBuffer) {\n\t\t\trenderPass.depthStencilOps.storeDepth = true;\n\t\t} else {\n\t\t\trenderPass.colorOps.clearValue.copy(shadowCamera.clearColor);\n\t\t\trenderPass.colorOps.clear = clearRenderTarget;\n\t\t\trenderPass.depthStencilOps.storeDepth = false;\n\t\t}\n\t\trenderPass.requiresCubemaps = false;\n\t}\n\tprepareFace(light, camera, face) {\n\t\tconst type = light._type;\n\t\tconst shadowType = light._shadowType;\n\t\tconst isClustered = this.renderer.scene.clusteredLightingEnabled;\n\t\tconst lightRenderData = this.getLightRenderData(light, camera, face);\n\t\tconst shadowCam = lightRenderData.shadowCamera;\n\t\tShadowRenderer.setShadowCameraSettings(shadowCam, this.device, shadowType, type, isClustered);\n\t\tconst renderTargetIndex = type === LIGHTTYPE_DIRECTIONAL ? 0 : face;\n\t\tshadowCam.renderTarget = light._shadowMap.renderTargets[renderTargetIndex];\n\t\treturn shadowCam;\n\t}\n\trenderFace(light, camera, face, clear, insideRenderPass = true) {\n\t\tconst device = this.device;\n\t\tconst lightRenderData = this.getLightRenderData(light, camera, face);\n\t\tconst shadowCam = lightRenderData.shadowCamera;\n\t\tthis.dispatchUniforms(light, shadowCam, lightRenderData, face);\n\t\tconst rt = shadowCam.renderTarget;\n\t\tconst renderer = this.renderer;\n\t\trenderer.setCameraUniforms(shadowCam, rt);\n\t\tif (device.supportsUniformBuffers) {\n\t\t\trenderer.setupViewUniformBuffers(lightRenderData.viewBindGroups, this.viewUniformFormat, this.viewBindGroupFormat, 1);\n\t\t}\n\t\tif (insideRenderPass) {\n\t\t\trenderer.setupViewport(shadowCam, rt);\n\t\t\tif (clear) {\n\t\t\t\trenderer.clear(shadowCam);\n\t\t\t}\n\t\t} else {\n\t\t\trenderer.clearView(shadowCam, rt, true, false);\n\t\t}\n\t\tthis.setupRenderState(device, light);\n\t\tthis.submitCasters(lightRenderData.visibleCasters, light);\n\t}\n\trender(light, camera, insideRenderPass = true) {\n\t\tif (this.needsShadowRendering(light)) {\n\t\t\tconst faceCount = light.numShadowFaces;\n\t\t\tfor (let face = 0; face < faceCount; face++) {\n\t\t\t\tthis.prepareFace(light, camera, face);\n\t\t\t\tthis.renderFace(light, camera, face, true, insideRenderPass);\n\t\t\t}\n\t\t\tthis.renderVsm(light, camera);\n\t\t}\n\t}\n\trenderVsm(light, camera) {\n\t\tif (light._isVsm && light._vsmBlurSize > 1) {\n\t\t\tconst isClustered = this.renderer.scene.clusteredLightingEnabled;\n\t\t\tif (!isClustered || light._type === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\tthis.applyVsmBlur(light, camera);\n\t\t\t}\n\t\t}\n\t}\n\tgetVsmBlurShader(isVsm8, blurMode, filterSize) {\n\t\tlet blurShader = (isVsm8 ? this.blurPackedVsmShader : this.blurVsmShader)[blurMode][filterSize];\n\t\tif (!blurShader) {\n\t\t\tthis.blurVsmWeights[filterSize] = gaussWeights(filterSize);\n\t\t\tconst blurVS = shaderChunks.fullscreenQuadVS;\n\t\t\tlet blurFS = `#define SAMPLES ${filterSize}\\n`;\n\t\t\tif (isVsm8) {\n\t\t\t\tblurFS += this.blurPackedVsmShaderCode[blurMode];\n\t\t\t} else {\n\t\t\t\tblurFS += this.blurVsmShaderCode[blurMode];\n\t\t\t}\n\t\t\tconst blurShaderName = `blurVsm${blurMode}${filterSize}${isVsm8}`;\n\t\t\tblurShader = createShaderFromCode(this.device, blurVS, blurFS, blurShaderName);\n\t\t\tif (isVsm8) {\n\t\t\t\tthis.blurPackedVsmShader[blurMode][filterSize] = blurShader;\n\t\t\t} else {\n\t\t\t\tthis.blurVsmShader[blurMode][filterSize] = blurShader;\n\t\t\t}\n\t\t}\n\t\treturn blurShader;\n\t}\n\tapplyVsmBlur(light, camera) {\n\t\tconst device = this.device;\n\t\tdevice.setBlendState(BlendState.NOBLEND);\n\t\tconst lightRenderData = light.getRenderData(light._type === LIGHTTYPE_DIRECTIONAL ? camera : null, 0);\n\t\tconst shadowCam = lightRenderData.shadowCamera;\n\t\tconst origShadowMap = shadowCam.renderTarget;\n\t\tconst tempShadowMap = this.renderer.shadowMapCache.get(device, light);\n\t\tconst tempRt = tempShadowMap.renderTargets[0];\n\t\tconst isVsm8 = light._shadowType === SHADOW_VSM8;\n\t\tconst blurMode = light.vsmBlurMode;\n\t\tconst filterSize = light._vsmBlurSize;\n\t\tconst blurShader = this.getVsmBlurShader(isVsm8, blurMode, filterSize);\n\t\tblurScissorRect.z = light._shadowResolution - 2;\n\t\tblurScissorRect.w = blurScissorRect.z;\n\t\tthis.sourceId.setValue(origShadowMap.colorBuffer);\n\t\tpixelOffset[0] = 1 / light._shadowResolution;\n\t\tpixelOffset[1] = 0;\n\t\tthis.pixelOffsetId.setValue(pixelOffset);\n\t\tif (blurMode === BLUR_GAUSSIAN) this.weightId.setValue(this.blurVsmWeights[filterSize]);\n\t\tdrawQuadWithShader(device, tempRt, blurShader, null, blurScissorRect);\n\t\tthis.sourceId.setValue(tempRt.colorBuffer);\n\t\tpixelOffset[1] = pixelOffset[0];\n\t\tpixelOffset[0] = 0;\n\t\tthis.pixelOffsetId.setValue(pixelOffset);\n\t\tdrawQuadWithShader(device, origShadowMap, blurShader, null, blurScissorRect);\n\t\tthis.renderer.shadowMapCache.add(light, tempShadowMap);\n\t}\n\tinitViewBindGroupFormat() {\n\t\tif (this.device.supportsUniformBuffers && !this.viewUniformFormat) {\n\t\t\tthis.viewUniformFormat = new UniformBufferFormat(this.device, [new UniformFormat('matrix_viewProjection', UNIFORMTYPE_MAT4)]);\n\t\t\tthis.viewBindGroupFormat = new BindGroupFormat(this.device, [new BindUniformBufferFormat(UNIFORM_BUFFER_DEFAULT_SLOT_NAME, SHADERSTAGE_VERTEX | SHADERSTAGE_FRAGMENT)]);\n\t\t}\n\t}\n\tframeUpdate() {\n\t\tthis.initViewBindGroupFormat();\n\t}\n}\n\nexport { ShadowRenderer };\n","import { WorldClusters } from '../lighting/world-clusters.js';\n\nconst tempClusterArray = [];\nclass WorldClustersAllocator {\n\tconstructor(graphicsDevice) {\n\t\tthis._empty = null;\n\t\tthis._allocated = [];\n\t\tthis._clusters = new Map();\n\t\tthis.device = graphicsDevice;\n\t}\n\tdestroy() {\n\t\tif (this._empty) {\n\t\t\tthis._empty.destroy();\n\t\t\tthis._empty = null;\n\t\t}\n\t\tthis._allocated.forEach(cluster => {\n\t\t\tcluster.destroy();\n\t\t});\n\t\tthis._allocated.length = 0;\n\t}\n\tget count() {\n\t\treturn this._allocated.length;\n\t}\n\tget empty() {\n\t\tif (!this._empty) {\n\t\t\tconst empty = new WorldClusters(this.device);\n\t\t\tempty.name = 'ClusterEmpty';\n\t\t\tempty.update([], false, null);\n\t\t\tthis._empty = empty;\n\t\t}\n\t\treturn this._empty;\n\t}\n\tassign(renderPasses) {\n\t\tconst empty = this.empty;\n\t\ttempClusterArray.push(...this._allocated);\n\t\tthis._allocated.length = 0;\n\t\tthis._clusters.clear();\n\t\tconst passCount = renderPasses.length;\n\t\tfor (let p = 0; p < passCount; p++) {\n\t\t\tconst renderPass = renderPasses[p];\n\t\t\tconst renderActions = renderPass.renderActions;\n\t\t\tif (renderActions) {\n\t\t\t\tconst count = renderActions.length;\n\t\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\t\tconst ra = renderActions[i];\n\t\t\t\t\tra.lightClusters = null;\n\t\t\t\t\tconst layer = ra.layer;\n\t\t\t\t\tif (layer.hasClusteredLights && layer.meshInstances.length) {\n\t\t\t\t\t\tconst hash = layer.getLightIdHash();\n\t\t\t\t\t\tconst existingRenderAction = this._clusters.get(hash);\n\t\t\t\t\t\tlet clusters = existingRenderAction == null ? void 0 : existingRenderAction.lightClusters;\n\t\t\t\t\t\tif (!clusters) {\n\t\t\t\t\t\t\tvar _tempClusterArray$pop;\n\t\t\t\t\t\t\tclusters = (_tempClusterArray$pop = tempClusterArray.pop()) != null ? _tempClusterArray$pop : new WorldClusters(this.device);\n\t\t\t\t\t\t\tthis._allocated.push(clusters);\n\t\t\t\t\t\t\tthis._clusters.set(hash, ra);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tra.lightClusters = clusters;\n\t\t\t\t\t}\n\t\t\t\t\tif (!ra.lightClusters) {\n\t\t\t\t\t\tra.lightClusters = empty;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttempClusterArray.forEach(item => item.destroy());\n\t\ttempClusterArray.length = 0;\n\t}\n\tupdate(renderPasses, gammaCorrection, lighting) {\n\t\tthis.assign(renderPasses);\n\t\tthis._clusters.forEach(renderAction => {\n\t\t\tconst layer = renderAction.layer;\n\t\t\tconst cluster = renderAction.lightClusters;\n\t\t\tcluster.update(layer.clusteredLightsSet, gammaCorrection, lighting);\n\t\t});\n\t}\n}\n\nexport { WorldClustersAllocator };\n","import { EventHandler } from '../core/event-handler.js';\nimport { Color } from '../core/math/color.js';\nimport { Vec3 } from '../core/math/vec3.js';\nimport { Quat } from '../core/math/quat.js';\nimport { math } from '../core/math/math.js';\nimport { Mat3 } from '../core/math/mat3.js';\nimport { Mat4 } from '../core/math/mat4.js';\nimport { ADDRESS_CLAMP_TO_EDGE, FILTER_LINEAR, PIXELFORMAT_RGBA8 } from '../platform/graphics/constants.js';\nimport { BAKE_COLORDIR, FOG_NONE, GAMMA_SRGB, LAYERID_IMMEDIATE } from './constants.js';\nimport { LightingParams } from './lighting/lighting-params.js';\nimport { Sky } from './skybox/sky.js';\nimport { Immediate } from './immediate/immediate.js';\nimport { EnvLighting } from './graphics/env-lighting.js';\n\nclass Scene extends EventHandler {\n\tconstructor(graphicsDevice) {\n\t\tsuper();\n\t\tthis.ambientBake = false;\n\t\tthis.ambientBakeOcclusionBrightness = 0;\n\t\tthis.ambientBakeOcclusionContrast = 0;\n\t\tthis.ambientLight = new Color(0, 0, 0);\n\t\tthis.ambientLuminance = 0;\n\t\tthis.exposure = 1;\n\t\tthis.fogColor = new Color(0, 0, 0);\n\t\tthis.fogDensity = 0;\n\t\tthis.fogEnd = 1000;\n\t\tthis.fogStart = 1;\n\t\tthis.lightmapSizeMultiplier = 1;\n\t\tthis.lightmapMaxResolution = 2048;\n\t\tthis.lightmapMode = BAKE_COLORDIR;\n\t\tthis.lightmapFilterEnabled = false;\n\t\tthis.lightmapHDR = false;\n\t\tthis.root = null;\n\t\tthis.physicalUnits = false;\n\t\tthis._envAtlas = null;\n\t\tthis._skyboxCubeMap = null;\n\t\tthis.device = graphicsDevice;\n\t\tthis._gravity = new Vec3(0, -9.8, 0);\n\t\tthis._layers = null;\n\t\tthis._fog = FOG_NONE;\n\t\tthis._gammaCorrection = GAMMA_SRGB;\n\t\tthis._toneMapping = 0;\n\t\tthis._prefilteredCubemaps = [];\n\t\tthis._internalEnvAtlas = null;\n\t\tthis._skyboxIntensity = 1;\n\t\tthis._skyboxLuminance = 0;\n\t\tthis._skyboxMip = 0;\n\t\tthis._skyboxRotationShaderInclude = false;\n\t\tthis._skyboxRotation = new Quat();\n\t\tthis._skyboxRotationMat3 = new Mat3();\n\t\tthis._skyboxRotationMat4 = new Mat4();\n\t\tthis._ambientBakeNumSamples = 1;\n\t\tthis._ambientBakeSpherePart = 0.4;\n\t\tthis._lightmapFilterRange = 10;\n\t\tthis._lightmapFilterSmoothness = 0.2;\n\t\tthis._clusteredLightingEnabled = true;\n\t\tthis._lightingParams = new LightingParams(this.device.supportsAreaLights, this.device.maxTextureSize, () => {\n\t\t\tthis.updateShaders = true;\n\t\t});\n\t\tthis._sky = new Sky(this);\n\t\tthis._stats = {\n\t\t\tmeshInstances: 0,\n\t\t\tlights: 0,\n\t\t\tdynamicLights: 0,\n\t\t\tbakedLights: 0,\n\t\t\tupdateShadersTime: 0\n\t\t};\n\t\tthis.updateShaders = true;\n\t\tthis._shaderVersion = 0;\n\t\tthis.immediate = new Immediate(this.device);\n\t}\n\tget defaultDrawLayer() {\n\t\treturn this.layers.getLayerById(LAYERID_IMMEDIATE);\n\t}\n\tset ambientBakeNumSamples(value) {\n\t\tthis._ambientBakeNumSamples = math.clamp(Math.floor(value), 1, 255);\n\t}\n\tget ambientBakeNumSamples() {\n\t\treturn this._ambientBakeNumSamples;\n\t}\n\tset ambientBakeSpherePart(value) {\n\t\tthis._ambientBakeSpherePart = math.clamp(value, 0.001, 1);\n\t}\n\tget ambientBakeSpherePart() {\n\t\treturn this._ambientBakeSpherePart;\n\t}\n\tset clusteredLightingEnabled(value) {\n\t\tif (this.device.isWebGPU && !value) {\n\t\t\treturn;\n\t\t}\n\t\tif (!this._clusteredLightingEnabled && value) {\n\t\t\tconsole.error('Turning on disabled clustered lighting is not currently supported');\n\t\t\treturn;\n\t\t}\n\t\tthis._clusteredLightingEnabled = value;\n\t}\n\tget clusteredLightingEnabled() {\n\t\treturn this._clusteredLightingEnabled;\n\t}\n\tset envAtlas(value) {\n\t\tif (value !== this._envAtlas) {\n\t\t\tthis._envAtlas = value;\n\t\t\tif (value) {\n\t\t\t\tvalue.addressU = ADDRESS_CLAMP_TO_EDGE;\n\t\t\t\tvalue.addressV = ADDRESS_CLAMP_TO_EDGE;\n\t\t\t\tvalue.minFilter = FILTER_LINEAR;\n\t\t\t\tvalue.magFilter = FILTER_LINEAR;\n\t\t\t\tvalue.mipmaps = false;\n\t\t\t}\n\t\t\tthis._prefilteredCubemaps = [];\n\t\t\tif (this._internalEnvAtlas) {\n\t\t\t\tthis._internalEnvAtlas.destroy();\n\t\t\t\tthis._internalEnvAtlas = null;\n\t\t\t}\n\t\t\tthis._resetSkyMesh();\n\t\t}\n\t}\n\tget envAtlas() {\n\t\treturn this._envAtlas;\n\t}\n\tset fog(type) {\n\t\tif (type !== this._fog) {\n\t\t\tthis._fog = type;\n\t\t\tthis.updateShaders = true;\n\t\t}\n\t}\n\tget fog() {\n\t\treturn this._fog;\n\t}\n\tset gammaCorrection(value) {\n\t\tif (value !== this._gammaCorrection) {\n\t\t\tthis._gammaCorrection = value;\n\t\t\tthis.updateShaders = true;\n\t\t}\n\t}\n\tget gammaCorrection() {\n\t\treturn this._gammaCorrection;\n\t}\n\tset layers(layers) {\n\t\tconst prev = this._layers;\n\t\tthis._layers = layers;\n\t\tthis.fire('set:layers', prev, layers);\n\t}\n\tget layers() {\n\t\treturn this._layers;\n\t}\n\tget sky() {\n\t\treturn this._sky;\n\t}\n\tget lighting() {\n\t\treturn this._lightingParams;\n\t}\n\tset lightmapFilterRange(value) {\n\t\tthis._lightmapFilterRange = Math.max(value, 0.001);\n\t}\n\tget lightmapFilterRange() {\n\t\treturn this._lightmapFilterRange;\n\t}\n\tset lightmapFilterSmoothness(value) {\n\t\tthis._lightmapFilterSmoothness = Math.max(value, 0.001);\n\t}\n\tget lightmapFilterSmoothness() {\n\t\treturn this._lightmapFilterSmoothness;\n\t}\n\tset prefilteredCubemaps(value) {\n\t\tvalue = value || [];\n\t\tconst cubemaps = this._prefilteredCubemaps;\n\t\tconst changed = cubemaps.length !== value.length || cubemaps.some((c, i) => c !== value[i]);\n\t\tif (changed) {\n\t\t\tconst complete = value.length === 6 && value.every(c => !!c);\n\t\t\tif (complete) {\n\t\t\t\tthis._internalEnvAtlas = EnvLighting.generatePrefilteredAtlas(value, {\n\t\t\t\t\ttarget: this._internalEnvAtlas\n\t\t\t\t});\n\t\t\t\tthis._envAtlas = this._internalEnvAtlas;\n\t\t\t} else {\n\t\t\t\tif (this._internalEnvAtlas) {\n\t\t\t\t\tthis._internalEnvAtlas.destroy();\n\t\t\t\t\tthis._internalEnvAtlas = null;\n\t\t\t\t}\n\t\t\t\tthis._envAtlas = null;\n\t\t\t}\n\t\t\tthis._prefilteredCubemaps = value.slice();\n\t\t\tthis._resetSkyMesh();\n\t\t}\n\t}\n\tget prefilteredCubemaps() {\n\t\treturn this._prefilteredCubemaps;\n\t}\n\tset skybox(value) {\n\t\tif (value !== this._skyboxCubeMap) {\n\t\t\tthis._skyboxCubeMap = value;\n\t\t\tthis._resetSkyMesh();\n\t\t}\n\t}\n\tget skybox() {\n\t\treturn this._skyboxCubeMap;\n\t}\n\tset skyboxIntensity(value) {\n\t\tif (value !== this._skyboxIntensity) {\n\t\t\tthis._skyboxIntensity = value;\n\t\t\tthis._resetSkyMesh();\n\t\t}\n\t}\n\tget skyboxIntensity() {\n\t\treturn this._skyboxIntensity;\n\t}\n\tset skyboxLuminance(value) {\n\t\tif (value !== this._skyboxLuminance) {\n\t\t\tthis._skyboxLuminance = value;\n\t\t\tthis._resetSkyMesh();\n\t\t}\n\t}\n\tget skyboxLuminance() {\n\t\treturn this._skyboxLuminance;\n\t}\n\tset skyboxMip(value) {\n\t\tif (value !== this._skyboxMip) {\n\t\t\tthis._skyboxMip = value;\n\t\t\tthis._resetSkyMesh();\n\t\t}\n\t}\n\tget skyboxMip() {\n\t\treturn this._skyboxMip;\n\t}\n\tset skyboxRotation(value) {\n\t\tif (!this._skyboxRotation.equals(value)) {\n\t\t\tconst isIdentity = value.equals(Quat.IDENTITY);\n\t\t\tthis._skyboxRotation.copy(value);\n\t\t\tif (isIdentity) {\n\t\t\t\tthis._skyboxRotationMat3.setIdentity();\n\t\t\t} else {\n\t\t\t\tthis._skyboxRotationMat4.setTRS(Vec3.ZERO, value, Vec3.ONE);\n\t\t\t\tthis._skyboxRotationMat3.invertMat4(this._skyboxRotationMat4);\n\t\t\t}\n\t\t\tif (!this._skyboxRotationShaderInclude && !isIdentity) {\n\t\t\t\tthis._skyboxRotationShaderInclude = true;\n\t\t\t\tthis._resetSkyMesh();\n\t\t\t}\n\t\t}\n\t}\n\tget skyboxRotation() {\n\t\treturn this._skyboxRotation;\n\t}\n\tset toneMapping(value) {\n\t\tif (value !== this._toneMapping) {\n\t\t\tthis._toneMapping = value;\n\t\t\tthis.updateShaders = true;\n\t\t}\n\t}\n\tget toneMapping() {\n\t\treturn this._toneMapping;\n\t}\n\tdestroy() {\n\t\tthis._resetSkyMesh();\n\t\tthis.root = null;\n\t\tthis.off();\n\t}\n\tdrawLine(start, end, color = Color.WHITE, depthTest = true, layer = this.defaultDrawLayer) {\n\t\tconst batch = this.immediate.getBatch(layer, depthTest);\n\t\tbatch.addLines([start, end], [color, color]);\n\t}\n\tdrawLines(positions, colors, depthTest = true, layer = this.defaultDrawLayer) {\n\t\tconst batch = this.immediate.getBatch(layer, depthTest);\n\t\tbatch.addLines(positions, colors);\n\t}\n\tdrawLineArrays(positions, colors, depthTest = true, layer = this.defaultDrawLayer) {\n\t\tconst batch = this.immediate.getBatch(layer, depthTest);\n\t\tbatch.addLinesArrays(positions, colors);\n\t}\n\tapplySettings(settings) {\n\t\tvar _render$skyboxIntensi, _render$skyboxLuminan, _render$skyboxMip, _render$clusteredLigh;\n\t\tconst physics = settings.physics;\n\t\tconst render = settings.render;\n\t\tthis._gravity.set(physics.gravity[0], physics.gravity[1], physics.gravity[2]);\n\t\tthis.ambientLight.set(render.global_ambient[0], render.global_ambient[1], render.global_ambient[2]);\n\t\tthis.ambientLuminance = render.ambientLuminance;\n\t\tthis._fog = render.fog;\n\t\tthis.fogColor.set(render.fog_color[0], render.fog_color[1], render.fog_color[2]);\n\t\tthis.fogStart = render.fog_start;\n\t\tthis.fogEnd = render.fog_end;\n\t\tthis.fogDensity = render.fog_density;\n\t\tthis._gammaCorrection = render.gamma_correction;\n\t\tthis._toneMapping = render.tonemapping;\n\t\tthis.lightmapSizeMultiplier = render.lightmapSizeMultiplier;\n\t\tthis.lightmapMaxResolution = render.lightmapMaxResolution;\n\t\tthis.lightmapMode = render.lightmapMode;\n\t\tthis.exposure = render.exposure;\n\t\tthis._skyboxIntensity = (_render$skyboxIntensi = render.skyboxIntensity) != null ? _render$skyboxIntensi : 1;\n\t\tthis._skyboxLuminance = (_render$skyboxLuminan = render.skyboxLuminance) != null ? _render$skyboxLuminan : 20000;\n\t\tthis._skyboxMip = (_render$skyboxMip = render.skyboxMip) != null ? _render$skyboxMip : 0;\n\t\tif (render.skyboxRotation) {\n\t\t\tthis.skyboxRotation = new Quat().setFromEulerAngles(render.skyboxRotation[0], render.skyboxRotation[1], render.skyboxRotation[2]);\n\t\t}\n\t\tthis.sky.applySettings(render);\n\t\tthis.clusteredLightingEnabled = (_render$clusteredLigh = render.clusteredLightingEnabled) != null ? _render$clusteredLigh : false;\n\t\tthis.lighting.applySettings(render);\n\t\t['lightmapFilterEnabled', 'lightmapFilterRange', 'lightmapFilterSmoothness', 'ambientBake', 'ambientBakeNumSamples', 'ambientBakeSpherePart', 'ambientBakeOcclusionBrightness', 'ambientBakeOcclusionContrast'].forEach(setting => {\n\t\t\tif (render.hasOwnProperty(setting)) {\n\t\t\t\tthis[setting] = render[setting];\n\t\t\t}\n\t\t});\n\t\tthis._resetSkyMesh();\n\t}\n\t_getSkyboxTex() {\n\t\tconst cubemaps = this._prefilteredCubemaps;\n\t\tif (this._skyboxMip) {\n\t\t\tconst skyboxMapping = [0, 1, 3, 4, 5, 6];\n\t\t\treturn cubemaps[skyboxMapping[this._skyboxMip]] || this._envAtlas || cubemaps[0] || this._skyboxCubeMap;\n\t\t}\n\t\treturn this._skyboxCubeMap || cubemaps[0] || this._envAtlas;\n\t}\n\t_updateSkyMesh() {\n\t\tif (!this.sky.skyMesh) {\n\t\t\tthis.sky.updateSkyMesh();\n\t\t}\n\t\tthis.sky.update();\n\t}\n\t_resetSkyMesh() {\n\t\tthis.sky.resetSkyMesh();\n\t\tthis.updateShaders = true;\n\t}\n\tsetSkybox(cubemaps) {\n\t\tif (!cubemaps) {\n\t\t\tthis.skybox = null;\n\t\t\tthis.envAtlas = null;\n\t\t} else {\n\t\t\tthis.skybox = cubemaps[0] || null;\n\t\t\tif (cubemaps[1] && !cubemaps[1].cubemap) {\n\t\t\t\tthis.envAtlas = cubemaps[1];\n\t\t\t} else {\n\t\t\t\tthis.prefilteredCubemaps = cubemaps.slice(1);\n\t\t\t}\n\t\t}\n\t}\n\tget lightmapPixelFormat() {\n\t\treturn this.lightmapHDR && this.device.getRenderableHdrFormat() || PIXELFORMAT_RGBA8;\n\t}\n}\nScene.EVENT_SETLAYERS = 'set:layers';\nScene.EVENT_SETSKYBOX = 'set:skybox';\n\nexport { Scene };\n","class ChunkBuilder {\n\tconstructor() {\n\t\tthis.code = '';\n\t}\n\tappend(...chunks) {\n\t\tchunks.forEach(chunk => {\n\t\t\tif (chunk.endsWith('\\n')) {\n\t\t\t\tthis.code += chunk;\n\t\t\t} else {\n\t\t\t\tthis.code += `${chunk}\\n`;\n\t\t\t}\n\t\t});\n\t}\n\tprepend(...chunks) {\n\t\tchunks.forEach(chunk => {\n\t\t\tif (chunk.endsWith('\\n')) {\n\t\t\t\tthis.code = chunk + this.code;\n\t\t\t} else {\n\t\t\t\tthis.code = `${chunk}\\n${this.code}`;\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport { ChunkBuilder };\n","const decodeTable = {\n\t'linear': 'decodeLinear',\n\t'srgb': 'decodeGamma',\n\t'rgbm': 'decodeRGBM',\n\t'rgbe': 'decodeRGBE',\n\t'rgbp': 'decodeRGBP'\n};\nconst encodeTable = {\n\t'linear': 'encodeLinear',\n\t'srgb': 'encodeGamma',\n\t'rgbm': 'encodeRGBM',\n\t'rgbe': 'encodeRGBE',\n\t'rgbp': 'encodeRGBP'\n};\nclass ChunkUtils {\n\tstatic decodeFunc(encoding) {\n\t\treturn decodeTable[encoding] || 'decodeGamma';\n\t}\n\tstatic encodeFunc(encoding) {\n\t\treturn encodeTable[encoding] || 'encodeGamma';\n\t}\n}\n\nexport { ChunkUtils };\n","import bakeDirLmEndPS from './lightmapper/frag/bakeDirLmEnd.js';\nimport bakeLmEndPS from './lightmapper/frag/bakeLmEnd.js';\nimport dilatePS from './lightmapper/frag/dilate.js';\nimport bilateralDeNoisePS from './lightmapper/frag/bilateralDeNoise.js';\n\nconst shaderChunksLightmapper = {\n\tbakeDirLmEndPS,\n\tbakeLmEndPS,\n\tdilatePS,\n\tbilateralDeNoisePS\n};\n\nexport { shaderChunksLightmapper };\n","import alphaTestPS from './standard/frag/alphaTest.js';\nimport ambientConstantPS from './lit/frag/ambientConstant.js';\nimport ambientEnvPS from './lit/frag/ambientEnv.js';\nimport ambientSHPS from './lit/frag/ambientSH.js';\nimport aoPS from './standard/frag/ao.js';\nimport aoDetailMapPS from './standard/frag/aoDetailMap.js';\nimport aoDiffuseOccPS from './lit/frag/aoDiffuseOcc.js';\nimport aoSpecOccPS from './lit/frag/aoSpecOcc.js';\nimport aoSpecOccConstPS from './lit/frag/aoSpecOccConst.js';\nimport aoSpecOccConstSimplePS from './lit/frag/aoSpecOccConstSimple.js';\nimport aoSpecOccSimplePS from './lit/frag/aoSpecOccSimple.js';\nimport basePS from './lit/frag/base.js';\nimport baseVS from './lit/vert/base.js';\nimport baseNineSlicedPS from './lit/frag/baseNineSliced.js';\nimport baseNineSlicedVS from './lit/vert/baseNineSliced.js';\nimport baseNineSlicedTiledPS from './lit/frag/baseNineSlicedTiled.js';\nimport bayerPS from './common/frag/bayer.js';\nimport biasConstPS from './lit/frag/biasConst.js';\nimport blurVSMPS from './lit/frag/blurVSM.js';\nimport clearCoatPS from './standard/frag/clearCoat.js';\nimport clearCoatGlossPS from './standard/frag/clearCoatGloss.js';\nimport clearCoatNormalPS from './standard/frag/clearCoatNormal.js';\nimport clusteredLightUtilsPS from './lit/frag/clusteredLightUtils.js';\nimport clusteredLightCookiesPS from './lit/frag/clusteredLightCookies.js';\nimport clusteredLightShadowsPS from './lit/frag/clusteredLightShadows.js';\nimport clusteredLightPS from './lit/frag/clusteredLight.js';\nimport combinePS from './lit/frag/combine.js';\nimport cookiePS from './lit/frag/cookie.js';\nimport cubeMapProjectBoxPS from './lit/frag/cubeMapProjectBox.js';\nimport cubeMapProjectNonePS from './lit/frag/cubeMapProjectNone.js';\nimport cubeMapRotatePS from './lit/frag/cubeMapRotate.js';\nimport debugOutputPS from './lit/frag/debug-output.js';\nimport debugProcessFrontendPS from './lit/frag/debug-process-frontend.js';\nimport decodePS from './common/frag/decode.js';\nimport detailModesPS from './standard/frag/detailModes.js';\nimport diffusePS from './standard/frag/diffuse.js';\nimport diffuseDetailMapPS from './standard/frag/diffuseDetailMap.js';\nimport emissivePS from './standard/frag/emissive.js';\nimport encodePS from './common/frag/encode.js';\nimport endPS from './lit/frag/end.js';\nimport endVS from './lit/vert/end.js';\nimport envAtlasPS from './common/frag/envAtlas.js';\nimport envConstPS from './common/frag/envConst.js';\nimport envMultiplyPS from './common/frag/envMultiply.js';\nimport extensionPS from './lit/frag/extension.js';\nimport extensionVS from './lit/vert/extension.js';\nimport falloffInvSquaredPS from './lit/frag/falloffInvSquared.js';\nimport falloffLinearPS from './lit/frag/falloffLinear.js';\nimport fixCubemapSeamsNonePS from './common/frag/fixCubemapSeamsNone.js';\nimport fixCubemapSeamsStretchPS from './common/frag/fixCubemapSeamsStretch.js';\nimport floatUnpackingPS from './lit/frag/float-unpacking.js';\nimport fogExpPS from './lit/frag/fogExp.js';\nimport fogExp2PS from './lit/frag/fogExp2.js';\nimport fogLinearPS from './lit/frag/fogLinear.js';\nimport fogNonePS from './lit/frag/fogNone.js';\nimport fresnelSchlickPS from './lit/frag/fresnelSchlick.js';\nimport fullscreenQuadPS from './common/frag/fullscreenQuad.js';\nimport fullscreenQuadVS from './common/vert/fullscreenQuad.js';\nimport gamma1_0PS from './common/frag/gamma1_0.js';\nimport gamma2_2PS from './common/frag/gamma2_2.js';\nimport gles2PS from '../../../platform/graphics/shader-chunks/frag/gles2.js';\nimport gles2VS from '../../../platform/graphics/shader-chunks/vert/gles2.js';\nimport gles3PS from '../../../platform/graphics/shader-chunks/frag/gles3.js';\nimport gles3VS from '../../../platform/graphics/shader-chunks/vert/gles3.js';\nimport glossPS from './standard/frag/gloss.js';\nimport iridescenceDiffractionPS from './lit/frag/iridescenceDiffraction.js';\nimport iridescencePS from './standard/frag/iridescence.js';\nimport iridescenceThicknessPS from './standard/frag/iridescenceThickness.js';\nimport instancingVS from './lit/vert/instancing.js';\nimport iorPS from './standard/frag/ior.js';\nimport lightDiffuseLambertPS from './lit/frag/lightDiffuseLambert.js';\nimport lightDirPointPS from './lit/frag/lightDirPoint.js';\nimport lightmapAddPS from './lit/frag/lightmapAdd.js';\nimport lightmapDirAddPS from './lit/frag/lightmapDirAdd.js';\nimport lightmapDirPS from './standard/frag/lightmapDir.js';\nimport lightmapSinglePS from './standard/frag/lightmapSingle.js';\nimport lightSpecularAnisoGGXPS from './lit/frag/lightSpecularAnisoGGX.js';\nimport lightSpecularBlinnPS from './lit/frag/lightSpecularBlinn.js';\nimport lightSpecularPhongPS from './lit/frag/lightSpecularPhong.js';\nimport lightSheenPS from './lit/frag/lightSheen.js';\nimport linearizeDepthPS from './common/frag/linearizeDepth.js';\nimport litShaderArgsPS from './standard/frag/litShaderArgs.js';\nimport ltcPS from './lit/frag/ltc.js';\nimport metalnessPS from './standard/frag/metalness.js';\nimport msdfPS from './common/frag/msdf.js';\nimport metalnessModulatePS from './lit/frag/metalnessModulate.js';\nimport msdfVS from './common/vert/msdf.js';\nimport normalVS from './lit/vert/normal.js';\nimport normalDetailMapPS from './standard/frag/normalDetailMap.js';\nimport normalInstancedVS from './lit/vert/normalInstanced.js';\nimport normalMapPS from './standard/frag/normalMap.js';\nimport normalSkinnedVS from './lit/vert/normalSkinned.js';\nimport normalXYPS from './standard/frag/normalXY.js';\nimport normalXYZPS from './standard/frag/normalXYZ.js';\nimport opacityPS from './standard/frag/opacity.js';\nimport opacityDitherPS from './standard/frag/opacity-dither.js';\nimport outputPS from './lit/frag/output.js';\nimport outputAlphaPS from './lit/frag/outputAlpha.js';\nimport outputAlphaOpaquePS from './lit/frag/outputAlphaOpaque.js';\nimport outputAlphaPremulPS from './lit/frag/outputAlphaPremul.js';\nimport outputTex2DPS from './common/frag/outputTex2D.js';\nimport packDepthPS from './common/frag/packDepth.js';\nimport sheenPS from './standard/frag/sheen.js';\nimport sheenGlossPS from './standard/frag/sheenGloss.js';\nimport parallaxPS from './standard/frag/parallax.js';\nimport particlePS from './particle/frag/particle.js';\nimport particleVS from './particle/vert/particle.js';\nimport particleAnimFrameClampVS from './particle/vert/particleAnimFrameClamp.js';\nimport particleAnimFrameLoopVS from './particle/vert/particleAnimFrameLoop.js';\nimport particleAnimTexVS from './particle/vert/particleAnimTex.js';\nimport particleInputFloatPS from './particle/frag/particleInputFloat.js';\nimport particleInputRgba8PS from './particle/frag/particleInputRgba8.js';\nimport particleOutputFloatPS from './particle/frag/particleOutputFloat.js';\nimport particleOutputRgba8PS from './particle/frag/particleOutputRgba8.js';\nimport particleUpdaterAABBPS from './particle/frag/particleUpdaterAABB.js';\nimport particleUpdaterEndPS from './particle/frag/particleUpdaterEnd.js';\nimport particleUpdaterInitPS from './particle/frag/particleUpdaterInit.js';\nimport particleUpdaterNoRespawnPS from './particle/frag/particleUpdaterNoRespawn.js';\nimport particleUpdaterOnStopPS from './particle/frag/particleUpdaterOnStop.js';\nimport particleUpdaterRespawnPS from './particle/frag/particleUpdaterRespawn.js';\nimport particleUpdaterSpherePS from './particle/frag/particleUpdaterSphere.js';\nimport particleUpdaterStartPS from './particle/frag/particleUpdaterStart.js';\nimport particle_billboardVS from './particle/vert/particle_billboard.js';\nimport particle_blendAddPS from './particle/frag/particle_blendAdd.js';\nimport particle_blendMultiplyPS from './particle/frag/particle_blendMultiply.js';\nimport particle_blendNormalPS from './particle/frag/particle_blendNormal.js';\nimport particle_cpuVS from './particle/vert/particle_cpu.js';\nimport particle_cpu_endVS from './particle/vert/particle_cpu_end.js';\nimport particle_customFaceVS from './particle/vert/particle_customFace.js';\nimport particle_endPS from './particle/frag/particle_end.js';\nimport particle_endVS from './particle/vert/particle_end.js';\nimport particle_halflambertPS from './particle/frag/particle_halflambert.js';\nimport particle_initVS from './particle/vert/particle_init.js';\nimport particle_lambertPS from './particle/frag/particle_lambert.js';\nimport particle_lightingPS from './particle/frag/particle_lighting.js';\nimport particle_localShiftVS from './particle/vert/particle_localShift.js';\nimport particle_meshVS from './particle/vert/particle_mesh.js';\nimport particle_normalVS from './particle/vert/particle_normal.js';\nimport particle_normalMapPS from './particle/frag/particle_normalMap.js';\nimport particle_pointAlongVS from './particle/vert/particle_pointAlong.js';\nimport particle_softPS from './particle/frag/particle_soft.js';\nimport particle_softVS from './particle/vert/particle_soft.js';\nimport particle_stretchVS from './particle/vert/particle_stretch.js';\nimport particle_TBNVS from './particle/vert/particle_TBN.js';\nimport particle_wrapVS from './particle/vert/particle_wrap.js';\nimport reflDirPS from './lit/frag/reflDir.js';\nimport reflDirAnisoPS from './lit/frag/reflDirAniso.js';\nimport reflectionCCPS from './lit/frag/reflectionCC.js';\nimport reflectionCubePS from './lit/frag/reflectionCube.js';\nimport reflectionEnvHQPS from './lit/frag/reflectionEnvHQ.js';\nimport reflectionEnvPS from './lit/frag/reflectionEnv.js';\nimport reflectionSpherePS from './lit/frag/reflectionSphere.js';\nimport reflectionSheenPS from './lit/frag/reflectionSheen.js';\nimport refractionCubePS from './lit/frag/refractionCube.js';\nimport refractionDynamicPS from './lit/frag/refractionDynamic.js';\nimport reprojectPS from './common/frag/reproject.js';\nimport sampleCatmullRomPS from './common/frag/sampleCatmullRom.js';\nimport screenDepthPS from './common/frag/screenDepth.js';\nimport shadowCascadesPS from './lit/frag/shadowCascades.js';\nimport shadowEVSMPS from './lit/frag/shadowEVSM.js';\nimport shadowEVSMnPS from './lit/frag/shadowEVSMn.js';\nimport shadowPCSSPS from './lit/frag/shadowPCSS.js';\nimport shadowSampleCoordPS from './lit/frag/shadowSampleCoord.js';\nimport shadowStandardPS from './lit/frag/shadowStandard.js';\nimport shadowStandardGL2PS from './lit/frag/shadowStandardGL2.js';\nimport shadowVSM8PS from './lit/frag/shadowVSM8.js';\nimport shadowVSM_commonPS from './lit/frag/shadowVSM_common.js';\nimport skinBatchConstVS from './common/vert/skinBatchConst.js';\nimport skinBatchTexVS from './common/vert/skinBatchTex.js';\nimport skinConstVS from './common/vert/skinConst.js';\nimport skinTexVS from './common/vert/skinTex.js';\nimport skyboxEnvPS from './skybox/frag/skyboxEnv.js';\nimport skyboxHDRPS from './skybox/frag/skyboxHDR.js';\nimport skyboxVS from './skybox/vert/skybox.js';\nimport specularPS from './standard/frag/specular.js';\nimport sphericalPS from './common/frag/spherical.js';\nimport specularityFactorPS from './standard/frag/specularityFactor.js';\nimport spotPS from './lit/frag/spot.js';\nimport startPS from './lit/frag/start.js';\nimport startVS from './lit/vert/start.js';\nimport startNineSlicedPS from './lit/frag/startNineSliced.js';\nimport startNineSlicedTiledPS from './lit/frag/startNineSlicedTiled.js';\nimport storeEVSMPS from './lit/frag/storeEVSM.js';\nimport tangentBinormalVS from './lit/vert/tangentBinormal.js';\nimport TBNPS from './lit/frag/TBN.js';\nimport TBNderivativePS from './lit/frag/TBNderivative.js';\nimport TBNfastPS from './lit/frag/TBNfast.js';\nimport TBNObjectSpacePS from './lit/frag/TBNObjectSpace.js';\nimport textureSamplePS from './standard/frag/textureSample.js';\nimport thicknessPS from './standard/frag/thickness.js';\nimport tonemappingAcesPS from './common/frag/tonemappingAces.js';\nimport tonemappingAces2PS from './common/frag/tonemappingAces2.js';\nimport tonemappingFilmicPS from './common/frag/tonemappingFilmic.js';\nimport tonemappingHejlPS from './common/frag/tonemappingHejl.js';\nimport tonemappingLinearPS from './common/frag/tonemappingLinear.js';\nimport tonemappingNeutralPS from './common/frag/tonemappingNeutral.js';\nimport tonemappingNonePS from './common/frag/tonemappingNone.js';\nimport transformVS from './common/vert/transform.js';\nimport transformDeclVS from './common/vert/transformDecl.js';\nimport transmissionPS from './standard/frag/transmission.js';\nimport twoSidedLightingPS from './lit/frag/twoSidedLighting.js';\nimport uv0VS from './lit/vert/uv0.js';\nimport uv1VS from './lit/vert/uv1.js';\nimport viewDirPS from './lit/frag/viewDir.js';\nimport viewNormalVS from './lit/vert/viewNormal.js';\nimport webgpuPS from '../../../platform/graphics/shader-chunks/frag/webgpu.js';\nimport webgpuVS from '../../../platform/graphics/shader-chunks/vert/webgpu.js';\n\nconst shaderChunks = {\n\talphaTestPS,\n\tambientConstantPS,\n\tambientEnvPS,\n\tambientSHPS,\n\taoPS,\n\taoDetailMapPS,\n\taoDiffuseOccPS,\n\taoSpecOccPS,\n\taoSpecOccConstPS,\n\taoSpecOccConstSimplePS,\n\taoSpecOccSimplePS,\n\tbasePS,\n\tbaseVS,\n\tbaseNineSlicedPS,\n\tbaseNineSlicedVS,\n\tbaseNineSlicedTiledPS,\n\tbayerPS,\n\tbiasConstPS,\n\tblurVSMPS,\n\tclearCoatPS,\n\tclearCoatGlossPS,\n\tclearCoatNormalPS,\n\tclusteredLightCookiesPS,\n\tclusteredLightShadowsPS,\n\tclusteredLightUtilsPS,\n\tclusteredLightPS,\n\tcombinePS,\n\tcookiePS,\n\tcubeMapProjectBoxPS,\n\tcubeMapProjectNonePS,\n\tcubeMapRotatePS,\n\tdebugOutputPS,\n\tdebugProcessFrontendPS,\n\tdetailModesPS,\n\tdiffusePS,\n\tdiffuseDetailMapPS,\n\tdecodePS,\n\temissivePS,\n\tencodePS,\n\tendPS,\n\tendVS,\n\tenvAtlasPS,\n\tenvConstPS,\n\tenvMultiplyPS,\n\textensionPS,\n\textensionVS,\n\tfalloffInvSquaredPS,\n\tfalloffLinearPS,\n\tfixCubemapSeamsNonePS,\n\tfixCubemapSeamsStretchPS,\n\tfloatUnpackingPS,\n\tfogExpPS,\n\tfogExp2PS,\n\tfogLinearPS,\n\tfogNonePS,\n\tfresnelSchlickPS,\n\tfullscreenQuadPS,\n\tfullscreenQuadVS,\n\tgamma1_0PS,\n\tgamma2_2PS,\n\tgles2PS,\n\tgles2VS,\n\tgles3PS,\n\tgles3VS,\n\tglossPS,\n\tiridescenceDiffractionPS,\n\tiridescencePS,\n\tiridescenceThicknessPS,\n\tinstancingVS,\n\tiorPS,\n\tlightDiffuseLambertPS,\n\tlightDirPointPS,\n\tlightmapAddPS,\n\tlightmapDirAddPS,\n\tlightmapDirPS,\n\tlightmapSinglePS,\n\tlightSpecularAnisoGGXPS,\n\tlightSpecularBlinnPS,\n\tlightSpecularPhongPS,\n\tlightSheenPS,\n\tlinearizeDepthPS,\n\tlitShaderArgsPS,\n\tltcPS,\n\tmetalnessPS,\n\tmetalnessModulatePS,\n\tmsdfPS,\n\tmsdfVS,\n\tnormalVS,\n\tnormalDetailMapPS,\n\tnormalInstancedVS,\n\tnormalMapPS,\n\tnormalSkinnedVS,\n\tnormalXYPS,\n\tnormalXYZPS,\n\topacityPS,\n\topacityDitherPS,\n\toutputPS,\n\toutputAlphaPS,\n\toutputAlphaOpaquePS,\n\toutputAlphaPremulPS,\n\toutputTex2DPS,\n\tpackDepthPS,\n\tsheenPS,\n\tsheenGlossPS,\n\tparallaxPS,\n\tparticlePS,\n\tparticleVS,\n\tparticleAnimFrameClampVS,\n\tparticleAnimFrameLoopVS,\n\tparticleAnimTexVS,\n\tparticleInputFloatPS,\n\tparticleInputRgba8PS,\n\tparticleOutputFloatPS,\n\tparticleOutputRgba8PS,\n\tparticleUpdaterAABBPS,\n\tparticleUpdaterEndPS,\n\tparticleUpdaterInitPS,\n\tparticleUpdaterNoRespawnPS,\n\tparticleUpdaterOnStopPS,\n\tparticleUpdaterRespawnPS,\n\tparticleUpdaterSpherePS,\n\tparticleUpdaterStartPS,\n\tparticle_billboardVS,\n\tparticle_blendAddPS,\n\tparticle_blendMultiplyPS,\n\tparticle_blendNormalPS,\n\tparticle_cpuVS,\n\tparticle_cpu_endVS,\n\tparticle_customFaceVS,\n\tparticle_endPS,\n\tparticle_endVS,\n\tparticle_halflambertPS,\n\tparticle_initVS,\n\tparticle_lambertPS,\n\tparticle_lightingPS,\n\tparticle_localShiftVS,\n\tparticle_meshVS,\n\tparticle_normalVS,\n\tparticle_normalMapPS,\n\tparticle_pointAlongVS,\n\tparticle_softPS,\n\tparticle_softVS,\n\tparticle_stretchVS,\n\tparticle_TBNVS,\n\tparticle_wrapVS,\n\treflDirPS,\n\treflDirAnisoPS,\n\treflectionCCPS,\n\treflectionCubePS,\n\treflectionEnvHQPS,\n\treflectionEnvPS,\n\treflectionSpherePS,\n\treflectionSheenPS,\n\trefractionCubePS,\n\trefractionDynamicPS,\n\treprojectPS,\n\tsampleCatmullRomPS,\n\tscreenDepthPS,\n\tshadowCascadesPS,\n\tshadowEVSMPS,\n\tshadowEVSMnPS,\n\tshadowPCSSPS,\n\tshadowSampleCoordPS,\n\tshadowStandardPS,\n\tshadowStandardGL2PS,\n\tshadowVSM8PS,\n\tshadowVSM_commonPS,\n\tskinBatchConstVS,\n\tskinBatchTexVS,\n\tskinConstVS,\n\tskinTexVS,\n\tskyboxEnvPS,\n\tskyboxHDRPS,\n\tskyboxVS,\n\tspecularPS,\n\tsphericalPS,\n\tspecularityFactorPS,\n\tspotPS,\n\tstartPS,\n\tstartVS,\n\tstartNineSlicedPS,\n\tstartNineSlicedTiledPS,\n\tstoreEVSMPS,\n\ttangentBinormalVS,\n\tTBNPS,\n\tTBNderivativePS,\n\tTBNfastPS,\n\tTBNObjectSpacePS,\n\ttextureSamplePS,\n\tthicknessPS,\n\ttonemappingAcesPS,\n\ttonemappingAces2PS,\n\ttonemappingFilmicPS,\n\ttonemappingHejlPS,\n\ttonemappingLinearPS,\n\ttonemappingNeutralPS,\n\ttonemappingNonePS,\n\ttransformVS,\n\ttransformDeclVS,\n\ttransmissionPS,\n\ttwoSidedLightingPS,\n\tuv0VS,\n\tuv1VS,\n\tviewDirPS,\n\tviewNormalVS,\n\twebgpuPS,\n\twebgpuVS\n};\n\nexport { shaderChunks };\n","var bayerPS = `\nfloat bayer2(vec2 p) {\n\treturn mod(2.0 * p.y + p.x + 1.0, 4.0);\n}\nfloat bayer4(vec2 p) {\n\tvec2 p1 = mod(p, 2.0);\n\tvec2 p2 = floor(0.5 * mod(p, 4.0));\n\treturn 4.0 * bayer2(p1) + bayer2(p2);\n}\nfloat bayer8(vec2 p) {\n\tvec2 p1 = mod(p, 2.0);\n\tvec2 p2 = floor(0.5 * mod(p, 4.0));\n\tvec2 p4 = floor(0.25 * mod(p, 8.0));\n\treturn 4.0 * (4.0 * bayer2(p1) + bayer2(p2)) + bayer2(p4);\n}\n`;\n\nexport { bayerPS as default };\n","var decodePS = `\nvec3 decodeLinear(vec4 raw) {\n\treturn raw.rgb;\n}\nfloat decodeGamma(float raw) {\n\treturn pow(raw, 2.2);\n}\nvec3 decodeGamma(vec3 raw) {\n\treturn pow(raw, vec3(2.2));\n}\nvec3 decodeGamma(vec4 raw) {\n\treturn pow(raw.xyz, vec3(2.2));\n}\nvec3 decodeRGBM(vec4 raw) {\n\tvec3 color = (8.0 * raw.a) * raw.rgb;\n\treturn color * color;\n}\nvec3 decodeRGBP(vec4 raw) {\n\tvec3 color = raw.rgb * (-raw.a * 7.0 + 8.0);\n\treturn color * color;\n}\nvec3 decodeRGBE(vec4 raw) {\n\tif (raw.a == 0.0) {\n\t\treturn vec3(0.0, 0.0, 0.0);\n\t} else {\n\t\treturn raw.xyz * pow(2.0, raw.w * 255.0 - 128.0);\n\t}\n}\nvec4 passThrough(vec4 raw) {\n\treturn raw;\n}\n`;\n\nexport { decodePS as default };\n","var encodePS = `\nvec4 encodeLinear(vec3 source) {\n\treturn vec4(source, 1.0);\n}\nvec4 encodeGamma(vec3 source) {\n\treturn vec4(pow(source + 0.0000001, vec3(1.0 / 2.2)), 1.0);\n}\nvec4 encodeRGBM(vec3 source) {\n\tvec4 result;\n\tresult.rgb = pow(source.rgb, vec3(0.5));\n\tresult.rgb *= 1.0 / 8.0;\n\tresult.a = saturate( max( max( result.r, result.g ), max( result.b, 1.0 / 255.0 ) ) );\n\tresult.a = ceil(result.a * 255.0) / 255.0;\n\tresult.rgb /= result.a;\n\treturn result;\n}\nvec4 encodeRGBP(vec3 source) {\n\tvec3 gamma = pow(source, vec3(0.5));\n\tfloat maxVal = min(8.0, max(1.0, max(gamma.x, max(gamma.y, gamma.z))));\n\tfloat v = 1.0 - ((maxVal - 1.0) / 7.0);\n\tv = ceil(v * 255.0) / 255.0;\n\treturn vec4(gamma / (-v * 7.0 + 8.0), v);\t\n}\nvec4 encodeRGBE(vec3 source) {\n\tfloat maxVal = max(source.x, max(source.y, source.z));\n\tif (maxVal < 1e-32) {\n\t\treturn vec4(0, 0, 0, 0);\n\t} else {\n\t\tfloat e = ceil(log2(maxVal));\n\t\treturn vec4(source / pow(2.0, e), (e + 128.0) / 255.0);\n\t}\n}\n`;\n\nexport { encodePS as default };\n","var envAtlasPS = `\nconst float atlasSize = 512.0;\nconst float seamSize = 1.0 / atlasSize;\nvec2 mapUv(vec2 uv, vec4 rect) {\n\treturn vec2(mix(rect.x + seamSize, rect.x + rect.z - seamSize, uv.x),\n\t\t\t\tmix(rect.y + seamSize, rect.y + rect.w - seamSize, uv.y));\n}\nvec2 mapRoughnessUv(vec2 uv, float level) {\n\tfloat t = 1.0 / exp2(level);\n\treturn mapUv(uv, vec4(0, 1.0 - t, t, t * 0.5));\n}\nvec2 mapShinyUv(vec2 uv, float level) {\n\tfloat t = 1.0 / exp2(level);\n\treturn mapUv(uv, vec4(1.0 - t, 1.0 - t, t, t * 0.5));\n}\n`;\n\nexport { envAtlasPS as default };\n","var envConstPS = `\nvec3 processEnvironment(vec3 color) {\n\treturn color;\n}\n`;\n\nexport { envConstPS as default };\n","var envMultiplyPS = `\nuniform float skyboxIntensity;\nvec3 processEnvironment(vec3 color) {\n\treturn color * skyboxIntensity;\n}\n`;\n\nexport { envMultiplyPS as default };\n","var fixCubemapSeamsNonePS = `\nvec3 fixSeams(vec3 vec, float mipmapIndex) {\n\treturn vec;\n}\nvec3 fixSeams(vec3 vec) {\n\treturn vec;\n}\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n\treturn vec;\n}\nvec3 calcSeam(vec3 vec) {\n\treturn vec3(0);\n}\nvec3 applySeam(vec3 vec, vec3 seam, float scale) {\n\treturn vec;\n}\n`;\n\nexport { fixCubemapSeamsNonePS as default };\n","var fixCubemapSeamsStretchPS = `\nvec3 fixSeams(vec3 vec, float mipmapIndex) {\n\tvec3 avec = abs(vec);\n\tfloat scale = 1.0 - exp2(mipmapIndex) / 128.0;\n\tfloat M = max(max(avec.x, avec.y), avec.z);\n\tif (avec.x != M) vec.x *= scale;\n\tif (avec.y != M) vec.y *= scale;\n\tif (avec.z != M) vec.z *= scale;\n\treturn vec;\n}\nvec3 fixSeams(vec3 vec) {\n\tvec3 avec = abs(vec);\n\tfloat scale = 1.0 - 1.0 / 128.0;\n\tfloat M = max(max(avec.x, avec.y), avec.z);\n\tif (avec.x != M) vec.x *= scale;\n\tif (avec.y != M) vec.y *= scale;\n\tif (avec.z != M) vec.z *= scale;\n\treturn vec;\n}\nvec3 fixSeamsStatic(vec3 vec, float invRecMipSize) {\n\tvec3 avec = abs(vec);\n\tfloat scale = invRecMipSize;\n\tfloat M = max(max(avec.x, avec.y), avec.z);\n\tif (avec.x != M) vec.x *= scale;\n\tif (avec.y != M) vec.y *= scale;\n\tif (avec.z != M) vec.z *= scale;\n\treturn vec;\n}\nvec3 calcSeam(vec3 vec) {\n\tvec3 avec = abs(vec);\n\tfloat M = max(avec.x, max(avec.y, avec.z));\n\treturn vec3(avec.x != M ? 1.0 : 0.0,\n\t\t\t\tavec.y != M ? 1.0 : 0.0,\n\t\t\t\tavec.z != M ? 1.0 : 0.0);\n}\nvec3 applySeam(vec3 vec, vec3 seam, float scale) {\n\treturn vec * (seam * -scale + vec3(1.0));\n}\n`;\n\nexport { fixCubemapSeamsStretchPS as default };\n","var fullscreenQuadPS = `\nvarying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n\tgl_FragColor = texture2D(source, vUv0);\n}\n`;\n\nexport { fullscreenQuadPS as default };\n","var gamma1_0PS = `\nfloat gammaCorrectInput(float color) {\n\treturn color;\n}\nvec3 gammaCorrectInput(vec3 color) {\n\treturn color;\n}\nvec4 gammaCorrectInput(vec4 color) {\n\treturn color;\n}\nvec3 gammaCorrectOutput(vec3 color) {\n\treturn color;\n}\n`;\n\nexport { gamma1_0PS as default };\n","var gamma2_2PS = `\nfloat gammaCorrectInput(float color) {\n\treturn decodeGamma(color);\n}\nvec3 gammaCorrectInput(vec3 color) {\n\treturn decodeGamma(color);\n}\nvec4 gammaCorrectInput(vec4 color) {\n\treturn vec4(decodeGamma(color.xyz), color.w);\n}\nvec3 gammaCorrectOutput(vec3 color) {\n#ifdef HDR\n\treturn color;\n#else\n\treturn pow(color + 0.0000001, vec3(1.0 / 2.2));\n#endif\n}\n`;\n\nexport { gamma2_2PS as default };\n","var linearizeDepthPS = `\n#ifndef LINEARIZE_DEPTH\n#define LINEARIZE_DEPTH\nfloat linearizeDepth(float z, vec4 cameraParams) {\n\tif (cameraParams.w == 0.0)\n\t\treturn (cameraParams.z * cameraParams.y) / (cameraParams.y + z * (cameraParams.z - cameraParams.y));\n\telse\n\t\treturn cameraParams.z + z * (cameraParams.y - cameraParams.z);\n}\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\n#ifdef GL2\nfloat linearizeDepth(float z) {\n\treturn linearizeDepth(z, camera_params);\n}\n#else\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(rgbaDepth, bitShift);\n}\n#endif\n#endif\n#endif\n`;\n\nexport { linearizeDepthPS as default };\n","var msdfPS = `\nuniform sampler2D texture_msdfMap;\n#ifdef GL_OES_standard_derivatives\n#define USE_FWIDTH\n#endif\n#ifdef GL2\n#define USE_FWIDTH\n#endif\nfloat median(float r, float g, float b) {\n\treturn max(min(r, g), min(max(r, g), b));\n}\nfloat map (float min, float max, float v) {\n\treturn (v - min) / (max - min);\n}\nuniform float font_sdfIntensity;\nuniform float font_pxrange;\nuniform float font_textureWidth;\n#ifdef UNIFORM_TEXT_PARAMETERS\nuniform vec4 outline_color;\nuniform float outline_thickness;\nuniform vec4 shadow_color;\nuniform vec2 shadow_offset;\n#else\nvarying vec4 outline_color;\nvarying float outline_thickness;\nvarying vec4 shadow_color;\nvarying vec2 shadow_offset;\n#endif\nvec4 applyMsdf(vec4 color) {\n\tvec3 tsample = texture2D(texture_msdfMap, vUv0).rgb;\n\tvec2 uvShdw = vUv0 - shadow_offset;\n\tvec3 ssample = texture2D(texture_msdfMap, uvShdw).rgb;\n\tfloat sigDist = median(tsample.r, tsample.g, tsample.b);\n\tfloat sigDistShdw = median(ssample.r, ssample.g, ssample.b);\n\tfloat smoothingMax = 0.2;\n\t#ifdef USE_FWIDTH\n\tvec2 w = fwidth(vUv0);\n\tfloat smoothing = clamp(w.x * font_textureWidth / font_pxrange, 0.0, smoothingMax);\n\t#else\n\tfloat font_size = 16.0;\n\tfloat smoothing = clamp(font_pxrange / font_size, 0.0, smoothingMax);\n\t#endif\n\tfloat mapMin = 0.05;\n\tfloat mapMax = clamp(1.0 - font_sdfIntensity, mapMin, 1.0);\n\tfloat sigDistInner = map(mapMin, mapMax, sigDist);\n\tfloat sigDistOutline = map(mapMin, mapMax, sigDist + outline_thickness);\n\tsigDistShdw = map(mapMin, mapMax, sigDistShdw + outline_thickness);\n\tfloat center = 0.5;\n\tfloat inside = smoothstep(center-smoothing, center+smoothing, sigDistInner);\n\tfloat outline = smoothstep(center-smoothing, center+smoothing, sigDistOutline);\n\tfloat shadow = smoothstep(center-smoothing, center+smoothing, sigDistShdw);\n\tvec4 tcolor = (outline > inside) ? outline * vec4(outline_color.a * outline_color.rgb, outline_color.a) : vec4(0.0);\n\ttcolor = mix(tcolor, color, inside);\n\tvec4 scolor = (shadow > outline) ? shadow * vec4(shadow_color.a * shadow_color.rgb, shadow_color.a) : tcolor;\n\ttcolor = mix(scolor, tcolor, outline);\n\t\n\treturn tcolor;\n}\n`;\n\nexport { msdfPS as default };\n","var outputTex2DPS = `\nvarying vec2 vUv0;\nuniform sampler2D source;\nvoid main(void) {\n\tgl_FragColor = texture2D(source, vUv0);\n}\n`;\n\nexport { outputTex2DPS as default };\n","var packDepthPS = `\nvec4 packFloat(float depth) {\n\tconst vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);\n\tconst vec4 bit_mask  = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);\n\tvec4 res = mod(depth * bit_shift * vec4(255), vec4(256) ) / vec4(255);\n\tres -= res.xxyz * bit_mask;\n\treturn res;\n}\n`;\n\nexport { packDepthPS as default };\n","import decodePS from './decode.js';\nimport encodePS from './encode.js';\n\nvar reprojectPS = `\nvarying vec2 vUv0;\n#ifdef CUBEMAP_SOURCE\n\tuniform samplerCube sourceCube;\n#else\n\tuniform sampler2D sourceTex;\n#endif\n#ifdef USE_SAMPLES_TEX\n\tuniform sampler2D samplesTex;\n\tuniform vec2 samplesTexInverseSize;\n#endif\nuniform vec3 params;\nfloat targetFace() { return params.x; }\nfloat sourceCubeSeamScale() { return params.y; }\nfloat targetCubeSeamScale() { return params.z; }\nfloat PI = 3.141592653589793;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n${decodePS}\n${encodePS}\nvec3 modifySeams(vec3 dir, float scale) {\n\tvec3 adir = abs(dir);\n\tfloat M = max(max(adir.x, adir.y), adir.z);\n\treturn dir / M * vec3(\n\t\tadir.x == M ? 1.0 : scale,\n\t\tadir.y == M ? 1.0 : scale,\n\t\tadir.z == M ? 1.0 : scale\n\t);\n}\nvec2 toSpherical(vec3 dir) {\n\treturn vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\n}\nvec3 fromSpherical(vec2 uv) {\n\treturn vec3(cos(uv.y) * sin(uv.x),\n\t\t\t\tsin(uv.y),\n\t\t\t\tcos(uv.y) * cos(uv.x));\n}\nvec3 getDirectionEquirect() {\n\treturn fromSpherical((vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0) * vec2(PI, PI * 0.5));\n}\nfloat signNotZero(float k){\n\treturn(k >= 0.0) ? 1.0 : -1.0;\n}\nvec2 signNotZero(vec2 v) {\n\treturn vec2(signNotZero(v.x), signNotZero(v.y));\n}\nvec3 octDecode(vec2 o) {\n\tvec3 v = vec3(o.x, 1.0 - abs(o.x) - abs(o.y), o.y);\n\tif (v.y < 0.0) {\n\t\tv.xz = (1.0 - abs(v.zx)) * signNotZero(v.xz);\n\t}\n\treturn normalize(v);\n}\nvec3 getDirectionOctahedral() {\n\treturn octDecode(vec2(vUv0.x, 1.0 - vUv0.y) * 2.0 - 1.0);\n}\nvec2 octEncode(in vec3 v) {\n\tfloat l1norm = abs(v.x) + abs(v.y) + abs(v.z);\n\tvec2 result = v.xz * (1.0 / l1norm);\n\tif (v.y < 0.0) {\n\t\tresult = (1.0 - abs(result.yx)) * signNotZero(result.xy);\n\t}\n\treturn result;\n}\n#ifdef CUBEMAP_SOURCE\n\tvec4 sampleCubemap(vec3 dir) {\n\t\treturn textureCube(sourceCube, modifySeams(dir, 1.0 - sourceCubeSeamScale()));\n\t}\n\tvec4 sampleCubemap(vec2 sph) {\n\treturn sampleCubemap(fromSpherical(sph));\n}\n\tvec4 sampleCubemap(vec3 dir, float mipLevel) {\n\t\treturn textureCubeLodEXT(sourceCube, modifySeams(dir, 1.0 - exp2(mipLevel) * sourceCubeSeamScale()), mipLevel);\n\t}\n\tvec4 sampleCubemap(vec2 sph, float mipLevel) {\n\t\treturn sampleCubemap(fromSpherical(sph), mipLevel);\n\t}\n#else\n\tvec4 sampleEquirect(vec2 sph) {\n\t\tvec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\n\t\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n\t}\n\tvec4 sampleEquirect(vec3 dir) {\n\t\treturn sampleEquirect(toSpherical(dir));\n\t}\n\tvec4 sampleEquirect(vec2 sph, float mipLevel) {\n\t\tvec2 uv = sph / vec2(PI * 2.0, PI) + 0.5;\n\t\treturn texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\n\t}\n\tvec4 sampleEquirect(vec3 dir, float mipLevel) {\n\t\treturn sampleEquirect(toSpherical(dir), mipLevel);\n\t}\n\tvec4 sampleOctahedral(vec3 dir) {\n\t\tvec2 uv = octEncode(dir) * 0.5 + 0.5;\n\t\treturn texture2D(sourceTex, vec2(uv.x, 1.0 - uv.y));\n\t}\n\tvec4 sampleOctahedral(vec2 sph) {\n\t\treturn sampleOctahedral(fromSpherical(sph));\n\t}\n\tvec4 sampleOctahedral(vec3 dir, float mipLevel) {\n\t\tvec2 uv = octEncode(dir) * 0.5 + 0.5;\n\t\treturn texture2DLodEXT(sourceTex, vec2(uv.x, 1.0 - uv.y), mipLevel);\n\t}\n\tvec4 sampleOctahedral(vec2 sph, float mipLevel) {\n\t\treturn sampleOctahedral(fromSpherical(sph), mipLevel);\n\t}\n#endif\nvec3 getDirectionCubemap() {\n\tvec2 st = vUv0 * 2.0 - 1.0;\n\tfloat face = targetFace();\n\tvec3 vec;\n\tif (face == 0.0) {\n\t\tvec = vec3(1, -st.y, -st.x);\n\t} else if (face == 1.0) {\n\t\tvec = vec3(-1, -st.y, st.x);\n\t} else if (face == 2.0) {\n\t\tvec = vec3(st.x, 1, st.y);\n\t} else if (face == 3.0) {\n\t\tvec = vec3(st.x, -1, -st.y);\n\t} else if (face == 4.0) {\n\t\tvec = vec3(st.x, -st.y, 1);\n\t} else {\n\t\tvec = vec3(-st.x, -st.y, -1);\n\t}\n\treturn normalize(modifySeams(vec, 1.0 / (1.0 - targetCubeSeamScale())));\n}\nmat3 matrixFromVector(vec3 n) {\n\tfloat a = 1.0 / (1.0 + n.z);\n\tfloat b = -n.x * n.y * a;\n\tvec3 b1 = vec3(1.0 - n.x * n.x * a, b, -n.x);\n\tvec3 b2 = vec3(b, 1.0 - n.y * n.y * a, -n.y);\n\treturn mat3(b1, b2, n);\n}\nmat3 matrixFromVectorSlow(vec3 n) {\n\tvec3 up = (1.0 - abs(n.y) <= 0.0000001) ? vec3(0.0, 0.0, n.y > 0.0 ? 1.0 : -1.0) : vec3(0.0, 1.0, 0.0);\n\tvec3 x = normalize(cross(up, n));\n\tvec3 y = cross(n, x);\n\treturn mat3(x, y, n);\n}\nvec4 reproject() {\n\tif (NUM_SAMPLES <= 1) {\n\t\treturn ENCODE_FUNC(DECODE_FUNC(SOURCE_FUNC(TARGET_FUNC())));\n\t} else {\n\t\tvec3 t = TARGET_FUNC();\n\t\tvec3 tu = dFdx(t);\n\t\tvec3 tv = dFdy(t);\n\t\tvec3 result = vec3(0.0);\n\t\tfor (float u = 0.0; u < NUM_SAMPLES_SQRT; ++u) {\n\t\t\tfor (float v = 0.0; v < NUM_SAMPLES_SQRT; ++v) {\n\t\t\t\tresult += DECODE_FUNC(SOURCE_FUNC(normalize(t +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttu * (u / NUM_SAMPLES_SQRT - 0.5) +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttv * (v / NUM_SAMPLES_SQRT - 0.5))));\n\t\t\t}\n\t\t}\n\t\treturn ENCODE_FUNC(result / (NUM_SAMPLES_SQRT * NUM_SAMPLES_SQRT));\n\t}\n}\nvec4 unpackFloat = vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0);\n#ifdef USE_SAMPLES_TEX\n\tvoid unpackSample(int i, out vec3 L, out float mipLevel) {\n\t\tfloat u = (float(i * 4) + 0.5) * samplesTexInverseSize.x;\n\t\tfloat v = (floor(u) + 0.5) * samplesTexInverseSize.y;\n\t\tvec4 raw;\n\t\traw.x = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n\t\traw.y = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n\t\traw.z = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat); u += samplesTexInverseSize.x;\n\t\traw.w = dot(texture2D(samplesTex, vec2(u, v)), unpackFloat);\n\t\tL.xyz = raw.xyz * 2.0 - 1.0;\n\t\tmipLevel = raw.w * 8.0;\n\t}\n\tvec4 prefilterSamples() {\n\t\tmat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());\n\t\tvec3 L;\n\t\tfloat mipLevel;\n\t\tvec3 result = vec3(0.0);\n\t\tfloat totalWeight = 0.0;\n\t\tfor (int i = 0; i < NUM_SAMPLES; ++i) {\n\t\t\tunpackSample(i, L, mipLevel);\n\t\t\tresult += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel)) * L.z;\n\t\t\ttotalWeight += L.z;\n\t\t}\n\t\treturn ENCODE_FUNC(result / totalWeight);\n\t}\n\tvec4 prefilterSamplesUnweighted() {\n\t\tmat3 vecSpace = matrixFromVectorSlow(TARGET_FUNC());\n\t\tvec3 L;\n\t\tfloat mipLevel;\n\t\tvec3 result = vec3(0.0);\n\t\tfloat totalWeight = 0.0;\n\t\tfor (int i = 0; i < NUM_SAMPLES; ++i) {\n\t\t\tunpackSample(i, L, mipLevel);\n\t\t\tresult += DECODE_FUNC(SOURCE_FUNC(vecSpace * L, mipLevel));\n\t\t}\n\t\treturn ENCODE_FUNC(result / float(NUM_SAMPLES));\n\t}\n#endif\nvoid main(void) {\n\tgl_FragColor = PROCESS_FUNC();\n}\n`;\n\nexport { reprojectPS as default };\n","var sampleCatmullRomPS = `\nvec4 SampleTextureCatmullRom(TEXTURE_ACCEPT(tex), vec2 uv, vec2 texSize) {\n\tvec2 samplePos = uv * texSize;\n\tvec2 texPos1 = floor(samplePos - 0.5) + 0.5;\n\tvec2 f = samplePos - texPos1;\n\tvec2 w0 = f * (-0.5 + f * (1.0 - 0.5 * f));\n\tvec2 w1 = 1.0 + f * f * (-2.5 + 1.5 * f);\n\tvec2 w2 = f * (0.5 + f * (2.0 - 1.5 * f));\n\tvec2 w3 = f * f * (-0.5 + 0.5 * f);\n\tvec2 w12 = w1 + w2;\n\tvec2 offset12 = w2 / (w1 + w2);\n\tvec2 texPos0 = (texPos1 - 1.0) / texSize;\n\tvec2 texPos3 = (texPos1 + 2.0) / texSize;\n\tvec2 texPos12 = (texPos1 + offset12) / texSize;\n\tvec4 result = vec4(0.0);\n\tresult += texture2DLodEXT(tex, vec2(texPos0.x, texPos0.y), 0.0) * w0.x * w0.y;\n\tresult += texture2DLodEXT(tex, vec2(texPos12.x, texPos0.y), 0.0) * w12.x * w0.y;\n\tresult += texture2DLodEXT(tex, vec2(texPos3.x, texPos0.y), 0.0) * w3.x * w0.y;\n\tresult += texture2DLodEXT(tex, vec2(texPos0.x, texPos12.y), 0.0) * w0.x * w12.y;\n\tresult += texture2DLodEXT(tex, vec2(texPos12.x, texPos12.y), 0.0) * w12.x * w12.y;\n\tresult += texture2DLodEXT(tex, vec2(texPos3.x, texPos12.y), 0.0) * w3.x * w12.y;\n\tresult += texture2DLodEXT(tex, vec2(texPos0.x, texPos3.y), 0.0) * w0.x * w3.y;\n\tresult += texture2DLodEXT(tex, vec2(texPos12.x, texPos3.y), 0.0) * w12.x * w3.y;\n\tresult += texture2DLodEXT(tex, vec2(texPos3.x, texPos3.y), 0.0) * w3.x * w3.y;\n\treturn result;\n}\n`;\n\nexport { sampleCatmullRomPS as default };\n","var screenDepthPS = `\nuniform highp sampler2D uSceneDepthMap;\n#ifndef SCREENSIZE\n#define SCREENSIZE\nuniform vec4 uScreenSize;\n#endif\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\n#ifndef LINEARIZE_DEPTH\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\n#define LINEARIZE_DEPTH\n#ifdef GL2\nfloat linearizeDepth(float z) {\n\tif (camera_params.w == 0.0)\n\t\treturn (camera_params.z * camera_params.y) / (camera_params.y + z * (camera_params.z - camera_params.y));\n\telse\n\t\treturn camera_params.z + z * (camera_params.y - camera_params.z);\n}\n#else\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(rgbaDepth, bitShift);\n}\n#endif\n#endif\n#endif\nfloat getLinearScreenDepth(vec2 uv) {\n\t#ifdef GL2\n\t\treturn linearizeDepth(texture2D(uSceneDepthMap, uv).r);\n\t#else\n\t\treturn unpackFloat(texture2D(uSceneDepthMap, uv)) * camera_params.y;\n\t#endif\n}\n#ifndef VERTEXSHADER\nfloat getLinearScreenDepth() {\n\tvec2 uv = gl_FragCoord.xy * uScreenSize.zw;\n\treturn getLinearScreenDepth(uv);\n}\n#endif\nfloat getLinearDepth(vec3 pos) {\n\treturn -(matrix_view * vec4(pos, 1.0)).z;\n}\n`;\n\nexport { screenDepthPS as default };\n","var sphericalPS = `\nconst float PI = 3.141592653589793;\nvec2 toSpherical(vec3 dir) {\n\treturn vec2(dir.xz == vec2(0.0) ? 0.0 : atan(dir.x, dir.z), asin(dir.y));\n}\nvec2 toSphericalUv(vec3 dir) {\n\tvec2 uv = toSpherical(dir) / vec2(PI * 2.0, PI) + 0.5;\n\treturn vec2(uv.x, 1.0 - uv.y);\n}\n`;\n\nexport { sphericalPS as default };\n","var tonemappingAcesPS = `\nuniform float exposure;\nvec3 toneMap(vec3 color) {\n\tfloat tA = 2.51;\n\tfloat tB = 0.03;\n\tfloat tC = 2.43;\n\tfloat tD = 0.59;\n\tfloat tE = 0.14;\n\tvec3 x = color * exposure;\n\treturn (x*(tA*x+tB))/(x*(tC*x+tD)+tE);\n}\n`;\n\nexport { tonemappingAcesPS as default };\n","var tonemappingAces2PS = `\nuniform float exposure;\nconst mat3 ACESInputMat = mat3(\n\t0.59719, 0.35458, 0.04823,\n\t0.07600, 0.90834, 0.01566,\n\t0.02840, 0.13383, 0.83777\n);\nconst mat3 ACESOutputMat = mat3(\n\t 1.60475, -0.53108, -0.07367,\n\t-0.10208,  1.10813, -0.00605,\n\t-0.00327, -0.07276,  1.07602\n);\nvec3 RRTAndODTFit(vec3 v) {\n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn a / b;\n}\nvec3 toneMap(vec3 color) {\n\tcolor *= exposure / 0.6;\n\tcolor = color * ACESInputMat;\n\tcolor = RRTAndODTFit(color);\n\tcolor = color * ACESOutputMat;\n\tcolor = clamp(color, 0.0, 1.0);\n\treturn color;\n}\n`;\n\nexport { tonemappingAces2PS as default };\n","var tonemappingFilmicPS = `\nconst float A =  0.15;\nconst float B =  0.50;\nconst float C =  0.10;\nconst float D =  0.20;\nconst float E =  0.02;\nconst float F =  0.30;\nconst float W =  11.2;\nuniform float exposure;\nvec3 uncharted2Tonemap(vec3 x) {\n\t return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;\n}\nvec3 toneMap(vec3 color) {\n\tcolor = uncharted2Tonemap(color * exposure);\n\tvec3 whiteScale = 1.0 / uncharted2Tonemap(vec3(W,W,W));\n\tcolor = color * whiteScale;\n\treturn color;\n}\n`;\n\nexport { tonemappingFilmicPS as default };\n","var tonemappingHejlPS = `\nuniform float exposure;\nvec3 toneMap(vec3 color) {\n\tcolor *= exposure;\n\tconst float  A = 0.22, B = 0.3, C = .1, D = 0.2, E = .01, F = 0.3;\n\tconst float Scl = 1.25;\n\tvec3 h = max( vec3(0.0), color - vec3(0.004) );\n\treturn (h*((Scl*A)*h+Scl*vec3(C*B,C*B,C*B))+Scl*vec3(D*E,D*E,D*E)) / (h*(A*h+vec3(B,B,B))+vec3(D*F,D*F,D*F)) - Scl*vec3(E/F,E/F,E/F);\n}\n`;\n\nexport { tonemappingHejlPS as default };\n","var tonemappingLinearPS = `\nuniform float exposure;\nvec3 toneMap(vec3 color) {\n\treturn color * exposure;\n}\n`;\n\nexport { tonemappingLinearPS as default };\n","var tonemappingNeutralPS = `\nuniform float exposure;\nvec3 toneMap(vec3 color) {\n\tcolor *= exposure;\n\tfloat startCompression = 0.8 - 0.04;\n\tfloat desaturation = 0.15;\n\tfloat x = min(color.r, min(color.g, color.b));\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max(color.r, max(color.g, color.b));\n\tif (peak < startCompression) return color;\n\tfloat d = 1. - startCompression;\n\tfloat newPeak = 1. - d * d / (peak + d - startCompression);\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);\n\treturn mix(color, newPeak * vec3(1, 1, 1), g);\n}\n`;\n\nexport { tonemappingNeutralPS as default };\n","var tonemappingNonePS = `\nvec3 toneMap(vec3 color) {\n\treturn color;\n}\n`;\n\nexport { tonemappingNonePS as default };\n","var fullscreenQuadVS = `\nattribute vec2 vertex_position;\nvarying vec2 vUv0;\nvoid main(void)\n{\n\tgl_Position = vec4(vertex_position, 0.5, 1.0);\n\tvUv0 = vertex_position.xy*0.5+0.5;\n}\n`;\n\nexport { fullscreenQuadVS as default };\n","var msdfVS = `\nattribute vec3 vertex_outlineParameters;\nattribute vec3 vertex_shadowParameters;\nvarying vec4 outline_color;\nvarying float outline_thickness;\nvarying vec4 shadow_color;\nvarying vec2 shadow_offset;\nvoid unpackMsdfParams() {\n\tvec3 little = mod(vertex_outlineParameters, 256.);\n\tvec3 big = (vertex_outlineParameters - little) / 256.;\n\toutline_color.rb = little.xy / 255.;\n\toutline_color.ga = big.xy / 255.;\n\toutline_thickness = little.z / 255. * 0.2;\n\tlittle = mod(vertex_shadowParameters, 256.);\n\tbig = (vertex_shadowParameters - little) / 256.;\n\tshadow_color.rb = little.xy / 255.;\n\tshadow_color.ga = big.xy / 255.;\n\tshadow_offset = (vec2(little.z, big.z) / 127. - 1.) * 0.005;\n}\n`;\n\nexport { msdfVS as default };\n","var skinBatchConstVS = `\nattribute float vertex_boneIndices;\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\nmat4 getBoneMatrix(const in float i) {\n\tvec4 v1 = matrix_pose[int(3.0 * i)];\n\tvec4 v2 = matrix_pose[int(3.0 * i + 1.0)];\n\tvec4 v3 = matrix_pose[int(3.0 * i + 2.0)];\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, 1\n\t);\n}\n`;\n\nexport { skinBatchConstVS as default };\n","var skinBatchTexVS = `\nattribute float vertex_boneIndices;\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\nmat4 getBoneMatrix(const in float i) {\n\tfloat j = i * 3.0;\n\tfloat dx = texture_poseMapSize.z;\n\tfloat dy = texture_poseMapSize.w;\n\tfloat y = floor(j * dx);\n\tfloat x = j - (y * texture_poseMapSize.x);\n\ty = dy * (y + 0.5);\n\tvec4 v1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n\tvec4 v2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n\tvec4 v3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, 1\n\t);\n}\n`;\n\nexport { skinBatchTexVS as default };\n","var skinConstVS = `\nattribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nuniform vec4 matrix_pose[BONE_LIMIT * 3];\nvoid getBoneMatrix(const in float i, out vec4 v1, out vec4 v2, out vec4 v3) {\n\tv1 = matrix_pose[int(3.0 * i)];\n\tv2 = matrix_pose[int(3.0 * i + 1.0)];\n\tv3 = matrix_pose[int(3.0 * i + 2.0)];\n}\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\n\tvec4 a1, a2, a3;\n\tgetBoneMatrix(indices.x, a1, a2, a3);\n\tvec4 b1, b2, b3;\n\tgetBoneMatrix(indices.y, b1, b2, b3);\n\tvec4 c1, c2, c3;\n\tgetBoneMatrix(indices.z, c1, c2, c3);\n\tvec4 d1, d2, d3;\n\tgetBoneMatrix(indices.w, d1, d2, d3);\n\tvec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n\tvec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n\tvec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n\tfloat one = dot(weights, vec4(1.0));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, one\n\t);\n}\n`;\n\nexport { skinConstVS as default };\n","var skinTexVS = `\nattribute vec4 vertex_boneWeights;\nattribute vec4 vertex_boneIndices;\nuniform highp sampler2D texture_poseMap;\nuniform vec4 texture_poseMapSize;\nvoid getBoneMatrix(const in float index, out vec4 v1, out vec4 v2, out vec4 v3) {\n\tfloat i = float(index);\n\tfloat j = i * 3.0;\n\tfloat dx = texture_poseMapSize.z;\n\tfloat dy = texture_poseMapSize.w;\n\t\n\tfloat y = floor(j * dx);\n\tfloat x = j - (y * texture_poseMapSize.x);\n\ty = dy * (y + 0.5);\n\tv1 = texture2D(texture_poseMap, vec2(dx * (x + 0.5), y));\n\tv2 = texture2D(texture_poseMap, vec2(dx * (x + 1.5), y));\n\tv3 = texture2D(texture_poseMap, vec2(dx * (x + 2.5), y));\n}\nmat4 getSkinMatrix(const in vec4 indices, const in vec4 weights) {\n\tvec4 a1, a2, a3;\n\tgetBoneMatrix(indices.x, a1, a2, a3);\n\tvec4 b1, b2, b3;\n\tgetBoneMatrix(indices.y, b1, b2, b3);\n\tvec4 c1, c2, c3;\n\tgetBoneMatrix(indices.z, c1, c2, c3);\n\tvec4 d1, d2, d3;\n\tgetBoneMatrix(indices.w, d1, d2, d3);\n\tvec4 v1 = a1 * weights.x + b1 * weights.y + c1 * weights.z + d1 * weights.w;\n\tvec4 v2 = a2 * weights.x + b2 * weights.y + c2 * weights.z + d2 * weights.w;\n\tvec4 v3 = a3 * weights.x + b3 * weights.y + c3 * weights.z + d3 * weights.w;\n\tfloat one = dot(weights, vec4(1.0));\n\treturn mat4(\n\t\tv1.x, v2.x, v3.x, 0,\n\t\tv1.y, v2.y, v3.y, 0,\n\t\tv1.z, v2.z, v3.z, 0,\n\t\tv1.w, v2.w, v3.w, one\n\t);\n}\n`;\n\nexport { skinTexVS as default };\n","var transformVS = `\n#ifdef PIXELSNAP\nuniform vec4 uScreenSize;\n#endif\n#ifdef SCREENSPACE\nuniform float projectionFlipY;\n#endif\n#ifdef MORPHING\nuniform vec4 morph_weights_a;\nuniform vec4 morph_weights_b;\n#endif\n#ifdef MORPHING_TEXTURE_BASED\n\tuniform vec4 morph_tex_params;\n\t#ifdef WEBGPU\n\t\tivec2 getTextureMorphCoords() {\n\t\t\tivec2 textureSize = ivec2(morph_tex_params.xy);\n\t\t\tint morphGridV = int(morph_vertex_id / textureSize.x);\n\t\t\tint morphGridU = int(morph_vertex_id - (morphGridV * textureSize.x));\n\t\t\tmorphGridV = textureSize.y - morphGridV - 1;\n\t\t\treturn ivec2(morphGridU, morphGridV);\n\t\t}\n\t#else\n\t\tvec2 getTextureMorphCoords() {\n\t\t\tvec2 textureSize = morph_tex_params.xy;\n\t\t\tvec2 invTextureSize = morph_tex_params.zw;\n\t\t\tfloat morphGridV = floor(morph_vertex_id * invTextureSize.x);\n\t\t\tfloat morphGridU = morph_vertex_id - (morphGridV * textureSize.x);\n\t\t\treturn vec2(morphGridU, morphGridV) * invTextureSize + (0.5 * invTextureSize);\n\t\t}\n\t#endif\n#endif\n#ifdef MORPHING_TEXTURE_BASED_POSITION\nuniform highp sampler2D morphPositionTex;\n#endif\nmat4 getModelMatrix() {\n\t#ifdef DYNAMICBATCH\n\treturn getBoneMatrix(vertex_boneIndices);\n\t#elif defined(SKIN)\n\treturn matrix_model * getSkinMatrix(vertex_boneIndices, vertex_boneWeights);\n\t#elif defined(INSTANCING)\n\treturn mat4(instance_line1, instance_line2, instance_line3, instance_line4);\n\t#else\n\treturn matrix_model;\n\t#endif\n}\nvec4 getPosition() {\n\tdModelMatrix = getModelMatrix();\n\tvec3 localPos = vertex_position;\n\t#ifdef NINESLICED\n\tlocalPos.xz *= outerScale;\n\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n\tlocalPos.xz += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\tvTiledUv = (localPos.xz - outerScale + innerOffset.xy) * -0.5 + 1.0;\n\tlocalPos.xz *= -0.5;\n\tlocalPos = localPos.xzy;\n\t#endif\n\t#ifdef MORPHING\n\t#ifdef MORPHING_POS03\n\tlocalPos.xyz += morph_weights_a[0] * morph_pos0;\n\tlocalPos.xyz += morph_weights_a[1] * morph_pos1;\n\tlocalPos.xyz += morph_weights_a[2] * morph_pos2;\n\tlocalPos.xyz += morph_weights_a[3] * morph_pos3;\n\t#endif\n\t#ifdef MORPHING_POS47\n\tlocalPos.xyz += morph_weights_b[0] * morph_pos4;\n\tlocalPos.xyz += morph_weights_b[1] * morph_pos5;\n\tlocalPos.xyz += morph_weights_b[2] * morph_pos6;\n\tlocalPos.xyz += morph_weights_b[3] * morph_pos7;\n\t#endif\n\t#endif\n\t#ifdef MORPHING_TEXTURE_BASED_POSITION\n\t\t#ifdef WEBGPU\n\t\t\tivec2 morphUV = getTextureMorphCoords();\n\t\t\tvec3 morphPos = texelFetch(morphPositionTex, ivec2(morphUV), 0).xyz;\n\t\t#else\n\t\t\tvec2 morphUV = getTextureMorphCoords();\n\t\t\tvec3 morphPos = texture2D(morphPositionTex, morphUV).xyz;\n\t\t#endif\n\t\tlocalPos += morphPos;\n\t#endif\n\tvec4 posW = dModelMatrix * vec4(localPos, 1.0);\n\t#ifdef SCREENSPACE\n\tposW.zw = vec2(0.0, 1.0);\n\t#endif\n\tdPositionW = posW.xyz;\n\tvec4 screenPos;\n\t#ifdef UV1LAYOUT\n\tscreenPos = vec4(vertex_texCoord1.xy * 2.0 - 1.0, 0.5, 1);\n\t\t#ifdef WEBGPU\n\t\tscreenPos.y *= -1.0;\n\t\t#endif\n\t#else\n\t#ifdef SCREENSPACE\n\tscreenPos = posW;\n\tscreenPos.y *= projectionFlipY;\n\t#else\n\tscreenPos = matrix_viewProjection * posW;\n\t#endif\n\t#ifdef PIXELSNAP\n\tscreenPos.xy = (screenPos.xy * 0.5) + 0.5;\n\tscreenPos.xy *= uScreenSize.xy;\n\tscreenPos.xy = floor(screenPos.xy);\n\tscreenPos.xy *= uScreenSize.zw;\n\tscreenPos.xy = (screenPos.xy * 2.0) - 1.0;\n\t#endif\n\t#endif\n\treturn screenPos;\n}\nvec3 getWorldPosition() {\n\treturn dPositionW;\n}\n`;\n\nexport { transformVS as default };\n","var transformDeclVS = `\nattribute vec3 vertex_position;\nuniform mat4 matrix_model;\nuniform mat4 matrix_viewProjection;\nvec3 dPositionW;\nmat4 dModelMatrix;\n`;\n\nexport { transformDeclVS as default };\n","var bakeDirLmEndPS = `\n\tvec4 dirLm = texture2D(texture_dirLightMap, vUv1);\n\tif (bakeDir > 0.5) {\n\t\tif (dAtten > 0.00001) {\n\t\t\tdirLm.xyz = dirLm.xyz * 2.0 - vec3(1.0);\n\t\t\tdAtten = saturate(dAtten);\n\t\t\tgl_FragColor.rgb = normalize(dLightDirNormW.xyz*dAtten + dirLm.xyz*dirLm.w) * 0.5 + vec3(0.5);\n\t\t\tgl_FragColor.a = dirLm.w + dAtten;\n\t\t\tgl_FragColor.a = max(gl_FragColor.a, 1.0 / 255.0);\n\t\t} else {\n\t\t\tgl_FragColor = dirLm;\n\t\t}\n\t} else {\n\t\tgl_FragColor.rgb = dirLm.xyz;\n\t\tgl_FragColor.a = max(dirLm.w, dAtten > 0.00001? (1.0/255.0) : 0.0);\n\t}\n`;\n\nexport { bakeDirLmEndPS as default };\n","var bakeLmEndPS = `\n#ifdef LIGHTMAP_RGBM\n\tgl_FragColor.rgb = dDiffuseLight;\n\tgl_FragColor.rgb = pow(gl_FragColor.rgb, vec3(0.5));\n\tgl_FragColor.rgb /= 8.0;\n\tgl_FragColor.a = clamp( max( max( gl_FragColor.r, gl_FragColor.g ), max( gl_FragColor.b, 1.0 / 255.0 ) ), 0.0,1.0 );\n\tgl_FragColor.a = ceil(gl_FragColor.a * 255.0) / 255.0;\n\tgl_FragColor.rgb /= gl_FragColor.a;\n#else\n\tgl_FragColor = vec4(dDiffuseLight, 1.0);\n#endif\n`;\n\nexport { bakeLmEndPS as default };\n","var bilateralDeNoisePS = `\nfloat normpdf3(in vec3 v, in float sigma) {\n\treturn 0.39894 * exp(-0.5 * dot(v, v) / (sigma * sigma)) / sigma;\n}\nvec3 decodeRGBM(vec4 rgbm) {\n\tvec3 color = (8.0 * rgbm.a) * rgbm.rgb;\n\treturn color * color;\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec4 encodeRGBM(vec3 color) {\n\tvec4 encoded;\n\tencoded.rgb = pow(color.rgb, vec3(0.5));\n\tencoded.rgb *= 1.0 / 8.0;\n\tencoded.a = saturate( max( max( encoded.r, encoded.g ), max( encoded.b, 1.0 / 255.0 ) ) );\n\tencoded.a = ceil(encoded.a * 255.0) / 255.0;\n\tencoded.rgb /= encoded.a;\n\treturn encoded;\n}\n#define MSIZE 15\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nuniform vec2 sigmas;\nuniform float bZnorm;\nuniform float kernel[MSIZE];\nvoid main(void) {\n\t\n\tvec4 pixelRgbm = texture2DLodEXT(source, vUv0, 0.0);\n\tif (pixelRgbm.a <= 0.0) {\n\t\tgl_FragColor = pixelRgbm;\n\t\treturn ;\n\t}\n\tfloat sigma = sigmas.x;\n\tfloat bSigma = sigmas.y;\n\tvec3 pixelHdr = decodeRGBM(pixelRgbm);\n\tvec3 accumulatedHdr = vec3(0.0);\n\tfloat accumulatedFactor = 0.0;\n\tconst int kSize = (MSIZE-1)/2;\n\tfor (int i = -kSize; i <= kSize; ++i) {\n\t\tfor (int j = -kSize; j <= kSize; ++j) {\n\t\t\t\n\t\t\tvec2 coord = vUv0 + vec2(float(i), float(j)) * pixelOffset;\n\t\t\tvec4 rgbm = texture2DLodEXT(source, coord, 0.0);\n\t\t\tif (rgbm.a > 0.0) {\n\t\t\t\tvec3 hdr = decodeRGBM(rgbm);\n\t\t\t\tfloat factor = kernel[kSize + j] * kernel[kSize + i];\n\t\t\t\tfactor *= normpdf3(hdr - pixelHdr, bSigma) * bZnorm;\n\t\t\t\taccumulatedHdr += factor * hdr;\n\t\t\t\taccumulatedFactor += factor;\n\t\t\t}\n\t\t}\n\t}\n\tgl_FragColor = encodeRGBM(accumulatedHdr / accumulatedFactor);\n}\n`;\n\nexport { bilateralDeNoisePS as default };\n","var dilatePS = `\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\nvoid main(void) {\n\tvec4 c = texture2DLodEXT(source, vUv0, 0.0);\n\tc = c.a>0.0? c : texture2DLodEXT(source, vUv0 - pixelOffset, 0.0);\n\tc = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(0, -pixelOffset.y), 0.0);\n\tc = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(pixelOffset.x, -pixelOffset.y), 0.0);\n\tc = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(-pixelOffset.x, 0), 0.0);\n\tc = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(pixelOffset.x, 0), 0.0);\n\tc = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(-pixelOffset.x, pixelOffset.y), 0.0);\n\tc = c.a>0.0? c : texture2DLodEXT(source, vUv0 + vec2(0, pixelOffset.y), 0.0);\n\tc = c.a>0.0? c : texture2DLodEXT(source, vUv0 + pixelOffset, 0.0);\n\tgl_FragColor = c;\n}\n`;\n\nexport { dilatePS as default };\n","var TBNPS = `\nvoid getTBN(vec3 tangent, vec3 binormal, vec3 normal) {\n\tdTBN = mat3(normalize(tangent), normalize(binormal), normalize(normal));\n}\n`;\n\nexport { TBNPS as default };\n","var TBNObjectSpacePS = `\nvoid getTBN(vec3 tangent, vec3 binormal, vec3 normal) {\n\tvec3 B = cross(normal, vObjectSpaceUpW);\n\tvec3 T = cross(normal, B);\n\tif (dot(B,B)==0.0)\n\t{\n\t\tfloat major=max(max(normal.x, normal.y), normal.z);\n\t\tif (normal.x == major)\n\t\t{\n\t\t\tB=cross(normal, vec3(0,1,0));\n\t\t\tT=cross(normal, B);\n\t\t}\n\t\telse if (normal.y == major)\n\t\t{\n\t\t\tB=cross(normal, vec3(0,0,1));\n\t\t\tT=cross(normal, B);\n\t\t}\n\t\telse if (normal.z == major)\n\t\t{\n\t\t\tB=cross(normal, vec3(1,0,0));\n\t\t\tT=cross(normal, B);\n\t\t}\n\t}\n\tdTBN = mat3(normalize(T), normalize(B), normalize(normal));\n}\n`;\n\nexport { TBNObjectSpacePS as default };\n","var TBNderivativePS = `\nuniform float tbnBasis;\nvoid getTBN(vec3 tangent, vec3 binormal, vec3 normal) {\n\tvec2 uv = $UV;\n\tvec3 dp1 = dFdx( vPositionW );\n\tvec3 dp2 = dFdy( vPositionW );\n\tvec2 duv1 = dFdx( uv );\n\tvec2 duv2 = dFdy( uv );\n\tvec3 dp2perp = cross( dp2, normal );\n\tvec3 dp1perp = cross( normal, dp1 );\n\tvec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n\tvec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n\tfloat denom = max( dot(T,T), dot(B,B) );\n\tfloat invmax = (denom == 0.0) ? 0.0 : tbnBasis / sqrt( denom );\n\tdTBN = mat3(T * invmax, -B * invmax, normal );\n}\n`;\n\nexport { TBNderivativePS as default };\n","var TBNfastPS = `\nvoid getTBN(vec3 tangent, vec3 binormal, vec3 normal) {\n\tdTBN = mat3(tangent, binormal, normal);\n}\n`;\n\nexport { TBNfastPS as default };\n","var ambientConstantPS = `\nvoid addAmbient(vec3 worldNormal) {\n\tdDiffuseLight += light_globalAmbient;\n}\n`;\n\nexport { ambientConstantPS as default };\n","var ambientEnvPS = `\n#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nvoid addAmbient(vec3 worldNormal) {\n\tvec3 dir = normalize(cubeMapRotate(worldNormal) * vec3(-1.0, 1.0, 1.0));\n\tvec2 uv = mapUv(toSphericalUv(dir), vec4(128.0, 256.0 + 128.0, 64.0, 32.0) / atlasSize);\n\tvec4 raw = texture2D(texture_envAtlas, uv);\n\tvec3 linear = $DECODE(raw);\n\tdDiffuseLight += processEnvironment(linear);\n}\n`;\n\nexport { ambientEnvPS as default };\n","var ambientSHPS = `\nuniform vec3 ambientSH[9];\nvoid addAmbient(vec3 worldNormal) {\n\tvec3 n = cubeMapRotate(worldNormal);\n\tvec3 color =\n\t\tambientSH[0] +\n\t\tambientSH[1] * n.x +\n\t\tambientSH[2] * n.y +\n\t\tambientSH[3] * n.z +\n\t\tambientSH[4] * n.x * n.z +\n\t\tambientSH[5] * n.z * n.y +\n\t\tambientSH[6] * n.y * n.x +\n\t\tambientSH[7] * (3.0 * n.z * n.z - 1.0) +\n\t\tambientSH[8] * (n.x * n.x - n.y * n.y);\n\tdDiffuseLight += processEnvironment(max(color, vec3(0.0)));\n}\n`;\n\nexport { ambientSHPS as default };\n","var aoDiffuseOccPS = `\nvoid occludeDiffuse(float ao) {\n\tdDiffuseLight *= ao;\n}\n`;\n\nexport { aoDiffuseOccPS as default };\n","var aoSpecOccPS = `\nuniform float material_occludeSpecularIntensity;\nvoid occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {\n\tfloat specPow = exp2(gloss * 11.0);\n\tfloat specOcc = saturate(pow(dot(worldNormal, viewDir) + ao, 0.01*specPow) - 1.0 + ao);\n\tspecOcc = mix(1.0, specOcc, material_occludeSpecularIntensity);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n\t\n#ifdef LIT_SHEEN\n\tsSpecularLight *= specOcc;\n\tsReflection *= specOcc;\n#endif\n}\n`;\n\nexport { aoSpecOccPS as default };\n","var aoSpecOccConstPS = `\nvoid occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {\n\tfloat specPow = exp2(gloss * 11.0);\n\tfloat specOcc = saturate(pow(dot(worldNormal, viewDir) + ao, 0.01*specPow) - 1.0 + ao);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n\t\n#ifdef LIT_SHEEN\n\tsSpecularLight *= specOcc;\n\tsReflection *= specOcc;\n#endif\n}\n`;\n\nexport { aoSpecOccConstPS as default };\n","var aoSpecOccConstSimplePS = `\nvoid occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {\n\tdSpecularLight *= ao;\n\tdReflection *= ao;\n#ifdef LIT_SHEEN\n\tsSpecularLight *= ao;\n\tsReflection *= ao;\n#endif\n}\n`;\n\nexport { aoSpecOccConstSimplePS as default };\n","var aoSpecOccSimplePS = `\nuniform float material_occludeSpecularIntensity;\nvoid occludeSpecular(float gloss, float ao, vec3 worldNormal, vec3 viewDir) {\n\tfloat specOcc = mix(1.0, ao, material_occludeSpecularIntensity);\n\tdSpecularLight *= specOcc;\n\tdReflection *= specOcc;\n#ifdef LIT_SHEEN\n\tsSpecularLight *= specOcc;\n\tsReflection *= specOcc;\n#endif\n}\n`;\n\nexport { aoSpecOccSimplePS as default };\n","var basePS = `\nuniform vec3 view_position;\nuniform vec3 light_globalAmbient;\nfloat square(float x) {\n\treturn x*x;\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 saturate(vec3 x) {\n\treturn clamp(x, vec3(0.0), vec3(1.0));\n}\n`;\n\nexport { basePS as default };\n","var baseNineSlicedPS = `\n#define NINESLICED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n`;\n\nexport { baseNineSlicedPS as default };\n","var baseNineSlicedTiledPS = `\n#define NINESLICED\n#define NINESLICETILED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\nvec2 nineSlicedUv;\n`;\n\nexport { baseNineSlicedTiledPS as default };\n","var biasConstPS = `\n#define SHADOWBIAS\n#define SHADOW_SAMPLE_Z_BIAS\nfloat getShadowBias(float resolution, float maxBias) {\n\treturn maxBias;\n}\n`;\n\nexport { biasConstPS as default };\n","var blurVSMPS = `\nvarying vec2 vUv0;\nuniform sampler2D source;\nuniform vec2 pixelOffset;\n#ifdef GAUSS\nuniform float weight[SAMPLES];\n#endif\n#ifdef PACKED\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nvec2 encodeFloatRG( float v ) {\n\tvec2 enc = vec2(1.0, 255.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n\treturn enc;\n}\n#endif\nvoid main(void) {\n\tvec3 moments = vec3(0.0);\n\tvec2 uv = vUv0 - pixelOffset * (float(SAMPLES) * 0.5);\n\tfor (int i=0; i<SAMPLES; i++) {\n\t\tvec4 c = texture2D(source, uv + pixelOffset * float(i));\n\t\t#ifdef PACKED\n\t\tc.xy = vec2(decodeFloatRG(c.xy), decodeFloatRG(c.zw));\n\t\t#endif\n\t\t#ifdef GAUSS\n\t\tmoments += c.xyz * weight[i];\n\t\t#else\n\t\tmoments += c.xyz;\n\t\t#endif\n\t}\n\t#ifndef GAUSS\n\tmoments /= float(SAMPLES);\n\t#endif\n\t#ifdef PACKED\n\tgl_FragColor = vec4(encodeFloatRG(moments.x), encodeFloatRG(moments.y));\n\t#else\n\tgl_FragColor = vec4(moments.x, moments.y, moments.z, 1.0);\n\t#endif\n}\n`;\n\nexport { blurVSMPS as default };\n","var clusteredLightPS = `\nuniform highp sampler2D clusterWorldTexture;\nuniform highp sampler2D lightsTexture8;\nuniform highp sampler2D lightsTextureFloat;\n#if defined(CLUSTER_COOKIES)\n\t#define CLUSTER_COOKIES_OR_SHADOWS\n#endif\n#if defined(CLUSTER_SHADOWS)\n\t#define CLUSTER_COOKIES_OR_SHADOWS\n#endif\n#ifdef CLUSTER_SHADOWS\n\t#ifdef GL2\n\t\tuniform sampler2DShadow shadowAtlasTexture;\n\t#else\n\t\tuniform sampler2D shadowAtlasTexture;\n\t#endif\n#endif\n#ifdef CLUSTER_COOKIES\n\tuniform sampler2D cookieAtlasTexture;\n#endif\n#ifdef GL2\n\tuniform int clusterMaxCells;\n#else\n\tuniform float clusterMaxCells;\n\tuniform vec4 lightsTextureInvSize;\n#endif\nuniform float clusterSkip;\nuniform vec3 clusterCellsCountByBoundsSize;\nuniform vec3 clusterTextureSize;\nuniform vec3 clusterBoundsMin;\nuniform vec3 clusterBoundsDelta;\nuniform vec3 clusterCellsDot;\nuniform vec3 clusterCellsMax;\nuniform vec2 clusterCompressionLimit0;\nuniform vec2 shadowAtlasParams;\nstruct ClusterLightData {\n\tvec3 halfWidth;\n\tfloat lightType;\n\tvec3 halfHeight;\n\t#ifdef GL2\n\t\tint lightIndex;\n\t#else\n\t\tfloat lightV;\n\t#endif\n\tvec3 position;\n\tfloat shape;\n\tvec3 direction;\n\tfloat falloffMode;\n\tvec3 color;\n\tfloat shadowIntensity;\n\tvec3 omniAtlasViewport;\n\tfloat range;\n\tvec4 cookieChannelMask;\n\tfloat shadowBias;\n\tfloat shadowNormalBias;\n\tfloat innerConeAngleCos;\n\tfloat outerConeAngleCos;\n\tfloat cookie;\n\tfloat cookieRgb;\n\tfloat cookieIntensity;\n\tfloat mask;\n};\nmat4 lightProjectionMatrix;\n#define isClusteredLightCastShadow(light) ( light.shadowIntensity > 0.0 )\n#define isClusteredLightCookie(light) (light.cookie > 0.5 )\n#define isClusteredLightCookieRgb(light) (light.cookieRgb > 0.5 )\n#define isClusteredLightSpot(light) ( light.lightType > 0.5 )\n#define isClusteredLightFalloffLinear(light) ( light.falloffMode < 0.5 )\n#define isClusteredLightArea(light) ( light.shape > 0.1 )\n#define isClusteredLightRect(light) ( light.shape < 0.3 )\n#define isClusteredLightDisk(light) ( light.shape < 0.6 )\n#ifdef CLUSTER_MESH_DYNAMIC_LIGHTS\n\t#define acceptLightMask(light) ( light.mask < 0.75)\n#else\n\t#define acceptLightMask(light) ( light.mask > 0.25)\n#endif\nvec4 decodeClusterLowRange4Vec4(vec4 d0, vec4 d1, vec4 d2, vec4 d3) {\n\treturn vec4(\n\t\tbytes2floatRange4(d0, -2.0, 2.0),\n\t\tbytes2floatRange4(d1, -2.0, 2.0),\n\t\tbytes2floatRange4(d2, -2.0, 2.0),\n\t\tbytes2floatRange4(d3, -2.0, 2.0)\n\t);\n}\n#ifdef GL2\n\tvec4 sampleLightsTexture8(const ClusterLightData clusterLightData, int index) {\n\t\treturn texelFetch(lightsTexture8, ivec2(index, clusterLightData.lightIndex), 0);\n\t}\n\tvec4 sampleLightTextureF(const ClusterLightData clusterLightData, int index) {\n\t\treturn texelFetch(lightsTextureFloat, ivec2(index, clusterLightData.lightIndex), 0);\n\t}\n#else\n\tvec4 sampleLightsTexture8(const ClusterLightData clusterLightData, float index) {\n\t\treturn texture2DLodEXT(lightsTexture8, vec2(index * lightsTextureInvSize.z, clusterLightData.lightV), 0.0);\n\t}\n\tvec4 sampleLightTextureF(const ClusterLightData clusterLightData, float index) {\n\t\treturn texture2DLodEXT(lightsTextureFloat, vec2(index * lightsTextureInvSize.x, clusterLightData.lightV), 0.0);\n\t}\n#endif\nvoid decodeClusterLightCore(inout ClusterLightData clusterLightData, float lightIndex) {\n\t#ifdef GL2\n\t\tclusterLightData.lightIndex = int(lightIndex);\n\t#else\n\t\tclusterLightData.lightV = (lightIndex + 0.5) * lightsTextureInvSize.w;\n\t#endif\n\tvec4 lightInfo = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_FLAGS);\n\tclusterLightData.lightType = lightInfo.x;\n\tclusterLightData.shape = lightInfo.y;\n\tclusterLightData.falloffMode = lightInfo.z;\n\tclusterLightData.shadowIntensity = lightInfo.w;\n\tvec4 colorA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_A);\n\tvec4 colorB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COLOR_B);\n\tclusterLightData.color = vec3(bytes2float2(colorA.xy), bytes2float2(colorA.zw), bytes2float2(colorB.xy)) * clusterCompressionLimit0.y;\n\tclusterLightData.cookie = colorB.z;\n\tclusterLightData.mask = colorB.w;\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\t\tvec4 lightPosRange = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_POSITION_RANGE);\n\t\tclusterLightData.position = lightPosRange.xyz;\n\t\tclusterLightData.range = lightPosRange.w;\n\t\tvec4 lightDir_Unused = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_SPOT_DIRECTION);\n\t\tclusterLightData.direction = lightDir_Unused.xyz;\n\t#else\n\t\tvec4 encPosX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_X);\n\t\tvec4 encPosY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Y);\n\t\tvec4 encPosZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_POSITION_Z);\n\t\tclusterLightData.position = vec3(bytes2float4(encPosX), bytes2float4(encPosY), bytes2float4(encPosZ)) * clusterBoundsDelta + clusterBoundsMin;\n\t\tvec4 encRange = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_RANGE);\n\t\tclusterLightData.range = bytes2float4(encRange) * clusterCompressionLimit0.x;\n\t\tvec4 encDirX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_X);\n\t\tvec4 encDirY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Y);\n\t\tvec4 encDirZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_DIRECTION_Z);\n\t\tclusterLightData.direction = vec3(bytes2float4(encDirX), bytes2float4(encDirY), bytes2float4(encDirZ)) * 2.0 - 1.0;\n\t#endif\n}\nvoid decodeClusterLightSpot(inout ClusterLightData clusterLightData) {\n\tvec4 coneAngle = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SPOT_ANGLES);\n\tclusterLightData.innerConeAngleCos = bytes2float2(coneAngle.xy) * 2.0 - 1.0;\n\tclusterLightData.outerConeAngleCos = bytes2float2(coneAngle.zw) * 2.0 - 1.0;\n}\nvoid decodeClusterLightOmniAtlasViewport(inout ClusterLightData clusterLightData) {\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\t\tclusterLightData.omniAtlasViewport = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0).xyz;\n\t#else\n\t\tvec4 viewportA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_A);\n\t\tvec4 viewportB = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_ATLAS_VIEWPORT_B);\n\t\tclusterLightData.omniAtlasViewport = vec3(bytes2float2(viewportA.xy), bytes2float2(viewportA.zw), bytes2float2(viewportB.xy));\n\t#endif\n}\nvoid decodeClusterLightAreaData(inout ClusterLightData clusterLightData) {\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\t\tclusterLightData.halfWidth = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_WIDTH).xyz;\n\t\tclusterLightData.halfHeight = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_AREA_DATA_HEIGHT).xyz;\n\t#else\n\t\tvec4 areaWidthX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_X);\n\t\tvec4 areaWidthY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Y);\n\t\tvec4 areaWidthZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_WIDTH_Z);\n\t\tclusterLightData.halfWidth = vec3(mantissaExponent2Float(areaWidthX), mantissaExponent2Float(areaWidthY), mantissaExponent2Float(areaWidthZ));\n\t\tvec4 areaHeightX = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_X);\n\t\tvec4 areaHeightY = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Y);\n\t\tvec4 areaHeightZ = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_AREA_DATA_HEIGHT_Z);\n\t\tclusterLightData.halfHeight = vec3(mantissaExponent2Float(areaHeightX), mantissaExponent2Float(areaHeightY), mantissaExponent2Float(areaHeightZ));\n\t#endif\n}\nvoid decodeClusterLightProjectionMatrixData(inout ClusterLightData clusterLightData) {\n\t\n\t#ifdef CLUSTER_TEXTURE_FLOAT\n\t\tvec4 m0 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_0);\n\t\tvec4 m1 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_1);\n\t\tvec4 m2 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_2);\n\t\tvec4 m3 = sampleLightTextureF(clusterLightData, CLUSTER_TEXTURE_F_PROJ_MAT_3);\n\t#else\n\t\tvec4 m00 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_00);\n\t\tvec4 m01 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_01);\n\t\tvec4 m02 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_02);\n\t\tvec4 m03 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_03);\n\t\tvec4 m0 = decodeClusterLowRange4Vec4(m00, m01, m02, m03);\n\t\tvec4 m10 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_10);\n\t\tvec4 m11 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_11);\n\t\tvec4 m12 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_12);\n\t\tvec4 m13 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_13);\n\t\tvec4 m1 = decodeClusterLowRange4Vec4(m10, m11, m12, m13);\n\t\tvec4 m20 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_20);\n\t\tvec4 m21 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_21);\n\t\tvec4 m22 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_22);\n\t\tvec4 m23 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_23);\n\t\tvec4 m2 = decodeClusterLowRange4Vec4(m20, m21, m22, m23);\n\t\tvec4 m30 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_30);\n\t\tvec4 m31 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_31);\n\t\tvec4 m32 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_32);\n\t\tvec4 m33 = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_PROJ_MAT_33);\n\t\tvec4 m3 = vec4(mantissaExponent2Float(m30), mantissaExponent2Float(m31), mantissaExponent2Float(m32), mantissaExponent2Float(m33));\n\t#endif\n\t\n\tlightProjectionMatrix = mat4(m0, m1, m2, m3);\n}\nvoid decodeClusterLightShadowData(inout ClusterLightData clusterLightData) {\n\t\n\tvec4 biases = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_SHADOW_BIAS);\n\tclusterLightData.shadowBias = bytes2floatRange2(biases.xy, -1.0, 20.0),\n\tclusterLightData.shadowNormalBias = bytes2float2(biases.zw);\n}\nvoid decodeClusterLightCookieData(inout ClusterLightData clusterLightData) {\n\tvec4 cookieA = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_A);\n\tclusterLightData.cookieIntensity = cookieA.x;\n\tclusterLightData.cookieRgb = cookieA.y;\n\tclusterLightData.cookieChannelMask = sampleLightsTexture8(clusterLightData, CLUSTER_TEXTURE_8_COOKIE_B);\n}\nvoid evaluateLight(\n\tClusterLightData light, \n\tvec3 worldNormal, \n\tvec3 viewDir, \n\tvec3 reflectionDir,\n#if defined(LIT_CLEARCOAT)\n\tvec3 clearcoatReflectionDir,\n#endif\n\tfloat gloss, \n\tvec3 specularity, \n\tvec3 geometricNormal, \n\tmat3 tbn, \n#if defined(LIT_IRIDESCENCE)\n\tvec3 iridescenceFresnel,\n#endif\n\tvec3 clearcoat_worldNormal,\n\tfloat clearcoat_gloss,\n\tfloat sheen_gloss,\n\tfloat iridescence_intensity\n) {\n\tvec3 cookieAttenuation = vec3(1.0);\n\tfloat diffuseAttenuation = 1.0;\n\tfloat falloffAttenuation = 1.0;\n\tgetLightDirPoint(light.position);\n\t#ifdef CLUSTER_AREALIGHTS\n\tif (isClusteredLightArea(light)) {\n\t\tdecodeClusterLightAreaData(light);\n\t\tif (isClusteredLightRect(light)) {\n\t\t\tcalcRectLightValues(light.position, light.halfWidth, light.halfHeight);\n\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\tcalcDiskLightValues(light.position, light.halfWidth, light.halfHeight);\n\t\t} else {\n\t\t\tcalcSphereLightValues(light.position, light.halfWidth, light.halfHeight);\n\t\t}\n\t\tfalloffAttenuation = getFalloffWindow(light.range, dLightDirW);\n\t} else\n\t#endif\n\t{\n\t\tif (isClusteredLightFalloffLinear(light))\n\t\t\tfalloffAttenuation = getFalloffLinear(light.range, dLightDirW);\n\t\telse\n\t\t\tfalloffAttenuation = getFalloffInvSquared(light.range, dLightDirW);\n\t}\n\tif (falloffAttenuation > 0.00001) {\n\t\t#ifdef CLUSTER_AREALIGHTS\n\t\tif (isClusteredLightArea(light)) {\n\t\t\tif (isClusteredLightRect(light)) {\n\t\t\t\tdiffuseAttenuation = getRectLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;\n\t\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\t\tdiffuseAttenuation = getDiskLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;\n\t\t\t} else {\n\t\t\t\tdiffuseAttenuation = getSphereLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW) * 16.0;\n\t\t\t}\n\t\t} else\n\t\t#endif\n\t\t{\n\t\t\tfalloffAttenuation *= getLightDiffuse(worldNormal, viewDir, dLightDirW, dLightDirNormW); \n\t\t}\n\t\tif (isClusteredLightSpot(light)) {\n\t\t\tdecodeClusterLightSpot(light);\n\t\t\tfalloffAttenuation *= getSpotEffect(light.direction, light.innerConeAngleCos, light.outerConeAngleCos, dLightDirNormW);\n\t\t}\n\t\t#if defined(CLUSTER_COOKIES_OR_SHADOWS)\n\t\tif (falloffAttenuation > 0.00001) {\n\t\t\tif (isClusteredLightCastShadow(light) || isClusteredLightCookie(light)) {\n\t\t\t\tif (isClusteredLightSpot(light)) {\n\t\t\t\t\tdecodeClusterLightProjectionMatrixData(light);\n\t\t\t\t} else {\n\t\t\t\t\tdecodeClusterLightOmniAtlasViewport(light);\n\t\t\t\t}\n\t\t\t\tfloat shadowTextureResolution = shadowAtlasParams.x;\n\t\t\t\tfloat shadowEdgePixels = shadowAtlasParams.y;\n\t\t\t\t#ifdef CLUSTER_COOKIES\n\t\t\t\tif (isClusteredLightCookie(light)) {\n\t\t\t\t\tdecodeClusterLightCookieData(light);\n\t\t\t\t\tif (isClusteredLightSpot(light)) {\n\t\t\t\t\t\tcookieAttenuation = getCookie2DClustered(TEXTURE_PASS(cookieAtlasTexture), lightProjectionMatrix, vPositionW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcookieAttenuation = getCookieCubeClustered(TEXTURE_PASS(cookieAtlasTexture), dLightDirW, light.cookieIntensity, isClusteredLightCookieRgb(light), light.cookieChannelMask, shadowTextureResolution, shadowEdgePixels, light.omniAtlasViewport);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t\t#ifdef CLUSTER_SHADOWS\n\t\t\t\tif (isClusteredLightCastShadow(light)) {\n\t\t\t\t\tdecodeClusterLightShadowData(light);\n\t\t\t\t\tvec4 shadowParams = vec4(shadowTextureResolution, light.shadowNormalBias, light.shadowBias, 1.0 / light.range);\n\t\t\t\t\tif (isClusteredLightSpot(light)) {\n\t\t\t\t\t\tgetShadowCoordPerspZbufferNormalOffset(lightProjectionMatrix, shadowParams, geometricNormal);\n\t\t\t\t\t\t\n\t\t\t\t\t\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\t\t\t\t\t\t\tfloat shadow = getShadowSpotClusteredPCF1(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF3)\n\t\t\t\t\t\t\tfloat shadow = getShadowSpotClusteredPCF3(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF5)\n\t\t\t\t\t\t\tfloat shadow = getShadowSpotClusteredPCF5(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCSS)\n\t\t\t\t\t\t\tfloat shadow = getShadowSpotClusteredPCSS(SHADOWMAP_PASS(shadowAtlasTexture), dShadowCoord, shadowParams);\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\tfalloffAttenuation *= mix(1.0, shadow, light.shadowIntensity);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvec3 dir = normalOffsetPointShadow(shadowParams, dLightPosW, dLightDirW, dLightDirNormW, geometricNormal);\n\t\t\t\t\t\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\t\t\t\t\t\t\tfloat shadow = getShadowOmniClusteredPCF1(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF3)\n\t\t\t\t\t\t\tfloat shadow = getShadowOmniClusteredPCF3(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);\n\t\t\t\t\t\t#elif defined(CLUSTER_SHADOW_TYPE_PCF5)\n\t\t\t\t\t\t\tfloat shadow = getShadowOmniClusteredPCF5(SHADOWMAP_PASS(shadowAtlasTexture), shadowParams, light.omniAtlasViewport, shadowEdgePixels, dir);\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\tfalloffAttenuation *= mix(1.0, shadow, light.shadowIntensity);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t#endif\n\t\t\t}\n\t\t}\n\t\t#endif\n\t\t#ifdef CLUSTER_AREALIGHTS\n\t\tif (isClusteredLightArea(light)) {\n\t\t\t{\n\t\t\t\tvec3 areaDiffuse = (diffuseAttenuation * falloffAttenuation) * light.color * cookieAttenuation;\n\t\t\t\t#if defined(LIT_SPECULAR)\n\t\t\t\t\t#if defined(LIT_CONSERVE_ENERGY)\n\t\t\t\t\t\tareaDiffuse = mix(areaDiffuse, vec3(0), dLTCSpecFres);\n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t\tdDiffuseLight += areaDiffuse;\n\t\t\t}\n\t\t\t#ifdef LIT_SPECULAR\n\t\t\t\tfloat areaLightSpecular;\n\t\t\t\tif (isClusteredLightRect(light)) {\n\t\t\t\t\tareaLightSpecular = getRectLightSpecular(worldNormal, viewDir);\n\t\t\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\t\t\tareaLightSpecular = getDiskLightSpecular(worldNormal, viewDir);\n\t\t\t\t} else {\n\t\t\t\t\tareaLightSpecular = getSphereLightSpecular(worldNormal, viewDir);\n\t\t\t\t}\n\t\t\t\tdSpecularLight += dLTCSpecFres * areaLightSpecular * falloffAttenuation * light.color * cookieAttenuation;\n\t\t\t\t#ifdef LIT_CLEARCOAT\n\t\t\t\t\tfloat areaLightSpecularCC;\n\t\t\t\t\tif (isClusteredLightRect(light)) {\n\t\t\t\t\t\tareaLightSpecularCC = getRectLightSpecular(clearcoat_worldNormal, viewDir);\n\t\t\t\t\t} else if (isClusteredLightDisk(light)) {\n\t\t\t\t\t\tareaLightSpecularCC = getDiskLightSpecular(clearcoat_worldNormal, viewDir);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tareaLightSpecularCC = getSphereLightSpecular(clearcoat_worldNormal, viewDir);\n\t\t\t\t\t}\n\t\t\t\t\tccSpecularLight += ccLTCSpecFres * areaLightSpecularCC * falloffAttenuation * light.color  * cookieAttenuation;\n\t\t\t\t#endif\n\t\t\t#endif\n\t\t} else\n\t\t#endif\n\t\t{\n\t\t\t{\n\t\t\t\tvec3 punctualDiffuse = falloffAttenuation * light.color * cookieAttenuation;\n\t\t\t\t#if defined(CLUSTER_AREALIGHTS)\n\t\t\t\t#if defined(LIT_SPECULAR)\n\t\t\t\t#if defined(LIT_CONSERVE_ENERGY)\n\t\t\t\t\tpunctualDiffuse = mix(punctualDiffuse, vec3(0), specularity);\n\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t\tdDiffuseLight += punctualDiffuse;\n\t\t\t}\n\t \n\t\t\t#ifdef LIT_SPECULAR\n\t\t\t\tvec3 halfDir = normalize(-dLightDirNormW + viewDir);\n\t\t\t\t\n\t\t\t\t#ifdef LIT_SPECULAR_FRESNEL\n\t\t\t\t\tdSpecularLight += \n\t\t\t\t\t\tgetLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dLightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * \n\t\t\t\t\t\tgetFresnel(\n\t\t\t\t\t\t\tdot(viewDir, halfDir), \n\t\t\t\t\t\t\tgloss, \n\t\t\t\t\t\t\tspecularity\n\t\t\t\t\t\t#if defined(LIT_IRIDESCENCE)\n\t\t\t\t\t\t\t, iridescenceFresnel,\n\t\t\t\t\t\t\tiridescence_intensity\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t);\n\t\t\t\t#else\n\t\t\t\t\tdSpecularLight += getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dLightDirNormW, gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * specularity;\n\t\t\t\t#endif\n\t\t\t\t#ifdef LIT_CLEARCOAT\n\t\t\t\t\t#ifdef LIT_SPECULAR_FRESNEL\n\t\t\t\t\t\tccSpecularLight += getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, dLightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation * getFresnelCC(dot(viewDir, halfDir));\n\t\t\t\t\t#else\n\t\t\t\t\t\tccSpecularLight += getLightSpecular(halfDir, clearcoatReflectionDir, clearcoat_worldNormal, viewDir, dLightDirNormW, clearcoat_gloss, tbn) * falloffAttenuation * light.color * cookieAttenuation; \n\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t\t\t#ifdef LIT_SHEEN\n\t\t\t\t\tsSpecularLight += getLightSpecularSheen(halfDir, worldNormal, viewDir, dLightDirNormW, sheen_gloss) * falloffAttenuation * light.color * cookieAttenuation;\n\t\t\t\t#endif\n\t\t\t#endif\n\t\t}\n\t}\n\tdAtten = falloffAttenuation;\n\tdAttenD = diffuseAttenuation;\n\tdAtten3 = cookieAttenuation;\n}\nvoid evaluateClusterLight(\n\tfloat lightIndex, \n\tvec3 worldNormal, \n\tvec3 viewDir, \n\tvec3 reflectionDir, \n#if defined(LIT_CLEARCOAT)\n\tvec3 clearcoatReflectionDir,\n#endif\n\tfloat gloss, \n\tvec3 specularity, \n\tvec3 geometricNormal, \n\tmat3 tbn, \n#if defined(LIT_IRIDESCENCE)\n\tvec3 iridescenceFresnel,\n#endif\n\tvec3 clearcoat_worldNormal,\n\tfloat clearcoat_gloss,\n\tfloat sheen_gloss,\n\tfloat iridescence_intensity\n) {\n\tClusterLightData clusterLightData;\n\tdecodeClusterLightCore(clusterLightData, lightIndex);\n\tif (acceptLightMask(clusterLightData))\n\t\tevaluateLight(\n\t\t\tclusterLightData, \n\t\t\tworldNormal, \n\t\t\tviewDir, \n\t\t\treflectionDir, \n#if defined(LIT_CLEARCOAT)\n\t\t\tclearcoatReflectionDir, \n#endif\n\t\t\tgloss, \n\t\t\tspecularity, \n\t\t\tgeometricNormal, \n\t\t\ttbn, \n#if defined(LIT_IRIDESCENCE)\n\t\t\tiridescenceFresnel,\n#endif\n\t\t\tclearcoat_worldNormal,\n\t\t\tclearcoat_gloss,\n\t\t\tsheen_gloss,\n\t\t\tiridescence_intensity\n\t\t);\n}\nvoid addClusteredLights(\n\tvec3 worldNormal, \n\tvec3 viewDir, \n\tvec3 reflectionDir, \n#if defined(LIT_CLEARCOAT)\n\tvec3 clearcoatReflectionDir,\n#endif\n\tfloat gloss, \n\tvec3 specularity, \n\tvec3 geometricNormal, \n\tmat3 tbn, \n#if defined(LIT_IRIDESCENCE)\n\tvec3 iridescenceFresnel,\n#endif\n\tvec3 clearcoat_worldNormal,\n\tfloat clearcoat_gloss,\n\tfloat sheen_gloss,\n\tfloat iridescence_intensity\n) {\n\tif (clusterSkip > 0.5)\n\t\treturn;\n\tvec3 cellCoords = floor((vPositionW - clusterBoundsMin) * clusterCellsCountByBoundsSize);\n\tif (!(any(lessThan(cellCoords, vec3(0.0))) || any(greaterThanEqual(cellCoords, clusterCellsMax)))) {\n\t\tfloat cellIndex = dot(clusterCellsDot, cellCoords);\n\t\tfloat clusterV = floor(cellIndex * clusterTextureSize.y);\n\t\tfloat clusterU = cellIndex - (clusterV * clusterTextureSize.x);\n\t\t#ifdef GL2\n\t\t\tfor (int lightCellIndex = 0; lightCellIndex < clusterMaxCells; lightCellIndex++) {\n\t\t\t\tfloat lightIndex = texelFetch(clusterWorldTexture, ivec2(int(clusterU) + lightCellIndex, clusterV), 0).x;\n\t\t\t\tif (lightIndex <= 0.0)\n\t\t\t\t\t\treturn;\n\t\t\t\tevaluateClusterLight(\n\t\t\t\t\tlightIndex * 255.0, \n\t\t\t\t\tworldNormal, \n\t\t\t\t\tviewDir, \n\t\t\t\t\treflectionDir,\n#if defined(LIT_CLEARCOAT)\n\t\t\t\t\tclearcoatReflectionDir,\n#endif\n\t\t\t\t\tgloss, \n\t\t\t\t\tspecularity, \n\t\t\t\t\tgeometricNormal, \n\t\t\t\t\ttbn, \n#if defined(LIT_IRIDESCENCE)\n\t\t\t\t\tiridescenceFresnel,\n#endif\n\t\t\t\t\tclearcoat_worldNormal,\n\t\t\t\t\tclearcoat_gloss,\n\t\t\t\t\tsheen_gloss,\n\t\t\t\t\tiridescence_intensity\n\t\t\t\t); \n\t\t\t}\n\t\t#else\n\t\t\tclusterV = (clusterV + 0.5) * clusterTextureSize.z;\n\t\t\tconst float maxLightCells = 256.0;\n\t\t\tfor (float lightCellIndex = 0.5; lightCellIndex < maxLightCells; lightCellIndex++) {\n\t\t\t\tfloat lightIndex = texture2DLodEXT(clusterWorldTexture, vec2(clusterTextureSize.y * (clusterU + lightCellIndex), clusterV), 0.0).x;\n\t\t\t\tif (lightIndex <= 0.0)\n\t\t\t\t\treturn;\n\t\t\t\t\n\t\t\t\tevaluateClusterLight(\n\t\t\t\t\tlightIndex * 255.0, \n\t\t\t\t\tworldNormal, \n\t\t\t\t\tviewDir, \n\t\t\t\t\treflectionDir,\n#if defined(LIT_CLEARCOAT)\n\t\t\t\t\tclearcoatReflectionDir,\n#endif\n\t\t\t\t\tgloss, \n\t\t\t\t\tspecularity, \n\t\t\t\t\tgeometricNormal, \n\t\t\t\t\ttbn, \n#if defined(LIT_IRIDESCENCE)\n\t\t\t\t\tiridescenceFresnel,\n#endif\n\t\t\t\t\tclearcoat_worldNormal,\n\t\t\t\t\tclearcoat_gloss,\n\t\t\t\t\tsheen_gloss,\n\t\t\t\t\tiridescence_intensity\n\t\t\t\t); \n\t\t\t\tif (lightCellIndex >= clusterMaxCells) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t#endif\n\t}\n}\n`;\n\nexport { clusteredLightPS as default };\n","var clusteredLightCookiesPS = `\nvec3 _getCookieClustered(TEXTURE_ACCEPT(tex), vec2 uv, float intensity, bool isRgb, vec4 cookieChannel) {\n\tvec4 pixel = mix(vec4(1.0), texture2DLodEXT(tex, uv, 0.0), intensity);\n\treturn isRgb == true ? pixel.rgb : vec3(dot(pixel, cookieChannel));\n}\nvec3 getCookie2DClustered(TEXTURE_ACCEPT(tex), mat4 transform, vec3 worldPosition, float intensity, bool isRgb, vec4 cookieChannel) {\n\tvec4 projPos = transform * vec4(worldPosition, 1.0);\n\treturn _getCookieClustered(TEXTURE_PASS(tex), projPos.xy / projPos.w, intensity, isRgb, cookieChannel);\n}\nvec3 getCookieCubeClustered(TEXTURE_ACCEPT(tex), vec3 dir, float intensity, bool isRgb, vec4 cookieChannel, float shadowTextureResolution, float shadowEdgePixels, vec3 omniAtlasViewport) {\n\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, dir);\n\treturn _getCookieClustered(TEXTURE_PASS(tex), uv, intensity, isRgb, cookieChannel);\n}\n`;\n\nexport { clusteredLightCookiesPS as default };\n","var clusteredLightShadowsPS = `\nvoid _getShadowCoordPerspZbuffer(mat4 shadowMatrix, vec4 shadowParams, vec3 wPos) {\n\tvec4 projPos = shadowMatrix * vec4(wPos, 1.0);\n\tprojPos.xyz /= projPos.w;\n\tdShadowCoord = projPos.xyz;\n}\nvoid getShadowCoordPerspZbufferNormalOffset(mat4 shadowMatrix, vec4 shadowParams, vec3 normal) {\n\tvec3 wPos = vPositionW + normal * shadowParams.y;\n\t_getShadowCoordPerspZbuffer(shadowMatrix, shadowParams, wPos);\n}\nvec3 normalOffsetPointShadow(vec4 shadowParams, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {\n\tfloat distScale = length(lightDir);\n\tvec3 wPos = vPositionW + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;\n\tvec3 dir = wPos - lightPos;\n\treturn dir;\n}\n#ifdef GL2\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\tfloat getShadowOmniClusteredPCF1(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n\t\tfloat shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n\t\treturn textureShadow(shadowMap, vec3(uv, shadowZ));\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\tfloat getShadowOmniClusteredPCF3(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n\t\tfloat shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n\t\tvec3 shadowCoord = vec3(uv, shadowZ);\n\t\treturn getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowOmniClusteredPCF5(SHADOWMAP_ACCEPT(shadowMap), vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n\t\tfloat shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n\t\tvec3 shadowCoord = vec3(uv, shadowZ);\n\t\treturn getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);\n\t}\n\t#endif\n#else\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\tfloat getShadowOmniClusteredPCF1(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n\t\tfloat depth = unpackFloat(textureShadow(shadowMap, uv));\n\t\tfloat shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n\t\treturn depth > shadowZ ? 1.0 : 0.0;\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\tfloat getShadowOmniClusteredPCF3(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n\t\tfloat shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n\t\tvec3 shadowCoord = vec3(uv, shadowZ);\n\t\treturn getShadowPCF3x3(shadowMap, shadowCoord, shadowParams);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowOmniClusteredPCF5(sampler2D shadowMap, vec4 shadowParams, vec3 omniAtlasViewport, float shadowEdgePixels, vec3 lightDir) {\n\t\tfloat shadowTextureResolution = shadowParams.x;\n\t\tvec2 uv = getCubemapAtlasCoordinates(omniAtlasViewport, shadowEdgePixels, shadowTextureResolution, lightDir);\n\t\tfloat shadowZ = length(lightDir) * shadowParams.w + shadowParams.z;\n\t\tvec3 shadowCoord = vec3(uv, shadowZ);\n\t\treturn getShadowPCF3x3(shadowMap, shadowCoord, shadowParams);\n\t}\n\t#endif\n#endif\n#ifdef GL2\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\tfloat getShadowSpotClusteredPCF1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\t\treturn textureShadow(shadowMap, shadowCoord);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\tfloat getShadowSpotClusteredPCF3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\t\treturn getShadowSpotPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowSpotClusteredPCF5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\t\treturn getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams);\n\t}\n\t#endif\n#else\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF1)\n\tfloat getShadowSpotClusteredPCF1(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {\n\t\tfloat depth = unpackFloat(textureShadow(shadowMap, shadowCoord.xy));\n\t\treturn depth > shadowCoord.z ? 1.0 : 0.0;\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF3)\n\tfloat getShadowSpotClusteredPCF3(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {\n\t\treturn getShadowSpotPCF3x3(shadowMap, shadowCoord, shadowParams);\n\t}\n\t#endif\n\t#if defined(CLUSTER_SHADOW_TYPE_PCF5)\n\tfloat getShadowSpotClusteredPCF5(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {\n\t\treturn getShadowSpotPCF3x3(shadowMap, shadowCoord, shadowParams);\n\t}\n\t#endif\n#endif\n`;\n\nexport { clusteredLightShadowsPS as default };\n","var clusteredLightUtilsPS = `\nvec2 getCubemapFaceCoordinates(const vec3 dir, out float faceIndex, out vec2 tileOffset)\n{\n\tvec3 vAbs = abs(dir);\n\tfloat ma;\n\tvec2 uv;\n\tif (vAbs.z >= vAbs.x && vAbs.z >= vAbs.y) {\n\t\tfaceIndex = dir.z < 0.0 ? 5.0 : 4.0;\n\t\tma = 0.5 / vAbs.z;\n\t\tuv = vec2(dir.z < 0.0 ? -dir.x : dir.x, -dir.y);\n\t\ttileOffset.x = 2.0;\n\t\ttileOffset.y = dir.z < 0.0 ? 1.0 : 0.0;\n\t} else if(vAbs.y >= vAbs.x) {\n\t\tfaceIndex = dir.y < 0.0 ? 3.0 : 2.0;\n\t\tma = 0.5 / vAbs.y;\n\t\tuv = vec2(dir.x, dir.y < 0.0 ? -dir.z : dir.z);\n\t\ttileOffset.x = 1.0;\n\t\ttileOffset.y = dir.y < 0.0 ? 1.0 : 0.0;\n\t} else {\n\t\tfaceIndex = dir.x < 0.0 ? 1.0 : 0.0;\n\t\tma = 0.5 / vAbs.x;\n\t\tuv = vec2(dir.x < 0.0 ? dir.z : -dir.z, -dir.y);\n\t\ttileOffset.x = 0.0;\n\t\ttileOffset.y = dir.x < 0.0 ? 1.0 : 0.0;\n\t}\n\treturn uv * ma + 0.5;\n}\nvec2 getCubemapAtlasCoordinates(const vec3 omniAtlasViewport, float shadowEdgePixels, float shadowTextureResolution, const vec3 dir) {\n\tfloat faceIndex;\n\tvec2 tileOffset;\n\tvec2 uv = getCubemapFaceCoordinates(dir, faceIndex, tileOffset);\n\tfloat atlasFaceSize = omniAtlasViewport.z;\n\tfloat tileSize = shadowTextureResolution * atlasFaceSize;\n\tfloat offset = shadowEdgePixels / tileSize;\n\tuv = uv * vec2(1.0 - offset * 2.0) + vec2(offset * 1.0);\n\tuv *= atlasFaceSize;\n\tuv += tileOffset * atlasFaceSize;\n\tuv += omniAtlasViewport.xy;\n\treturn uv;\n}\n`;\n\nexport { clusteredLightUtilsPS as default };\n","var combinePS = `\nvec3 combineColor(vec3 albedo, vec3 sheenSpecularity, float clearcoatSpecularity) {\n\tvec3 ret = vec3(0);\n#ifdef LIT_OLD_AMBIENT\n\tret += (dDiffuseLight - light_globalAmbient) * albedo + material_ambient * light_globalAmbient;\n#else\n\tret += albedo * dDiffuseLight;\n#endif\n#ifdef LIT_SPECULAR\n\tret += dSpecularLight;\n#endif\n#ifdef LIT_REFLECTIONS\n\tret += dReflection.rgb * dReflection.a;\n#endif\n#ifdef LIT_SHEEN\n\tfloat sheenScaling = 1.0 - max(max(sheenSpecularity.r, sheenSpecularity.g), sheenSpecularity.b) * 0.157;\n\tret = ret * sheenScaling + (sSpecularLight + sReflection.rgb) * sheenSpecularity;\n#endif\n#ifdef LIT_CLEARCOAT\n\tfloat clearCoatScaling = 1.0 - ccFresnel * clearcoatSpecularity;\n\tret = ret * clearCoatScaling + (ccSpecularLight + ccReflection.rgb) * clearcoatSpecularity;\n#endif\n\treturn ret;\n}\n`;\n\nexport { combinePS as default };\n","var cookiePS = `\nvec4 getCookie2D(sampler2D tex, mat4 transform, float intensity) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DClip(sampler2D tex, mat4 transform, float intensity) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n\treturn mix(vec4(1.0), texture2D(tex, projPos.xy), intensity);\n}\nvec4 getCookie2DXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tprojPos.xy += cookieOffset;\n\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookie2DClipXform(sampler2D tex, mat4 transform, float intensity, vec4 cookieMatrix, vec2 cookieOffset) {\n\tvec4 projPos = transform * vec4(vPositionW, 1.0);\n\tprojPos.xy /= projPos.w;\n\tprojPos.xy += cookieOffset;\n\tif (projPos.x < 0.0 || projPos.x > 1.0 || projPos.y < 0.0 || projPos.y > 1.0 || projPos.z < 0.0) return vec4(0.0);\n\tvec2 uv = mat2(cookieMatrix) * (projPos.xy-vec2(0.5)) + vec2(0.5);\n\treturn mix(vec4(1.0), texture2D(tex, uv), intensity);\n}\nvec4 getCookieCube(samplerCube tex, mat4 transform, float intensity) {\n\treturn mix(vec4(1.0), textureCube(tex, dLightDirNormW * mat3(transform)), intensity);\n}\n`;\n\nexport { cookiePS as default };\n","var cubeMapProjectBoxPS = `\nuniform vec3 envBoxMin;\nuniform vec3 envBoxMax;\nvec3 cubeMapProject(vec3 nrdir) {\n\tnrdir = cubeMapRotate(nrdir);\n\tvec3 rbmax = (envBoxMax - vPositionW) / nrdir;\n\tvec3 rbmin = (envBoxMin - vPositionW) / nrdir;\n\tvec3 rbminmax;\n\trbminmax.x = nrdir.x>0.0? rbmax.x : rbmin.x;\n\trbminmax.y = nrdir.y>0.0? rbmax.y : rbmin.y;\n\trbminmax.z = nrdir.z>0.0? rbmax.z : rbmin.z;\n\tfloat fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);\n\tvec3 posonbox = vPositionW + nrdir * fa;\n\tvec3 envBoxPos = (envBoxMin + envBoxMax) * 0.5;\n\treturn normalize(posonbox - envBoxPos);\n}\n`;\n\nexport { cubeMapProjectBoxPS as default };\n","var cubeMapProjectNonePS = `\nvec3 cubeMapProject(vec3 dir) {\n\treturn cubeMapRotate(dir);\n}\n`;\n\nexport { cubeMapProjectNonePS as default };\n","var cubeMapRotatePS = `\n#ifdef CUBEMAP_ROTATION\nuniform mat3 cubeMapRotationMatrix;\n#endif\nvec3 cubeMapRotate(vec3 refDir) {\n#ifdef CUBEMAP_ROTATION\n\treturn refDir * cubeMapRotationMatrix;\n#else\n\treturn refDir;\n#endif\n}\n`;\n\nexport { cubeMapRotatePS as default };\n","var debugOutputPS = `\n#ifdef DEBUG_ALBEDO_PASS\ngl_FragColor = vec4(gammaCorrectOutput(dAlbedo), 1.0);\n#endif\n#ifdef DEBUG_UV0_PASS\ngl_FragColor = vec4(litArgs_albedo , 1.0);\n#endif\n#ifdef DEBUG_WORLD_NORMAL_PASS\ngl_FragColor = vec4(litArgs_worldNormal * 0.5 + 0.5, 1.0);\n#endif\n#ifdef DEBUG_OPACITY_PASS\ngl_FragColor = vec4(vec3(litArgs_opacity) , 1.0);\n#endif\n#ifdef DEBUG_SPECULARITY_PASS\ngl_FragColor = vec4(litArgs_specularity, 1.0);\n#endif\n#ifdef DEBUG_GLOSS_PASS\ngl_FragColor = vec4(vec3(litArgs_gloss) , 1.0);\n#endif\n#ifdef DEBUG_METALNESS_PASS\ngl_FragColor = vec4(vec3(litArgs_metalness) , 1.0);\n#endif\n#ifdef DEBUG_AO_PASS\ngl_FragColor = vec4(vec3(litArgs_ao) , 1.0);\n#endif\n#ifdef DEBUG_EMISSION_PASS\ngl_FragColor = vec4(gammaCorrectOutput(litArgs_emission), 1.0);\n#endif\n`;\n\nexport { debugOutputPS as default };\n","var debugProcessFrontendPS = `\n#ifdef DEBUG_LIGHTING_PASS\nlitArgs_albedo = vec3(0.5);\n#endif\n#ifdef DEBUG_UV0_PASS\n#ifdef VARYING_VUV0\nlitArgs_albedo = vec3(vUv0, 0);\n#else\nlitArgs_albedo = vec3(0);\n#endif\n#endif\n`;\n\nexport { debugProcessFrontendPS as default };\n","var endPS = `\n\tgl_FragColor.rgb = combineColor(litArgs_albedo, litArgs_sheen_specularity, litArgs_clearcoat_specularity);\n\tgl_FragColor.rgb += litArgs_emission;\n\tgl_FragColor.rgb = addFog(gl_FragColor.rgb);\n\t#ifndef HDR\n\tgl_FragColor.rgb = toneMap(gl_FragColor.rgb);\n\tgl_FragColor.rgb = gammaCorrectOutput(gl_FragColor.rgb);\n\t#endif\n`;\n\nexport { endPS as default };\n","var extensionPS = `\n`;\n\nexport { extensionPS as default };\n","var falloffInvSquaredPS = `\nfloat getFalloffWindow(float lightRadius, vec3 lightDir) {\n\tfloat sqrDist = dot(lightDir, lightDir);\n\tfloat invRadius = 1.0 / lightRadius;\n\treturn square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n}\nfloat getFalloffInvSquared(float lightRadius, vec3 lightDir) {\n\tfloat sqrDist = dot(lightDir, lightDir);\n\tfloat falloff = 1.0 / (sqrDist + 1.0);\n\tfloat invRadius = 1.0 / lightRadius;\n\tfalloff *= 16.0;\n\tfalloff *= square( saturate( 1.0 - square( sqrDist * square(invRadius) ) ) );\n\treturn falloff;\n}\n`;\n\nexport { falloffInvSquaredPS as default };\n","var falloffLinearPS = `\nfloat getFalloffLinear(float lightRadius, vec3 lightDir) {\n\tfloat d = length(lightDir);\n\treturn max(((lightRadius - d) / lightRadius), 0.0);\n}\n`;\n\nexport { falloffLinearPS as default };\n","var floatUnpackingPS = `\nfloat bytes2float2(vec2 data) {\n\treturn dot(data, vec2(1.0, 1.0 / 255.0));\n}\nfloat bytes2float3(vec3 data) {\n\treturn dot(data, vec3(1.0, 1.0 / 255.0, 1.0 / 65025.0));\n}\nfloat bytes2float4(vec4 data) {\n\treturn dot(data, vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));\n}\nfloat bytes2floatRange2(vec2 data, float min, float max) {\n\treturn mix(min, max, bytes2float2(data));\n}\nfloat bytes2floatRange3(vec3 data, float min, float max) {\n\treturn mix(min, max, bytes2float3(data));\n}\nfloat bytes2floatRange4(vec4 data, float min, float max) {\n\treturn mix(min, max, bytes2float4(data));\n}\nfloat mantissaExponent2Float(vec4 pack)\n{\n\tfloat value = bytes2floatRange3(pack.xyz, -1.0, 1.0);\n\tfloat exponent = floor(pack.w * 255.0 - 127.0);\n\treturn value * exp2(exponent);\n}\n`;\n\nexport { floatUnpackingPS as default };\n","var fogExpPS = `\nuniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = exp(-depth * fog_density);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n`;\n\nexport { fogExpPS as default };\n","var fogExp2PS = `\nuniform vec3 fog_color;\nuniform float fog_density;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = exp(-depth * depth * fog_density * fog_density);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n`;\n\nexport { fogExp2PS as default };\n","var fogLinearPS = `\nuniform vec3 fog_color;\nuniform float fog_start;\nuniform float fog_end;\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\tfloat fogFactor = (fog_end - depth) / (fog_end - fog_start);\n\tfogFactor = clamp(fogFactor, 0.0, 1.0);\n\treturn mix(fog_color * dBlendModeFogFactor, color, fogFactor);\n}\n`;\n\nexport { fogLinearPS as default };\n","var fogNonePS = `\nfloat dBlendModeFogFactor = 1.0;\nvec3 addFog(vec3 color) {\n\treturn color;\n}\n`;\n\nexport { fogNonePS as default };\n","var fresnelSchlickPS = `\nvec3 getFresnel(\n\t\tfloat cosTheta, \n\t\tfloat gloss, \n\t\tvec3 specularity\n#if defined(LIT_IRIDESCENCE)\n\t\t, vec3 iridescenceFresnel, \n\t\tfloat iridescenceIntensity\n#endif\n\t) {\n\tfloat fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);\n\tfloat glossSq = gloss * gloss;\n\tvec3 ret = specularity + (max(vec3(glossSq), specularity) - specularity) * fresnel;\n#if defined(LIT_IRIDESCENCE)\n\treturn mix(ret, iridescenceFresnel, iridescenceIntensity);\n#else\n\treturn ret;\n#endif\t\n}\nfloat getFresnelCC(float cosTheta) {\n\tfloat fresnel = pow(1.0 - max(cosTheta, 0.0), 5.0);\n\treturn 0.04 + (1.0 - 0.04) * fresnel;\n}\n`;\n\nexport { fresnelSchlickPS as default };\n","var iridescenceDiffractionPS = `\nuniform float material_iridescenceRefractionIndex;\n#ifndef PI\n#define PI 3.14159265\n#endif\nfloat iridescence_iorToFresnel(float transmittedIor, float incidentIor) {\n\treturn pow((transmittedIor - incidentIor) / (transmittedIor + incidentIor), 2.0);\n}\nvec3 iridescence_iorToFresnel(vec3 transmittedIor, float incidentIor) {\n\treturn pow((transmittedIor - vec3(incidentIor)) / (transmittedIor + vec3(incidentIor)), vec3(2.0));\n}\nvec3 iridescence_fresnelToIor(vec3 f0) {\n\tvec3 sqrtF0 = sqrt(f0);\n\treturn (vec3(1.0) + sqrtF0) / (vec3(1.0) - sqrtF0);\n}\nvec3 iridescence_sensitivity(float opd, vec3 shift) {\n\tfloat phase = 2.0 * PI * opd * 1.0e-9;\n\tconst vec3 val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);\n\tconst vec3 pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);\n\tconst vec3 var = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);\n\tvec3 xyz = val * sqrt(2.0 * PI * var) * cos(pos * phase + shift) * exp(-pow(phase, 2.0) * var);\n\txyz.x += 9.7470e-14 * sqrt(2.0 * PI * 4.5282e+09) * cos(2.2399e+06 * phase + shift[0]) * exp(-4.5282e+09 * pow(phase, 2.0));\n\txyz /= vec3(1.0685e-07);\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t3.2404542, -0.9692660,  0.0556434,\n\t   -1.5371385,  1.8760108, -0.2040259,\n\t   -0.4985314,  0.0415560,  1.0572252\n\t);\n\treturn XYZ_TO_REC709 * xyz;\n}\nfloat iridescence_fresnel(float cosTheta, float f0) {\n\tfloat x = clamp(1.0 - cosTheta, 0.0, 1.0);\n\tfloat x2 = x * x;\n\tfloat x5 = x * x2 * x2;\n\treturn f0 + (1.0 - f0) * x5;\n} \nvec3 iridescence_fresnel(float cosTheta, vec3 f0) {\n\tfloat x = clamp(1.0 - cosTheta, 0.0, 1.0);\n\tfloat x2 = x * x;\n\tfloat x5 = x * x2 * x2; \n\treturn f0 + (vec3(1.0) - f0) * x5;\n}\nvec3 calcIridescence(float outsideIor, float cosTheta, vec3 base_f0, float iridescenceThickness) {\n\tfloat iridescenceIor = mix(outsideIor, material_iridescenceRefractionIndex, smoothstep(0.0, 0.03, iridescenceThickness));\n\tfloat sinTheta2Sq = pow(outsideIor / iridescenceIor, 2.0) * (1.0 - pow(cosTheta, 2.0));\n\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\tif (cosTheta2Sq < 0.0) {\n\t\treturn vec3(1.0);\n\t}\n\tfloat cosTheta2 = sqrt(cosTheta2Sq);\n\tfloat r0 = iridescence_iorToFresnel(iridescenceIor, outsideIor);\n\tfloat r12 = iridescence_fresnel(cosTheta, r0);\n\tfloat r21 = r12;\n\tfloat t121 = 1.0 - r12;\n\tfloat phi12 = iridescenceIor < outsideIor ? PI : 0.0;\n\tfloat phi21 = PI - phi12;\n\tvec3 baseIor = iridescence_fresnelToIor(base_f0 + vec3(0.0001));\n\tvec3 r1 = iridescence_iorToFresnel(baseIor, iridescenceIor);\n\tvec3 r23 = iridescence_fresnel(cosTheta2, r1);\n\tvec3 phi23 = vec3(0.0);\n\tif (baseIor[0] < iridescenceIor) phi23[0] = PI;\n\tif (baseIor[1] < iridescenceIor) phi23[1] = PI;\n\tif (baseIor[2] < iridescenceIor) phi23[2] = PI;\n\tfloat opd = 2.0 * iridescenceIor * iridescenceThickness * cosTheta2;\n\tvec3 phi = vec3(phi21) + phi23; \n\tvec3 r123Sq = clamp(r12 * r23, 1e-5, 0.9999);\n\tvec3 r123 = sqrt(r123Sq);\n\tvec3 rs = pow(t121, 2.0) * r23 / (1.0 - r123Sq);\n\tvec3 c0 = r12 + rs;\n\tvec3 i = c0;\n\tvec3 cm = rs - t121;\n\tfor (int m = 1; m <= 2; m++) {\n\t\tcm *= r123;\n\t\tvec3 sm = 2.0 * iridescence_sensitivity(float(m) * opd, float(m) * phi);\n\t\ti += cm * sm;\n\t}\n\treturn max(i, vec3(0.0));\n}\nvec3 getIridescence(float cosTheta, vec3 specularity, float iridescenceThickness) {\n\treturn calcIridescence(1.0, cosTheta, specularity, iridescenceThickness);\n}\n`;\n\nexport { iridescenceDiffractionPS as default };\n","var lightDiffuseLambertPS = `\nfloat getLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {\n\treturn max(dot(worldNormal, -lightDirNorm), 0.0);\n}\n`;\n\nexport { lightDiffuseLambertPS as default };\n","var lightDirPointPS = `\nvoid getLightDirPoint(vec3 lightPosW) {\n\tdLightDirW = vPositionW - lightPosW;\n\tdLightDirNormW = normalize(dLightDirW);\n\tdLightPosW = lightPosW;\n}\n`;\n\nexport { lightDirPointPS as default };\n","var lightSheenPS = `\nfloat sheenD(vec3 normal, vec3 h, float roughness) {\n\tfloat invR = 1.0 / (roughness * roughness);\n\tfloat cos2h = max(dot(normal, h), 0.0);\n\tcos2h *= cos2h;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\n\treturn (2.0 + invR) * pow(sin2h, invR * 0.5) / (2.0 * PI);\n}\nfloat sheenV(vec3 normal, vec3 viewDir, vec3 light) {\n\tfloat NoV = max(dot(normal, viewDir), 0.000001);\n\tfloat NoL = max(dot(normal, light), 0.000001);\n\treturn 1.0 / (4.0 * (NoL + NoV - NoL * NoV));\n}\nfloat getLightSpecularSheen(vec3 h, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float sheenGloss) {\n\tfloat D = sheenD(worldNormal, h, sheenGloss);\n\tfloat V = sheenV(worldNormal, viewDir, -lightDirNorm);\n\treturn D * V;\n}\n`;\n\nexport { lightSheenPS as default };\n","var lightSpecularAnisoGGXPS = `\nfloat calcLightSpecular(float gloss, vec3 worldNormal, vec3 viewDir, vec3 h, vec3 lightDirNorm, mat3 tbn) {\n\tfloat PI = 3.141592653589793;\n\tfloat roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);\n\tfloat anisotropy = material_anisotropy * roughness;\n \n\tfloat at = max((roughness + anisotropy), roughness / 4.0);\n\tfloat ab = max((roughness - anisotropy), roughness / 4.0);\n\tfloat NoH = dot(worldNormal, h);\n\tfloat ToH = dot(tbn[0], h);\n\tfloat BoH = dot(tbn[1], h);\n\tfloat a2 = at * ab;\n\tvec3 v = vec3(ab * ToH, at * BoH, a2 * NoH);\n\tfloat v2 = dot(v, v);\n\tfloat w2 = a2 / v2;\n\tfloat D = a2 * w2 * w2 * (1.0 / PI);\n\tfloat ToV = dot(tbn[0], viewDir);\n\tfloat BoV = dot(tbn[1], viewDir);\n\tfloat ToL = dot(tbn[0], -lightDirNorm);\n\tfloat BoL = dot(tbn[1], -lightDirNorm);\n\tfloat NoV = dot(worldNormal, viewDir);\n\tfloat NoL = dot(worldNormal, -lightDirNorm);\n\tfloat lambdaV = NoL * length(vec3(at * ToV, ab * BoV, NoV));\n\tfloat lambdaL = NoV * length(vec3(at * ToL, ab * BoL, NoL));\n\tfloat G = 0.5 / (lambdaV + lambdaL);\n\treturn D * G;\n}\nfloat getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {\n\treturn calcLightSpecular(gloss, worldNormal, viewDir, h, lightDirNorm, tbn);\n}\n`;\n\nexport { lightSpecularAnisoGGXPS as default };\n","var lightSpecularBlinnPS = `\nfloat calcLightSpecular(float gloss, vec3 worldNormal, vec3 h) {\n\tfloat nh = max( dot( h, worldNormal ), 0.0 );\n\tfloat specPow = exp2(gloss * 11.0);\n\tspecPow = max(specPow, 0.0001);\n\treturn pow(nh, specPow) * (specPow + 2.0) / 8.0;\n}\nfloat getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {\n\treturn calcLightSpecular(gloss, worldNormal, h);\n}\n`;\n\nexport { lightSpecularBlinnPS as default };\n","var lightSpecularPhongPS = `\nfloat calcLightSpecular(float gloss, vec3 reflDir, vec3 lightDirNorm) {\n\tfloat specPow = gloss;\n\treturn pow(max(dot(reflDir, -lightDirNorm), 0.0), specPow + 0.0001);\n}\nfloat getLightSpecular(vec3 h, vec3 reflDir, vec3 worldNormal, vec3 viewDir, vec3 lightDirNorm, float gloss, mat3 tbn) {\n\treturn calcLightSpecular(gloss, reflDir, lightDirNorm);\n}\n`;\n\nexport { lightSpecularPhongPS as default };\n","var lightmapAddPS = `\nvoid addLightMap(\n\tvec3 lightmap, \n\tvec3 dir, \n\tvec3 worldNormal, \n\tvec3 viewDir, \n\tvec3 reflectionDir, \n\tfloat gloss, \n\tvec3 specularity, \n\tvec3 vertexNormal, \n\tmat3 tbn\n#if defined(LIT_IRIDESCENCE)\n\tvec3 iridescenceFresnel, \n\tfloat iridescenceIntensity\n#endif\n) {\n\tdDiffuseLight += lightmap;\n}\n`;\n\nexport { lightmapAddPS as default };\n","var lightmapDirAddPS = `\nvoid addLightMap(\n\tvec3 lightmap, \n\tvec3 dir, \n\tvec3 worldNormal, \n\tvec3 viewDir, \n\tvec3 reflectionDir, \n\tfloat gloss, \n\tvec3 specularity, \n\tvec3 vertexNormal, \n\tmat3 tbn\n#if defined(LIT_IRIDESCENCE)\n\tvec3 iridescenceFresnel, \n\tfloat iridescenceIntensity\n#endif\n) {\n\tif (dot(dir, dir) < 0.0001) {\n\t\tdDiffuseLight += lightmap;\n\t} else {\n\t\tfloat vlight = saturate(dot(dir, -vertexNormal));\n\t\tfloat flight = saturate(dot(dir, -worldNormal));\n\t\tfloat nlight = (flight / max(vlight, 0.01)) * 0.5;\n\t\tdDiffuseLight += lightmap * nlight * 2.0;\n\t\tvec3 halfDir = normalize(-dir + viewDir);\n\t\tvec3 specularLight = lightmap * getLightSpecular(halfDir, reflectionDir, worldNormal, viewDir, dir, gloss, tbn);\n#ifdef LIT_SPECULAR_FRESNEL\n\t\tspecularLight *= \n\t\t\tgetFresnel(dot(viewDir, halfDir), \n\t\t\tgloss, \n\t\t\tspecularity\n\t\t#if defined(LIT_IRIDESCENCE)\n\t\t\t, iridescenceFresnel,\n\t\t\tiridescenceIntensity\n\t\t#endif\n\t\t\t);\n#endif\n\t\tdSpecularLight += specularLight;\n\t}\n}\n`;\n\nexport { lightmapDirAddPS as default };\n","var ltcPS = `\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nstruct Coords {\n\tvec3 coord0;\n\tvec3 coord1;\n\tvec3 coord2;\n\tvec3 coord3;\n};\nfloat LTC_EvaluateRect( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in Coords rectCoords) {\n\tvec3 v1 = rectCoords.coord1 - rectCoords.coord0;\n\tvec3 v2 = rectCoords.coord3 - rectCoords.coord0;\n\t\n\tvec3 lightNormal = cross( v1, v2 );\n\tfloat factor = sign(-dot( lightNormal, P - rectCoords.coord0 ));\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 =  factor * cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords.coord0 - P );\n\tcoords[ 1 ] = mat * ( rectCoords.coord1 - P );\n\tcoords[ 2 ] = mat * ( rectCoords.coord2 - P );\n\tcoords[ 3 ] = mat * ( rectCoords.coord3 - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn result;\n}\nCoords dLTCCoords;\nCoords getLTCLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n\tCoords coords;\n\tcoords.coord0 = lightPos + halfWidth - halfHeight;\n\tcoords.coord1 = lightPos - halfWidth - halfHeight;\n\tcoords.coord2 = lightPos - halfWidth + halfHeight;\n\tcoords.coord3 = lightPos + halfWidth + halfHeight;\n\treturn coords;\n}\nfloat dSphereRadius;\nCoords getSphereLightCoords(vec3 lightPos, vec3 halfWidth, vec3 halfHeight){\n\tdSphereRadius = max(length(halfWidth), length(halfHeight));\n\tvec3 f = reflect(normalize(lightPos - view_position), vNormalW);\n\tvec3 w = normalize(cross(f, halfHeight));\n\tvec3 h = normalize(cross(f, w));\n\treturn getLTCLightCoords(lightPos, w * dSphereRadius, h * dSphereRadius);\n}\nvec2 dLTCUV;\n#ifdef LIT_CLEARCOAT\nvec2 ccLTCUV;\n#endif\nvec2 getLTCLightUV(float gloss, vec3 worldNormal, vec3 viewDir)\n{\n\tfloat roughness = max((1.0 - gloss) * (1.0 - gloss), 0.001);\n\treturn LTC_Uv( worldNormal, viewDir, roughness );\n}\nvec3 dLTCSpecFres;\n#ifdef LIT_CLEARCOAT\nvec3 ccLTCSpecFres;\n#endif\nvec3 getLTCLightSpecFres(vec2 uv, vec3 specularity)\n{\n\tvec4 t2 = texture2DLodEXT(areaLightsLutTex2, uv, 0.0);\n\t#ifdef AREA_R8_G8_B8_A8_LUTS\n\tt2 *= vec4(0.693103,1,1,1);\n\tt2 += vec4(0.306897,0,0,0);\n\t#endif\n\treturn specularity * t2.x + ( vec3( 1.0 ) - specularity) * t2.y;\n}\nvoid calcLTCLightValues(float gloss, vec3 worldNormal, vec3 viewDir, vec3 specularity, float clearcoatGloss, vec3 clearcoatWorldNormal, float clearcoatSpecularity)\n{\n\tdLTCUV = getLTCLightUV(gloss, worldNormal, viewDir);\n\tdLTCSpecFres = getLTCLightSpecFres(dLTCUV, specularity); \n#ifdef LIT_CLEARCOAT\n\tccLTCUV = getLTCLightUV(clearcoatGloss, clearcoatWorldNormal, viewDir);\n\tccLTCSpecFres = getLTCLightSpecFres(ccLTCUV, vec3(clearcoatSpecularity));\n#endif\n}\nvoid calcRectLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\tdLTCCoords = getLTCLightCoords(lightPos, halfWidth, halfHeight);\n}\nvoid calcDiskLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\tcalcRectLightValues(lightPos, halfWidth, halfHeight);\n}\nvoid calcSphereLightValues(vec3 lightPos, vec3 halfWidth, vec3 halfHeight)\n{\n\tdLTCCoords = getSphereLightCoords(lightPos, halfWidth, halfHeight);\n}\nvec3 SolveCubic(vec4 Coefficient)\n{\n\tfloat pi = 3.14159;\n\tCoefficient.xyz /= Coefficient.w;\n\tCoefficient.yz /= 3.0;\n\tfloat A = Coefficient.w;\n\tfloat B = Coefficient.z;\n\tfloat C = Coefficient.y;\n\tfloat D = Coefficient.x;\n\tvec3 Delta = vec3(\n\t\t-Coefficient.z * Coefficient.z + Coefficient.y,\n\t\t-Coefficient.y * Coefficient.z + Coefficient.x,\n\t\tdot(vec2(Coefficient.z, -Coefficient.y), Coefficient.xy)\n\t);\n\tfloat Discriminant = dot(vec2(4.0 * Delta.x, -Delta.y), Delta.zy);\n\tvec3 RootsA, RootsD;\n\tvec2 xlc, xsc;\n\t{\n\t\tfloat A_a = 1.0;\n\t\tfloat C_a = Delta.x;\n\t\tfloat D_a = -2.0 * B * Delta.x + Delta.y;\n\t\tfloat Theta = atan(sqrt(Discriminant), -D_a) / 3.0;\n\t\tfloat x_1a = 2.0 * sqrt(-C_a) * cos(Theta);\n\t\tfloat x_3a = 2.0 * sqrt(-C_a) * cos(Theta + (2.0 / 3.0) * pi);\n\t\tfloat xl;\n\t\tif ((x_1a + x_3a) > 2.0 * B)\n\t\t\txl = x_1a;\n\t\telse\n\t\t\txl = x_3a;\n\t\txlc = vec2(xl - B, A);\n\t}\n\t{\n\t\tfloat A_d = D;\n\t\tfloat C_d = Delta.z;\n\t\tfloat D_d = -D * Delta.y + 2.0 * C * Delta.z;\n\t\tfloat Theta = atan(D * sqrt(Discriminant), -D_d) / 3.0;\n\t\tfloat x_1d = 2.0 * sqrt(-C_d) * cos(Theta);\n\t\tfloat x_3d = 2.0 * sqrt(-C_d) * cos(Theta + (2.0 / 3.0) * pi);\n\t\tfloat xs;\n\t\tif (x_1d + x_3d < 2.0 * C)\n\t\t\txs = x_1d;\n\t\telse\n\t\t\txs = x_3d;\n\t\txsc = vec2(-D, xs + C);\n\t}\n\tfloat E =  xlc.y * xsc.y;\n\tfloat F = -xlc.x * xsc.y - xlc.y * xsc.x;\n\tfloat G =  xlc.x * xsc.x;\n\tvec2 xmc = vec2(C * F - B * G, -B * F + C * E);\n\tvec3 Root = vec3(xsc.x / xsc.y, xmc.x / xmc.y, xlc.x / xlc.y);\n\tif (Root.x < Root.y && Root.x < Root.z)\n\t\tRoot.xyz = Root.yxz;\n\telse if (Root.z < Root.x && Root.z < Root.y)\n\t\tRoot.xyz = Root.xzy;\n\treturn Root;\n}\nfloat LTC_EvaluateDisk(vec3 N, vec3 V, vec3 P, mat3 Minv, Coords points)\n{\n\tvec3 T1, T2;\n\tT1 = normalize(V - N * dot(V, N));\n\tT2 = cross(N, T1);\n\tmat3 R = transposeMat3( mat3( T1, T2, N ) );\n\tvec3 L_[ 3 ];\n\tL_[ 0 ] = R * ( points.coord0 - P );\n\tL_[ 1 ] = R * ( points.coord1 - P );\n\tL_[ 2 ] = R * ( points.coord2 - P );\n\tvec3 Lo_i = vec3(0);\n\tvec3 C  = 0.5 * (L_[0] + L_[2]);\n\tvec3 V1 = 0.5 * (L_[1] - L_[2]);\n\tvec3 V2 = 0.5 * (L_[1] - L_[0]);\n\tC  = Minv * C;\n\tV1 = Minv * V1;\n\tV2 = Minv * V2;\n\tfloat a, b;\n\tfloat d11 = dot(V1, V1);\n\tfloat d22 = dot(V2, V2);\n\tfloat d12 = dot(V1, V2);\n\tif (abs(d12) / sqrt(d11 * d22) > 0.0001)\n\t{\n\t\tfloat tr = d11 + d22;\n\t\tfloat det = -d12 * d12 + d11 * d22;\n\t\tdet = sqrt(det);\n\t\tfloat u = 0.5 * sqrt(tr - 2.0 * det);\n\t\tfloat v = 0.5 * sqrt(tr + 2.0 * det);\n\t\tfloat e_max = (u + v) * (u + v);\n\t\tfloat e_min = (u - v) * (u - v);\n\t\tvec3 V1_, V2_;\n\t\tif (d11 > d22)\n\t\t{\n\t\t\tV1_ = d12 * V1 + (e_max - d11) * V2;\n\t\t\tV2_ = d12 * V1 + (e_min - d11) * V2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV1_ = d12*V2 + (e_max - d22)*V1;\n\t\t\tV2_ = d12*V2 + (e_min - d22)*V1;\n\t\t}\n\t\ta = 1.0 / e_max;\n\t\tb = 1.0 / e_min;\n\t\tV1 = normalize(V1_);\n\t\tV2 = normalize(V2_);\n\t}\n\telse\n\t{\n\t\ta = 1.0 / dot(V1, V1);\n\t\tb = 1.0 / dot(V2, V2);\n\t\tV1 *= sqrt(a);\n\t\tV2 *= sqrt(b);\n\t}\n\tvec3 V3 = normalize(cross(V1, V2));\n\tif (dot(C, V3) < 0.0)\n\t\tV3 *= -1.0;\n\tfloat L  = dot(V3, C);\n\tfloat x0 = dot(V1, C) / L;\n\tfloat y0 = dot(V2, C) / L;\n\tfloat E1 = inversesqrt(a);\n\tfloat E2 = inversesqrt(b);\n\ta *= L * L;\n\tb *= L * L;\n\tfloat c0 = a * b;\n\tfloat c1 = a * b * (1.0 + x0 * x0 + y0 * y0) - a - b;\n\tfloat c2 = 1.0 - a * (1.0 + x0 * x0) - b * (1.0 + y0 * y0);\n\tfloat c3 = 1.0;\n\tvec3 roots = SolveCubic(vec4(c0, c1, c2, c3));\n\tfloat e1 = roots.x;\n\tfloat e2 = roots.y;\n\tfloat e3 = roots.z;\n\tvec3 avgDir = vec3(a * x0 / (a - e2), b * y0 / (b - e2), 1.0);\n\tmat3 rotate = mat3(V1, V2, V3);\n\tavgDir = rotate * avgDir;\n\tavgDir = normalize(avgDir);\n\tfloat L1 = sqrt(-e2 / e3);\n\tfloat L2 = sqrt(-e2 / e1);\n\tfloat formFactor = max(0.0, L1 * L2 * inversesqrt((1.0 + L1 * L1) * (1.0 + L2 * L2)));\n\t\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tvec2 uv = vec2(avgDir.z * 0.5 + 0.5, formFactor);\n\tuv = uv*LUT_SCALE + LUT_BIAS;\n\tfloat scale = texture2DLodEXT(areaLightsLutTex2, uv, 0.0).w;\n\treturn formFactor*scale;\n}\nfloat getRectLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {\n\treturn LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords );\n}\nfloat getDiskLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {\n\treturn LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mat3( 1.0 ), dLTCCoords );\n}\nfloat getSphereLightDiffuse(vec3 worldNormal, vec3 viewDir, vec3 lightDir, vec3 lightDirNorm) {\n\tfloat falloff = dSphereRadius / (dot(lightDir, lightDir) + dSphereRadius);\n\treturn getLightDiffuse(worldNormal, viewDir, lightDir, lightDirNorm) * falloff;\n}\nmat3 getLTCLightInvMat(vec2 uv)\n{\n\tvec4 t1 = texture2DLodEXT(areaLightsLutTex1, uv, 0.0);\n\t#ifdef AREA_R8_G8_B8_A8_LUTS\n\tt1 *= vec4(1.001, 0.3239, 0.60437568, 1.0);\n\tt1 += vec4(0.0, -0.2976, -0.01381, 0.0);\n\t#endif\n\treturn mat3(\n\t\tvec3( t1.x, 0, t1.y ),\n\t\tvec3(\t0, 1,\t0 ),\n\t\tvec3( t1.z, 0, t1.w )\n\t);\n}\nfloat calcRectLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {\n\tmat3 mInv = getLTCLightInvMat(uv);\n\treturn LTC_EvaluateRect( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );\n}\nfloat getRectLightSpecular(vec3 worldNormal, vec3 viewDir) {\n\treturn calcRectLightSpecular(worldNormal, viewDir, dLTCUV);\n}\nfloat calcDiskLightSpecular(vec3 worldNormal, vec3 viewDir, vec2 uv) {\n\tmat3 mInv = getLTCLightInvMat(uv);\n\treturn LTC_EvaluateDisk( worldNormal, viewDir, vPositionW, mInv, dLTCCoords );\n}\nfloat getDiskLightSpecular(vec3 worldNormal, vec3 viewDir) {\n\treturn calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);\n}\nfloat getSphereLightSpecular(vec3 worldNormal, vec3 viewDir) {\n\treturn calcDiskLightSpecular(worldNormal, viewDir, dLTCUV);\n}\n`;\n\nexport { ltcPS as default };\n","var metalnessModulatePS = `\nvec3 getSpecularModulate(in vec3 specularity, in vec3 albedo, in float metalness, in float f0) {\n\tvec3 dielectricF0 = f0 * specularity;\n\treturn mix(dielectricF0, albedo, metalness);\n}\nvec3 getAlbedoModulate(in vec3 albedo, in float metalness) {\n\treturn albedo * (1.0 - metalness);\n}\n`;\n\nexport { metalnessModulatePS as default };\n","var outputPS = `\n`;\n\nexport { outputPS as default };\n","var outputAlphaPS = `\ngl_FragColor.a = litArgs_opacity;\n`;\n\nexport { outputAlphaPS as default };\n","var outputAlphaOpaquePS = `\n\tgl_FragColor.a = 1.0;\n`;\n\nexport { outputAlphaOpaquePS as default };\n","var outputAlphaPremulPS = `\ngl_FragColor.rgb *= litArgs_opacity;\ngl_FragColor.a = litArgs_opacity;\n`;\n\nexport { outputAlphaPremulPS as default };\n","var reflDirPS = `\nvoid getReflDir(vec3 worldNormal, vec3 viewDir, float gloss, mat3 tbn) {\n\tdReflDirW = normalize(-reflect(viewDir, worldNormal));\n}\n`;\n\nexport { reflDirPS as default };\n","var reflDirAnisoPS = `\nvoid getReflDir(vec3 worldNormal, vec3 viewDir, float gloss, mat3 tbn) {\n\tfloat roughness = sqrt(1.0 - min(gloss, 1.0));\n\tfloat anisotropy = material_anisotropy * roughness;\n\tvec3 anisotropicDirection = anisotropy >= 0.0 ? tbn[1] : tbn[0];\n\tvec3 anisotropicTangent = cross(anisotropicDirection, viewDir);\n\tvec3 anisotropicNormal = cross(anisotropicTangent, anisotropicDirection);\n\tvec3 bentNormal = normalize(mix(normalize(worldNormal), normalize(anisotropicNormal), anisotropy));\n\tdReflDirW = reflect(-viewDir, bentNormal);\n}\n`;\n\nexport { reflDirAnisoPS as default };\n","var reflectionCCPS = `\n#ifdef LIT_CLEARCOAT\nvoid addReflectionCC(vec3 reflDir, float gloss) {\n\tccReflection += calcReflection(reflDir, gloss);\n}\n#endif\n`;\n\nexport { reflectionCCPS as default };\n","var reflectionCubePS = `\nuniform samplerCube texture_cubeMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 reflDir, float gloss) {\n\tvec3 lookupVec = fixSeams(cubeMapProject(reflDir));\n\tlookupVec.x *= -1.0;\n\treturn $DECODE(textureCube(texture_cubeMap, lookupVec));\n}\nvoid addReflection(vec3 reflDir, float gloss) {   \n\tdReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);\n}\n`;\n\nexport { reflectionCubePS as default };\n","var reflectionEnvPS = `\n#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nuniform float material_reflectivity;\nfloat shinyMipLevel(vec2 uv) {\n\tvec2 dx = dFdx(uv);\n\tvec2 dy = dFdy(uv);\n\tvec2 uv2 = vec2(fract(uv.x + 0.5), uv.y);\n\tvec2 dx2 = dFdx(uv2);\n\tvec2 dy2 = dFdy(uv2);\n\tfloat maxd = min(max(dot(dx, dx), dot(dy, dy)), max(dot(dx2, dx2), dot(dy2, dy2)));\n\treturn clamp(0.5 * log2(maxd) - 1.0 + textureBias, 0.0, 5.0);\n}\nvec3 calcReflection(vec3 reflDir, float gloss) {\n\tvec3 dir = cubeMapProject(reflDir) * vec3(-1.0, 1.0, 1.0);\n\tvec2 uv = toSphericalUv(dir);\n\tfloat level = saturate(1.0 - gloss) * 5.0;\n\tfloat ilevel = floor(level);\n\tfloat level2 = shinyMipLevel(uv * atlasSize);\n\tfloat ilevel2 = floor(level2);\n\tvec2 uv0, uv1;\n\tfloat weight;\n\tif (ilevel == 0.0) {\n\t\tuv0 = mapShinyUv(uv, ilevel2);\n\t\tuv1 = mapShinyUv(uv, ilevel2 + 1.0);\n\t\tweight = level2 - ilevel2;\n\t} else {\n\t\tuv0 = uv1 = mapRoughnessUv(uv, ilevel);\n\t\tweight = 0.0;\n\t}\n\tvec3 linearA = $DECODE(texture2D(texture_envAtlas, uv0));\n\tvec3 linearB = $DECODE(texture2D(texture_envAtlas, uv1));\n\tvec3 linear0 = mix(linearA, linearB, weight);\n\tvec3 linear1 = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));\n\treturn processEnvironment(mix(linear0, linear1, level - ilevel));\n}\nvoid addReflection(vec3 reflDir, float gloss) {   \n\tdReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);\n}\n`;\n\nexport { reflectionEnvPS as default };\n","var reflectionEnvHQPS = `\n#ifndef ENV_ATLAS\n#define ENV_ATLAS\nuniform sampler2D texture_envAtlas;\n#endif\nuniform samplerCube texture_cubeMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 reflDir, float gloss) {\n\tvec3 dir = cubeMapProject(reflDir) * vec3(-1.0, 1.0, 1.0);\n\tvec2 uv = toSphericalUv(dir);\n\tfloat level = saturate(1.0 - gloss) * 5.0;\n\tfloat ilevel = floor(level);\n\tfloat flevel = level - ilevel;\n\tvec3 sharp = $DECODE_CUBEMAP(textureCube(texture_cubeMap, fixSeams(dir)));\n\tvec3 roughA = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel)));\n\tvec3 roughB = $DECODE(texture2D(texture_envAtlas, mapRoughnessUv(uv, ilevel + 1.0)));\n\treturn processEnvironment(mix(sharp, mix(roughA, roughB, flevel), min(level, 1.0)));\n}\nvoid addReflection(vec3 reflDir, float gloss) {   \n\tdReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);\n}\n`;\n\nexport { reflectionEnvHQPS as default };\n","var reflectionSheenPS = `\nvoid addReflectionSheen(vec3 worldNormal, vec3 viewDir, float gloss) {\n\tfloat NoV = dot(worldNormal, viewDir);\n\tfloat alphaG = gloss * gloss;\n\tfloat a = gloss < 0.25 ? -339.2 * alphaG + 161.4 * gloss - 25.9 : -8.48 * alphaG + 14.3 * gloss - 9.95;\n\tfloat b = gloss < 0.25 ? 44.0 * alphaG - 23.7 * gloss + 3.26 : 1.97 * alphaG - 3.27 * gloss + 0.72;\n\tfloat DG = exp( a * NoV + b ) + ( gloss < 0.25 ? 0.0 : 0.1 * ( gloss - 0.25 ) );\n\tsReflection += calcReflection(worldNormal, 0.0) * saturate(DG);\n}\n`;\n\nexport { reflectionSheenPS as default };\n","var reflectionSpherePS = `\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform sampler2D texture_sphereMap;\nuniform float material_reflectivity;\nvec3 calcReflection(vec3 reflDir, float gloss) {\n\tvec3 reflDirV = (mat3(matrix_view) * reflDir).xyz;\n\tfloat m = 2.0 * sqrt( dot(reflDirV.xy, reflDirV.xy) + (reflDirV.z+1.0)*(reflDirV.z+1.0) );\n\tvec2 sphereMapUv = reflDirV.xy / m + 0.5;\n\treturn $DECODE(texture2D(texture_sphereMap, sphereMapUv));\n}\nvoid addReflection(vec3 reflDir, float gloss) {   \n\tdReflection += vec4(calcReflection(reflDir, gloss), material_reflectivity);\n}\n`;\n\nexport { reflectionSpherePS as default };\n","var refractionCubePS = `\nvec3 refract2(vec3 viewVec, vec3 normal, float IOR) {\n\tfloat vn = dot(viewVec, normal);\n\tfloat k = 1.0 - IOR * IOR * (1.0 - vn * vn);\n\tvec3 refrVec = IOR * viewVec - (IOR * vn + sqrt(k)) * normal;\n\treturn refrVec;\n}\nvoid addRefraction(\n\tvec3 worldNormal, \n\tvec3 viewDir, \n\tfloat thickness, \n\tfloat gloss, \n\tvec3 specularity, \n\tvec3 albedo, \n\tfloat transmission,\n\tfloat refractionIndex,\n\tfloat dispersion\n#if defined(LIT_IRIDESCENCE)\n\t, vec3 iridescenceFresnel,\n\tfloat iridescenceIntensity\n#endif \n) {\n\tvec4 tmpRefl = dReflection;\n\tvec3 reflectionDir = refract2(-viewDir, worldNormal, refractionIndex);\n\tdReflection = vec4(0);\n\taddReflection(reflectionDir, gloss);\n\tdDiffuseLight = mix(dDiffuseLight, dReflection.rgb * albedo, transmission);\n\tdReflection = tmpRefl;\n}\n`;\n\nexport { refractionCubePS as default };\n","var refractionDynamicPS = `\nuniform float material_invAttenuationDistance;\nuniform vec3 material_attenuation;\nvec3 evalRefractionColor(vec3 refractionVector, float gloss, float refractionIndex) {\n\tvec4 pointOfRefraction = vec4(vPositionW + refractionVector, 1.0);\n\tvec4 projectionPoint = matrix_viewProjection * pointOfRefraction;\n\tvec2 uv = getGrabScreenPos(projectionPoint);\n\t#ifdef SUPPORTS_TEXLOD\n\t\tfloat iorToRoughness = (1.0 - gloss) * clamp((1.0 / refractionIndex) * 2.0 - 2.0, 0.0, 1.0);\n\t\tfloat refractionLod = log2(uScreenSize.x) * iorToRoughness;\n\t\tvec3 refraction = texture2DLodEXT(uSceneColorMap, uv, refractionLod).rgb;\n\t#else\n\t\tvec3 refraction = texture2D(uSceneColorMap, uv).rgb;\n\t#endif\n\treturn refraction;\n}\nvoid addRefraction(\n\tvec3 worldNormal, \n\tvec3 viewDir, \n\tfloat thickness, \n\tfloat gloss, \n\tvec3 specularity, \n\tvec3 albedo, \n\tfloat transmission,\n\tfloat refractionIndex,\n\tfloat dispersion\n#if defined(LIT_IRIDESCENCE)\n\t, vec3 iridescenceFresnel,\n\tfloat iridescenceIntensity\n#endif\n) {\n\tvec3 modelScale;\n\tmodelScale.x = length(vec3(matrix_model[0].xyz));\n\tmodelScale.y = length(vec3(matrix_model[1].xyz));\n\tmodelScale.z = length(vec3(matrix_model[2].xyz));\n\tvec3 scale = thickness * modelScale;\n\tvec3 refractionVector = normalize(refract(-viewDir, worldNormal, refractionIndex)) * scale;\n\tvec3 refraction = evalRefractionColor(refractionVector, gloss, refractionIndex);\n\t#ifdef DISPERSION\n\t\tfloat halfSpread = (1.0 / refractionIndex - 1.0) * 0.025 * dispersion;\n\t\tfloat refractionIndexR = refractionIndex - halfSpread;\n\t\trefractionVector = normalize(refract(-viewDir, worldNormal, refractionIndexR)) * scale;\n\t\trefraction.r = evalRefractionColor(refractionVector, gloss, refractionIndexR).r;\n\t\tfloat refractionIndexB = refractionIndex + halfSpread;\n\t\trefractionVector = normalize(refract(-viewDir, worldNormal, refractionIndexB)) * scale;\n\t\trefraction.b = evalRefractionColor(refractionVector, gloss, refractionIndexB).b;\n\t#endif\n\tvec3 transmittance;\n\tif (material_invAttenuationDistance != 0.0)\n\t{\n\t\tvec3 attenuation = -log(material_attenuation) * material_invAttenuationDistance;\n\t\ttransmittance = exp(-attenuation * length(refractionVector));\n\t}\n\telse\n\t{\n\t\ttransmittance = refraction;\n\t}\n\tvec3 fresnel = vec3(1.0) - \n\t\tgetFresnel(\n\t\t\tdot(viewDir, worldNormal), \n\t\t\tgloss, \n\t\t\tspecularity\n\t\t#if defined(LIT_IRIDESCENCE)\n\t\t\t, iridescenceFresnel,\n\t\t\tiridescenceIntensity\n\t\t#endif\n\t\t);\n\tdDiffuseLight = mix(dDiffuseLight, refraction * transmittance * fresnel, transmission);\n}\n`;\n\nexport { refractionDynamicPS as default };\n","var shadowCascadesPS = `\nconst float maxCascades = 4.0;\nmat4 cascadeShadowMat;\nvoid getShadowCascadeMatrix(mat4 shadowMatrixPalette[4], float shadowCascadeDistances[4], float shadowCascadeCount) {\n\tfloat depth = 1.0 / gl_FragCoord.w;\n\tfloat cascadeIndex = 0.0;\n\tfor (float i = 0.0; i < maxCascades; i++) {\n\t\tif (depth < shadowCascadeDistances[int(i)]) {\n\t\t\tcascadeIndex = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcascadeIndex = min(cascadeIndex, shadowCascadeCount - 1.0);\n\t#ifdef GL2\n\t\tcascadeShadowMat = shadowMatrixPalette[int(cascadeIndex)];\n\t#else\n\t\tif (cascadeIndex == 0.0) {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[0];\n\t\t}\n\t\telse if (cascadeIndex == 1.0) {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[1];\n\t\t}\n\t\telse if (cascadeIndex == 2.0) {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[2];\n\t\t}\n\t\telse {\n\t\t\tcascadeShadowMat = shadowMatrixPalette[3];\n\t\t}\n\t#endif\n}\nvoid fadeShadow(float shadowCascadeDistances[4]) {\t\t\t\t  \n\tfloat depth = 1.0 / gl_FragCoord.w;\n\tif (depth > shadowCascadeDistances[int(maxCascades - 1.0)]) {\n\t\tdShadowCoord.z = -9999999.0;\n\t}\n}\n`;\n\nexport { shadowCascadesPS as default };\n","var shadowEVSMPS = `\nfloat VSM$(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tvec3 moments = texture2D(tex, texCoords).xyz;\n\treturn calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {\n\treturn VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {\n\treturn VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n`;\n\nexport { shadowEVSMPS as default };\n","var shadowEVSMnPS = `\nfloat VSM$(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tfloat pixelSize = 1.0 / resolution;\n\ttexCoords -= vec2(pixelSize);\n\tvec3 s00 = texture2D(tex, texCoords).xyz;\n\tvec3 s10 = texture2D(tex, texCoords + vec2(pixelSize, 0)).xyz;\n\tvec3 s01 = texture2D(tex, texCoords + vec2(0, pixelSize)).xyz;\n\tvec3 s11 = texture2D(tex, texCoords + vec2(pixelSize)).xyz;\n\tvec2 fr = fract(texCoords * resolution);\n\tvec3 h0 = mix(s00, s10, fr.x);\n\tvec3 h1 = mix(s01, s11, fr.x);\n\tvec3 moments = mix(h0, h1, fr.y);\n\treturn calculateEVSM(moments, Z, vsmBias, exponent);\n}\nfloat getShadowVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {\n\treturn VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, exponent);\n}\nfloat getShadowSpotVSM$(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {\n\treturn VSM$(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, exponent);\n}\n`;\n\nexport { shadowEVSMnPS as default };\n","var shadowPCSSPS = `\n#define PCSS_SAMPLE_COUNT 16\nuniform float pcssDiskSamples[PCSS_SAMPLE_COUNT];\nuniform float pcssSphereSamples[PCSS_SAMPLE_COUNT];\nvec2 vogelDisk(int sampleIndex, float count, float phi, float r) {\n\tconst float GoldenAngle = 2.4;\n\tfloat theta = float(sampleIndex) * GoldenAngle + phi;\n\tfloat sine = sin(theta);\n\tfloat cosine = cos(theta);\n\treturn vec2(r * cosine, r * sine);\n}\nvec3 vogelSphere(int sampleIndex, float count, float phi, float r) {\n\tconst float GoldenAngle = 2.4;\n\tfloat theta = float(sampleIndex) * GoldenAngle + phi;\n\tfloat weight = float(sampleIndex) / count;\n\treturn vec3(cos(theta) * r, weight, sin(theta) * r);\n}\nfloat noise(vec2 screenPos) {\n\tconst float PHI = 1.61803398874989484820459;\n\treturn fract(sin(dot(screenPos * PHI, screenPos)) * screenPos.x);\n}\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\treturn dot(rgbaDepth, bitShift);\n}\n#endif\nfloat viewSpaceDepth(float depth, mat4 invProjection) {\n\tfloat z = depth * 2.0 - 1.0;\n\tvec4 clipSpace = vec4(0.0, 0.0, z, 1.0);\n\tvec4 viewSpace = invProjection * clipSpace;\n\treturn viewSpace.z;\n}\nfloat PCSSBlockerDistance(TEXTURE_ACCEPT(shadowMap), vec2 sampleCoords[PCSS_SAMPLE_COUNT], vec2 shadowCoords, vec2 searchSize, float z) {\n\tfloat blockers = 0.0;\n\tfloat averageBlocker = 0.0;\n\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n\t\tvec2 offset = sampleCoords[i] * searchSize;\n\t\tvec2 sampleUV = shadowCoords + offset;\n\t#ifdef GL2\n\t\tfloat blocker = textureLod(shadowMap, sampleUV, 0.0).r;\n\t#else\n\t\tfloat blocker = unpackFloat(texture2D(shadowMap, sampleUV));\n\t#endif\t\t\n\t\tfloat isBlocking = step(blocker, z);\n\t\tblockers += isBlocking;\n\t\taverageBlocker += blocker * isBlocking;\n\t}\n\tif (blockers > 0.0)\n\t\treturn averageBlocker /= blockers;\n\treturn -1.0;\n}\nfloat PCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoords, vec4 cameraParams, vec2 shadowSearchArea) {\n\tfloat receiverDepth = shadowCoords.z;\n#ifndef GL2\n\treceiverDepth *= 1.0 / (cameraParams.y - cameraParams.z);\n#endif\n\tvec2 samplePoints[PCSS_SAMPLE_COUNT];\n\tfloat noise = noise( gl_FragCoord.xy ) * 2.0 * PI;\n\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n\t\tfloat pcssPresample = pcssDiskSamples[i];\n\t\tsamplePoints[i] = vogelDisk(i, float(PCSS_SAMPLE_COUNT), noise, pcssPresample);\n\t}\n\tfloat averageBlocker = PCSSBlockerDistance(TEXTURE_PASS(shadowMap), samplePoints, shadowCoords.xy, shadowSearchArea, receiverDepth);\n\tif (averageBlocker == -1.0) {\n\t\treturn 1.0;\n\t} else {\n\t\tvec2 filterRadius = ((receiverDepth - averageBlocker) / averageBlocker) * shadowSearchArea * cameraParams.x;\n\t\tfloat shadow = 0.0;\n\t\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i ++)\n\t\t{\n\t\t\tvec2 sampleUV = samplePoints[i] * filterRadius;\n\t\t\tsampleUV = shadowCoords.xy + sampleUV;\n\t\t#ifdef GL2\n\t\t\tfloat depth = textureLod(shadowMap, sampleUV, 0.0).r;\n\t\t#else\n\t\t\tfloat depth = unpackFloat(texture2D(shadowMap, sampleUV));\n\t\t#endif\n\t\t\tshadow += step(receiverDepth, depth);\n\t\t}\n\t\treturn shadow / float(PCSS_SAMPLE_COUNT);\n\t} \n}\nfloat PCSSCubeBlockerDistance(samplerCube shadowMap, vec3 lightDirNorm, vec3 samplePoints[PCSS_SAMPLE_COUNT], float z, float shadowSearchArea) {\n\tfloat blockers = 0.0;\n\tfloat averageBlocker = 0.0;\n\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n\t\tvec3 sampleDir = lightDirNorm + samplePoints[i] * shadowSearchArea;\n\t\tsampleDir = normalize(sampleDir);\n\t#ifdef GL2\n\t\tfloat blocker = textureCubeLodEXT(shadowMap, sampleDir, 0.0).r;\n\t#else\n\t\tfloat blocker = unpackFloat(textureCube(shadowMap, sampleDir));\n\t#endif\n\t\tfloat isBlocking = step(blocker, z);\n\t\tblockers += isBlocking;\n\t\taverageBlocker += blocker * isBlocking;\n\t}\n\tif (blockers > 0.0)\n\t\treturn averageBlocker /= float(blockers);\n\treturn -1.0;\n}\nfloat PCSSCube(samplerCube shadowMap, vec4 shadowParams, vec3 shadowCoords, vec4 cameraParams, float shadowSearchArea, vec3 lightDir) {\n\t\n\tvec3 samplePoints[PCSS_SAMPLE_COUNT];\n\tfloat noise = noise( gl_FragCoord.xy ) * 2.0 * PI;\n\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i++) {\n\t\tfloat r = pcssSphereSamples[i];\n\t\tsamplePoints[i] = vogelSphere(i, float(PCSS_SAMPLE_COUNT), noise, r);\n\t}\n\tfloat receiverDepth = length(lightDir) * shadowParams.w + shadowParams.z;\n\tvec3 lightDirNorm = normalize(lightDir);\n\t\n\tfloat averageBlocker = PCSSCubeBlockerDistance(shadowMap, lightDirNorm, samplePoints, receiverDepth, shadowSearchArea);\n\tif (averageBlocker == -1.0) {\n\t\treturn 1.0;\n\t} else {\n\t\tfloat filterRadius = ((receiverDepth - averageBlocker) / averageBlocker) * shadowSearchArea;\n\t\tfloat shadow = 0.0;\n\t\tfor (int i = 0; i < PCSS_SAMPLE_COUNT; i++)\n\t\t{\n\t\t\tvec3 offset = samplePoints[i] * filterRadius;\n\t\t\tvec3 sampleDir = lightDirNorm + offset;\n\t\t\tsampleDir = normalize(sampleDir);\n\t\t\t#ifdef GL2\n\t\t\t\tfloat depth = textureCubeLodEXT(shadowMap, sampleDir, 0.0).r;\n\t\t\t#else\n\t\t\t\tfloat depth = unpackFloat(textureCube(shadowMap, sampleDir));\n\t\t\t#endif\n\t\t\tshadow += step(receiverDepth, depth);\n\t\t}\n\t\treturn shadow / float(PCSS_SAMPLE_COUNT);\n\t}\n}\nfloat getShadowPointPCSS(samplerCube shadowMap, vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {\n\treturn PCSSCube(shadowMap, shadowParams, shadowCoord, cameraParams, shadowSearchArea.x, lightDir);\n}\nfloat getShadowSpotPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {\n\treturn PCSS(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, shadowSearchArea);\n}\nfloat getShadowPCSS(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, vec4 cameraParams, vec2 shadowSearchArea, vec3 lightDir) {\n\treturn PCSS(TEXTURE_PASS(shadowMap), shadowCoord, cameraParams, shadowSearchArea);\n}\n`;\n\nexport { shadowPCSSPS as default };\n","var shadowSampleCoordPS = `\nvec3 getShadowSampleCoord$LIGHT(mat4 shadowTransform, vec4 shadowParams, vec3 worldPosition, vec3 lightPos, inout vec3 lightDir, vec3 lightDirNorm, vec3 normal) {\n\tvec3 surfacePosition = worldPosition;\n#ifdef SHADOW_SAMPLE_POINT\n\t#ifdef SHADOW_SAMPLE_NORMAL_OFFSET\n\t\tfloat distScale = length(lightDir);\n\t\tsurfacePosition = worldPosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;\n\t\tlightDir = surfacePosition - lightPos;\n\t\treturn lightDir;\n\t#endif\n#else\n\t#ifdef SHADOW_SAMPLE_SOURCE_ZBUFFER\n\t\t#ifdef SHADOW_SAMPLE_NORMAL_OFFSET\n\t\t\tsurfacePosition = worldPosition + normal * shadowParams.y;\n\t\t#endif\n\t#else\n\t\t#ifdef SHADOW_SAMPLE_NORMAL_OFFSET\n\t\t\t#ifdef SHADOW_SAMPLE_ORTHO\n\t\t\t\tfloat distScale = 1.0;\n\t\t\t#else\n\t\t\t\tfloat distScale = abs(dot(vPositionW - lightPos, lightDirNorm));\n\t\t\t#endif\n\t\t\tsurfacePosition = worldPosition + normal * shadowParams.y * clamp(1.0 - dot(normal, -lightDirNorm), 0.0, 1.0) * distScale;\n\t\t#endif\n\t#endif\n\tvec4 positionInShadowSpace = shadowTransform * vec4(surfacePosition, 1.0);\n\t#ifdef SHADOW_SAMPLE_ORTHO\n\t\tpositionInShadowSpace.z = saturate(positionInShadowSpace.z) - 0.0001;\n\t#else\n\t\t#ifdef SHADOW_SAMPLE_SOURCE_ZBUFFER\n\t\t\tpositionInShadowSpace.xyz /= positionInShadowSpace.w;\n\t\t#else\n\t\t\tpositionInShadowSpace.xy /= positionInShadowSpace.w;\n\t\t\tpositionInShadowSpace.z = length(lightDir) * shadowParams.w;\n\t\t#endif\n\t#endif\n\t#ifdef SHADOW_SAMPLE_Z_BIAS\n\t\tpositionInShadowSpace.z += getShadowBias(shadowParams.x, shadowParams.z);\n\t#endif\n\tsurfacePosition = positionInShadowSpace.xyz;\n#endif\n\treturn surfacePosition;\n}\n`;\n\nexport { shadowSampleCoordPS as default };\n","var shadowStandardPS = `\nvec3 lessThan2(vec3 a, vec3 b) {\n\treturn clamp((b - a)*1000.0, 0.0, 1.0);\n}\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\n\tfloat unpackFloat(vec4 rgbaDepth) {\n\t\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\t\treturn dot(rgbaDepth, bitShift);\n\t}\n#endif\n#ifdef GL2\nfloat _getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {\n\tfloat z = shadowCoord.z;\n\tvec2 uv = shadowCoord.xy * shadowParams.x;\n\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\n\tvec2 base_uv = floor(uv + 0.5);\n\tfloat s = (uv.x + 0.5 - base_uv.x);\n\tfloat t = (uv.y + 0.5 - base_uv.y);\n\tbase_uv -= vec2(0.5);\n\tbase_uv *= shadowMapSizeInv;\n\tfloat sum = 0.0;\n\tfloat uw0 = (3.0 - 2.0 * s);\n\tfloat uw1 = (1.0 + 2.0 * s);\n\tfloat u0 = (2.0 - s) / uw0 - 1.0;\n\tfloat u1 = s / uw1 + 1.0;\n\tfloat vw0 = (3.0 - 2.0 * t);\n\tfloat vw1 = (1.0 + 2.0 * t);\n\tfloat v0 = (2.0 - t) / vw0 - 1.0;\n\tfloat v1 = t / vw1 + 1.0;\n\tu0 = u0 * shadowMapSizeInv + base_uv.x;\n\tv0 = v0 * shadowMapSizeInv + base_uv.y;\n\tu1 = u1 * shadowMapSizeInv + base_uv.x;\n\tv1 = v1 * shadowMapSizeInv + base_uv.y;\n\tsum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));\n\tsum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));\n\tsum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));\n\tsum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));\n\tsum *= 1.0f / 16.0;\n\treturn sum;\n}\nfloat getShadowPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\nfloat getShadowSpotPCF3x3(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\nfloat getShadowPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\treturn textureShadow(shadowMap, shadowCoord);\n}\nfloat getShadowSpotPCF1x1(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\treturn textureShadow(shadowMap, shadowCoord);\n}\n#else\nfloat _xgetShadowPCF3x3(mat3 depthKernel, vec3 shadowCoord, sampler2D shadowMap, vec3 shadowParams) {\n\tmat3 shadowKernel;\n\tvec3 shadowZ = vec3(shadowCoord.z);\n\tshadowKernel[0] = vec3(greaterThan(depthKernel[0], shadowZ));\n\tshadowKernel[1] = vec3(greaterThan(depthKernel[1], shadowZ));\n\tshadowKernel[2] = vec3(greaterThan(depthKernel[2], shadowZ));\n\tvec2 fractionalCoord = fract( shadowCoord.xy * shadowParams.x );\n\tshadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n\tshadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\tvec4 shadowValues;\n\tshadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n\tshadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n\tshadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n\tshadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\treturn dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\nfloat _getShadowPCF3x3(sampler2D shadowMap, vec3 shadowCoord, vec3 shadowParams) {\n\tfloat xoffset = 1.0 / shadowParams.x;\n\tfloat dx0 = -xoffset;\n\tfloat dx1 = xoffset;\n\tmat3 depthKernel;\n\tdepthKernel[0][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, dx0)));\n\tdepthKernel[0][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, 0.0)));\n\tdepthKernel[0][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx0, dx1)));\n\tdepthKernel[1][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(0.0, dx0)));\n\tdepthKernel[1][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy));\n\tdepthKernel[1][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(0.0, dx1)));\n\tdepthKernel[2][0] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, dx0)));\n\tdepthKernel[2][1] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, 0.0)));\n\tdepthKernel[2][2] = unpackFloat(textureShadow(shadowMap, shadowCoord.xy + vec2(dx1, dx1)));\n\treturn _xgetShadowPCF3x3(depthKernel, shadowCoord, shadowMap, shadowParams);\n}\nfloat getShadowPCF3x3(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowCoord, shadowParams.xyz);\n}\nfloat getShadowSpotPCF3x3(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {\n\treturn _getShadowPCF3x3(shadowMap, shadowCoord, shadowParams.xyz);\n}\nfloat _getShadowPCF1x1(sampler2D shadowMap, vec3 shadowCoord) {\n\tfloat shadowSample = unpackFloat(textureShadow(shadowMap, shadowCoord.xy));\n\treturn shadowSample > shadowCoord.z ? 1.0 : 0.0;\n}\nfloat getShadowPCF1x1(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {\n\treturn _getShadowPCF1x1(shadowMap, shadowCoord);\n}\nfloat getShadowSpotPCF1x1(sampler2D shadowMap, vec3 shadowCoord, vec4 shadowParams) {\n\treturn _getShadowPCF1x1(shadowMap, shadowCoord);\n}\n#endif\n#ifndef WEBGPU\nfloat _getShadowPoint(samplerCube shadowMap, vec4 shadowParams, vec3 dir) {\n\tvec3 tc = normalize(dir);\n\tvec3 tcAbs = abs(tc);\n\tvec4 dirX = vec4(1,0,0, tc.x);\n\tvec4 dirY = vec4(0,1,0, tc.y);\n\tfloat majorAxisLength = tc.z;\n\tif ((tcAbs.x > tcAbs.y) && (tcAbs.x > tcAbs.z)) {\n\t\tdirX = vec4(0,0,1, tc.z);\n\t\tdirY = vec4(0,1,0, tc.y);\n\t\tmajorAxisLength = tc.x;\n\t} else if ((tcAbs.y > tcAbs.x) && (tcAbs.y > tcAbs.z)) {\n\t\tdirX = vec4(1,0,0, tc.x);\n\t\tdirY = vec4(0,0,1, tc.z);\n\t\tmajorAxisLength = tc.y;\n\t}\n\tfloat shadowParamsInFaceSpace = ((1.0/shadowParams.x) * 2.0) * abs(majorAxisLength);\n\tvec3 xoffset = (dirX.xyz * shadowParamsInFaceSpace);\n\tvec3 yoffset = (dirY.xyz * shadowParamsInFaceSpace);\n\tvec3 dx0 = -xoffset;\n\tvec3 dy0 = -yoffset;\n\tvec3 dx1 = xoffset;\n\tvec3 dy1 = yoffset;\n\tmat3 shadowKernel;\n\tmat3 depthKernel;\n\tdepthKernel[0][0] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy0));\n\tdepthKernel[0][1] = unpackFloat(textureCube(shadowMap, tc + dx0));\n\tdepthKernel[0][2] = unpackFloat(textureCube(shadowMap, tc + dx0 + dy1));\n\tdepthKernel[1][0] = unpackFloat(textureCube(shadowMap, tc + dy0));\n\tdepthKernel[1][1] = unpackFloat(textureCube(shadowMap, tc));\n\tdepthKernel[1][2] = unpackFloat(textureCube(shadowMap, tc + dy1));\n\tdepthKernel[2][0] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy0));\n\tdepthKernel[2][1] = unpackFloat(textureCube(shadowMap, tc + dx1));\n\tdepthKernel[2][2] = unpackFloat(textureCube(shadowMap, tc + dx1 + dy1));\n\tvec3 shadowZ = vec3(length(dir) * shadowParams.w + shadowParams.z);\n\tshadowKernel[0] = vec3(lessThan2(depthKernel[0], shadowZ));\n\tshadowKernel[1] = vec3(lessThan2(depthKernel[1], shadowZ));\n\tshadowKernel[2] = vec3(lessThan2(depthKernel[2], shadowZ));\n\tvec2 uv = (vec2(dirX.w, dirY.w) / abs(majorAxisLength)) * 0.5;\n\tvec2 fractionalCoord = fract( uv * shadowParams.x );\n\tshadowKernel[0] = mix(shadowKernel[0], shadowKernel[1], fractionalCoord.x);\n\tshadowKernel[1] = mix(shadowKernel[1], shadowKernel[2], fractionalCoord.x);\n\tvec4 shadowValues;\n\tshadowValues.x = mix(shadowKernel[0][0], shadowKernel[0][1], fractionalCoord.y);\n\tshadowValues.y = mix(shadowKernel[0][1], shadowKernel[0][2], fractionalCoord.y);\n\tshadowValues.z = mix(shadowKernel[1][0], shadowKernel[1][1], fractionalCoord.y);\n\tshadowValues.w = mix(shadowKernel[1][1], shadowKernel[1][2], fractionalCoord.y);\n\treturn 1.0 - dot( shadowValues, vec4( 1.0 ) ) * 0.25;\n}\nfloat getShadowPointPCF3x3(samplerCube shadowMap, vec3 shadowCoord, vec4 shadowParams, vec3 lightDir) {\n\treturn _getShadowPoint(shadowMap, shadowParams, lightDir);\n}\n#endif\n`;\n\nexport { shadowStandardPS as default };\n","var shadowStandardGL2PS = `\nfloat _getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec3 shadowParams) {\n\tfloat z = shadowCoord.z;\n\tvec2 uv = shadowCoord.xy * shadowParams.x;\n\tfloat shadowMapSizeInv = 1.0 / shadowParams.x;\n\tvec2 base_uv = floor(uv + 0.5);\n\tfloat s = (uv.x + 0.5 - base_uv.x);\n\tfloat t = (uv.y + 0.5 - base_uv.y);\n\tbase_uv -= vec2(0.5);\n\tbase_uv *= shadowMapSizeInv;\n\tfloat uw0 = (4.0 - 3.0 * s);\n\tfloat uw1 = 7.0;\n\tfloat uw2 = (1.0 + 3.0 * s);\n\tfloat u0 = (3.0 - 2.0 * s) / uw0 - 2.0;\n\tfloat u1 = (3.0 + s) / uw1;\n\tfloat u2 = s / uw2 + 2.0;\n\tfloat vw0 = (4.0 - 3.0 * t);\n\tfloat vw1 = 7.0;\n\tfloat vw2 = (1.0 + 3.0 * t);\n\tfloat v0 = (3.0 - 2.0 * t) / vw0 - 2.0;\n\tfloat v1 = (3.0 + t) / vw1;\n\tfloat v2 = t / vw2 + 2.0;\n\tfloat sum = 0.0;\n\tu0 = u0 * shadowMapSizeInv + base_uv.x;\n\tv0 = v0 * shadowMapSizeInv + base_uv.y;\n\tu1 = u1 * shadowMapSizeInv + base_uv.x;\n\tv1 = v1 * shadowMapSizeInv + base_uv.y;\n\tu2 = u2 * shadowMapSizeInv + base_uv.x;\n\tv2 = v2 * shadowMapSizeInv + base_uv.y;\n\tsum += uw0 * vw0 * textureShadow(shadowMap, vec3(u0, v0, z));\n\tsum += uw1 * vw0 * textureShadow(shadowMap, vec3(u1, v0, z));\n\tsum += uw2 * vw0 * textureShadow(shadowMap, vec3(u2, v0, z));\n\tsum += uw0 * vw1 * textureShadow(shadowMap, vec3(u0, v1, z));\n\tsum += uw1 * vw1 * textureShadow(shadowMap, vec3(u1, v1, z));\n\tsum += uw2 * vw1 * textureShadow(shadowMap, vec3(u2, v1, z));\n\tsum += uw0 * vw2 * textureShadow(shadowMap, vec3(u0, v2, z));\n\tsum += uw1 * vw2 * textureShadow(shadowMap, vec3(u1, v2, z));\n\tsum += uw2 * vw2 * textureShadow(shadowMap, vec3(u2, v2, z));\n\tsum *= 1.0f / 144.0;\n\tsum = saturate(sum);\n\treturn sum;\n}\nfloat getShadowPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\treturn _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\nfloat getShadowSpotPCF5x5(SHADOWMAP_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams) {\n\treturn _getShadowPCF5x5(SHADOWMAP_PASS(shadowMap), shadowCoord, shadowParams.xyz);\n}\n`;\n\nexport { shadowStandardGL2PS as default };\n","var shadowVSM8PS = `\nfloat calculateVSM8(vec3 moments, float Z, float vsmBias) {\n\tfloat VSMBias = vsmBias;\n\tfloat depthScale = VSMBias * Z;\n\tfloat minVariance1 = depthScale * depthScale;\n\treturn chebyshevUpperBound(moments.xy, Z, minVariance1, 0.1);\n}\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nfloat VSM8(TEXTURE_ACCEPT(tex), vec2 texCoords, float resolution, float Z, float vsmBias, float exponent) {\n\tvec4 c = texture2D(tex, texCoords);\n\tvec3 moments = vec3(decodeFloatRG(c.xy), decodeFloatRG(c.zw), 0.0);\n\treturn calculateVSM8(moments, Z, vsmBias);\n}\nfloat getShadowVSM8(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {\n\treturn VSM8(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, shadowCoord.z, shadowParams.y, 0.0);\n}\nfloat getShadowSpotVSM8(TEXTURE_ACCEPT(shadowMap), vec3 shadowCoord, vec4 shadowParams, float exponent, vec3 lightDir) {\n\treturn VSM8(TEXTURE_PASS(shadowMap), shadowCoord.xy, shadowParams.x, length(lightDir) * shadowParams.w + shadowParams.z, shadowParams.y, 0.0);\n}\n`;\n\nexport { shadowVSM8PS as default };\n","var shadowVSM_commonPS = `\nfloat linstep(float a, float b, float v) {\n\treturn saturate((v - a) / (b - a));\n}\nfloat reduceLightBleeding(float pMax, float amount) {\n\t return linstep(amount, 1.0, pMax);\n}\nfloat chebyshevUpperBound(vec2 moments, float mean, float minVariance, float lightBleedingReduction) {\n\tfloat variance = moments.y - (moments.x * moments.x);\n\tvariance = max(variance, minVariance);\n\tfloat d = mean - moments.x;\n\tfloat pMax = variance / (variance + (d * d));\n\tpMax = reduceLightBleeding(pMax, lightBleedingReduction);\n\treturn (mean <= moments.x ? 1.0 : pMax);\n}\nfloat calculateEVSM(vec3 moments, float Z, float vsmBias, float exponent) {\n\tZ = 2.0 * Z - 1.0;\n\tfloat warpedDepth = exp(exponent * Z);\n\tmoments.xy += vec2(warpedDepth, warpedDepth*warpedDepth) * (1.0 - moments.z);\n\tfloat VSMBias = vsmBias;\n\tfloat depthScale = VSMBias * exponent * warpedDepth;\n\tfloat minVariance1 = depthScale * depthScale;\n\treturn chebyshevUpperBound(moments.xy, warpedDepth, minVariance1, 0.1);\n}\n`;\n\nexport { shadowVSM_commonPS as default };\n","var spotPS = `\nfloat getSpotEffect(vec3 lightSpotDir, float lightInnerConeAngle, float lightOuterConeAngle, vec3 lightDirNorm) {\n\tfloat cosAngle = dot(lightDirNorm, lightSpotDir);\n\treturn smoothstep(lightOuterConeAngle, lightInnerConeAngle, cosAngle);\n}\n`;\n\nexport { spotPS as default };\n","var startPS = `\nvoid main(void) {\n\tdReflection = vec4(0);\n\t#ifdef LIT_CLEARCOAT\n\tccSpecularLight = vec3(0);\n\tccReflection = vec3(0);\n\t#endif\n`;\n\nexport { startPS as default };\n","var startNineSlicedPS = `\n\tnineSlicedUv = vUv0;\n\tnineSlicedUv.y = 1.0 - nineSlicedUv.y;\n`;\n\nexport { startNineSlicedPS as default };\n","var startNineSlicedTiledPS = `\n\tvec2 tileMask = step(vMask, vec2(0.99999));\n\tvec2 tileSize = 0.5 * (innerOffset.xy + innerOffset.zw);\n\tvec2 tileScale = vec2(1.0) / (vec2(1.0) - tileSize);\n\tvec2 clampedUv = mix(innerOffset.xy * 0.5, vec2(1.0) - innerOffset.zw * 0.5, fract((vTiledUv - tileSize) * tileScale));\n\tclampedUv = clampedUv * atlasRect.zw + atlasRect.xy;\n\tnineSlicedUv = vUv0 * tileMask + clampedUv * (vec2(1.0) - tileMask);\n\tnineSlicedUv.y = 1.0 - nineSlicedUv.y;\n\t\n`;\n\nexport { startNineSlicedTiledPS as default };\n","var storeEVSMPS = `\nfloat exponent = VSM_EXPONENT;\ndepth = 2.0 * depth - 1.0;\ndepth =  exp(exponent * depth);\ngl_FragColor = vec4(depth, depth*depth, 1.0, 1.0);\n`;\n\nexport { storeEVSMPS as default };\n","var twoSidedLightingPS = `\nuniform float twoSidedLightingNegScaleFactor;\nvoid handleTwoSidedLighting() {\n\tdTBN[2] *= gl_FrontFacing ? twoSidedLightingNegScaleFactor : -twoSidedLightingNegScaleFactor;\n}\n`;\n\nexport { twoSidedLightingPS as default };\n","var viewDirPS = `\nvoid getViewDir() {\n\tdViewDirW = normalize(view_position - vPositionW);\n}\n`;\n\nexport { viewDirPS as default };\n","var baseVS = `\nattribute vec3 vertex_position;\nattribute vec3 vertex_normal;\nattribute vec4 vertex_tangent;\nattribute vec2 vertex_texCoord0;\nattribute vec2 vertex_texCoord1;\nattribute vec4 vertex_color;\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nvec3 dPositionW;\nmat4 dModelMatrix;\nmat3 dNormalMatrix;\n`;\n\nexport { baseVS as default };\n","var baseNineSlicedVS = `\n#define NINESLICED\nvarying vec2 vMask;\nvarying vec2 vTiledUv;\nuniform mediump vec4 innerOffset;\nuniform mediump vec2 outerScale;\nuniform mediump vec4 atlasRect;\n`;\n\nexport { baseNineSlicedVS as default };\n","var endVS = `\n`;\n\nexport { endVS as default };\n","var extensionVS = `\n`;\n\nexport { extensionVS as default };\n","var instancingVS = `\nattribute vec4 instance_line1;\nattribute vec4 instance_line2;\nattribute vec4 instance_line3;\nattribute vec4 instance_line4;\n`;\n\nexport { instancingVS as default };\n","var normalVS = `\n#ifdef MORPHING_TEXTURE_BASED_NORMAL\nuniform highp sampler2D morphNormalTex;\n#endif\nvec3 getNormal() {\n\t#ifdef SKIN\n\tdNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n\t#elif defined(INSTANCING)\n\tdNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n\t#else\n\tdNormalMatrix = matrix_normal;\n\t#endif\n\tvec3 tempNormal = vertex_normal;\n\t#ifdef MORPHING\n\t#ifdef MORPHING_NRM03\n\ttempNormal += morph_weights_a[0] * morph_nrm0;\n\ttempNormal += morph_weights_a[1] * morph_nrm1;\n\ttempNormal += morph_weights_a[2] * morph_nrm2;\n\ttempNormal += morph_weights_a[3] * morph_nrm3;\n\t#endif\n\t#ifdef MORPHING_NRM47\n\ttempNormal += morph_weights_b[0] * morph_nrm4;\n\ttempNormal += morph_weights_b[1] * morph_nrm5;\n\ttempNormal += morph_weights_b[2] * morph_nrm6;\n\ttempNormal += morph_weights_b[3] * morph_nrm7;\n\t#endif\n\t#endif\n\t#ifdef MORPHING_TEXTURE_BASED_NORMAL\n\t\t#ifdef WEBGPU\n\t\t\tivec2 morphUV = getTextureMorphCoords();\n\t\t\tvec3 morphNormal = texelFetch(morphNormalTex, ivec2(morphUV), 0).xyz;\n\t\t#else\n\t\t\tvec2 morphUV = getTextureMorphCoords();\n\t\t\tvec3 morphNormal = texture2D(morphNormalTex, morphUV).xyz;\n\t\t#endif\n\ttempNormal += morphNormal;\n\t#endif\n\treturn normalize(dNormalMatrix * tempNormal);\n}\n`;\n\nexport { normalVS as default };\n","var normalInstancedVS = `\nvec3 getNormal() {\n\tdNormalMatrix = mat3(instance_line1.xyz, instance_line2.xyz, instance_line3.xyz);\n\treturn normalize(dNormalMatrix * vertex_normal);\n}\n`;\n\nexport { normalInstancedVS as default };\n","var normalSkinnedVS = `\nvec3 getNormal() {\n\tdNormalMatrix = mat3(dModelMatrix[0].xyz, dModelMatrix[1].xyz, dModelMatrix[2].xyz);\n\treturn normalize(dNormalMatrix * vertex_normal);\n}\n`;\n\nexport { normalSkinnedVS as default };\n","var startVS = `\nvoid main(void) {\n\tgl_Position = getPosition();\n`;\n\nexport { startVS as default };\n","var tangentBinormalVS = `\nvec3 getTangent() {\n\treturn normalize(dNormalMatrix * vertex_tangent.xyz);\n}\nvec3 getBinormal() {\n\treturn cross(vNormalW, vTangentW) * vertex_tangent.w;\n}\n`;\n\nexport { tangentBinormalVS as default };\n","var uv0VS = `\n#ifdef NINESLICED\nvec2 getUv0() {\n\tvec2 uv = vertex_position.xz;\n\tvec2 positiveUnitOffset = clamp(vertex_position.xz, vec2(0.0), vec2(1.0));\n\tvec2 negativeUnitOffset = clamp(-vertex_position.xz, vec2(0.0), vec2(1.0));\n\tuv += (-positiveUnitOffset * innerOffset.xy + negativeUnitOffset * innerOffset.zw) * vertex_texCoord0.xy;\n\tuv = uv * -0.5 + 0.5;\n\tuv = uv * atlasRect.zw + atlasRect.xy;\n\tvMask = vertex_texCoord0.xy;\n\treturn uv;\n}\n#else\nvec2 getUv0() {\n\treturn vertex_texCoord0;\n}\n#endif\n`;\n\nexport { uv0VS as default };\n","var uv1VS = `\nvec2 getUv1() {\n\treturn vertex_texCoord1;\n}\n`;\n\nexport { uv1VS as default };\n","var viewNormalVS = `\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nvec3 getViewNormal() {\n\treturn mat3(matrix_view) * vNormalW;\n}\n`;\n\nexport { viewNormalVS as default };\n","var particlePS = `\nvarying vec4 texCoordsAlphaLife;\nuniform sampler2D colorMap;\nuniform sampler2D colorParam;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nuniform float softening;\nuniform float colorMult;\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\n#ifndef UNPACKFLOAT\n#define UNPACKFLOAT\nfloat unpackFloat(vec4 rgbaDepth) {\n\tconst vec4 bitShift = vec4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);\n\tfloat depth = dot(rgbaDepth, bitShift);\n\treturn depth;\n}\n#endif\nvoid main(void) {\n\tvec4 tex  = gammaCorrectInput(texture2D(colorMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)));\n\tvec4 ramp = gammaCorrectInput(texture2D(colorParam, vec2(texCoordsAlphaLife.w, 0.0)));\n\tramp.rgb *= colorMult;\n\tramp.a += texCoordsAlphaLife.z;\n\tvec3 rgb = tex.rgb * ramp.rgb;\n\tfloat a  = tex.a * ramp.a;\n`;\n\nexport { particlePS as default };\n","var particleInputFloatPS = `\nvoid readInput(float uv) {\n\tvec4 tex = texture2D(particleTexIN, vec2(uv, 0.25));\n\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.75));\n\tinPos = tex.xyz;\n\tinVel = tex2.xyz;\n\tinAngle = (tex.w < 0.0? -tex.w : tex.w) - 1000.0;\n\tinShow = tex.w >= 0.0;\n\tinLife = tex2.w;\n}\n`;\n\nexport { particleInputFloatPS as default };\n","var particleInputRgba8PS = `\n#define PI2 6.283185307179586\nuniform vec3 inBoundsSize;\nuniform vec3 inBoundsCenter;\nuniform float maxVel;\nfloat decodeFloatRG(vec2 rg) {\n\treturn rg.y*(1.0/255.0) + rg.x;\n}\nfloat decodeFloatRGBA( vec4 rgba ) {\n\treturn dot( rgba, vec4(1.0, 1.0/255.0, 1.0/65025.0, 1.0/160581375.0) );\n}\nvoid readInput(float uv) {\n\tvec4 tex0 = texture2D(particleTexIN, vec2(uv, 0.125));\n\tvec4 tex1 = texture2D(particleTexIN, vec2(uv, 0.375));\n\tvec4 tex2 = texture2D(particleTexIN, vec2(uv, 0.625));\n\tvec4 tex3 = texture2D(particleTexIN, vec2(uv, 0.875));\n\tinPos = vec3(decodeFloatRG(tex0.rg), decodeFloatRG(tex0.ba), decodeFloatRG(tex1.rg));\n\tinPos = (inPos - vec3(0.5)) * inBoundsSize + inBoundsCenter;\n\tinVel = tex2.xyz;\n\tinVel = (inVel - vec3(0.5)) * maxVel;\n\tinAngle = decodeFloatRG(tex1.ba) * PI2;\n\tinShow = tex2.a > 0.5;\n\tinLife = decodeFloatRGBA(tex3);\n\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n\tfloat maxPosLife = lifetime+1.0;\n\tinLife = inLife * (maxNegLife + maxPosLife) - maxNegLife;\n}\n`;\n\nexport { particleInputRgba8PS as default };\n","var particleOutputFloatPS = `\nvoid writeOutput() {\n\tif (gl_FragCoord.y<1.0) {\n\t\tgl_FragColor = vec4(outPos, (outAngle + 1000.0) * visMode);\n\t} else {\n\t\tgl_FragColor = vec4(outVel, outLife);\n\t}\n}\n`;\n\nexport { particleOutputFloatPS as default };\n","var particleOutputRgba8PS = `\nuniform vec3 outBoundsMul;\nuniform vec3 outBoundsAdd;\nvec2 encodeFloatRG( float v ) {\n\tvec2 enc = vec2(1.0, 255.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\n\treturn enc;\n}\nvec4 encodeFloatRGBA( float v ) {\n\tvec4 enc = vec4(1.0, 255.0, 65025.0, 160581375.0) * v;\n\tenc = fract(enc);\n\tenc -= enc.yzww * vec4(1.0/255.0,1.0/255.0,1.0/255.0,0.0);\n\treturn enc;\n}\nvoid writeOutput() {\n\toutPos = outPos * outBoundsMul + outBoundsAdd;\n\toutAngle = fract(outAngle / PI2);\n\toutVel = (outVel / maxVel) + vec3(0.5);\n\tfloat maxNegLife = max(lifetime, (numParticles - 1.0) * (rate+rateDiv));\n\tfloat maxPosLife = lifetime+1.0;\n\toutLife = (outLife + maxNegLife) / (maxNegLife + maxPosLife);\n\tif (gl_FragCoord.y < 1.0) {\n\t\tgl_FragColor = vec4(encodeFloatRG(outPos.x), encodeFloatRG(outPos.y));\n\t} else if (gl_FragCoord.y < 2.0) {\n\t\tgl_FragColor = vec4(encodeFloatRG(outPos.z), encodeFloatRG(outAngle));\n\t} else if (gl_FragCoord.y < 3.0) {\n\t\tgl_FragColor = vec4(outVel, visMode*0.5+0.5);\n\t} else {\n\t\tgl_FragColor = encodeFloatRGBA(outLife);\n\t}\n}\n`;\n\nexport { particleOutputRgba8PS as default };\n","var particleUpdaterAABBPS = `\nuniform mat3 spawnBounds;\nuniform vec3 spawnPosInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n\tvec3 pos = inBounds - vec3(0.5);\n\tvec3 posAbs = abs(pos);\n\tvec3 maxPos = vec3(max(posAbs.x, max(posAbs.y, posAbs.z)));\n\tvec3 edge = maxPos + (vec3(0.5) - maxPos) * spawnPosInnerRatio;\n\tpos.x = edge.x * (maxPos.x == posAbs.x ? sign(pos.x) : 2.0 * pos.x);\n\tpos.y = edge.y * (maxPos.y == posAbs.y ? sign(pos.y) : 2.0 * pos.y);\n\tpos.z = edge.z * (maxPos.z == posAbs.z ? sign(pos.z) : 2.0 * pos.z);\n#ifndef LOCAL_SPACE\n\treturn emitterPos + spawnBounds * pos;\n#else\n\treturn spawnBounds * pos;\n#endif\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n\tlocalVelocity -= vec3(0, 0, initialVelocity);\n}\n`;\n\nexport { particleUpdaterAABBPS as default };\n","var particleUpdaterEndPS = `\n\twriteOutput();\n}\n`;\n\nexport { particleUpdaterEndPS as default };\n","var particleUpdaterInitPS = `\nvarying vec2 vUv0;\nuniform highp sampler2D particleTexIN;\nuniform highp sampler2D internalTex0;\nuniform highp sampler2D internalTex1;\nuniform highp sampler2D internalTex2;\nuniform highp sampler2D internalTex3;\nuniform mat3 emitterMatrix;\nuniform mat3 emitterMatrixInv;\nuniform vec3 emitterScale;\nuniform vec3 emitterPos;\nuniform vec3 frameRandom;\nuniform vec3 localVelocityDivMult;\nuniform vec3 velocityDivMult;\nuniform float delta;\nuniform float rate;\nuniform float rateDiv;\nuniform float lifetime;\nuniform float numParticles;\nuniform float rotSpeedDivMult;\nuniform float radialSpeedDivMult;\nuniform float seed;\nuniform float startAngle;\nuniform float startAngle2;\nuniform float initialVelocity;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\nfloat visMode;\nvec3 outPos;\nvec3 outVel;\nfloat outAngle;\nbool outShow;\nfloat outLife;\n`;\n\nexport { particleUpdaterInitPS as default };\n","var particleUpdaterNoRespawnPS = `\n\tif (outLife >= lifetime) {\n\t\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n\t\tvisMode = -1.0;\n\t}\n`;\n\nexport { particleUpdaterNoRespawnPS as default };\n","var particleUpdaterOnStopPS = `\n\tvisMode = outLife < 0.0? -1.0: visMode;\n`;\n\nexport { particleUpdaterOnStopPS as default };\n","var particleUpdaterRespawnPS = `\n\tif (outLife >= lifetime) {\n\t\toutLife -= max(lifetime, (numParticles - 1.0) * particleRate);\n\t\tvisMode = 1.0;\n\t}\n\tvisMode = outLife < 0.0? 1.0: visMode;\n`;\n\nexport { particleUpdaterRespawnPS as default };\n","var particleUpdaterSpherePS = `\nuniform float spawnBoundsSphere;\nuniform float spawnBoundsSphereInnerRatio;\nvec3 calcSpawnPosition(vec3 inBounds, float rndFactor) {\n\tfloat rnd4 = fract(rndFactor * 1000.0);\n\tvec3 norm = normalize(inBounds.xyz - vec3(0.5));\n\tfloat r = rnd4 * (1.0 - spawnBoundsSphereInnerRatio) + spawnBoundsSphereInnerRatio;\n#ifndef LOCAL_SPACE\n\treturn emitterPos + norm * r * spawnBoundsSphere;\n#else\n\treturn norm * r * spawnBoundsSphere;\n#endif\n}\nvoid addInitialVelocity(inout vec3 localVelocity, vec3 inBounds) {\n\tlocalVelocity += normalize(inBounds - vec3(0.5)) * initialVelocity;\n}\n`;\n\nexport { particleUpdaterSpherePS as default };\n","var particleUpdaterStartPS = `\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec3 unpack3NFloats(float src) {\n\tfloat r = fract(src);\n\tfloat g = fract(src * 256.0);\n\tfloat b = fract(src * 65536.0);\n\treturn vec3(r, g, b);\n}\nvec3 tex1Dlod_lerp(TEXTURE_ACCEPT_HIGHP(tex), vec2 tc, out vec3 w) {\n\tvec4 a = texture2D(tex, tc);\n\tvec4 b = texture2D(tex, tc + graphSampleSize);\n\tfloat c = fract(tc.x * graphNumSamples);\n\tvec3 unpackedA = unpack3NFloats(a.w);\n\tvec3 unpackedB = unpack3NFloats(b.w);\n\tw = mix(unpackedA, unpackedB, c);\n\treturn mix(a.xyz, b.xyz, c);\n}\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\nvec4 hash41(float p) {\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n\tp4 += dot(p4, p4.wzxy+19.19);\n\treturn fract(vec4((p4.x + p4.y)*p4.z, (p4.x + p4.z)*p4.y, (p4.y + p4.z)*p4.w, (p4.z + p4.w)*p4.x));\n}\nvoid main(void) {\n\tif (gl_FragCoord.x > numParticles) discard;\n\treadInput(vUv0.x);\n\tvisMode = inShow? 1.0 : -1.0;\n\tvec4 rndFactor = hash41(gl_FragCoord.x + seed);\n\tfloat particleRate = rate + rateDiv * rndFactor.x;\n\toutLife = inLife + delta;\n\tfloat nlife = clamp(outLife / lifetime, 0.0, 1.0);\n\tvec3 localVelocityDiv;\n\tvec3 velocityDiv;\n\tvec3 paramDiv;\n\tvec3 localVelocity = tex1Dlod_lerp(TEXTURE_PASS(internalTex0), vec2(nlife, 0), localVelocityDiv);\n\tvec3 velocity =\t  tex1Dlod_lerp(TEXTURE_PASS(internalTex1), vec2(nlife, 0), velocityDiv);\n\tvec3 params =\t\ttex1Dlod_lerp(TEXTURE_PASS(internalTex2), vec2(nlife, 0), paramDiv);\n\tfloat rotSpeed = params.x;\n\tfloat rotSpeedDiv = paramDiv.y;\n\tvec3 radialParams = tex1Dlod_lerp(TEXTURE_PASS(internalTex3), vec2(nlife, 0), paramDiv);\n\tfloat radialSpeed = radialParams.x;\n\tfloat radialSpeedDiv = radialParams.y;\n\tbool respawn = inLife <= 0.0 || outLife >= lifetime;\n\tinPos = respawn ? calcSpawnPosition(rndFactor.xyz, rndFactor.x) : inPos;\n\tinAngle = respawn ? mix(startAngle, startAngle2, rndFactor.x) : inAngle;\n#ifndef LOCAL_SPACE\n\tvec3 radialVel = inPos - emitterPos;\n#else\n\tvec3 radialVel = inPos;\n#endif\n\tradialVel = (dot(radialVel, radialVel) > 1.0E-8) ? radialSpeed * normalize(radialVel) : vec3(0.0);\n\tradialVel += (radialSpeedDiv * vec3(2.0) - vec3(1.0)) * radialSpeedDivMult * rndFactor.xyz;\n\tlocalVelocity +=\t(localVelocityDiv * vec3(2.0) - vec3(1.0)) * localVelocityDivMult * rndFactor.xyz;\n\tvelocity +=\t\t (velocityDiv * vec3(2.0) - vec3(1.0)) * velocityDivMult * rndFactor.xyz;\n\trotSpeed +=\t\t (rotSpeedDiv * 2.0 - 1.0) * rotSpeedDivMult * rndFactor.y;\n\taddInitialVelocity(localVelocity, rndFactor.xyz);\n#ifndef LOCAL_SPACE\n\toutVel = emitterMatrix * localVelocity + (radialVel + velocity) * emitterScale;\n#else\n\toutVel = (localVelocity + radialVel) / emitterScale + emitterMatrixInv * velocity;\n#endif\n\toutPos = inPos + outVel * delta;\n\toutAngle = inAngle + rotSpeed * delta;\n`;\n\nexport { particleUpdaterStartPS as default };\n","var particle_blendAddPS = `\n\tdBlendModeFogFactor = 0.0;\n\trgb *= saturate(gammaCorrectInput(max(a, 0.0)));\n\tif ((rgb.r + rgb.g + rgb.b) < 0.000001) discard;\n`;\n\nexport { particle_blendAddPS as default };\n","var particle_blendMultiplyPS = `\n\trgb = mix(vec3(1.0), rgb, vec3(a));\n\tif (rgb.r + rgb.g + rgb.b > 2.99) discard;\n`;\n\nexport { particle_blendMultiplyPS as default };\n","var particle_blendNormalPS = `\n\tif (a < 0.01) discard;\n`;\n\nexport { particle_blendNormalPS as default };\n","var particle_endPS = `\n\trgb = addFog(rgb);\n\trgb = toneMap(rgb);\n\trgb = gammaCorrectOutput(rgb);\n\tgl_FragColor = vec4(rgb, a);\n}\n`;\n\nexport { particle_endPS as default };\n","var particle_halflambertPS = `\n\tvec3 negNormal = normal*0.5+0.5;\n\tvec3 posNormal = -normal*0.5+0.5;\n\tnegNormal *= negNormal;\n\tposNormal *= posNormal;\n`;\n\nexport { particle_halflambertPS as default };\n","var particle_lambertPS = `\n\tvec3 negNormal = max(normal, vec3(0.0));\n\tvec3 posNormal = max(-normal, vec3(0.0));\n`;\n\nexport { particle_lambertPS as default };\n","var particle_lightingPS = `\n\tvec3 light = negNormal.x*lightCube[0] + posNormal.x*lightCube[1] +\n\t\t\t\t\t\tnegNormal.y*lightCube[2] + posNormal.y*lightCube[3] +\n\t\t\t\t\t\tnegNormal.z*lightCube[4] + posNormal.z*lightCube[5];\n\trgb *= light;\n`;\n\nexport { particle_lightingPS as default };\n","var particle_normalMapPS = `\n\tvec3 normalMap = normalize(texture2D(normalMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)).xyz * 2.0 - 1.0);\n\tvec3 normal = ParticleMat * normalMap;\n`;\n\nexport { particle_normalMapPS as default };\n","var particle_softPS = `\n\tfloat depth = getLinearScreenDepth();\n\tfloat particleDepth = vDepth;\n\tfloat depthDiff = saturate(abs(particleDepth - depth) * softening);\n\ta *= depthDiff;\n`;\n\nexport { particle_softPS as default };\n","var particleVS = `\nvec3 unpack3NFloats(float src) {\n\tfloat r = fract(src);\n\tfloat g = fract(src * 256.0);\n\tfloat b = fract(src * 65536.0);\n\treturn vec3(r, g, b);\n}\nfloat saturate(float x) {\n\treturn clamp(x, 0.0, 1.0);\n}\nvec4 tex1Dlod_lerp(TEXTURE_ACCEPT_HIGHP(tex), vec2 tc) {\n\treturn mix( texture2D(tex,tc), texture2D(tex,tc + graphSampleSize), fract(tc.x*graphNumSamples) );\n}\nvec4 tex1Dlod_lerp(TEXTURE_ACCEPT_HIGHP(tex), vec2 tc, out vec3 w) {\n\tvec4 a = texture2D(tex,tc);\n\tvec4 b = texture2D(tex,tc + graphSampleSize);\n\tfloat c = fract(tc.x*graphNumSamples);\n\tvec3 unpackedA = unpack3NFloats(a.w);\n\tvec3 unpackedB = unpack3NFloats(b.w);\n\tw = mix(unpackedA, unpackedB, c);\n\treturn mix(a, b, c);\n}\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix) {\n\tfloat c = cos(pRotation);\n\tfloat s = sin(pRotation);\n\tmat2 m = mat2(c, -s, s, c);\n\trotMatrix = m;\n\treturn m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY) {\n\t#ifdef SCREEN_SPACE\n\t\tvec3 pos = vec3(-1, 0, 0) * quadXY.x + vec3(0, -1, 0) * quadXY.y;\n\t#else\n\t\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n\t#endif\n\treturn pos;\n}\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY) {\n\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n\treturn pos;\n}\nvec2 safeNormalize(vec2 v) {\n\tfloat l = length(v);\n\treturn (l > 1e-06) ? v / l : v;\n}\nvoid main(void) {\n\tvec3 meshLocalPos = particle_vertexData.xyz;\n\tfloat id = floor(particle_vertexData.w);\n\tfloat rndFactor = fract(sin(id + 1.0 + seed));\n\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n\tfloat uv = id / numParticlesPot;\n\treadInput(uv);\n#ifdef LOCAL_SPACE\n\tinVel = mat3(matrix_model) * inVel;\n#endif\n\tvec2 velocityV = safeNormalize((mat3(matrix_view) * inVel).xy);\n\tfloat particleLifetime = lifetime;\n\tif (inLife <= 0.0 || inLife > particleLifetime || !inShow) meshLocalPos = vec3(0.0);\n\tvec2 quadXY = meshLocalPos.xy;\n\tfloat nlife = clamp(inLife / particleLifetime, 0.0, 1.0);\n\tvec3 paramDiv;\n\tvec4 params = tex1Dlod_lerp(TEXTURE_PASS(internalTex2), vec2(nlife, 0), paramDiv);\n\tfloat scale = params.y;\n\tfloat scaleDiv = paramDiv.x;\n\tfloat alphaDiv = paramDiv.z;\n\tscale += (scaleDiv * 2.0 - 1.0) * scaleDivMult * fract(rndFactor*10000.0);\n#ifndef USE_MESH\n\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#else\n\ttexCoordsAlphaLife = vec4(particle_uv, (alphaDiv * 2.0 - 1.0) * alphaDivMult * fract(rndFactor*1000.0), nlife);\n#endif\n\tvec3 particlePos = inPos;\n\tvec3 particlePosMoved = vec3(0.0);\n\tmat2 rotMatrix;\n`;\n\nexport { particleVS as default };\n","var particleAnimFrameClampVS = `\n\tfloat animFrame = min(floor(texCoordsAlphaLife.w * animTexParams.y) + animTexParams.x, animTexParams.z);\n`;\n\nexport { particleAnimFrameClampVS as default };\n","var particleAnimFrameLoopVS = `\n\tfloat animFrame = floor(mod(texCoordsAlphaLife.w * animTexParams.y + animTexParams.x, animTexParams.z + 1.0));\n`;\n\nexport { particleAnimFrameLoopVS as default };\n","var particleAnimTexVS = `\n\tfloat animationIndex;\n\tif (animTexIndexParams.y == 1.0) {\n\t\tanimationIndex = floor((animTexParams.w + 1.0) * rndFactor3.z) * (animTexParams.z + 1.0);\n\t} else {\n\t\tanimationIndex = animTexIndexParams.x * (animTexParams.z + 1.0);\n\t}\n\tfloat atlasX = (animationIndex + animFrame) * animTexTilesParams.x;\n\tfloat atlasY = 1.0 - floor(atlasX + 1.0) * animTexTilesParams.y;\n\tatlasX = fract(atlasX);\n\ttexCoordsAlphaLife.xy *= animTexTilesParams.xy;\n\ttexCoordsAlphaLife.xy += vec2(atlasX, atlasY);\n`;\n\nexport { particleAnimTexVS as default };\n","var particle_TBNVS = `\n\tmat3 rot3 = mat3(rotMatrix[0][0], rotMatrix[0][1], 0.0, rotMatrix[1][0], rotMatrix[1][1], 0.0, 0.0, 0.0, 1.0);\n\tParticleMat = mat3(-matrix_viewInverse[0].xyz, -matrix_viewInverse[1].xyz, matrix_viewInverse[2].xyz) * rot3;\n`;\n\nexport { particle_TBNVS as default };\n","var particle_billboardVS = `\n\tquadXY = rotate(quadXY, inAngle, rotMatrix);\n\tvec3 localPos = billboard(particlePos, quadXY);\n`;\n\nexport { particle_billboardVS as default };\n","var particle_cpuVS = `\nattribute vec4 particle_vertexData;\nattribute vec4 particle_vertexData2;\nattribute vec4 particle_vertexData3;\nattribute float particle_vertexData4;\n#ifndef USE_MESH\nattribute vec2 particle_vertexData5;\n#else\nattribute vec4 particle_vertexData5;\n#endif\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\nuniform float numParticles;\nuniform float lifetime;\nuniform float stretch;\nuniform float seed;\nuniform vec3 wrapBounds;\nuniform vec3 emitterScale;\nuniform vec3 faceTangent;\nuniform vec3 faceBinorm;\n#ifdef PARTICLE_GPU\n\tuniform highp sampler2D internalTex0;\n\tuniform highp sampler2D internalTex1;\n\tuniform highp sampler2D internalTex2;\n#endif\nuniform vec3 emitterPos;\nvarying vec4 texCoordsAlphaLife;\nvec2 rotate(vec2 quadXY, float pRotation, out mat2 rotMatrix)\n{\n\tfloat c = cos(pRotation);\n\tfloat s = sin(pRotation);\n\tmat2 m = mat2(c, -s, s, c);\n\trotMatrix = m;\n\treturn m * quadXY;\n}\nvec3 billboard(vec3 InstanceCoords, vec2 quadXY)\n{\n\tvec3 pos = -matrix_viewInverse[0].xyz * quadXY.x + -matrix_viewInverse[1].xyz * quadXY.y;\n\treturn pos;\n}\nvec3 customFace(vec3 InstanceCoords, vec2 quadXY)\n{\n\tvec3 pos = faceTangent * quadXY.x + faceBinorm * quadXY.y;\n\treturn pos;\n}\nvoid main(void)\n{\n\tvec3 particlePos = particle_vertexData.xyz;\n\tvec3 inPos = particlePos;\n\tvec3 vertPos = particle_vertexData3.xyz;\n\tvec3 inVel = vec3(particle_vertexData2.w, particle_vertexData3.w, particle_vertexData5.x);\n\tfloat id = floor(particle_vertexData4);\n\tfloat rndFactor = fract(sin(id + 1.0 + seed));\n\tvec3 rndFactor3 = vec3(rndFactor, fract(rndFactor*10.0), fract(rndFactor*100.0));\n#ifdef LOCAL_SPACE\n\tinVel = mat3(matrix_model) * inVel;\n#endif\n\tvec2 velocityV = normalize((mat3(matrix_view) * inVel).xy);\n\tvec2 quadXY = vertPos.xy;\n#ifdef USE_MESH\n\ttexCoordsAlphaLife = vec4(particle_vertexData5.zw, particle_vertexData2.z, particle_vertexData.w);\n#else\n\ttexCoordsAlphaLife = vec4(quadXY * -0.5 + 0.5, particle_vertexData2.z, particle_vertexData.w);\n#endif\n\tmat2 rotMatrix;\n\tfloat inAngle = particle_vertexData2.x;\n\tvec3 particlePosMoved = vec3(0.0);\n\tvec3 meshLocalPos = particle_vertexData3.xyz;\n`;\n\nexport { particle_cpuVS as default };\n","var particle_cpu_endVS = `\n\tlocalPos *= particle_vertexData2.y * emitterScale;\n\tlocalPos += particlePos;\n\tgl_Position = matrix_viewProjection * vec4(localPos, 1.0);\n`;\n\nexport { particle_cpu_endVS as default };\n","var particle_customFaceVS = `\n\tquadXY = rotate(quadXY, inAngle, rotMatrix);\n\tvec3 localPos = customFace(particlePos, quadXY);\n`;\n\nexport { particle_customFaceVS as default };\n","var particle_endVS = `\n\tlocalPos *= scale * emitterScale;\n\tlocalPos += particlePos;\n\t#ifdef SCREEN_SPACE\n\tgl_Position = vec4(localPos.x, localPos.y, 0.0, 1.0);\n\t#else\n\tgl_Position = matrix_viewProjection * vec4(localPos.xyz, 1.0);\n\t#endif\n`;\n\nexport { particle_endVS as default };\n","var particle_initVS = `\nattribute vec4 particle_vertexData;\n#ifdef USE_MESH\nattribute vec2 particle_uv;\n#endif\nuniform mat4 matrix_viewProjection;\nuniform mat4 matrix_model;\nuniform mat3 matrix_normal;\nuniform mat4 matrix_viewInverse;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform float numParticles;\nuniform float numParticlesPot;\nuniform float graphSampleSize;\nuniform float graphNumSamples;\nuniform float stretch;\nuniform vec3 wrapBounds;\nuniform vec3 emitterScale;\nuniform vec3 emitterPos;\nuniform vec3 faceTangent;\nuniform vec3 faceBinorm;\nuniform float rate;\nuniform float rateDiv;\nuniform float lifetime;\nuniform float deltaRandomnessStatic;\nuniform float scaleDivMult;\nuniform float alphaDivMult;\nuniform float seed;\nuniform float delta;\nuniform sampler2D particleTexOUT;\nuniform sampler2D particleTexIN;\n#ifdef PARTICLE_GPU\n\tuniform highp sampler2D internalTex0;\n\tuniform highp sampler2D internalTex1;\n\tuniform highp sampler2D internalTex2;\n#endif\n#ifndef CAMERAPLANES\n#define CAMERAPLANES\nuniform vec4 camera_params;\n#endif\nvarying vec4 texCoordsAlphaLife;\nvec3 inPos;\nvec3 inVel;\nfloat inAngle;\nbool inShow;\nfloat inLife;\n`;\n\nexport { particle_initVS as default };\n","var particle_localShiftVS = `\n\tparticlePos = (matrix_model * vec4(particlePos, 1.0)).xyz;\n`;\n\nexport { particle_localShiftVS as default };\n","var particle_meshVS = `\n\tvec3 localPos = meshLocalPos;\n\tlocalPos.xy = rotate(localPos.xy, inAngle, rotMatrix);\n\tlocalPos.yz = rotate(localPos.yz, inAngle, rotMatrix);\n\tbillboard(particlePos, quadXY);\n`;\n\nexport { particle_meshVS as default };\n","var particle_normalVS = `\n\tNormal = normalize(localPos + matrix_viewInverse[2].xyz);\n`;\n\nexport { particle_normalVS as default };\n","var particle_pointAlongVS = `\n\tinAngle = atan(velocityV.x, velocityV.y);\n`;\n\nexport { particle_pointAlongVS as default };\n","var particle_softVS = `\n\tvDepth = getLinearDepth(localPos);\n`;\n\nexport { particle_softVS as default };\n","var particle_stretchVS = `\n\tvec3 moveDir = inVel * stretch;\n\tvec3 posPrev = particlePos - moveDir;\n\tposPrev += particlePosMoved;\n\tvec2 centerToVertexV = normalize((mat3(matrix_view) * localPos).xy);\n\tfloat interpolation = dot(-velocityV, centerToVertexV) * 0.5 + 0.5;\n\tparticlePos = mix(particlePos, posPrev, interpolation);\n`;\n\nexport { particle_stretchVS as default };\n","var particle_wrapVS = `\n\tvec3 origParticlePos = particlePos;\n\tparticlePos -= matrix_model[3].xyz;\n\tparticlePos = mod(particlePos, wrapBounds) - wrapBounds * 0.5;\n\tparticlePos += matrix_model[3].xyz;\n\tparticlePosMoved = particlePos - origParticlePos;\n`;\n\nexport { particle_wrapVS as default };\n","var skyboxEnvPS = `\nvarying vec3 vViewDir;\nuniform sampler2D texture_envAtlas;\nuniform float mipLevel;\nvoid main(void) {\n\tvec3 dir = vViewDir * vec3(-1.0, 1.0, 1.0);\n\tvec2 uv = toSphericalUv(normalize(dir));\n\tvec3 linear = SKYBOX_DECODE_FNC(texture2D(texture_envAtlas, mapRoughnessUv(uv, mipLevel)));\n\tgl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);\n}\n`;\n\nexport { skyboxEnvPS as default };\n","var skyboxHDRPS = `\nvarying vec3 vViewDir;\nuniform samplerCube texture_cubeMap;\n#ifdef SKYMESH\n\tvarying vec3 vWorldPos;\n\tuniform mat3 cubeMapRotationMatrix;\n\tuniform vec3 projectedSkydomeCenter;\n#endif\nvoid main(void) {\n\t#ifdef SKYMESH\n\t\tvec3 envDir = normalize(vWorldPos - projectedSkydomeCenter);\n\t\tvec3 dir = envDir * cubeMapRotationMatrix;\n\t#else\n\t\tvec3 dir = vViewDir;\n\t#endif\n\tdir.x *= -1.0;\n\tvec3 linear = SKYBOX_DECODE_FNC(textureCube(texture_cubeMap, fixSeamsStatic(dir, SKYBOX_MIP)));\n\tgl_FragColor = vec4(gammaCorrectOutput(toneMap(processEnvironment(linear))), 1.0);\n}\n`;\n\nexport { skyboxHDRPS as default };\n","var skyboxVS = `\nattribute vec3 aPosition;\n#ifndef VIEWMATRIX\n#define VIEWMATRIX\nuniform mat4 matrix_view;\n#endif\nuniform mat4 matrix_projectionSkybox;\nuniform mat3 cubeMapRotationMatrix;\nvarying vec3 vViewDir;\n#ifdef SKYMESH\n\tuniform mat4 matrix_model;\n\tvarying vec3 vWorldPos;\n#endif\nvoid main(void) {\n\tmat4 view = matrix_view;\n\t#ifdef SKYMESH\n\t\tvec4 worldPos = matrix_model * vec4(aPosition, 1.0);\n\t\tvWorldPos = worldPos.xyz;\n\t\tgl_Position = matrix_projectionSkybox * view * worldPos;\n\t#else\n\t\tview[3][0] = view[3][1] = view[3][2] = 0.0;\n\t\tgl_Position = matrix_projectionSkybox * view * vec4(aPosition, 1.0);\n\t\tvViewDir = aPosition * cubeMapRotationMatrix;\n\t#endif\n\tgl_Position.z = gl_Position.w - 1.0e-7;\n}\n`;\n\nexport { skyboxVS as default };\n","var alphaTestPS = `\nuniform float alpha_ref;\nvoid alphaTest(float a) {\n\tif (a < alpha_ref) discard;\n}\n`;\n\nexport { alphaTestPS as default };\n","var aoPS = `\nvoid getAO() {\n\tdAo = 1.0;\n\t#ifdef MAPTEXTURE\n\tfloat aoBase = texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\tdAo *= addAoDetail(aoBase);\n\t#endif\n\t#ifdef MAPVERTEX\n\tdAo *= saturate(vVertexColor.$VC);\n\t#endif\n}\n`;\n\nexport { aoPS as default };\n","var aoDetailMapPS = `\nfloat addAoDetail(float ao) {\n#ifdef MAPTEXTURE\n\tfloat aoDetail = texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\treturn detailMode_$DETAILMODE(vec3(ao), vec3(aoDetail)).r;\n#else\n\treturn ao;\n#endif\n}\n`;\n\nexport { aoDetailMapPS as default };\n","var clearCoatPS = `\n#ifdef MAPFLOAT\nuniform float material_clearCoat;\n#endif\nvoid getClearCoat() {\n\tccSpecularity = 1.0;\n\t#ifdef MAPFLOAT\n\tccSpecularity *= material_clearCoat;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tccSpecularity *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tccSpecularity *= saturate(vVertexColor.$VC);\n\t#endif\n}\n`;\n\nexport { clearCoatPS as default };\n","var clearCoatGlossPS = `\n#ifdef MAPFLOAT\nuniform float material_clearCoatGloss;\n#endif\nvoid getClearCoatGlossiness() {\n\tccGlossiness = 1.0;\n\t#ifdef MAPFLOAT\n\tccGlossiness *= material_clearCoatGloss;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tccGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tccGlossiness *= saturate(vVertexColor.$VC);\n\t#endif\n\t#ifdef MAPINVERT\n\tccGlossiness = 1.0 - ccGlossiness;\n\t#endif\n\tccGlossiness += 0.0000001;\n}\n`;\n\nexport { clearCoatGlossPS as default };\n","var clearCoatNormalPS = `\n#ifdef MAPTEXTURE\nuniform float material_clearCoatBumpiness;\n#endif\nvoid getClearCoatNormal() {\n#ifdef MAPTEXTURE\n\tvec3 normalMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));\n\tnormalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_clearCoatBumpiness);\n\tccNormalW = normalize(dTBN * normalMap);\n#else\n\tccNormalW = dVertexNormalW;\n#endif\n}\n`;\n\nexport { clearCoatNormalPS as default };\n","var detailModesPS = `\nvec3 detailMode_mul(vec3 c1, vec3 c2) {\n\treturn c1 * c2;\n}\nvec3 detailMode_add(vec3 c1, vec3 c2) {\n\treturn c1 + c2;\n}\nvec3 detailMode_screen(vec3 c1, vec3 c2) {\n\treturn 1.0 - (1.0 - c1)*(1.0 - c2);\n}\nvec3 detailMode_overlay(vec3 c1, vec3 c2) {\n\treturn mix(1.0 - 2.0*(1.0 - c1)*(1.0 - c2), 2.0*c1*c2, step(c1, vec3(0.5)));\n}\nvec3 detailMode_min(vec3 c1, vec3 c2) {\n\treturn min(c1, c2);\n}\nvec3 detailMode_max(vec3 c1, vec3 c2) {\n\treturn max(c1, c2);\n}\n`;\n\nexport { detailModesPS as default };\n","var diffusePS = `\n#ifdef MAPCOLOR\nuniform vec3 material_diffuse;\n#endif\nvoid getAlbedo() {\n\tdAlbedo = vec3(1.0);\n#ifdef MAPCOLOR\n\tdAlbedo *= material_diffuse.rgb;\n#endif\n#ifdef MAPTEXTURE\n\tvec3 albedoBase = $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n\tdAlbedo *= addAlbedoDetail(albedoBase);\n#endif\n#ifdef MAPVERTEX\n\tdAlbedo *= gammaCorrectInput(saturate(vVertexColor.$VC));\n#endif\n}\n`;\n\nexport { diffusePS as default };\n","var diffuseDetailMapPS = `\nvec3 addAlbedoDetail(vec3 albedo) {\n#ifdef MAPTEXTURE\n\tvec3 albedoDetail = $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n\treturn detailMode_$DETAILMODE(albedo, albedoDetail);\n#else\n\treturn albedo;\n#endif\n}\n`;\n\nexport { diffuseDetailMapPS as default };\n","var emissivePS = `\n#ifdef MAPCOLOR\nuniform vec3 material_emissive;\n#endif\n#ifdef MAPFLOAT\nuniform float material_emissiveIntensity;\n#endif\nvoid getEmission() {\n\tdEmission = vec3(1.0);\n\t#ifdef MAPFLOAT\n\tdEmission *= material_emissiveIntensity;\n\t#endif\n\t#ifdef MAPCOLOR\n\tdEmission *= material_emissive;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdEmission *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdEmission *= gammaCorrectInput(saturate(vVertexColor.$VC));\n\t#endif\n}\n`;\n\nexport { emissivePS as default };\n","var glossPS = `\n#ifdef MAPFLOAT\nuniform float material_gloss;\n#endif\nvoid getGlossiness() {\n\tdGlossiness = 1.0;\n\t#ifdef MAPFLOAT\n\tdGlossiness *= material_gloss;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdGlossiness *= saturate(vVertexColor.$VC);\n\t#endif\n\t#ifdef MAPINVERT\n\tdGlossiness = 1.0 - dGlossiness;\n\t#endif\n\tdGlossiness += 0.0000001;\n}\n`;\n\nexport { glossPS as default };\n","var iorPS = `\n#ifdef MAPFLOAT\nuniform float material_refractionIndex;\n#endif\nvoid getIor() {\n#ifdef MAPFLOAT\n\tdIor = material_refractionIndex;\n#else\n\tdIor = 1.0 / 1.5;\n#endif\n}\n`;\n\nexport { iorPS as default };\n","var iridescencePS = `\n#ifdef MAPFLOAT\nuniform float material_iridescence;\n#endif\nvoid getIridescence() {\n\tfloat iridescence = 1.0;\n\t#ifdef MAPFLOAT\n\tiridescence *= material_iridescence;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tiridescence *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\tdIridescence = iridescence; \n}\n`;\n\nexport { iridescencePS as default };\n","var iridescenceThicknessPS = `\nuniform float material_iridescenceThicknessMax;\n#ifdef MAPTEXTURE\nuniform float material_iridescenceThicknessMin;\n#endif\nvoid getIridescenceThickness() {\n\t#ifdef MAPTEXTURE\n\tfloat blend = texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\tfloat iridescenceThickness = mix(material_iridescenceThicknessMin, material_iridescenceThicknessMax, blend);\n\t#else\n\tfloat iridescenceThickness = material_iridescenceThicknessMax;\n\t#endif\n\tdIridescenceThickness = iridescenceThickness; \n}\n`;\n\nexport { iridescenceThicknessPS as default };\n","var lightmapDirPS = `\nuniform sampler2D texture_lightMap;\nuniform sampler2D texture_dirLightMap;\nvoid getLightMap() {\n\tdLightmap = $DECODE(texture2DBias(texture_lightMap, $UV, textureBias)).$CH;\n\tvec3 dir = texture2DBias(texture_dirLightMap, $UV, textureBias).xyz * 2.0 - 1.0;\n\tfloat dirDot = dot(dir, dir);\n\tdLightmapDir = (dirDot > 0.001) ? dir / sqrt(dirDot) : vec3(0.0);\n}\n`;\n\nexport { lightmapDirPS as default };\n","var lightmapSinglePS = `\nvoid getLightMap() {\n\tdLightmap = vec3(1.0);\n\t#ifdef MAPTEXTURE\n\tdLightmap *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdLightmap *= saturate(vVertexColor.$VC);\n\t#endif\n}\n`;\n\nexport { lightmapSinglePS as default };\n","var litShaderArgsPS = `\nvec3 litArgs_albedo;\nfloat litArgs_opacity;\nvec3 litArgs_emission;\nvec3 litArgs_worldNormal;\nfloat litArgs_ao;\nvec3 litArgs_lightmap;\nvec3 litArgs_lightmapDir;\nfloat litArgs_metalness;\nvec3 litArgs_specularity;\nfloat litArgs_specularityFactor;\nfloat litArgs_gloss;\nfloat litArgs_sheen_gloss;\nvec3 litArgs_sheen_specularity;\nfloat litArgs_transmission;\nfloat litArgs_thickness;\nfloat litArgs_ior;\nfloat litArgs_dispersion;\nfloat litArgs_iridescence_intensity;\nfloat litArgs_iridescence_thickness;\nvec3 litArgs_clearcoat_worldNormal;\nfloat litArgs_clearcoat_specularity;\nfloat litArgs_clearcoat_gloss;\n`;\n\nexport { litShaderArgsPS as default };\n","var metalnessPS = `\n#ifdef MAPFLOAT\nuniform float material_metalness;\n#endif\nvoid getMetalness() {\n\tfloat metalness = 1.0;\n\t#ifdef MAPFLOAT\n\tmetalness *= material_metalness;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tmetalness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tmetalness *= saturate(vVertexColor.$VC);\n\t#endif\n\tdMetalness = metalness;\n}\n`;\n\nexport { metalnessPS as default };\n","var normalDetailMapPS = `\n#ifdef MAPTEXTURE\nuniform float material_normalDetailMapBumpiness;\nvec3 blendNormals(vec3 n1, vec3 n2) {\n\tn1 += vec3(0, 0, 1);\n\tn2 *= vec3(-1, -1, 1);\n\treturn n1 * dot(n1, n2) / n1.z - n2;\n}\n#endif\nvec3 addNormalDetail(vec3 normalMap) {\n#ifdef MAPTEXTURE\n\tvec3 normalDetailMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));\n\tnormalDetailMap = mix(vec3(0.0, 0.0, 1.0), normalDetailMap, material_normalDetailMapBumpiness);\n\treturn blendNormals(normalMap, normalDetailMap);\n#else\n\treturn normalMap;\n#endif\n}\n`;\n\nexport { normalDetailMapPS as default };\n","var normalMapPS = `\n#ifdef MAPTEXTURE\nuniform float material_bumpiness;\n#endif\nvoid getNormal() {\n#ifdef MAPTEXTURE\n\tvec3 normalMap = unpackNormal(texture2DBias($SAMPLER, $UV, textureBias));\n\tnormalMap = mix(vec3(0.0, 0.0, 1.0), normalMap, material_bumpiness);\n\tdNormalW = normalize(dTBN * addNormalDetail(normalMap));\n#else\n\tdNormalW = dVertexNormalW;\n#endif\n}\n`;\n\nexport { normalMapPS as default };\n","var normalXYPS = `\nvec3 unpackNormal(vec4 nmap) {\n\tvec3 normal;\n\tnormal.xy = nmap.wy * 2.0 - 1.0;\n\tnormal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));\n\treturn normal;\n}\n`;\n\nexport { normalXYPS as default };\n","var normalXYZPS = `\nvec3 unpackNormal(vec4 nmap) {\n\treturn nmap.xyz * 2.0 - 1.0;\n}\n`;\n\nexport { normalXYZPS as default };\n","var opacityDitherPS = `\nuniform vec4 blueNoiseJitter;\n#ifdef DITHER_BLUENOISE\n\tuniform sampler2D blueNoiseTex32;\n#endif\nvoid opacityDither(float alpha, float id) {\n\t#ifdef DITHER_BAYER8\n\t\tfloat noise = bayer8(floor(mod(gl_FragCoord.xy + blueNoiseJitter.xy + id, 8.0))) / 64.0;\n\t#else\n\t\t#ifdef DITHER_BLUENOISE\n\t\t\tvec2 uv = fract(gl_FragCoord.xy / 32.0 + blueNoiseJitter.xy + id);\n\t\t\tfloat noise = texture2DLodEXT(blueNoiseTex32, uv, 0.0).y;\n\t\t#endif\n\t\t#ifdef DITHER_IGNNOISE\n\t\t\tvec3 magic = vec3(0.06711056, 0.00583715, 52.9829189);\n\t\t\tfloat noise = fract(magic.z * fract(dot(gl_FragCoord.xy + blueNoiseJitter.xy + id, magic.xy)));\n\t\t#endif\n\t#endif\n\tif (alpha < noise)\n\t\tdiscard;\n}\n`;\n\nexport { opacityDitherPS as default };\n","var opacityPS = `\n#ifdef MAPFLOAT\nuniform float material_opacity;\n#endif\nvoid getOpacity() {\n\tdAlpha = 1.0;\n\t#ifdef MAPFLOAT\n\tdAlpha *= material_opacity;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdAlpha *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdAlpha *= clamp(vVertexColor.$VC, 0.0, 1.0);\n\t#endif\n}\n`;\n\nexport { opacityPS as default };\n","var parallaxPS = `\nuniform float material_heightMapFactor;\nvoid getParallax() {\n\tfloat parallaxScale = material_heightMapFactor;\n\tfloat height = texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\theight = height * parallaxScale - parallaxScale*0.5;\n\tvec3 viewDirT = dViewDirW * dTBN;\n\tviewDirT.z += 0.42;\n\tdUvOffset = height * (viewDirT.xy / viewDirT.z);\n}\n`;\n\nexport { parallaxPS as default };\n","var sheenPS = `\n#ifdef MAPCOLOR\nuniform vec3 material_sheen;\n#endif\nvoid getSheen() {\n\tvec3 sheenColor = vec3(1, 1, 1);\n\t#ifdef MAPCOLOR\n\tsheenColor *= material_sheen;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tsheenColor *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tsheenColor *= saturate(vVertexColor.$VC);\n\t#endif\n\tsSpecularity = sheenColor;\n}\n`;\n\nexport { sheenPS as default };\n","var sheenGlossPS = `\n#ifdef MAPFLOAT\nuniform float material_sheenGloss;\n#endif\nvoid getSheenGlossiness() {\n\tfloat sheenGlossiness = 1.0;\n\t#ifdef MAPFLOAT\n\tsheenGlossiness *= material_sheenGloss;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tsheenGlossiness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tsheenGlossiness *= saturate(vVertexColor.$VC);\n\t#endif\n\t#ifdef MAPINVERT\n\tsheenGlossiness = 1.0 - sheenGlossiness;\n\t#endif\n\tsheenGlossiness += 0.0000001;\n\tsGlossiness = sheenGlossiness;\n}\n`;\n\nexport { sheenGlossPS as default };\n","var specularPS = `\n#ifdef MAPCOLOR\nuniform vec3 material_specular;\n#endif\nvoid getSpecularity() {\n\tvec3 specularColor = vec3(1,1,1);\n\t#ifdef MAPCOLOR\n\tspecularColor *= material_specular;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tspecularColor *= $DECODE(texture2DBias($SAMPLER, $UV, textureBias)).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tspecularColor *= saturate(vVertexColor.$VC);\n\t#endif\n\tdSpecularity = specularColor;\n}\n`;\n\nexport { specularPS as default };\n","var specularityFactorPS = `\n#ifdef MAPFLOAT\nuniform float material_specularityFactor;\n#endif\nvoid getSpecularityFactor() {\n\tfloat specularityFactor = 1.0;\n\t#ifdef MAPFLOAT\n\tspecularityFactor *= material_specularityFactor;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tspecularityFactor *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tspecularityFactor *= saturate(vVertexColor.$VC);\n\t#endif\n\tdSpecularityFactor = specularityFactor;\n}\n`;\n\nexport { specularityFactorPS as default };\n","var textureSamplePS = `\nvec4 texture2DSRGB(sampler2D tex, vec2 uv) {\n\treturn gammaCorrectInput(texture2D(tex, uv));\n}\nvec4 texture2DSRGB(sampler2D tex, vec2 uv, float bias) {\n\treturn gammaCorrectInput(texture2D(tex, uv, bias));\n}\nvec3 texture2DRGBM(sampler2D tex, vec2 uv) {\n\treturn decodeRGBM(texture2D(tex, uv));\n}\nvec3 texture2DRGBM(sampler2D tex, vec2 uv, float bias) {\n\treturn decodeRGBM(texture2D(tex, uv, bias));\n}\nvec3 texture2DRGBE(sampler2D tex, vec2 uv) {\n\treturn decodeRGBM(texture2D(tex, uv));\n}\nvec3 texture2DRGBE(sampler2D tex, vec2 uv, float bias) {\n\treturn decodeRGBM(texture2D(tex, uv, bias));\n}\n`;\n\nexport { textureSamplePS as default };\n","var thicknessPS = `\n#ifdef MAPFLOAT\nuniform float material_thickness;\n#endif\nvoid getThickness() {\n\tdThickness = 1.0;\n\t#ifdef MAPFLOAT\n\tdThickness *= material_thickness;\n\t#endif\n\t#ifdef MAPTEXTURE\n\tdThickness *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\tdThickness *= saturate(vVertexColor.$VC);\n\t#endif\n}\n`;\n\nexport { thicknessPS as default };\n","var transmissionPS = `\n#ifdef MAPFLOAT\nuniform float material_refraction;\n#endif\nvoid getRefraction() {\n\tfloat refraction = 1.0;\n\t#ifdef MAPFLOAT\n\trefraction = material_refraction;\n\t#endif\n\t#ifdef MAPTEXTURE\n\trefraction *= texture2DBias($SAMPLER, $UV, textureBias).$CH;\n\t#endif\n\t#ifdef MAPVERTEX\n\trefraction *= saturate(vVertexColor.$VC);\n\t#endif\n\tdTransmission = refraction;\n}\n`;\n\nexport { transmissionPS as default };\n","import { DeviceCache } from '../../platform/graphics/device-cache.js';\n\nconst programLibraryDeviceCache = new DeviceCache();\nfunction getProgramLibrary(device) {\n\tconst library = programLibraryDeviceCache.get(device);\n\treturn library;\n}\nfunction setProgramLibrary(device, library) {\n\tprogramLibraryDeviceCache.get(device, () => {\n\t\treturn library;\n\t});\n}\n\nexport { getProgramLibrary, setProgramLibrary };\n","import { hashCode } from '../../core/hash.js';\nimport { version, revision } from '../../core/core.js';\nimport { Shader } from '../../platform/graphics/shader.js';\nimport { SHADER_FORWARD, SHADER_SHADOW, SHADER_DEPTH, SHADER_PICK, SHADER_PREPASS_VELOCITY } from '../constants.js';\nimport { ShaderPass } from '../shader-pass.js';\nimport { StandardMaterialOptions } from '../materials/standard-material-options.js';\n\nclass ProgramLibrary {\n\tconstructor(device, standardMaterial) {\n\t\tthis.processedCache = new Map();\n\t\tthis.definitionsCache = new Map();\n\t\tthis._generators = new Map();\n\t\tthis._device = device;\n\t\tthis._isClearingCache = false;\n\t\tthis._precached = false;\n\t\tthis._programsCollection = [];\n\t\tthis._defaultStdMatOption = new StandardMaterialOptions();\n\t\tthis._defaultStdMatOptionMin = new StandardMaterialOptions();\n\t\tstandardMaterial.shaderOptBuilder.updateRef(this._defaultStdMatOption, {}, standardMaterial, null, [], SHADER_FORWARD, null);\n\t\tstandardMaterial.shaderOptBuilder.updateMinRef(this._defaultStdMatOptionMin, {}, standardMaterial, null, SHADER_SHADOW, null);\n\t\tdevice.on('destroy:shader', shader => {\n\t\t\tthis.removeFromCache(shader);\n\t\t});\n\t}\n\tdestroy() {\n\t\tthis.clearCache();\n\t}\n\tregister(name, generator) {\n\t\tif (!this._generators.has(name)) {\n\t\t\tthis._generators.set(name, generator);\n\t\t}\n\t}\n\tunregister(name) {\n\t\tif (this._generators.has(name)) {\n\t\t\tthis._generators.delete(name);\n\t\t}\n\t}\n\tisRegistered(name) {\n\t\treturn this._generators.has(name);\n\t}\n\tgenerateShaderDefinition(generator, name, key, options) {\n\t\tlet def = this.definitionsCache.get(key);\n\t\tif (!def) {\n\t\t\tvar _options$litOptions, _options$litOptions2, _def$name;\n\t\t\tlet lights;\n\t\t\tif ((_options$litOptions = options.litOptions) != null && _options$litOptions.lights) {\n\t\t\t\tlights = options.litOptions.lights;\n\t\t\t\toptions.litOptions.lights = lights.map(l => {\n\t\t\t\t\tconst lcopy = l.clone ? l.clone() : l;\n\t\t\t\t\tlcopy.key = l.key;\n\t\t\t\t\treturn lcopy;\n\t\t\t\t});\n\t\t\t}\n\t\t\tthis.storeNewProgram(name, options);\n\t\t\tif ((_options$litOptions2 = options.litOptions) != null && _options$litOptions2.lights) {\n\t\t\t\toptions.litOptions.lights = lights;\n\t\t\t}\n\t\t\tif (this._precached) ;\n\t\t\tconst device = this._device;\n\t\t\tdef = generator.createShaderDefinition(device, options);\n\t\t\tdef.name = (_def$name = def.name) != null ? _def$name : options.pass ? `${name}-pass:${options.pass}` : name;\n\t\t\tthis.definitionsCache.set(key, def);\n\t\t}\n\t\treturn def;\n\t}\n\tgetCachedShader(key) {\n\t\treturn this.processedCache.get(key);\n\t}\n\tsetCachedShader(key, shader) {\n\t\tthis.processedCache.set(key, shader);\n\t}\n\tgetProgram(name, options, processingOptions, userMaterialId) {\n\t\tconst generator = this._generators.get(name);\n\t\tif (!generator) {\n\t\t\treturn null;\n\t\t}\n\t\tconst generationKeyString = generator.generateKey(options);\n\t\tconst generationKey = hashCode(generationKeyString);\n\t\tconst processingKeyString = processingOptions.generateKey(this._device);\n\t\tconst processingKey = hashCode(processingKeyString);\n\t\tconst totalKey = `${generationKey}#${processingKey}`;\n\t\tlet processedShader = this.getCachedShader(totalKey);\n\t\tif (!processedShader) {\n\t\t\tconst generatedShaderDef = this.generateShaderDefinition(generator, name, generationKey, options);\n\t\t\tlet passName = '';\n\t\t\tlet shaderPassInfo;\n\t\t\tif (options.pass !== undefined) {\n\t\t\t\tshaderPassInfo = ShaderPass.get(this._device).getByIndex(options.pass);\n\t\t\t\tpassName = `-${shaderPassInfo.name}`;\n\t\t\t}\n\t\t\tthis._device.fire('shader:generate', {\n\t\t\t\tuserMaterialId,\n\t\t\t\tshaderPassInfo,\n\t\t\t\tdefinition: generatedShaderDef\n\t\t\t});\n\t\t\tconst shaderDefinition = {\n\t\t\t\tname: `${generatedShaderDef.name}${passName}-proc`,\n\t\t\t\tattributes: generatedShaderDef.attributes,\n\t\t\t\tvshader: generatedShaderDef.vshader,\n\t\t\t\tvincludes: generatedShaderDef.vincludes,\n\t\t\t\tfincludes: generatedShaderDef.fincludes,\n\t\t\t\tfshader: generatedShaderDef.fshader,\n\t\t\t\tprocessingOptions: processingOptions,\n\t\t\t\tshaderLanguage: generatedShaderDef.shaderLanguage\n\t\t\t};\n\t\t\tprocessedShader = new Shader(this._device, shaderDefinition);\n\t\t\tthis.setCachedShader(totalKey, processedShader);\n\t\t}\n\t\treturn processedShader;\n\t}\n\tstoreNewProgram(name, options) {\n\t\tlet opt = {};\n\t\tif (name === 'standard') {\n\t\t\tconst defaultMat = this._getDefaultStdMatOptions(options.pass);\n\t\t\tfor (const p in options) {\n\t\t\t\tif (options.hasOwnProperty(p) && defaultMat[p] !== options[p] || p === 'pass') {\n\t\t\t\t\topt[p] = options[p];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (const p in options.litOptions) {\n\t\t\t\topt[p] = options.litOptions[p];\n\t\t\t}\n\t\t} else {\n\t\t\topt = options;\n\t\t}\n\t\tthis._programsCollection.push(JSON.stringify({\n\t\t\tname: name,\n\t\t\toptions: opt\n\t\t}));\n\t}\n\tdumpPrograms() {\n\t\tlet text = 'let device = pc.app ? pc.app.graphicsDevice : pc.Application.getApplication().graphicsDevice;\\n';\n\t\ttext += 'let shaders = [';\n\t\tif (this._programsCollection[0]) {\n\t\t\ttext += `\\n\\t${this._programsCollection[0]}`;\n\t\t}\n\t\tfor (let i = 1; i < this._programsCollection.length; ++i) {\n\t\t\ttext += `,\\n\\t${this._programsCollection[i]}`;\n\t\t}\n\t\ttext += '\\n];\\n';\n\t\ttext += 'device.getProgramLibrary().precompile(shaders);\\n';\n\t\ttext += `if (pc.version != \\\"${version}\\\" || pc.revision != \\\"${revision}\\\")\\n`;\n\t\ttext += '\\tconsole.warn(\\\"precompile-shaders.js: engine version mismatch, rebuild shaders lib with current engine\\\");';\n\t\tconst element = document.createElement('a');\n\t\telement.setAttribute('href', `data:text/plain;charset=utf-8,${encodeURIComponent(text)}`);\n\t\telement.setAttribute('download', 'precompile-shaders.js');\n\t\telement.style.display = 'none';\n\t\tdocument.body.appendChild(element);\n\t\telement.click();\n\t\tdocument.body.removeChild(element);\n\t}\n\tclearCache() {\n\t\tthis._isClearingCache = true;\n\t\tthis.processedCache.forEach(shader => {\n\t\t\tshader.destroy();\n\t\t});\n\t\tthis.processedCache.clear();\n\t\tthis._isClearingCache = false;\n\t}\n\tremoveFromCache(shader) {\n\t\tif (this._isClearingCache) {\n\t\t\treturn;\n\t\t}\n\t\tthis.processedCache.forEach((cachedShader, key) => {\n\t\t\tif (shader === cachedShader) {\n\t\t\t\tthis.processedCache.delete(key);\n\t\t\t}\n\t\t});\n\t}\n\t_getDefaultStdMatOptions(pass) {\n\t\tconst shaderPassInfo = ShaderPass.get(this._device).getByIndex(pass);\n\t\treturn pass === SHADER_DEPTH || pass === SHADER_PICK || pass === SHADER_PREPASS_VELOCITY || shaderPassInfo.isShadow ? this._defaultStdMatOptionMin : this._defaultStdMatOption;\n\t}\n\tprecompile(cache) {\n\t\tif (cache) {\n\t\t\tconst shaders = new Array(cache.length);\n\t\t\tfor (let i = 0; i < cache.length; i++) {\n\t\t\t\tif (cache[i].name === 'standard') {\n\t\t\t\t\tconst opt = cache[i].options;\n\t\t\t\t\tconst defaultMat = this._getDefaultStdMatOptions(opt.pass);\n\t\t\t\t\tfor (const p in defaultMat) {\n\t\t\t\t\t\tif (defaultMat.hasOwnProperty(p) && opt[p] === undefined) {\n\t\t\t\t\t\t\topt[p] = defaultMat[p];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshaders[i] = this.getProgram(cache[i].name, cache[i].options);\n\t\t\t}\n\t\t}\n\t\tthis._precached = true;\n\t}\n}\n\nexport { ProgramLibrary };\n","import { SEMANTIC_POSITION, SEMANTIC_BLENDWEIGHT, SEMANTIC_BLENDINDICES, SEMANTIC_COLOR, SEMANTIC_TEXCOORD0 } from '../../../platform/graphics/constants.js';\nimport { ShaderUtils } from '../../../platform/graphics/shader-utils.js';\nimport { shaderChunks } from '../chunks/chunks.js';\nimport { ShaderPass } from '../../shader-pass.js';\nimport { ShaderGenerator } from './shader-generator.js';\n\nconst vShader = `\n\n\t\t#include \"shaderPassDefines\"\n\t\t#include \"transformDeclVS\"\n\n\t\t#ifdef SKIN\n\t\t\t\t#include \"skinCode\"\n\t\t#endif\n\n\t\t#include \"transformVS\"\n\n\t\t#ifdef VERTEX_COLORS\n\t\t\t\tattribute vec4 vertex_color;\n\t\t\t\tvarying vec4 vColor;\n\t\t#endif\n\n\t\t#ifdef DIFFUSE_MAP\n\t\t\t\tattribute vec2 vertex_texCoord0;\n\t\t\t\tvarying vec2 vUv0;\n\t\t#endif\n\n\t\t#ifdef DEPTH_PASS\n\t\t\t\tvarying float vDepth;\n\t\t\t\t\n\t\t\t\t#ifndef VIEWMATRIX\n\t\t\t\t#define VIEWMATRIX\n\t\t\t\t\t\tuniform mat4 matrix_view;\n\t\t\t\t#endif\n\n\t\t\t\t#ifndef CAMERAPLANES\n\t\t\t\t#define CAMERAPLANES\n\t\t\t\t\t\tuniform vec4 camera_params;\n\t\t\t\t#endif\n\t\t#endif\n\n\t\tvoid main(void) {\n\t\t\t\tgl_Position = getPosition();\n\n\t\t\t\t#ifdef DEPTH_PASS\n\t\t\t\t\t\tvDepth = -(matrix_view * vec4(getWorldPosition(),1.0)).z * camera_params.x;\n\t\t\t\t#endif        \n\n\t\t\t\t#ifdef VERTEX_COLORS\n\t\t\t\t\t\tvColor = vertex_color;\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef DIFFUSE_MAP\n\t\t\t\t\t\tvUv0 = vertex_texCoord0;\n\t\t\t\t#endif\n\t\t}\n`;\nconst fShader = `\n\n\t\t#include \"shaderPassDefines\"\n\n\t\t#ifdef VERTEX_COLORS\n\t\t\t\tvarying vec4 vColor;\n\t\t#else\n\t\t\t\tuniform vec4 uColor;\n\t\t#endif\n\n\t\t#ifdef DIFFUSE_MAP\n\t\t\t\tvarying vec2 vUv0;\n\t\t\t\tuniform sampler2D texture_diffuseMap;\n\t\t#endif\n\n\t\t#ifdef FOG\n\t\t\t\t#include \"fogCode\"\n\t\t#endif\n\n\t\t#ifdef ALPHA_TEST\n\t\t\t\t#include \"alphaTestPS\"\n\t\t#endif\n\n\t\t#ifdef DEPTH_PASS\n\t\t\t\tvarying float vDepth;\n\t\t\t\t#include \"packDepthPS\"\n\t\t#endif\n\n\t\tvoid main(void) {\n\n\t\t\t\t#ifdef VERTEX_COLORS\n\t\t\t\t\t\tgl_FragColor = vColor;\n\t\t\t\t#else\n\t\t\t\t\t\tgl_FragColor = uColor;\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef DIFFUSE_MAP\n\t\t\t\t\t\tgl_FragColor *= texture2D(texture_diffuseMap, vUv0);\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef ALPHA_TEST\n\t\t\t\t\t\talphaTest(gl_FragColor.a);\n\t\t\t\t#endif\n\n\t\t\t\t#ifndef PICK_PASS\n\n\t\t\t\t\t\t#ifdef DEPTH_PASS\n\t\t\t\t\t\t\t\tgl_FragColor = packFloat(vDepth);\n\t\t\t\t\t\t#else\n\t\t\t\t\t\t\t\t#ifdef FOG\n\t\t\t\t\t\t\t\t\t\tglFragColor.rgb = addFog(gl_FragColor.rgb);\n\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t#endif\n\t\t\t\t#endif\n\t\t}\n`;\nclass ShaderGeneratorBasic extends ShaderGenerator {\n\tgenerateKey(options) {\n\t\tlet key = 'basic';\n\t\tif (options.fog) key += '_fog';\n\t\tif (options.alphaTest) key += '_atst';\n\t\tif (options.vertexColors) key += '_vcol';\n\t\tif (options.diffuseMap) key += '_diff';\n\t\tif (options.skin) key += '_skin';\n\t\tif (options.screenSpace) key += '_ss';\n\t\tif (options.useInstancing) key += '_inst';\n\t\tif (options.useMorphPosition) key += '_morphp';\n\t\tif (options.useMorphNormal) key += '_morphn';\n\t\tif (options.useMorphTextureBased) key += '_morpht';\n\t\tkey += `_${options.pass}`;\n\t\treturn key;\n\t}\n\tcreateAttributesDefinition(definitionOptions, options) {\n\t\tconst attributes = {\n\t\t\tvertex_position: SEMANTIC_POSITION\n\t\t};\n\t\tif (options.skin) {\n\t\t\tattributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;\n\t\t\tattributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;\n\t\t}\n\t\tif (options.vertexColors) {\n\t\t\tattributes.vertex_color = SEMANTIC_COLOR;\n\t\t}\n\t\tif (options.diffuseMap) {\n\t\t\tattributes.vertex_texCoord0 = SEMANTIC_TEXCOORD0;\n\t\t}\n\t\tdefinitionOptions.attributes = attributes;\n\t}\n\tcreateVertexDefinition(device, definitionOptions, options, shaderPassInfo) {\n\t\tconst includes = new Map();\n\t\tconst defines = new Map();\n\t\tincludes.set('shaderPassDefines', shaderPassInfo.shaderDefines);\n\t\tincludes.set('transformDeclVS', shaderChunks.transformDeclVS);\n\t\tincludes.set('transformVS', shaderChunks.transformVS);\n\t\tincludes.set('skinCode', ShaderGenerator.skinCode(device));\n\t\tif (options.skin) defines.set('SKIN', true);\n\t\tif (options.vertexColors) defines.set('VERTEX_COLORS', true);\n\t\tif (options.diffuseMap) defines.set('DIFFUSE_MAP', true);\n\t\tdefinitionOptions.vertexCode = vShader;\n\t\tdefinitionOptions.vertexIncludes = includes;\n\t\tdefinitionOptions.vertexDefines = defines;\n\t}\n\tcreateFragmentDefinition(definitionOptions, options, shaderPassInfo) {\n\t\tconst includes = new Map();\n\t\tconst defines = new Map();\n\t\tincludes.set('shaderPassDefines', shaderPassInfo.shaderDefines);\n\t\tincludes.set('fogCode', ShaderGenerator.fogCode(options.fog));\n\t\tincludes.set('alphaTestPS', shaderChunks.alphaTestPS);\n\t\tincludes.set('packDepthPS', shaderChunks.packDepthPS);\n\t\tif (options.vertexColors) defines.set('VERTEX_COLORS', true);\n\t\tif (options.diffuseMap) defines.set('DIFFUSE_MAP', true);\n\t\tif (options.fog) defines.set('FOG', true);\n\t\tif (options.alphaTest) defines.set('ALPHA_TEST', true);\n\t\tdefinitionOptions.fragmentCode = fShader;\n\t\tdefinitionOptions.fragmentIncludes = includes;\n\t\tdefinitionOptions.fragmentDefines = defines;\n\t}\n\tcreateShaderDefinition(device, options) {\n\t\tconst definitionOptions = {\n\t\t\tname: 'BasicShader'\n\t\t};\n\t\tconst shaderPassInfo = ShaderPass.get(device).getByIndex(options.pass);\n\t\tthis.createAttributesDefinition(definitionOptions, options);\n\t\tthis.createVertexDefinition(device, definitionOptions, options, shaderPassInfo);\n\t\tthis.createFragmentDefinition(definitionOptions, options, shaderPassInfo);\n\t\treturn ShaderUtils.createDefinition(device, definitionOptions);\n\t}\n}\nconst basic = new ShaderGeneratorBasic();\n\nexport { basic };\n","import { LIGHTTYPE_DIRECTIONAL } from '../../constants.js';\n\nconst LitOptionsUtils = {\n\tgenerateKey(options) {\n\t\treturn `lit${Object.keys(options).sort().map(key => {\n\t\t\tif (key === 'chunks') {\n\t\t\t\treturn LitOptionsUtils.generateChunksKey(options);\n\t\t\t} else if (key === 'lights') {\n\t\t\t\treturn LitOptionsUtils.generateLightsKey(options);\n\t\t\t}\n\t\t\treturn key + options[key];\n\t\t}).join('\\n')}`;\n\t},\n\tgenerateLightsKey(options) {\n\t\treturn `lights:${options.lights.map(light => {\n\t\t\treturn !options.clusteredLightingEnabled || light._type === LIGHTTYPE_DIRECTIONAL ? `${light.key},` : '';\n\t\t}).join('')}`;\n\t},\n\tgenerateChunksKey(options) {\n\t\tvar _options$chunks;\n\t\treturn `chunks:\\n${Object.keys((_options$chunks = options.chunks) != null ? _options$chunks : {}).sort().map(key => key + options.chunks[key]).join('')}`;\n\t}\n};\n\nexport { LitOptionsUtils };\n","import { BLEND_NONE, DITHER_NONE, FOG_NONE, GAMMA_NONE } from '../../constants.js';\n\nclass LitShaderOptions {\n\tconstructor() {\n\t\tthis.hasTangents = false;\n\t\tthis.chunks = {};\n\t\tthis.pass = 0;\n\t\tthis.alphaTest = false;\n\t\tthis.blendType = BLEND_NONE;\n\t\tthis.separateAmbient = false;\n\t\tthis.screenSpace = false;\n\t\tthis.skin = false;\n\t\tthis.useInstancing = false;\n\t\tthis.useMorphPosition = false;\n\t\tthis.useMorphNormal = false;\n\t\tthis.useMorphTextureBased = false;\n\t\tthis.nineSlicedMode = 0;\n\t\tthis.clusteredLightingEnabled = true;\n\t\tthis.clusteredLightingCookiesEnabled = false;\n\t\tthis.clusteredLightingShadowsEnabled = false;\n\t\tthis.clusteredLightingShadowType = 0;\n\t\tthis.clusteredLightingAreaLightsEnabled = false;\n\t\tthis.vertexColors = false;\n\t\tthis.lightMapEnabled = false;\n\t\tthis.dirLightMapEnabled = false;\n\t\tthis.useHeights = false;\n\t\tthis.useNormals = false;\n\t\tthis.useClearCoatNormals = false;\n\t\tthis.useAo = false;\n\t\tthis.diffuseMapEnabled = false;\n\t\tthis.useAmbientTint = false;\n\t\tthis.customFragmentShader = null;\n\t\tthis.pixelSnap = false;\n\t\tthis.shadingModel = 0;\n\t\tthis.ambientSH = false;\n\t\tthis.fastTbn = false;\n\t\tthis.twoSidedLighting = false;\n\t\tthis.occludeDirect = false;\n\t\tthis.occludeSpecular = 0;\n\t\tthis.occludeSpecularFloat = false;\n\t\tthis.useMsdf = false;\n\t\tthis.msdfTextAttribute = false;\n\t\tthis.alphaToCoverage = false;\n\t\tthis.opacityFadesSpecular = false;\n\t\tthis.opacityDither = DITHER_NONE;\n\t\tthis.opacityShadowDither = DITHER_NONE;\n\t\tthis.cubeMapProjection = 0;\n\t\tthis.conserveEnergy = false;\n\t\tthis.useSpecular = false;\n\t\tthis.useSpecularityFactor = false;\n\t\tthis.enableGGXSpecular = false;\n\t\tthis.fresnelModel = 0;\n\t\tthis.useRefraction = false;\n\t\tthis.useClearCoat = false;\n\t\tthis.useSheen = false;\n\t\tthis.useIridescence = false;\n\t\tthis.useMetalness = false;\n\t\tthis.useDynamicRefraction = false;\n\t\tthis.dispersion = false;\n\t\tthis.fog = FOG_NONE;\n\t\tthis.gamma = GAMMA_NONE;\n\t\tthis.toneMap = -1;\n\t\tthis.fixSeams = false;\n\t\tthis.reflectionSource = null;\n\t\tthis.reflectionEncoding = null;\n\t\tthis.reflectionCubemapEncoding = null;\n\t\tthis.ambientSource = 'constant';\n\t\tthis.ambientEncoding = null;\n\t\tthis.skyboxIntensity = 1.0;\n\t\tthis.useCubeMapRotation = false;\n\t\tthis.lightMapWithoutAmbient = false;\n\t\tthis.lights = [];\n\t\tthis.noShadow = false;\n\t\tthis.lightMaskDynamic = 0x0;\n\t\tthis.userAttributes = {};\n\t}\n}\n\nexport { LitShaderOptions };\n","import { SEMANTIC_POSITION, SEMANTIC_ATTR12, SEMANTIC_ATTR13, SEMANTIC_ATTR14, SEMANTIC_ATTR15, SEMANTIC_NORMAL, SEMANTIC_TANGENT, SEMANTIC_COLOR, SEMANTIC_ATTR8, SEMANTIC_ATTR9, SEMANTIC_ATTR10, SEMANTIC_ATTR11, SEMANTIC_BLENDWEIGHT, SEMANTIC_BLENDINDICES, PIXELFORMAT_RGBA8, SHADERTAG_MATERIAL, SEMANTIC_TEXCOORD0, SEMANTIC_TEXCOORD1 } from '../../../platform/graphics/constants.js';\nimport { shaderChunks } from '../chunks/chunks.js';\nimport { ChunkUtils } from '../chunk-utils.js';\nimport { SPRITE_RENDERMODE_SLICED, SPRITE_RENDERMODE_TILED, LIGHTSHAPE_SPHERE, LIGHTSHAPE_DISK, LIGHTSHAPE_RECT, SHADER_DEPTH, SHADER_PREPASS_VELOCITY, LIGHTTYPE_DIRECTIONAL, SHADOW_VSM32, LIGHTTYPE_OMNI, SHADOW_PCSS, SHADOW_VSM8, LIGHTSHAPE_PUNCTUAL, LIGHTTYPE_SPOT, FRESNEL_SCHLICK, SPECOCC_GLOSSDEPENDENT, SPECOCC_AO, SHADOW_PCF3, SHADOW_PCF5, SHADOW_PCF1, SHADOW_VSM16, SPECULAR_PHONG, shadowTypeToString, LIGHTFALLOFF_LINEAR, BLEND_NORMAL, BLEND_PREMULTIPLIED, BLEND_ADDITIVEALPHA, SHADER_PICK } from '../../constants.js';\nimport { LightsBuffer } from '../../lighting/lights-buffer.js';\nimport { ShaderPass } from '../../shader-pass.js';\nimport { ShaderUtils } from '../../../platform/graphics/shader-utils.js';\nimport { ChunkBuilder } from '../chunk-builder.js';\nimport { ShaderGenerator } from './shader-generator.js';\n\nconst builtinAttributes = {\n\tvertex_normal: SEMANTIC_NORMAL,\n\tvertex_tangent: SEMANTIC_TANGENT,\n\tvertex_texCoord0: SEMANTIC_TEXCOORD0,\n\tvertex_texCoord1: SEMANTIC_TEXCOORD1,\n\tvertex_color: SEMANTIC_COLOR,\n\tvertex_boneWeights: SEMANTIC_BLENDWEIGHT,\n\tvertex_boneIndices: SEMANTIC_BLENDINDICES\n};\nconst builtinVaryings = {\n\tvVertexColor: 'vec4',\n\tvPositionW: 'vec3',\n\tvNormalV: 'vec3',\n\tvNormalW: 'vec3',\n\tvTangentW: 'vec3',\n\tvBinormalW: 'vec3',\n\tvObjectSpaceUpW: 'vec3',\n\tvUv0: 'vec2',\n\tvUv1: 'vec2'\n};\nclass LitShader {\n\tconstructor(device, options) {\n\t\tthis.device = device;\n\t\tthis.options = options;\n\t\tthis.attributes = {\n\t\t\tvertex_position: SEMANTIC_POSITION\n\t\t};\n\t\tif (options.userAttributes) {\n\t\t\tfor (const [semantic, name] of Object.entries(options.userAttributes)) {\n\t\t\t\tthis.attributes[name] = semantic;\n\t\t\t}\n\t\t}\n\t\tif (options.chunks) {\n\t\t\tconst userChunks = options.chunks;\n\t\t\tthis.chunks = Object.create(shaderChunks);\n\t\t\tfor (const chunkName in shaderChunks) {\n\t\t\t\tif (userChunks.hasOwnProperty(chunkName)) {\n\t\t\t\t\tconst chunk = userChunks[chunkName];\n\t\t\t\t\tfor (const a in builtinAttributes) {\n\t\t\t\t\t\tif (builtinAttributes.hasOwnProperty(a) && chunk.indexOf(a) >= 0) {\n\t\t\t\t\t\t\tthis.attributes[a] = builtinAttributes[a];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.chunks[chunkName] = chunk;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthis.chunks = shaderChunks;\n\t\t}\n\t\tthis.shaderPassInfo = ShaderPass.get(this.device).getByIndex(options.pass);\n\t\tthis.shadowPass = this.shaderPassInfo.isShadow;\n\t\tthis.lighting = options.lights.length > 0 || options.dirLightMapEnabled || options.clusteredLightingEnabled;\n\t\tthis.reflections = !!options.reflectionSource;\n\t\tthis.needsNormal = this.lighting || this.reflections || options.useSpecular || options.ambientSH || options.useHeights || options.enableGGXSpecular || options.clusteredLightingEnabled && !this.shadowPass || options.useClearCoatNormals;\n\t\tthis.needsNormal = this.needsNormal && !this.shadowPass;\n\t\tthis.needsSceneColor = options.useDynamicRefraction;\n\t\tthis.needsScreenSize = options.useDynamicRefraction;\n\t\tthis.needsTransforms = options.useDynamicRefraction;\n\t\tthis.varyings = '';\n\t\tthis.varyingDefines = '';\n\t\tthis.vshader = null;\n\t\tthis.frontendDecl = null;\n\t\tthis.frontendCode = null;\n\t\tthis.frontendFunc = null;\n\t\tthis.lightingUv = null;\n\t\tthis.defines = [];\n\t\tthis.fshader = null;\n\t}\n\t_vsAddBaseCode(code, chunks, options) {\n\t\tcode += chunks.baseVS;\n\t\tif (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED || options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {\n\t\t\tcode += chunks.baseNineSlicedVS;\n\t\t}\n\t\treturn code;\n\t}\n\t_vsAddTransformCode(code, device, chunks, options) {\n\t\tcode += this.chunks.transformVS;\n\t\treturn code;\n\t}\n\t_setMapTransform(codes, name, id, uv) {\n\t\tconst checkId = id + uv * 100;\n\t\tif (!codes[3][checkId]) {\n\t\t\tconst varName = `texture_${name}MapTransform`;\n\t\t\tcodes[0] += `uniform vec3 ${varName}0;\\n`;\n\t\t\tcodes[0] += `uniform vec3 ${varName}1;\\n`;\n\t\t\tcodes[1] += `varying vec2 vUV${uv}_${id};\\n`;\n\t\t\tcodes[2] += `   vUV${uv}_${id} = vec2(dot(vec3(uv${uv}, 1), ${varName}0), dot(vec3(uv${uv}, 1), ${varName}1));\\n`;\n\t\t\tcodes[3][checkId] = true;\n\t\t}\n\t\treturn codes;\n\t}\n\t_fsGetBaseCode() {\n\t\tconst options = this.options;\n\t\tconst chunks = this.chunks;\n\t\tlet result = this.chunks.basePS;\n\t\tif (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {\n\t\t\tresult += chunks.baseNineSlicedPS;\n\t\t} else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {\n\t\t\tresult += chunks.baseNineSlicedTiledPS;\n\t\t}\n\t\treturn result;\n\t}\n\t_fsGetStartCode(code, device, chunks, options) {\n\t\tlet result = chunks.startPS;\n\t\tif (options.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {\n\t\t\tresult += chunks.startNineSlicedPS;\n\t\t} else if (options.nineSlicedMode === SPRITE_RENDERMODE_TILED) {\n\t\t\tresult += chunks.startNineSlicedTiledPS;\n\t\t}\n\t\treturn result;\n\t}\n\t_getLightSourceShapeString(shape) {\n\t\tswitch (shape) {\n\t\t\tcase LIGHTSHAPE_RECT:\n\t\t\t\treturn 'Rect';\n\t\t\tcase LIGHTSHAPE_DISK:\n\t\t\t\treturn 'Disk';\n\t\t\tcase LIGHTSHAPE_SPHERE:\n\t\t\t\treturn 'Sphere';\n\t\t\tdefault:\n\t\t\t\treturn '';\n\t\t}\n\t}\n\tgenerateVertexShader(useUv, useUnmodifiedUv, mapTransforms) {\n\t\tconst device = this.device;\n\t\tconst options = this.options;\n\t\tconst chunks = this.chunks;\n\t\tlet code = '';\n\t\tlet codeBody = '';\n\t\tcode = this._vsAddBaseCode(code, chunks, options);\n\t\tcodeBody += '   vPositionW    = getWorldPosition();\\n';\n\t\tif (this.options.pass === SHADER_DEPTH || this.options.pass === SHADER_PREPASS_VELOCITY) {\n\t\t\tcode += 'varying float vDepth;\\n';\n\t\t\tcode += '#ifndef VIEWMATRIX\\n';\n\t\t\tcode += '#define VIEWMATRIX\\n';\n\t\t\tcode += 'uniform mat4 matrix_view;\\n';\n\t\t\tcode += '#endif\\n';\n\t\t\tcode += '#ifndef CAMERAPLANES\\n';\n\t\t\tcode += '#define CAMERAPLANES\\n';\n\t\t\tcode += 'uniform vec4 camera_params;\\n\\n';\n\t\t\tcode += '#endif\\n';\n\t\t\tcodeBody += '    vDepth = -(matrix_view * vec4(vPositionW,1.0)).z * camera_params.x;\\n';\n\t\t}\n\t\tif (this.options.pass === SHADER_PREPASS_VELOCITY) ;\n\t\tif (this.options.useInstancing) {\n\t\t\tthis.attributes.instance_line1 = SEMANTIC_ATTR12;\n\t\t\tthis.attributes.instance_line2 = SEMANTIC_ATTR13;\n\t\t\tthis.attributes.instance_line3 = SEMANTIC_ATTR14;\n\t\t\tthis.attributes.instance_line4 = SEMANTIC_ATTR15;\n\t\t\tcode += chunks.instancingVS;\n\t\t}\n\t\tif (this.needsNormal) {\n\t\t\tthis.attributes.vertex_normal = SEMANTIC_NORMAL;\n\t\t\tcodeBody += '   vNormalW = getNormal();\\n';\n\t\t\tif (options.reflectionSource === 'sphereMap' && device.fragmentUniformsCount <= 16) {\n\t\t\t\tcode += chunks.viewNormalVS;\n\t\t\t\tcodeBody += '   vNormalV    = getViewNormal();\\n';\n\t\t\t}\n\t\t\tif (options.hasTangents && (options.useHeights || options.useNormals || options.enableGGXSpecular)) {\n\t\t\t\tthis.attributes.vertex_tangent = SEMANTIC_TANGENT;\n\t\t\t\tcode += chunks.tangentBinormalVS;\n\t\t\t\tcodeBody += '   vTangentW   = getTangent();\\n';\n\t\t\t\tcodeBody += '   vBinormalW  = getBinormal();\\n';\n\t\t\t} else if (options.enableGGXSpecular || !device.extStandardDerivatives) {\n\t\t\t\tcodeBody += '   vObjectSpaceUpW = normalize(dNormalMatrix * vec3(0, 1, 0));\\n';\n\t\t\t}\n\t\t}\n\t\tconst maxUvSets = 2;\n\t\tfor (let i = 0; i < maxUvSets; i++) {\n\t\t\tif (useUv[i]) {\n\t\t\t\tthis.attributes[`vertex_texCoord${i}`] = `TEXCOORD${i}`;\n\t\t\t\tcode += chunks[`uv${i}VS`];\n\t\t\t\tcodeBody += `   vec2 uv${i} = getUv${i}();\\n`;\n\t\t\t}\n\t\t\tif (useUnmodifiedUv[i]) {\n\t\t\t\tcodeBody += `   vUv${i} = uv${i};\\n`;\n\t\t\t}\n\t\t}\n\t\tconst codes = [code, this.varyings, codeBody, []];\n\t\tmapTransforms.forEach(mapTransform => {\n\t\t\tthis._setMapTransform(codes, mapTransform.name, mapTransform.id, mapTransform.uv);\n\t\t});\n\t\tcode = codes[0];\n\t\tthis.varyings = codes[1];\n\t\tcodeBody = codes[2];\n\t\tif (options.vertexColors) {\n\t\t\tthis.attributes.vertex_color = SEMANTIC_COLOR;\n\t\t\tcodeBody += '   vVertexColor = vertex_color;\\n';\n\t\t}\n\t\tif (options.useMsdf && options.msdfTextAttribute) {\n\t\t\tthis.attributes.vertex_outlineParameters = SEMANTIC_ATTR8;\n\t\t\tthis.attributes.vertex_shadowParameters = SEMANTIC_ATTR9;\n\t\t\tcodeBody += '    unpackMsdfParams();\\n';\n\t\t\tcode += chunks.msdfVS;\n\t\t}\n\t\tif (options.useMorphPosition || options.useMorphNormal) {\n\t\t\tif (options.useMorphTextureBased) {\n\t\t\t\tcode += '#define MORPHING_TEXTURE_BASED\\n';\n\t\t\t\tif (options.useMorphPosition) {\n\t\t\t\t\tcode += '#define MORPHING_TEXTURE_BASED_POSITION\\n';\n\t\t\t\t}\n\t\t\t\tif (options.useMorphNormal) {\n\t\t\t\t\tcode += '#define MORPHING_TEXTURE_BASED_NORMAL\\n';\n\t\t\t\t}\n\t\t\t\tthis.attributes.morph_vertex_id = SEMANTIC_ATTR15;\n\t\t\t\tconst morphIdType = device.isWebGPU ? 'uint' : 'float';\n\t\t\t\tcode += `attribute ${morphIdType} morph_vertex_id;\\n`;\n\t\t\t} else {\n\t\t\t\tcode += '#define MORPHING\\n';\n\t\t\t\tif (options.useMorphPosition) {\n\t\t\t\t\tthis.attributes.morph_pos0 = SEMANTIC_ATTR8;\n\t\t\t\t\tthis.attributes.morph_pos1 = SEMANTIC_ATTR9;\n\t\t\t\t\tthis.attributes.morph_pos2 = SEMANTIC_ATTR10;\n\t\t\t\t\tthis.attributes.morph_pos3 = SEMANTIC_ATTR11;\n\t\t\t\t\tcode += '#define MORPHING_POS03\\n';\n\t\t\t\t\tcode += 'attribute vec3 morph_pos0;\\n';\n\t\t\t\t\tcode += 'attribute vec3 morph_pos1;\\n';\n\t\t\t\t\tcode += 'attribute vec3 morph_pos2;\\n';\n\t\t\t\t\tcode += 'attribute vec3 morph_pos3;\\n';\n\t\t\t\t} else if (options.useMorphNormal) {\n\t\t\t\t\tthis.attributes.morph_nrm0 = SEMANTIC_ATTR8;\n\t\t\t\t\tthis.attributes.morph_nrm1 = SEMANTIC_ATTR9;\n\t\t\t\t\tthis.attributes.morph_nrm2 = SEMANTIC_ATTR10;\n\t\t\t\t\tthis.attributes.morph_nrm3 = SEMANTIC_ATTR11;\n\t\t\t\t\tcode += '#define MORPHING_NRM03\\n';\n\t\t\t\t\tcode += 'attribute vec3 morph_nrm0;\\n';\n\t\t\t\t\tcode += 'attribute vec3 morph_nrm1;\\n';\n\t\t\t\t\tcode += 'attribute vec3 morph_nrm2;\\n';\n\t\t\t\t\tcode += 'attribute vec3 morph_nrm3;\\n';\n\t\t\t\t}\n\t\t\t\tif (!options.useMorphNormal) {\n\t\t\t\t\tthis.attributes.morph_pos4 = SEMANTIC_ATTR12;\n\t\t\t\t\tthis.attributes.morph_pos5 = SEMANTIC_ATTR13;\n\t\t\t\t\tthis.attributes.morph_pos6 = SEMANTIC_ATTR14;\n\t\t\t\t\tthis.attributes.morph_pos7 = SEMANTIC_ATTR15;\n\t\t\t\t\tcode += '#define MORPHING_POS47\\n';\n\t\t\t\t\tcode += 'attribute vec3 morph_pos4;\\n';\n\t\t\t\t\tcode += 'attribute vec3 morph_pos5;\\n';\n\t\t\t\t\tcode += 'attribute vec3 morph_pos6;\\n';\n\t\t\t\t\tcode += 'attribute vec3 morph_pos7;\\n';\n\t\t\t\t} else {\n\t\t\t\t\tthis.attributes.morph_nrm4 = SEMANTIC_ATTR12;\n\t\t\t\t\tthis.attributes.morph_nrm5 = SEMANTIC_ATTR13;\n\t\t\t\t\tthis.attributes.morph_nrm6 = SEMANTIC_ATTR14;\n\t\t\t\t\tthis.attributes.morph_nrm7 = SEMANTIC_ATTR15;\n\t\t\t\t\tcode += '#define MORPHING_NRM47\\n';\n\t\t\t\t\tcode += 'attribute vec3 morph_nrm4;\\n';\n\t\t\t\t\tcode += 'attribute vec3 morph_nrm5;\\n';\n\t\t\t\t\tcode += 'attribute vec3 morph_nrm6;\\n';\n\t\t\t\t\tcode += 'attribute vec3 morph_nrm7;\\n';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (options.skin) {\n\t\t\tthis.attributes.vertex_boneWeights = SEMANTIC_BLENDWEIGHT;\n\t\t\tthis.attributes.vertex_boneIndices = SEMANTIC_BLENDINDICES;\n\t\t\tcode += ShaderGenerator.skinCode(device, chunks);\n\t\t\tcode += '#define SKIN\\n';\n\t\t} else if (options.useInstancing) {\n\t\t\tcode += '#define INSTANCING\\n';\n\t\t}\n\t\tif (options.screenSpace) {\n\t\t\tcode += '#define SCREENSPACE\\n';\n\t\t}\n\t\tif (options.pixelSnap) {\n\t\t\tcode += '#define PIXELSNAP\\n';\n\t\t}\n\t\tcode = this._vsAddTransformCode(code, device, chunks, options);\n\t\tif (this.needsNormal) {\n\t\t\tcode += chunks.normalVS;\n\t\t}\n\t\tcode += '\\n';\n\t\tcode += chunks.startVS;\n\t\tcode += codeBody;\n\t\tcode += chunks.endVS;\n\t\tcode += '}';\n\t\tObject.keys(builtinVaryings).forEach(v => {\n\t\t\tif (code.indexOf(v) >= 0) {\n\t\t\t\tthis.varyings += `varying ${builtinVaryings[v]} ${v};\\n`;\n\t\t\t\tthis.varyingDefines += `#define VARYING_${v.toUpperCase()}\\n`;\n\t\t\t}\n\t\t});\n\t\tconst shaderPassDefines = this.shaderPassInfo.shaderDefines;\n\t\tthis.vshader = shaderPassDefines + this.varyings + code;\n\t}\n\t_fsGetBeginCode() {\n\t\tlet code = this.shaderPassInfo.shaderDefines;\n\t\tfor (let i = 0; i < this.defines.length; i++) {\n\t\t\tcode += `#define ${this.defines[i]}\\n`;\n\t\t}\n\t\treturn code;\n\t}\n\t_fsGetPickPassCode() {\n\t\tlet code = this._fsGetBeginCode();\n\t\tcode += 'uniform vec4 uColor;\\n';\n\t\tcode += this.varyings;\n\t\tcode += this.varyingDefines;\n\t\tcode += this.frontendDecl;\n\t\tcode += this.frontendCode;\n\t\tcode += ShaderGenerator.begin();\n\t\tcode += this.frontendFunc;\n\t\tcode += '    gl_FragColor = uColor;\\n';\n\t\tcode += ShaderGenerator.end();\n\t\treturn code;\n\t}\n\t_fsGetDepthPassCode() {\n\t\tconst chunks = this.chunks;\n\t\tlet code = this._fsGetBeginCode();\n\t\tcode += 'varying float vDepth;\\n';\n\t\tcode += this.varyings;\n\t\tcode += this.varyingDefines;\n\t\tcode += chunks.packDepthPS;\n\t\tcode += this.frontendDecl;\n\t\tcode += this.frontendCode;\n\t\tcode += ShaderGenerator.begin();\n\t\tcode += this.frontendFunc;\n\t\tcode += '    gl_FragColor = packFloat(vDepth);\\n';\n\t\tcode += ShaderGenerator.end();\n\t\treturn code;\n\t}\n\t_fsGetPrePassVelocityCode() {\n\t\treturn this._fsGetDepthPassCode();\n\t}\n\t_fsGetShadowPassCode() {\n\t\tconst device = this.device;\n\t\tconst options = this.options;\n\t\tconst chunks = this.chunks;\n\t\tconst varyings = this.varyings;\n\t\tconst lightType = this.shaderPassInfo.lightType;\n\t\tlet shadowType = this.shaderPassInfo.shadowType;\n\t\tif (lightType !== LIGHTTYPE_DIRECTIONAL && options.clusteredLightingEnabled) {\n\t\t\tif (shadowType === SHADOW_VSM8 || shadowType === SHADOW_VSM16 || shadowType === SHADOW_VSM32 || shadowType === SHADOW_PCSS) {\n\t\t\t\tshadowType = SHADOW_PCF3;\n\t\t\t}\n\t\t}\n\t\tlet code = this._fsGetBeginCode();\n\t\tif (device.extStandardDerivatives && device.isWebGL1) {\n\t\t\tcode += 'uniform vec2 polygonOffset;\\n';\n\t\t}\n\t\tif (shadowType === SHADOW_VSM32) {\n\t\t\tif (device.textureFloatHighPrecision) {\n\t\t\t\tcode += '#define VSM_EXPONENT 15.0\\n\\n';\n\t\t\t} else {\n\t\t\t\tcode += '#define VSM_EXPONENT 5.54\\n\\n';\n\t\t\t}\n\t\t} else if (shadowType === SHADOW_VSM16) {\n\t\t\tcode += '#define VSM_EXPONENT 5.54\\n\\n';\n\t\t}\n\t\tif (lightType !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\tcode += 'uniform vec3 view_position;\\n';\n\t\t\tcode += 'uniform float light_radius;\\n';\n\t\t}\n\t\tcode += varyings;\n\t\tcode += this.varyingDefines;\n\t\tcode += this.frontendDecl;\n\t\tcode += this.frontendCode;\n\t\tconst mayPackDepth = shadowType === SHADOW_PCF1 || shadowType === SHADOW_PCF3 || shadowType === SHADOW_PCF5 || shadowType === SHADOW_PCSS;\n\t\tconst mustPackDepth = lightType === LIGHTTYPE_OMNI && shadowType !== SHADOW_PCSS && !options.clusteredLightingEnabled;\n\t\tconst usePackedDepth = mayPackDepth && !device.supportsDepthShadow || mustPackDepth;\n\t\tif (usePackedDepth) {\n\t\t\tcode += chunks.packDepthPS;\n\t\t} else if (shadowType === SHADOW_VSM8) {\n\t\t\tcode += 'vec2 encodeFloatRG( float v ) {\\n';\n\t\t\tcode += '    vec2 enc = vec2(1.0, 255.0) * v;\\n';\n\t\t\tcode += '    enc = fract(enc);\\n';\n\t\t\tcode += '    enc -= enc.yy * vec2(1.0/255.0, 1.0/255.0);\\n';\n\t\t\tcode += '    return enc;\\n';\n\t\t\tcode += '}\\n\\n';\n\t\t}\n\t\tif (shadowType === SHADOW_PCSS) {\n\t\t\tcode += shaderChunks.linearizeDepthPS;\n\t\t}\n\t\tcode += ShaderGenerator.begin();\n\t\tcode += this.frontendFunc;\n\t\tconst isVsm = shadowType === SHADOW_VSM8 || shadowType === SHADOW_VSM16 || shadowType === SHADOW_VSM32;\n\t\tconst applySlopeScaleBias = device.isWebGL1 && device.extStandardDerivatives;\n\t\tconst usePerspectiveDepth = lightType === LIGHTTYPE_DIRECTIONAL || !isVsm && lightType === LIGHTTYPE_SPOT;\n\t\tlet hasModifiedDepth = false;\n\t\tif (usePerspectiveDepth) {\n\t\t\tcode += '    float depth = gl_FragCoord.z;\\n';\n\t\t} else {\n\t\t\tcode += '    float depth = min(distance(view_position, vPositionW) / light_radius, 0.99999);\\n';\n\t\t\thasModifiedDepth = true;\n\t\t}\n\t\tif (applySlopeScaleBias) {\n\t\t\tcode += '    float minValue = 2.3374370500153186e-10; //(1.0 / 255.0) / (256.0 * 256.0 * 256.0);\\n';\n\t\t\tcode += '    depth += polygonOffset.x * max(abs(dFdx(depth)), abs(dFdy(depth))) + minValue * polygonOffset.y;\\n';\n\t\t\thasModifiedDepth = true;\n\t\t}\n\t\tif (usePackedDepth) {\n\t\t\tcode += '    gl_FragColor = packFloat(depth);\\n';\n\t\t} else if (!isVsm) {\n\t\t\tconst exportR32 = shadowType === SHADOW_PCSS;\n\t\t\tif (exportR32) {\n\t\t\t\tcode += '    gl_FragColor.r = depth;\\n';\n\t\t\t} else {\n\t\t\t\tif (hasModifiedDepth) {\n\t\t\t\t\tcode += '    gl_FragDepth = depth;\\n';\n\t\t\t\t}\n\t\t\t\tcode += '    gl_FragColor = vec4(1.0);\\n';\n\t\t\t}\n\t\t} else if (shadowType === SHADOW_VSM8) {\n\t\t\tcode += '    gl_FragColor = vec4(encodeFloatRG(depth), encodeFloatRG(depth*depth));\\n';\n\t\t} else {\n\t\t\tcode += chunks.storeEVSMPS;\n\t\t}\n\t\tcode += ShaderGenerator.end();\n\t\treturn code;\n\t}\n\t_fsGetLitPassCode() {\n\t\tconst device = this.device;\n\t\tconst options = this.options;\n\t\tconst chunks = this.chunks;\n\t\tconst decl = new ChunkBuilder();\n\t\tconst func = new ChunkBuilder();\n\t\tconst backend = new ChunkBuilder();\n\t\tconst code = new ChunkBuilder();\n\t\tif (options.opacityFadesSpecular === false) {\n\t\t\tdecl.append('uniform float material_alphaFade;');\n\t\t}\n\t\tif (options.useSpecular) {\n\t\t\tthis.defines.push('LIT_SPECULAR');\n\t\t\tif (this.reflections) {\n\t\t\t\tthis.defines.push('LIT_REFLECTIONS');\n\t\t\t}\n\t\t\tif (options.useClearCoat) {\n\t\t\t\tthis.defines.push('LIT_CLEARCOAT');\n\t\t\t}\n\t\t\tif (options.fresnelModel > 0) {\n\t\t\t\tthis.defines.push('LIT_SPECULAR_FRESNEL');\n\t\t\t}\n\t\t\tif (options.conserveEnergy) {\n\t\t\t\tthis.defines.push('LIT_CONSERVE_ENERGY');\n\t\t\t}\n\t\t\tif (options.useSheen) {\n\t\t\t\tthis.defines.push('LIT_SHEEN');\n\t\t\t}\n\t\t\tif (options.useIridescence) {\n\t\t\t\tthis.defines.push('LIT_IRIDESCENCE');\n\t\t\t}\n\t\t}\n\t\tconst shadowTypeUsed = [];\n\t\tlet numShadowLights = 0;\n\t\tlet shadowedDirectionalLightUsed = false;\n\t\tlet useVsm = false;\n\t\tlet usePcss = false;\n\t\tlet hasAreaLights = options.lights.some(light => {\n\t\t\treturn light._shape && light._shape !== LIGHTSHAPE_PUNCTUAL;\n\t\t});\n\t\tif (options.clusteredLightingEnabled && options.clusteredLightingAreaLightsEnabled) {\n\t\t\thasAreaLights = true;\n\t\t}\n\t\tif (hasAreaLights || options.clusteredLightingEnabled) {\n\t\t\tlet areaLutsPrecision = 'highp';\n\t\t\tif (device.areaLightLutFormat === PIXELFORMAT_RGBA8) {\n\t\t\t\tdecl.append('#define AREA_R8_G8_B8_A8_LUTS');\n\t\t\t\tareaLutsPrecision = 'lowp';\n\t\t\t}\n\t\t\tdecl.append('#define AREA_LIGHTS');\n\t\t\tdecl.append(`uniform ${areaLutsPrecision} sampler2D areaLightsLutTex1;`);\n\t\t\tdecl.append(`uniform ${areaLutsPrecision} sampler2D areaLightsLutTex2;`);\n\t\t}\n\t\tfor (let i = 0; i < options.lights.length; i++) {\n\t\t\tconst light = options.lights[i];\n\t\t\tconst lightType = light._type;\n\t\t\tif (options.clusteredLightingEnabled && lightType !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst lightShape = hasAreaLights && light._shape ? light._shape : LIGHTSHAPE_PUNCTUAL;\n\t\t\tdecl.append(`uniform vec3 light${i}_color;`);\n\t\t\tif (light._shadowType === SHADOW_PCSS && light.castShadows && !options.noShadow) {\n\t\t\t\tdecl.append(`uniform float light${i}_shadowSearchArea;`);\n\t\t\t\tdecl.append(`uniform vec4 light${i}_cameraParams;`);\n\t\t\t}\n\t\t\tif (lightType === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\tdecl.append(`uniform vec3 light${i}_direction;`);\n\t\t\t} else {\n\t\t\t\tdecl.append(`uniform vec3 light${i}_position;`);\n\t\t\t\tdecl.append(`uniform float light${i}_radius;`);\n\t\t\t\tif (lightType === LIGHTTYPE_SPOT) {\n\t\t\t\t\tdecl.append(`uniform vec3 light${i}_direction;`);\n\t\t\t\t\tdecl.append(`uniform float light${i}_innerConeAngle;`);\n\t\t\t\t\tdecl.append(`uniform float light${i}_outerConeAngle;`);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lightShape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\t\tif (lightType === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tdecl.append(`uniform vec3 light${i}_position;`);\n\t\t\t\t}\n\t\t\t\tdecl.append(`uniform vec3 light${i}_halfWidth;`);\n\t\t\t\tdecl.append(`uniform vec3 light${i}_halfHeight;`);\n\t\t\t}\n\t\t\tif (light.castShadows && !options.noShadow) {\n\t\t\t\tdecl.append(`uniform mat4 light${i}_shadowMatrix;`);\n\t\t\t\tdecl.append(`uniform float light${i}_shadowIntensity;`);\n\t\t\t\tif (lightType === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tdecl.append(`uniform mat4 light${i}_shadowMatrixPalette[4];`);\n\t\t\t\t\tdecl.append(`uniform float light${i}_shadowCascadeDistances[4];`);\n\t\t\t\t\tdecl.append(`uniform float light${i}_shadowCascadeCount;`);\n\t\t\t\t}\n\t\t\t\tdecl.append(`uniform vec4 light${i}_shadowParams;`);\n\t\t\t\tif (lightType === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tshadowedDirectionalLightUsed = true;\n\t\t\t\t}\n\t\t\t\tif (lightType === LIGHTTYPE_OMNI) {\n\t\t\t\t\tdecl.append(`uniform samplerCube light${i}_shadowMap;`);\n\t\t\t\t} else {\n\t\t\t\t\tif (light._isPcf && device.supportsDepthShadow) {\n\t\t\t\t\t\tdecl.append(`uniform sampler2DShadow light${i}_shadowMap;`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdecl.append(`uniform sampler2D light${i}_shadowMap;`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnumShadowLights++;\n\t\t\t\tshadowTypeUsed[light._shadowType] = true;\n\t\t\t\tif (light._isVsm) useVsm = true;\n\t\t\t\tif (light._shadowType === SHADOW_PCSS) usePcss = true;\n\t\t\t}\n\t\t\tif (light._cookie) {\n\t\t\t\tif (light._cookie._cubemap) {\n\t\t\t\t\tif (lightType === LIGHTTYPE_OMNI) {\n\t\t\t\t\t\tdecl.append(`uniform samplerCube light${i}_cookie;`);\n\t\t\t\t\t\tdecl.append(`uniform float light${i}_cookieIntensity;`);\n\t\t\t\t\t\tif (!light.castShadows || options.noShadow) {\n\t\t\t\t\t\t\tdecl.append(`uniform mat4 light${i}_shadowMatrix;`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (lightType === LIGHTTYPE_SPOT) {\n\t\t\t\t\t\tdecl.append(`uniform sampler2D light${i}_cookie;`);\n\t\t\t\t\t\tdecl.append(`uniform float light${i}_cookieIntensity;`);\n\t\t\t\t\t\tif (!light.castShadows || options.noShadow) {\n\t\t\t\t\t\t\tdecl.append(`uniform mat4 light${i}_shadowMatrix;`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (light._cookieTransform) {\n\t\t\t\t\t\t\tdecl.append(`uniform vec4 light${i}_cookieMatrix;`);\n\t\t\t\t\t\t\tdecl.append(`uniform vec2 light${i}_cookieOffset;`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst hasTBN = this.needsNormal && (options.useNormals || options.useClearCoatNormals || options.enableGGXSpecular && !options.useHeights);\n\t\tif (hasTBN) {\n\t\t\tif (options.hasTangents) {\n\t\t\t\tfunc.append(options.fastTbn ? chunks.TBNfastPS : chunks.TBNPS);\n\t\t\t} else {\n\t\t\t\tif (device.extStandardDerivatives && (options.useNormals || options.useClearCoatNormals)) {\n\t\t\t\t\tfunc.append(chunks.TBNderivativePS.replace(/\\$UV/g, this.lightingUv));\n\t\t\t\t} else {\n\t\t\t\t\tfunc.append(chunks.TBNObjectSpacePS);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.twoSidedLighting) {\n\t\t\t\tfunc.append(chunks.twoSidedLightingPS);\n\t\t\t}\n\t\t}\n\t\tfunc.append(chunks.sphericalPS);\n\t\tfunc.append(chunks.decodePS);\n\t\tfunc.append(ShaderGenerator.gammaCode(options.gamma, chunks));\n\t\tfunc.append(ShaderGenerator.tonemapCode(options.toneMap, chunks));\n\t\tfunc.append(ShaderGenerator.fogCode(options.fog, chunks));\n\t\tfunc.append(this.frontendCode);\n\t\tif (options.useCubeMapRotation) {\n\t\t\tdecl.append('#define CUBEMAP_ROTATION');\n\t\t}\n\t\tif (this.needsNormal) {\n\t\t\tfunc.append(chunks.cubeMapRotatePS);\n\t\t\tfunc.append(options.cubeMapProjection > 0 ? chunks.cubeMapProjectBoxPS : chunks.cubeMapProjectNonePS);\n\t\t\tfunc.append(options.skyboxIntensity ? chunks.envMultiplyPS : chunks.envConstPS);\n\t\t}\n\t\tif (this.lighting && options.useSpecular || this.reflections) {\n\t\t\tif (options.useMetalness) {\n\t\t\t\tfunc.append(chunks.metalnessModulatePS);\n\t\t\t}\n\t\t\tif (options.fresnelModel === FRESNEL_SCHLICK) {\n\t\t\t\tfunc.append(chunks.fresnelSchlickPS);\n\t\t\t}\n\t\t\tif (options.useIridescence) {\n\t\t\t\tfunc.append(chunks.iridescenceDiffractionPS);\n\t\t\t}\n\t\t}\n\t\tif (options.useAo) {\n\t\t\tfunc.append(chunks.aoDiffuseOccPS);\n\t\t\tswitch (options.occludeSpecular) {\n\t\t\t\tcase SPECOCC_AO:\n\t\t\t\t\tfunc.append(options.occludeSpecularFloat ? chunks.aoSpecOccSimplePS : chunks.aoSpecOccConstSimplePS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase SPECOCC_GLOSSDEPENDENT:\n\t\t\t\t\tfunc.append(options.occludeSpecularFloat ? chunks.aoSpecOccPS : chunks.aoSpecOccConstPS);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (options.reflectionSource === 'envAtlasHQ') {\n\t\t\tfunc.append(options.fixSeams ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS);\n\t\t\tfunc.append(chunks.envAtlasPS);\n\t\t\tfunc.append(chunks.reflectionEnvHQPS.replace(/\\$DECODE_CUBEMAP/g, ChunkUtils.decodeFunc(options.reflectionCubemapEncoding)).replace(/\\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding)));\n\t\t} else if (options.reflectionSource === 'envAtlas') {\n\t\t\tfunc.append(chunks.envAtlasPS);\n\t\t\tfunc.append(chunks.reflectionEnvPS.replace(/\\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding)));\n\t\t} else if (options.reflectionSource === 'cubeMap') {\n\t\t\tfunc.append(options.fixSeams ? chunks.fixCubemapSeamsStretchPS : chunks.fixCubemapSeamsNonePS);\n\t\t\tfunc.append(chunks.reflectionCubePS.replace(/\\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding)));\n\t\t} else if (options.reflectionSource === 'sphereMap') {\n\t\t\tfunc.append(chunks.reflectionSpherePS.replace(/\\$DECODE/g, ChunkUtils.decodeFunc(options.reflectionEncoding)));\n\t\t}\n\t\tif (this.reflections) {\n\t\t\tif (options.useClearCoat) {\n\t\t\t\tfunc.append(chunks.reflectionCCPS);\n\t\t\t}\n\t\t\tif (options.useSheen) {\n\t\t\t\tfunc.append(chunks.reflectionSheenPS);\n\t\t\t}\n\t\t}\n\t\tif (options.useRefraction) {\n\t\t\tif (options.useDynamicRefraction) {\n\t\t\t\tif (options.dispersion) {\n\t\t\t\t\tdecl.append('uniform float material_dispersion;');\n\t\t\t\t\tdecl.append('#define DISPERSION\\n');\n\t\t\t\t}\n\t\t\t\tfunc.append(chunks.refractionDynamicPS);\n\t\t\t} else if (this.reflections) {\n\t\t\t\tfunc.append(chunks.refractionCubePS);\n\t\t\t}\n\t\t}\n\t\tif (options.useSheen) {\n\t\t\tfunc.append(chunks.lightSheenPS);\n\t\t}\n\t\tif (options.clusteredLightingEnabled) {\n\t\t\tfunc.append(chunks.clusteredLightUtilsPS);\n\t\t\tif (options.clusteredLightingCookiesEnabled) {\n\t\t\t\tfunc.append(chunks.clusteredLightCookiesPS);\n\t\t\t}\n\t\t\tif (options.clusteredLightingShadowsEnabled && !options.noShadow) {\n\t\t\t\tshadowTypeUsed[SHADOW_PCF3] = true;\n\t\t\t\tshadowTypeUsed[SHADOW_PCF5] = true;\n\t\t\t\tshadowTypeUsed[SHADOW_PCSS] = true;\n\t\t\t}\n\t\t}\n\t\tif (numShadowLights > 0 || options.clusteredLightingEnabled) {\n\t\t\tif (shadowedDirectionalLightUsed) {\n\t\t\t\tfunc.append(chunks.shadowCascadesPS);\n\t\t\t}\n\t\t\tif (shadowTypeUsed[SHADOW_PCF1] || shadowTypeUsed[SHADOW_PCF3]) {\n\t\t\t\tfunc.append(chunks.shadowStandardPS);\n\t\t\t}\n\t\t\tif (shadowTypeUsed[SHADOW_PCF5] && !device.isWebGL1) {\n\t\t\t\tfunc.append(chunks.shadowStandardGL2PS);\n\t\t\t}\n\t\t\tif (useVsm) {\n\t\t\t\tfunc.append(chunks.shadowVSM_commonPS);\n\t\t\t\tif (shadowTypeUsed[SHADOW_VSM8]) {\n\t\t\t\t\tfunc.append(chunks.shadowVSM8PS);\n\t\t\t\t}\n\t\t\t\tif (shadowTypeUsed[SHADOW_VSM16]) {\n\t\t\t\t\tfunc.append(device.extTextureHalfFloatLinear ? chunks.shadowEVSMPS.replace(/\\$/g, '16') : chunks.shadowEVSMnPS.replace(/\\$/g, '16'));\n\t\t\t\t}\n\t\t\t\tif (shadowTypeUsed[SHADOW_VSM32]) {\n\t\t\t\t\tfunc.append(device.extTextureFloatLinear ? chunks.shadowEVSMPS.replace(/\\$/g, '32') : chunks.shadowEVSMnPS.replace(/\\$/g, '32'));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (usePcss) {\n\t\t\t\tfunc.append(chunks.linearizeDepthPS);\n\t\t\t\tfunc.append(chunks.shadowPCSSPS);\n\t\t\t}\n\t\t\tif (!(device.isWebGL2 || device.isWebGPU || device.extStandardDerivatives)) {\n\t\t\t\tfunc.append(chunks.biasConstPS);\n\t\t\t}\n\t\t}\n\t\tif (options.enableGGXSpecular) func.append('uniform float material_anisotropy;');\n\t\tif (this.lighting) {\n\t\t\tfunc.append(chunks.lightDiffuseLambertPS);\n\t\t\tif (hasAreaLights || options.clusteredLightingAreaLightsEnabled) {\n\t\t\t\tfunc.append(chunks.ltcPS);\n\t\t\t}\n\t\t}\n\t\tlet useOldAmbient = false;\n\t\tif (options.useSpecular) {\n\t\t\tif (this.lighting) {\n\t\t\t\tfunc.append(options.shadingModel === SPECULAR_PHONG ? chunks.lightSpecularPhongPS : options.enableGGXSpecular ? chunks.lightSpecularAnisoGGXPS : chunks.lightSpecularBlinnPS);\n\t\t\t}\n\t\t\tif (!options.fresnelModel && !this.reflections && !options.diffuseMapEnabled) {\n\t\t\t\tdecl.append('uniform vec3 material_ambient;');\n\t\t\t\tdecl.append('#define LIT_OLD_AMBIENT');\n\t\t\t\tuseOldAmbient = true;\n\t\t\t}\n\t\t}\n\t\tfunc.append(chunks.combinePS);\n\t\tif (options.lightMapEnabled) {\n\t\t\tfunc.append(options.useSpecular && options.dirLightMapEnabled ? chunks.lightmapDirAddPS : chunks.lightmapAddPS);\n\t\t}\n\t\tconst addAmbient = !options.lightMapEnabled || options.lightMapWithoutAmbient;\n\t\tif (addAmbient) {\n\t\t\tif (options.ambientSource === 'ambientSH') {\n\t\t\t\tfunc.append(chunks.ambientSHPS);\n\t\t\t} else if (options.ambientSource === 'envAtlas') {\n\t\t\t\tif (options.reflectionSource !== 'envAtlas' && options.reflectionSource !== 'envAtlasHQ') {\n\t\t\t\t\tfunc.append(chunks.envAtlasPS);\n\t\t\t\t}\n\t\t\t\tfunc.append(chunks.ambientEnvPS.replace(/\\$DECODE/g, ChunkUtils.decodeFunc(options.ambientEncoding)));\n\t\t\t} else {\n\t\t\t\tfunc.append(chunks.ambientConstantPS);\n\t\t\t}\n\t\t}\n\t\tif (options.useAmbientTint && !useOldAmbient) {\n\t\t\tdecl.append('uniform vec3 material_ambient;');\n\t\t}\n\t\tif (options.useMsdf) {\n\t\t\tif (!options.msdfTextAttribute) {\n\t\t\t\tdecl.append('#define UNIFORM_TEXT_PARAMETERS');\n\t\t\t}\n\t\t\tfunc.append(chunks.msdfPS);\n\t\t}\n\t\tif (this.needsNormal) {\n\t\t\tfunc.append(chunks.viewDirPS);\n\t\t\tif (options.useSpecular) {\n\t\t\t\tfunc.append(options.enableGGXSpecular ? chunks.reflDirAnisoPS : chunks.reflDirPS);\n\t\t\t}\n\t\t}\n\t\tlet hasPointLights = false;\n\t\tlet usesLinearFalloff = false;\n\t\tlet usesInvSquaredFalloff = false;\n\t\tlet usesSpot = false;\n\t\tlet usesCookie = false;\n\t\tlet usesCookieNow;\n\t\tif (options.clusteredLightingEnabled && this.lighting) {\n\t\t\tusesSpot = true;\n\t\t\thasPointLights = true;\n\t\t\tusesLinearFalloff = true;\n\t\t\tusesCookie = true;\n\t\t\tfunc.append(chunks.floatUnpackingPS);\n\t\t\tif (options.lightMaskDynamic) {\n\t\t\t\tdecl.append('#define CLUSTER_MESH_DYNAMIC_LIGHTS');\n\t\t\t}\n\t\t\tif (options.clusteredLightingCookiesEnabled) {\n\t\t\t\tdecl.append('#define CLUSTER_COOKIES');\n\t\t\t}\n\t\t\tif (options.clusteredLightingShadowsEnabled && !options.noShadow) {\n\t\t\t\tdecl.append('#define CLUSTER_SHADOWS');\n\t\t\t\tdecl.append(`#define CLUSTER_SHADOW_TYPE_${shadowTypeToString[options.clusteredLightingShadowType]}`);\n\t\t\t}\n\t\t\tif (options.clusteredLightingAreaLightsEnabled) {\n\t\t\t\tdecl.append('#define CLUSTER_AREALIGHTS');\n\t\t\t}\n\t\t\tdecl.append(LightsBuffer.getShaderDefines(device));\n\t\t\tif (options.clusteredLightingShadowsEnabled && !options.noShadow) {\n\t\t\t\tfunc.append(chunks.clusteredLightShadowsPS);\n\t\t\t}\n\t\t\tfunc.append(chunks.clusteredLightPS);\n\t\t}\n\t\tcode.append(this._fsGetStartCode(code, device, chunks, options));\n\t\tif (this.needsNormal) {\n\t\t\tcode.append('    dVertexNormalW = normalize(vNormalW);');\n\t\t\tif ((options.useHeights || options.useNormals) && options.hasTangents) {\n\t\t\t\tcode.append('    dTangentW = vTangentW;');\n\t\t\t\tcode.append('    dBinormalW = vBinormalW;');\n\t\t\t}\n\t\t\tcode.append('    getViewDir();');\n\t\t\tif (hasTBN) {\n\t\t\t\tcode.append('    getTBN(dTangentW, dBinormalW, dVertexNormalW);');\n\t\t\t\tif (options.twoSidedLighting) {\n\t\t\t\t\tcode.append('    handleTwoSidedLighting();');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcode.append(this.frontendFunc);\n\t\tif (this.needsNormal) {\n\t\t\tif (options.useSpecular) {\n\t\t\t\tbackend.append('    getReflDir(litArgs_worldNormal, dViewDirW, litArgs_gloss, dTBN);');\n\t\t\t}\n\t\t\tif (options.useClearCoat) {\n\t\t\t\tbackend.append('    ccReflDirW = normalize(-reflect(dViewDirW, litArgs_clearcoat_worldNormal));');\n\t\t\t}\n\t\t}\n\t\tif (this.lighting && options.useSpecular || this.reflections) {\n\t\t\tif (options.useMetalness) {\n\t\t\t\tbackend.append('    float f0 = 1.0 / litArgs_ior; f0 = (f0 - 1.0) / (f0 + 1.0); f0 *= f0;');\n\t\t\t\tbackend.append('    litArgs_specularity = getSpecularModulate(litArgs_specularity, litArgs_albedo, litArgs_metalness, f0);');\n\t\t\t\tbackend.append('    litArgs_albedo = getAlbedoModulate(litArgs_albedo, litArgs_metalness);');\n\t\t\t}\n\t\t\tif (options.useIridescence) {\n\t\t\t\tbackend.append('    vec3 iridescenceFresnel = getIridescence(saturate(dot(dViewDirW, litArgs_worldNormal)), litArgs_specularity, litArgs_iridescence_thickness);');\n\t\t\t}\n\t\t}\n\t\tif (addAmbient) {\n\t\t\tbackend.append('    addAmbient(litArgs_worldNormal);');\n\t\t\tif (options.conserveEnergy && options.useSpecular) {\n\t\t\t\tbackend.append('   dDiffuseLight = dDiffuseLight * (1.0 - litArgs_specularity);');\n\t\t\t}\n\t\t\tif (options.separateAmbient) {\n\t\t\t\tbackend.append(`\n\t\t\t\t\t\t\t\t\t\tvec3 dAmbientLight = dDiffuseLight;\n\t\t\t\t\t\t\t\t\t\tdDiffuseLight = vec3(0);\n\t\t\t\t\t\t\t\t`);\n\t\t\t}\n\t\t}\n\t\tif (options.useAmbientTint && !useOldAmbient) {\n\t\t\tbackend.append('    dDiffuseLight *= material_ambient;');\n\t\t}\n\t\tif (options.useAo && !options.occludeDirect) {\n\t\t\tbackend.append('    occludeDiffuse(litArgs_ao);');\n\t\t}\n\t\tif (options.lightMapEnabled) {\n\t\t\tbackend.append(`    addLightMap(\n\t\t\t\t\t\t\t\tlitArgs_lightmap, \n\t\t\t\t\t\t\t\tlitArgs_lightmapDir, \n\t\t\t\t\t\t\t\tlitArgs_worldNormal, \n\t\t\t\t\t\t\t\tdViewDirW, \n\t\t\t\t\t\t\t\tdReflDirW, \n\t\t\t\t\t\t\t\tlitArgs_gloss, \n\t\t\t\t\t\t\t\tlitArgs_specularity, \n\t\t\t\t\t\t\t\tdVertexNormalW,\n\t\t\t\t\t\t\t\tdTBN\n\t\t\t\t\t\t#if defined(LIT_IRIDESCENCE)\n\t\t\t\t\t\t\t\t, iridescenceFresnel,\n\t\t\t\t\t\t\t\tlitArgs_iridescence_intensity\n\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t);`);\n\t\t}\n\t\tif (this.lighting || this.reflections) {\n\t\t\tif (this.reflections) {\n\t\t\t\tif (options.useClearCoat) {\n\t\t\t\t\tbackend.append('    addReflectionCC(ccReflDirW, litArgs_clearcoat_gloss);');\n\t\t\t\t\tif (options.fresnelModel > 0) {\n\t\t\t\t\t\tbackend.append('    ccFresnel = getFresnelCC(dot(dViewDirW, litArgs_clearcoat_worldNormal));');\n\t\t\t\t\t\tbackend.append('    ccReflection.rgb *= ccFresnel;');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbackend.append('    ccFresnel = 0.0;');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (options.useSpecularityFactor) {\n\t\t\t\t\tbackend.append('    ccReflection.rgb *= litArgs_specularityFactor;');\n\t\t\t\t}\n\t\t\t\tif (options.useSheen) {\n\t\t\t\t\tbackend.append('    addReflectionSheen(litArgs_worldNormal, dViewDirW, litArgs_sheen_gloss);');\n\t\t\t\t}\n\t\t\t\tbackend.append('    addReflection(dReflDirW, litArgs_gloss);');\n\t\t\t\tif (options.fresnelModel > 0) {\n\t\t\t\t\tbackend.append(`    dReflection.rgb *= \n\t\t\t\t\t\t\t\t\t\t\t\tgetFresnel(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tdot(dViewDirW, litArgs_worldNormal), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitArgs_gloss, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitArgs_specularity\n\t\t\t\t\t\t\t\t\t\t\t\t#if defined(LIT_IRIDESCENCE)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t, iridescenceFresnel,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitArgs_iridescence_intensity\n\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t);`);\n\t\t\t\t} else {\n\t\t\t\t\tbackend.append('    dReflection.rgb *= litArgs_specularity;');\n\t\t\t\t}\n\t\t\t\tif (options.useSpecularityFactor) {\n\t\t\t\t\tbackend.append('    dReflection.rgb *= litArgs_specularityFactor;');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasAreaLights) {\n\t\t\t\tbackend.append('    dSpecularLight *= litArgs_specularity;');\n\t\t\t\tif (options.useSpecular) {\n\t\t\t\t\tbackend.append('    calcLTCLightValues(litArgs_gloss, litArgs_worldNormal, dViewDirW, litArgs_specularity, litArgs_clearcoat_gloss, litArgs_clearcoat_worldNormal, litArgs_clearcoat_specularity);');\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (let i = 0; i < options.lights.length; i++) {\n\t\t\t\tconst light = options.lights[i];\n\t\t\t\tconst lightType = light._type;\n\t\t\t\tif (options.clusteredLightingEnabled && lightType !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tusesCookieNow = false;\n\t\t\t\tconst lightShape = hasAreaLights && light._shape ? light.shape : LIGHTSHAPE_PUNCTUAL;\n\t\t\t\tconst shapeString = hasAreaLights && light._shape ? this._getLightSourceShapeString(lightShape) : '';\n\t\t\t\tif (lightShape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\t\t\tbackend.append(`    calc${shapeString}LightValues(light${i}_position, light${i}_halfWidth, light${i}_halfHeight);`);\n\t\t\t\t}\n\t\t\t\tif (lightType === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tbackend.append(`    dLightDirNormW = light${i}_direction;`);\n\t\t\t\t\tbackend.append('    dAtten = 1.0;');\n\t\t\t\t} else {\n\t\t\t\t\tif (light._cookie) {\n\t\t\t\t\t\tif (lightType === LIGHTTYPE_SPOT && !light._cookie._cubemap) {\n\t\t\t\t\t\t\tusesCookie = true;\n\t\t\t\t\t\t\tusesCookieNow = true;\n\t\t\t\t\t\t} else if (lightType === LIGHTTYPE_OMNI && light._cookie._cubemap) {\n\t\t\t\t\t\t\tusesCookie = true;\n\t\t\t\t\t\t\tusesCookieNow = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbackend.append(`    getLightDirPoint(light${i}_position);`);\n\t\t\t\t\thasPointLights = true;\n\t\t\t\t\tif (usesCookieNow) {\n\t\t\t\t\t\tif (lightType === LIGHTTYPE_SPOT) {\n\t\t\t\t\t\t\tbackend.append(`    dAtten3 = getCookie2D${light._cookieFalloff ? '' : 'Clip'}${light._cookieTransform ? 'Xform' : ''}(light${i}_cookie, light${i}_shadowMatrix, light${i}_cookieIntensity${light._cookieTransform ? `, light${i}_cookieMatrix, light${i}_cookieOffset` : ''}).${light._cookieChannel};`);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbackend.append(`    dAtten3 = getCookieCube(light${i}_cookie, light${i}_shadowMatrix, light${i}_cookieIntensity).${light._cookieChannel};`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (lightShape === LIGHTSHAPE_PUNCTUAL) {\n\t\t\t\t\t\tif (light._falloffMode === LIGHTFALLOFF_LINEAR) {\n\t\t\t\t\t\t\tbackend.append(`    dAtten = getFalloffLinear(light${i}_radius, dLightDirW);`);\n\t\t\t\t\t\t\tusesLinearFalloff = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbackend.append(`    dAtten = getFalloffInvSquared(light${i}_radius, dLightDirW);`);\n\t\t\t\t\t\t\tusesInvSquaredFalloff = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbackend.append(`    dAtten = getFalloffWindow(light${i}_radius, dLightDirW);`);\n\t\t\t\t\t\tusesInvSquaredFalloff = true;\n\t\t\t\t\t}\n\t\t\t\t\tbackend.append('    if (dAtten > 0.00001) {');\n\t\t\t\t\tif (lightType === LIGHTTYPE_SPOT) {\n\t\t\t\t\t\tif (!(usesCookieNow && !light._cookieFalloff)) {\n\t\t\t\t\t\t\tbackend.append(`    dAtten *= getSpotEffect(light${i}_direction, light${i}_innerConeAngle, light${i}_outerConeAngle, dLightDirNormW);`);\n\t\t\t\t\t\t\tusesSpot = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lightShape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\t\t\tif (lightType === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\t\tbackend.append('    dAttenD = getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW);');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbackend.append(`    dAttenD = get${shapeString}LightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW) * 16.0;`);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tbackend.append('    dAtten *= getLightDiffuse(litArgs_worldNormal, dViewDirW, dLightDirW, dLightDirNormW);');\n\t\t\t\t}\n\t\t\t\tif (light.castShadows && !options.noShadow) {\n\t\t\t\t\tconst pcssShadows = light._shadowType === SHADOW_PCSS;\n\t\t\t\t\tconst vsmShadows = light._shadowType === SHADOW_VSM8 || light._shadowType === SHADOW_VSM16 || light._shadowType === SHADOW_VSM32;\n\t\t\t\t\tconst pcfShadows = light._shadowType === SHADOW_PCF1 || light._shadowType === SHADOW_PCF3 || light._shadowType === SHADOW_PCF5;\n\t\t\t\t\tlet shadowReadMode = null;\n\t\t\t\t\tlet evsmExp;\n\t\t\t\t\tswitch (light._shadowType) {\n\t\t\t\t\t\tcase SHADOW_VSM8:\n\t\t\t\t\t\t\tshadowReadMode = 'VSM8';\n\t\t\t\t\t\t\tevsmExp = '0.0';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase SHADOW_VSM16:\n\t\t\t\t\t\t\tshadowReadMode = 'VSM16';\n\t\t\t\t\t\t\tevsmExp = '5.54';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase SHADOW_VSM32:\n\t\t\t\t\t\t\tshadowReadMode = 'VSM32';\n\t\t\t\t\t\t\tif (device.textureFloatHighPrecision) {\n\t\t\t\t\t\t\t\tevsmExp = '15.0';\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tevsmExp = '5.54';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase SHADOW_PCF1:\n\t\t\t\t\t\t\tshadowReadMode = 'PCF1x1';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase SHADOW_PCF5:\n\t\t\t\t\t\t\tshadowReadMode = 'PCF5x5';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase SHADOW_PCSS:\n\t\t\t\t\t\t\tshadowReadMode = 'PCSS';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase SHADOW_PCF3:\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tshadowReadMode = 'PCF3x3';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (shadowReadMode !== null) {\n\t\t\t\t\t\tif (light._normalOffsetBias && !light._isVsm) {\n\t\t\t\t\t\t\tfunc.append('#define SHADOW_SAMPLE_NORMAL_OFFSET');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (lightType === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\t\t\tfunc.append('#define SHADOW_SAMPLE_ORTHO');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ((pcfShadows || pcssShadows) && device.isWebGL2 || device.isWebGPU || device.extStandardDerivatives) {\n\t\t\t\t\t\t\tfunc.append('#define SHADOW_SAMPLE_SOURCE_ZBUFFER');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (lightType === LIGHTTYPE_OMNI) {\n\t\t\t\t\t\t\tfunc.append('#define SHADOW_SAMPLE_POINT');\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst coordCode = chunks.shadowSampleCoordPS;\n\t\t\t\t\t\tfunc.append(coordCode.replace('$LIGHT', i));\n\t\t\t\t\t\tfunc.append('#undef SHADOW_SAMPLE_NORMAL_OFFSET');\n\t\t\t\t\t\tfunc.append('#undef SHADOW_SAMPLE_ORTHO');\n\t\t\t\t\t\tfunc.append('#undef SHADOW_SAMPLE_SOURCE_ZBUFFER');\n\t\t\t\t\t\tfunc.append('#undef SHADOW_SAMPLE_POINT');\n\t\t\t\t\t\tlet shadowMatrix = `light${i}_shadowMatrix`;\n\t\t\t\t\t\tif (lightType === LIGHTTYPE_DIRECTIONAL && light.numCascades > 1) {\n\t\t\t\t\t\t\tbackend.append(`    getShadowCascadeMatrix(light${i}_shadowMatrixPalette, light${i}_shadowCascadeDistances, light${i}_shadowCascadeCount);`);\n\t\t\t\t\t\t\tshadowMatrix = 'cascadeShadowMat';\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbackend.append(`    dShadowCoord = getShadowSampleCoord${i}(${shadowMatrix}, light${i}_shadowParams, vPositionW, dLightPosW, dLightDirW, dLightDirNormW, dVertexNormalW);`);\n\t\t\t\t\t\tif (lightType === LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\t\t\tbackend.append(`    fadeShadow(light${i}_shadowCascadeDistances);`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet shadowCoordArgs = `SHADOWMAP_PASS(light${i}_shadowMap), dShadowCoord, light${i}_shadowParams`;\n\t\t\t\t\t\tif (vsmShadows) {\n\t\t\t\t\t\t\tshadowCoordArgs = `${shadowCoordArgs}, ${evsmExp}, dLightDirW`;\n\t\t\t\t\t\t} else if (pcssShadows) {\n\t\t\t\t\t\t\tlet penumbraSizeArg = `vec2(light${i}_shadowSearchArea)`;\n\t\t\t\t\t\t\tif (lightShape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\t\t\t\t\t\tpenumbraSizeArg = `vec2(length(light${i}_halfWidth), length(light${i}_halfHeight)) * light${i}_shadowSearchArea`;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tshadowCoordArgs = `${shadowCoordArgs}, light${i}_cameraParams, ${penumbraSizeArg}, dLightDirW`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (lightType === LIGHTTYPE_OMNI) {\n\t\t\t\t\t\t\tshadowReadMode = `Point${shadowReadMode}`;\n\t\t\t\t\t\t\tif (!pcssShadows) {\n\t\t\t\t\t\t\t\tshadowCoordArgs = `${shadowCoordArgs}, dLightDirW`;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (lightType === LIGHTTYPE_SPOT) {\n\t\t\t\t\t\t\tshadowReadMode = `Spot${shadowReadMode}`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbackend.append(`    float shadow${i} = getShadow${shadowReadMode}(${shadowCoordArgs});`);\n\t\t\t\t\t\tbackend.append(`    dAtten *= mix(1.0, shadow${i}, light${i}_shadowIntensity);`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lightShape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\t\t\tif (options.conserveEnergy && options.useSpecular) {\n\t\t\t\t\t\tbackend.append(`    dDiffuseLight += ((dAttenD * dAtten) * light${i}_color${usesCookieNow ? ' * dAtten3' : ''}) * (1.0 - dLTCSpecFres);`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbackend.append(`    dDiffuseLight += (dAttenD * dAtten) * light${i}_color${usesCookieNow ? ' * dAtten3' : ''};`);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (hasAreaLights && options.conserveEnergy && options.useSpecular) {\n\t\t\t\t\t\tbackend.append(`    dDiffuseLight += (dAtten * light${i}_color${usesCookieNow ? ' * dAtten3' : ''}) * (1.0 - litArgs_specularity);`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbackend.append(`    dDiffuseLight += dAtten * light${i}_color${usesCookieNow ? ' * dAtten3' : ''};`);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (options.useSpecular) {\n\t\t\t\t\tbackend.append('    dHalfDirW = normalize(-dLightDirNormW + dViewDirW);');\n\t\t\t\t}\n\t\t\t\tif (light.affectSpecularity) {\n\t\t\t\t\tif (lightShape !== LIGHTSHAPE_PUNCTUAL) {\n\t\t\t\t\t\tif (options.useClearCoat) {\n\t\t\t\t\t\t\tbackend.append(`    ccSpecularLight += ccLTCSpecFres * get${shapeString}LightSpecular(litArgs_clearcoat_worldNormal, dViewDirW) * dAtten * light${i}_color${usesCookieNow ? ' * dAtten3' : ''};`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (options.useSpecular) {\n\t\t\t\t\t\t\tbackend.append(`    dSpecularLight += dLTCSpecFres * get${shapeString}LightSpecular(litArgs_worldNormal, dViewDirW) * dAtten * light${i}_color${usesCookieNow ? ' * dAtten3' : ''};`);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet calcFresnel = false;\n\t\t\t\t\t\tif (lightType === LIGHTTYPE_DIRECTIONAL && options.fresnelModel > 0) {\n\t\t\t\t\t\t\tcalcFresnel = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (options.useClearCoat) {\n\t\t\t\t\t\t\tbackend.append(`    ccSpecularLight += getLightSpecular(dHalfDirW, ccReflDirW, litArgs_clearcoat_worldNormal, dViewDirW, dLightDirNormW, litArgs_clearcoat_gloss, dTBN) * dAtten * light${i}_color${usesCookieNow ? ' * dAtten3' : ''}${calcFresnel ? ' * getFresnelCC(dot(dViewDirW, dHalfDirW));' : ';'}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (options.useSheen) {\n\t\t\t\t\t\t\tbackend.append(`    sSpecularLight += getLightSpecularSheen(dHalfDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_sheen_gloss) * dAtten * light${i}_color${usesCookieNow ? ' * dAtten3;' : ';'}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (options.useSpecular) {\n\t\t\t\t\t\t\tbackend.append(`    dSpecularLight += getLightSpecular(dHalfDirW, dReflDirW, litArgs_worldNormal, dViewDirW, dLightDirNormW, litArgs_gloss, dTBN) * dAtten * light${i}_color${usesCookieNow ? ' * dAtten3' : ''}${calcFresnel ? ` \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t* getFresnel(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdot(dViewDirW, dHalfDirW), \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitArgs_gloss, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitArgs_specularity\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#if defined(LIT_IRIDESCENCE)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t, iridescenceFresnel, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitArgs_iridescence_intensity\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);` : '* litArgs_specularity;'}`);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (lightType !== LIGHTTYPE_DIRECTIONAL) {\n\t\t\t\t\tbackend.append('    }');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.clusteredLightingEnabled && this.lighting) {\n\t\t\t\tusesLinearFalloff = true;\n\t\t\t\tusesInvSquaredFalloff = true;\n\t\t\t\thasPointLights = true;\n\t\t\t\tbackend.append(`    addClusteredLights(\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitArgs_worldNormal, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdViewDirW, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdReflDirW,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#if defined(LIT_CLEARCOAT)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tccReflDirW,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitArgs_gloss, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitArgs_specularity, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdVertexNormalW, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdTBN, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#if defined(LIT_IRIDESCENCE)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tiridescenceFresnel,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitArgs_clearcoat_worldNormal, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitArgs_clearcoat_gloss,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitArgs_sheen_gloss,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlitArgs_iridescence_intensity\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t);`);\n\t\t\t}\n\t\t\tif (hasAreaLights) {\n\t\t\t\tif (options.useClearCoat) {\n\t\t\t\t\tbackend.append('    litArgs_clearcoat_specularity = 1.0;');\n\t\t\t\t}\n\t\t\t\tif (options.useSpecular) {\n\t\t\t\t\tbackend.append('    litArgs_specularity = vec3(1);');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.useRefraction) {\n\t\t\t\tbackend.append(`    addRefraction(\n\t\t\t\t\t\t\t\t\t\t\t\tlitArgs_worldNormal, \n\t\t\t\t\t\t\t\t\t\t\t\tdViewDirW, \n\t\t\t\t\t\t\t\t\t\t\t\tlitArgs_thickness, \n\t\t\t\t\t\t\t\t\t\t\t\tlitArgs_gloss, \n\t\t\t\t\t\t\t\t\t\t\t\tlitArgs_specularity, \n\t\t\t\t\t\t\t\t\t\t\t\tlitArgs_albedo, \n\t\t\t\t\t\t\t\t\t\t\t\tlitArgs_transmission,\n\t\t\t\t\t\t\t\t\t\t\t\tlitArgs_ior,\n\t\t\t\t\t\t\t\t\t\t\t\tlitArgs_dispersion\n\t\t\t\t\t\t\t\t\t\t#if defined(LIT_IRIDESCENCE)\n\t\t\t\t\t\t\t\t\t\t\t\t, iridescenceFresnel, \n\t\t\t\t\t\t\t\t\t\t\t\tlitArgs_iridescence_intensity\n\t\t\t\t\t\t\t\t\t\t#endif\n\t\t\t\t\t\t\t\t\t\t);`);\n\t\t\t}\n\t\t}\n\t\tif (options.useAo) {\n\t\t\tif (options.occludeDirect) {\n\t\t\t\tbackend.append('    occludeDiffuse(litArgs_ao);');\n\t\t\t}\n\t\t\tif (options.occludeSpecular === SPECOCC_AO || options.occludeSpecular === SPECOCC_GLOSSDEPENDENT) {\n\t\t\t\tbackend.append('    occludeSpecular(litArgs_gloss, litArgs_ao, litArgs_worldNormal, dViewDirW);');\n\t\t\t}\n\t\t}\n\t\tif (options.useSpecularityFactor) {\n\t\t\tbackend.append('    dSpecularLight *= litArgs_specularityFactor;');\n\t\t}\n\t\tif (options.opacityFadesSpecular === false) {\n\t\t\tif (options.blendType === BLEND_NORMAL || options.blendType === BLEND_PREMULTIPLIED) {\n\t\t\t\tbackend.append('float specLum = dot((dSpecularLight + dReflection.rgb * dReflection.a), vec3( 0.2126, 0.7152, 0.0722 ));');\n\t\t\t\tbackend.append('#ifdef LIT_CLEARCOAT\\n specLum += dot(ccSpecularLight * litArgs_clearcoat_specularity + ccReflection.rgb * litArgs_clearcoat_specularity, vec3( 0.2126, 0.7152, 0.0722 ));\\n#endif');\n\t\t\t\tbackend.append('litArgs_opacity = clamp(litArgs_opacity + gammaCorrectInput(specLum), 0.0, 1.0);');\n\t\t\t}\n\t\t\tbackend.append('litArgs_opacity *= material_alphaFade;');\n\t\t}\n\t\tbackend.append(chunks.endPS);\n\t\tif (options.blendType === BLEND_NORMAL || options.blendType === BLEND_ADDITIVEALPHA || options.alphaToCoverage) {\n\t\t\tbackend.append(chunks.outputAlphaPS);\n\t\t} else if (options.blendType === BLEND_PREMULTIPLIED) {\n\t\t\tbackend.append(chunks.outputAlphaPremulPS);\n\t\t} else {\n\t\t\tbackend.append(chunks.outputAlphaOpaquePS);\n\t\t}\n\t\tif (options.useMsdf) {\n\t\t\tbackend.append('    gl_FragColor = applyMsdf(gl_FragColor);');\n\t\t}\n\t\tbackend.append(chunks.outputPS);\n\t\tbackend.append(chunks.debugOutputPS);\n\t\tif (hasPointLights) {\n\t\t\tfunc.prepend(chunks.lightDirPointPS);\n\t\t}\n\t\tif (usesLinearFalloff) {\n\t\t\tfunc.prepend(chunks.falloffLinearPS);\n\t\t}\n\t\tif (usesInvSquaredFalloff) {\n\t\t\tfunc.prepend(chunks.falloffInvSquaredPS);\n\t\t}\n\t\tif (usesSpot) {\n\t\t\tfunc.prepend(chunks.spotPS);\n\t\t}\n\t\tif (usesCookie && !options.clusteredLightingEnabled) {\n\t\t\tfunc.prepend(chunks.cookiePS);\n\t\t}\n\t\tlet structCode = '';\n\t\tconst backendCode = `void evaluateBackend() {\\n${backend.code}\\n}`;\n\t\tfunc.append(backendCode);\n\t\tcode.append(chunks.debugProcessFrontendPS);\n\t\tcode.append('    evaluateBackend();');\n\t\tcode.append(ShaderGenerator.end());\n\t\tconst mergedCode = decl.code + func.code + code.code;\n\t\tif (mergedCode.includes('dTBN')) structCode += 'mat3 dTBN;\\n';\n\t\tif (mergedCode.includes('dVertexNormalW')) structCode += 'vec3 dVertexNormalW;\\n';\n\t\tif (mergedCode.includes('dTangentW')) structCode += 'vec3 dTangentW;\\n';\n\t\tif (mergedCode.includes('dBinormalW')) structCode += 'vec3 dBinormalW;\\n';\n\t\tif (mergedCode.includes('dViewDirW')) structCode += 'vec3 dViewDirW;\\n';\n\t\tif (mergedCode.includes('dReflDirW')) structCode += 'vec3 dReflDirW;\\n';\n\t\tif (mergedCode.includes('dHalfDirW')) structCode += 'vec3 dHalfDirW;\\n';\n\t\tif (mergedCode.includes('ccReflDirW')) structCode += 'vec3 ccReflDirW;\\n';\n\t\tif (mergedCode.includes('dLightDirNormW')) structCode += 'vec3 dLightDirNormW;\\n';\n\t\tif (mergedCode.includes('dLightDirW')) structCode += 'vec3 dLightDirW;\\n';\n\t\tif (mergedCode.includes('dLightPosW')) structCode += 'vec3 dLightPosW;\\n';\n\t\tif (mergedCode.includes('dShadowCoord')) structCode += 'vec3 dShadowCoord;\\n';\n\t\tif (mergedCode.includes('dReflection')) structCode += 'vec4 dReflection;\\n';\n\t\tif (mergedCode.includes('dDiffuseLight')) structCode += 'vec3 dDiffuseLight;\\n';\n\t\tif (mergedCode.includes('dSpecularLight')) structCode += 'vec3 dSpecularLight;\\n';\n\t\tif (mergedCode.includes('dAtten')) structCode += 'float dAtten;\\n';\n\t\tif (mergedCode.includes('dAttenD')) structCode += 'float dAttenD;\\n';\n\t\tif (mergedCode.includes('dAtten3')) structCode += 'vec3 dAtten3;\\n';\n\t\tif (mergedCode.includes('dMsdf')) structCode += 'vec4 dMsdf;\\n';\n\t\tif (mergedCode.includes('ccFresnel')) structCode += 'float ccFresnel;\\n';\n\t\tif (mergedCode.includes('ccReflection')) structCode += 'vec3 ccReflection;\\n';\n\t\tif (mergedCode.includes('ccSpecularLight')) structCode += 'vec3 ccSpecularLight;\\n';\n\t\tif (mergedCode.includes('ccSpecularityNoFres')) structCode += 'float ccSpecularityNoFres;\\n';\n\t\tif (mergedCode.includes('sSpecularLight')) structCode += 'vec3 sSpecularLight;\\n';\n\t\tif (mergedCode.includes('sReflection')) structCode += 'vec3 sReflection;\\n';\n\t\tconst result = this._fsGetBeginCode() + this.varyings + this.varyingDefines + this._fsGetBaseCode() + structCode + this.frontendDecl + mergedCode;\n\t\treturn result;\n\t}\n\tgenerateFragmentShader(frontendDecl, frontendCode, frontendFunc, lightingUv) {\n\t\tvar _this$handleCompatibi;\n\t\tconst options = this.options;\n\t\tthis.frontendDecl = frontendDecl;\n\t\tthis.frontendCode = frontendCode;\n\t\tthis.frontendFunc = frontendFunc;\n\t\tthis.lightingUv = lightingUv;\n\t\tif (options.pass === SHADER_PICK) {\n\t\t\tthis.fshader = this._fsGetPickPassCode();\n\t\t} else if (options.pass === SHADER_DEPTH) {\n\t\t\tthis.fshader = this._fsGetDepthPassCode();\n\t\t} else if (options.pass === SHADER_PREPASS_VELOCITY) {\n\t\t\tthis.fshader = this._fsGetPrePassVelocityCode();\n\t\t} else if (this.shadowPass) {\n\t\t\tthis.fshader = this._fsGetShadowPassCode();\n\t\t} else if (options.customFragmentShader) {\n\t\t\tthis.fshader = this._fsGetBeginCode() + options.customFragmentShader;\n\t\t} else {\n\t\t\tthis.fshader = this._fsGetLitPassCode();\n\t\t}\n\t\t(_this$handleCompatibi = this.handleCompatibility) == null || _this$handleCompatibi.call(this);\n\t}\n\tgetDefinition() {\n\t\tconst definition = ShaderUtils.createDefinition(this.device, {\n\t\t\tname: 'LitShader',\n\t\t\tattributes: this.attributes,\n\t\t\tvertexCode: this.vshader,\n\t\t\tfragmentCode: this.fshader\n\t\t});\n\t\tif (this.shaderPassInfo.isForward) {\n\t\t\tdefinition.tag = SHADERTAG_MATERIAL;\n\t\t}\n\t\treturn definition;\n\t}\n}\n\nexport { LitShader };\n","import { ShaderUtils } from '../../../platform/graphics/shader-utils.js';\nimport { BLEND_NORMAL, BLEND_ADDITIVE, BLEND_MULTIPLICATIVE } from '../../constants.js';\nimport { shaderChunks } from '../chunks/chunks.js';\nimport { ShaderGenerator } from './shader-generator.js';\n\nclass ShaderGeneratorParticle extends ShaderGenerator {\n\tgenerateKey(options) {\n\t\tlet key = 'particle';\n\t\tfor (const prop in options) {\n\t\t\tif (options.hasOwnProperty(prop)) {\n\t\t\t\tkey += options[prop];\n\t\t\t}\n\t\t}\n\t\treturn key;\n\t}\n\t_animTex(options) {\n\t\tlet vshader = '';\n\t\tvshader += options.animTexLoop ? shaderChunks.particleAnimFrameLoopVS : shaderChunks.particleAnimFrameClampVS;\n\t\tvshader += shaderChunks.particleAnimTexVS;\n\t\treturn vshader;\n\t}\n\tcreateShaderDefinition(device, options) {\n\t\tconst executionDefine = `#define PARTICLE_${options.useCpu ? 'CPU' : 'GPU'}\\n`;\n\t\tlet fshader = `#define PARTICLE\\n${executionDefine}`;\n\t\tlet vshader = `#define VERTEXSHADER\\n${executionDefine}`;\n\t\tif (options.mesh) vshader += '#define USE_MESH\\n';\n\t\tif (options.localSpace) vshader += '#define LOCAL_SPACE\\n';\n\t\tif (options.screenSpace) vshader += '#define SCREEN_SPACE\\n';\n\t\tif (options.animTex) vshader += '\\nuniform vec2 animTexTilesParams;\\n';\n\t\tif (options.animTex) vshader += '\\nuniform vec4 animTexParams;\\n';\n\t\tif (options.animTex) vshader += '\\nuniform vec2 animTexIndexParams;\\n';\n\t\tif (options.normal === 2) vshader += '\\nvarying mat3 ParticleMat;\\n';\n\t\tif (options.normal === 1) vshader += '\\nvarying vec3 Normal;\\n';\n\t\tif (options.soft) vshader += '\\nvarying float vDepth;\\n';\n\t\tconst faceVS = options.customFace ? shaderChunks.particle_customFaceVS : shaderChunks.particle_billboardVS;\n\t\tif (!options.useCpu) {\n\t\t\tvshader += shaderChunks.particle_initVS;\n\t\t\tvshader += options.pack8 ? shaderChunks.particleInputRgba8PS : shaderChunks.particleInputFloatPS;\n\t\t\tif (options.soft > 0) vshader += shaderChunks.screenDepthPS;\n\t\t\tvshader += shaderChunks.particleVS;\n\t\t\tif (options.localSpace) vshader += shaderChunks.particle_localShiftVS;\n\t\t\tif (options.animTex) vshader += this._animTex(options);\n\t\t\tif (options.wrap) vshader += shaderChunks.particle_wrapVS;\n\t\t\tif (options.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;\n\t\t\tvshader += options.mesh ? shaderChunks.particle_meshVS : faceVS;\n\t\t\tif (options.normal === 1) vshader += shaderChunks.particle_normalVS;\n\t\t\tif (options.normal === 2) vshader += shaderChunks.particle_TBNVS;\n\t\t\tif (options.stretch > 0.0) vshader += shaderChunks.particle_stretchVS;\n\t\t\tvshader += shaderChunks.particle_endVS;\n\t\t\tif (options.soft > 0) vshader += shaderChunks.particle_softVS;\n\t\t} else {\n\t\t\tif (options.soft > 0) vshader += shaderChunks.screenDepthPS;\n\t\t\tvshader += shaderChunks.particle_cpuVS;\n\t\t\tif (options.localSpace) vshader += shaderChunks.particle_localShiftVS;\n\t\t\tif (options.animTex) vshader += this._animTex(options);\n\t\t\tif (options.alignToMotion) vshader += shaderChunks.particle_pointAlongVS;\n\t\t\tvshader += options.mesh ? shaderChunks.particle_meshVS : faceVS;\n\t\t\tif (options.normal === 1) vshader += shaderChunks.particle_normalVS;\n\t\t\tif (options.normal === 2) vshader += shaderChunks.particle_TBNVS;\n\t\t\tif (options.stretch > 0.0) vshader += shaderChunks.particle_stretchVS;\n\t\t\tvshader += shaderChunks.particle_cpu_endVS;\n\t\t\tif (options.soft > 0) vshader += shaderChunks.particle_softVS;\n\t\t}\n\t\tvshader += '}\\n';\n\t\tif (options.normal > 0) {\n\t\t\tif (options.normal === 1) {\n\t\t\t\tfshader += '\\nvarying vec3 Normal;\\n';\n\t\t\t} else if (options.normal === 2) {\n\t\t\t\tfshader += '\\nvarying mat3 ParticleMat;\\n';\n\t\t\t}\n\t\t\tfshader += '\\nuniform vec3 lightCube[6];\\n';\n\t\t}\n\t\tif (options.soft) fshader += '\\nvarying float vDepth;\\n';\n\t\tif (options.normal === 0 && options.fog === 'none') options.srgb = false;\n\t\tfshader += shaderChunks.decodePS;\n\t\tfshader += ShaderGenerator.gammaCode(options.gamma);\n\t\tfshader += ShaderGenerator.tonemapCode(options.toneMap);\n\t\tif (options.fog === 'linear') {\n\t\t\tfshader += shaderChunks.fogLinearPS;\n\t\t} else if (options.fog === 'exp') {\n\t\t\tfshader += shaderChunks.fogExpPS;\n\t\t} else if (options.fog === 'exp2') {\n\t\t\tfshader += shaderChunks.fogExp2PS;\n\t\t} else {\n\t\t\tfshader += shaderChunks.fogNonePS;\n\t\t}\n\t\tif (options.normal === 2) fshader += '\\nuniform sampler2D normalMap;\\n';\n\t\tif (options.soft > 0) fshader += shaderChunks.screenDepthPS;\n\t\tfshader += shaderChunks.particlePS;\n\t\tif (options.soft > 0) fshader += shaderChunks.particle_softPS;\n\t\tif (options.normal === 1) fshader += '\\nvec3 normal = Normal;\\n';\n\t\tif (options.normal === 2) fshader += shaderChunks.particle_normalMapPS;\n\t\tif (options.normal > 0) fshader += options.halflambert ? shaderChunks.particle_halflambertPS : shaderChunks.particle_lambertPS;\n\t\tif (options.normal > 0) fshader += shaderChunks.particle_lightingPS;\n\t\tif (options.blend === BLEND_NORMAL) {\n\t\t\tfshader += shaderChunks.particle_blendNormalPS;\n\t\t} else if (options.blend === BLEND_ADDITIVE) {\n\t\t\tfshader += shaderChunks.particle_blendAddPS;\n\t\t} else if (options.blend === BLEND_MULTIPLICATIVE) {\n\t\t\tfshader += shaderChunks.particle_blendMultiplyPS;\n\t\t}\n\t\tfshader += shaderChunks.particle_endPS;\n\t\treturn ShaderUtils.createDefinition(device, {\n\t\t\tname: 'ParticleShader',\n\t\t\tvertexCode: vshader,\n\t\t\tfragmentCode: fshader\n\t\t});\n\t}\n}\nconst particle = new ShaderGeneratorParticle();\n\nexport { particle };\n","import { GAMMA_SRGB, GAMMA_SRGBFAST, GAMMA_SRGBHDR, TONEMAP_NEUTRAL, TONEMAP_ACES2, TONEMAP_ACES, TONEMAP_HEJL, TONEMAP_LINEAR, TONEMAP_FILMIC } from '../../constants.js';\nimport { shaderChunks } from '../chunks/chunks.js';\n\nclass ShaderGenerator {\n\tstatic begin() {\n\t\treturn 'void main(void)\\n{\\n';\n\t}\n\tstatic end() {\n\t\treturn '}\\n';\n\t}\n\tstatic skinCode(device, chunks = shaderChunks) {\n\t\tif (device.supportsBoneTextures) {\n\t\t\treturn chunks.skinTexVS;\n\t\t}\n\t\treturn `#define BONE_LIMIT ${device.getBoneLimit()}\\n${chunks.skinConstVS}`;\n\t}\n\tstatic fogCode(value, chunks = shaderChunks) {\n\t\tif (value === 'linear') {\n\t\t\treturn chunks.fogLinearPS ? chunks.fogLinearPS : shaderChunks.fogLinearPS;\n\t\t} else if (value === 'exp') {\n\t\t\treturn chunks.fogExpPS ? chunks.fogExpPS : shaderChunks.fogExpPS;\n\t\t} else if (value === 'exp2') {\n\t\t\treturn chunks.fogExp2PS ? chunks.fogExp2PS : shaderChunks.fogExp2PS;\n\t\t}\n\t\treturn chunks.fogNonePS ? chunks.fogNonePS : shaderChunks.fogNonePS;\n\t}\n\tstatic gammaCode(value, chunks = shaderChunks) {\n\t\tif (value === GAMMA_SRGB || value === GAMMA_SRGBFAST) {\n\t\t\treturn chunks.gamma2_2PS ? chunks.gamma2_2PS : shaderChunks.gamma2_2PS;\n\t\t} else if (value === GAMMA_SRGBHDR) {\n\t\t\treturn `#define HDR\\n${chunks.gamma2_2PS ? chunks.gamma2_2PS : shaderChunks.gamma2_2PS}`;\n\t\t}\n\t\treturn chunks.gamma1_0PS ? chunks.gamma1_0PS : shaderChunks.gamma1_0PS;\n\t}\n\tstatic tonemapCode(value, chunks = shaderChunks) {\n\t\tvar _chunks$tonemappingFi, _chunks$tonemappingLi, _chunks$tonemappingHe, _chunks$tonemappingAc, _chunks$tonemappingAc2, _chunks$tonemappingNe, _chunks$tonemapingNon;\n\t\tswitch (value) {\n\t\t\tcase TONEMAP_FILMIC:\n\t\t\t\treturn (_chunks$tonemappingFi = chunks.tonemappingFilmicPS) != null ? _chunks$tonemappingFi : shaderChunks.tonemappingFilmicPS;\n\t\t\tcase TONEMAP_LINEAR:\n\t\t\t\treturn (_chunks$tonemappingLi = chunks.tonemappingLinearPS) != null ? _chunks$tonemappingLi : shaderChunks.tonemappingLinearPS;\n\t\t\tcase TONEMAP_HEJL:\n\t\t\t\treturn (_chunks$tonemappingHe = chunks.tonemappingHejlPS) != null ? _chunks$tonemappingHe : shaderChunks.tonemappingHejlPS;\n\t\t\tcase TONEMAP_ACES:\n\t\t\t\treturn (_chunks$tonemappingAc = chunks.tonemappingAcesPS) != null ? _chunks$tonemappingAc : shaderChunks.tonemappingAcesPS;\n\t\t\tcase TONEMAP_ACES2:\n\t\t\t\treturn (_chunks$tonemappingAc2 = chunks.tonemappingAces2PS) != null ? _chunks$tonemappingAc2 : shaderChunks.tonemappingAces2PS;\n\t\t\tcase TONEMAP_NEUTRAL:\n\t\t\t\treturn (_chunks$tonemappingNe = chunks.tonemappingNeutralPS) != null ? _chunks$tonemappingNe : shaderChunks.tonemappingNeutralPS;\n\t\t}\n\t\treturn (_chunks$tonemapingNon = chunks.tonemapingNonePS) != null ? _chunks$tonemapingNon : shaderChunks.tonemappingNonePS;\n\t}\n}\n\nexport { ShaderGenerator };\n","import { SEMANTIC_POSITION } from '../../../platform/graphics/constants.js';\nimport { shaderChunks } from '../chunks/chunks.js';\nimport { ChunkUtils } from '../chunk-utils.js';\nimport { ShaderUtils } from '../../../platform/graphics/shader-utils.js';\nimport { ShaderGenerator } from './shader-generator.js';\nimport { SKYTYPE_INFINITE } from '../../constants.js';\n\nconst mip2size = [128, 64, 16, 8, 4, 2];\nconst fShader = `\n\t\t#include \"decodePS\"\n\t\t#include \"gamma\"\n\t\t#include \"tonemapping\"\n\t\t#include \"envMultiplyPS\"\n\n\t\t#ifdef SKY_CUBEMAP\n\t\t\t\t#include \"cubemapSeams\"\n\t\t\t\t#include \"skyboxHDRPS\"\n\t\t#else\n\t\t\t\t#include \"sphericalPS\"\n\t\t\t\t#include \"envAtlasPS\"\n\t\t\t\t#include \"skyboxEnvPS\"\n\t\t#endif\n`;\nclass ShaderGeneratorSkybox extends ShaderGenerator {\n\tgenerateKey(options) {\n\t\tconst sharedKey = `skybox-${options.type}-${options.encoding}-${options.gamma}-${options.toneMapping}-${options.skymesh}`;\n\t\treturn sharedKey + (options.type === 'cubemap' ? `-${options.mip}` : '');\n\t}\n\tcreateShaderDefinition(device, options) {\n\t\tconst defines = new Map();\n\t\tdefines.set('SKYBOX_DECODE_FNC', ChunkUtils.decodeFunc(options.encoding));\n\t\tif (options.skymesh !== SKYTYPE_INFINITE) defines.set('SKYMESH', '');\n\t\tif (options.type === 'cubemap') {\n\t\t\tdefines.set('SKY_CUBEMAP', '');\n\t\t\tdefines.set('SKYBOX_MIP', (1 - 1 / mip2size[options.mip]).toString());\n\t\t}\n\t\tconst includes = new Map();\n\t\tincludes.set('decodePS', shaderChunks.decodePS);\n\t\tincludes.set('gamma', ShaderGenerator.gammaCode(options.gamma));\n\t\tincludes.set('tonemapping', ShaderGenerator.tonemapCode(options.toneMapping));\n\t\tincludes.set('envMultiplyPS', shaderChunks.envMultiplyPS);\n\t\tif (options.type === 'cubemap') {\n\t\t\tincludes.set('cubemapSeams', options.mip ? shaderChunks.fixCubemapSeamsStretchPS : shaderChunks.fixCubemapSeamsNonePS);\n\t\t\tincludes.set('skyboxHDRPS', shaderChunks.skyboxHDRPS);\n\t\t} else {\n\t\t\tincludes.set('sphericalPS', shaderChunks.sphericalPS);\n\t\t\tincludes.set('envAtlasPS', shaderChunks.envAtlasPS);\n\t\t\tincludes.set('skyboxEnvPS', shaderChunks.skyboxEnvPS);\n\t\t}\n\t\treturn ShaderUtils.createDefinition(device, {\n\t\t\tname: 'SkyboxShader',\n\t\t\tattributes: {\n\t\t\t\taPosition: SEMANTIC_POSITION\n\t\t\t},\n\t\t\tvertexCode: shaderChunks.skyboxVS,\n\t\t\tvertexDefines: defines,\n\t\t\tfragmentCode: fShader,\n\t\t\tfragmentDefines: defines,\n\t\t\tfragmentIncludes: includes\n\t\t});\n\t}\n}\nconst skybox = new ShaderGeneratorSkybox();\n\nexport { skybox };\n","import { SHADER_FORWARD, SHADER_FORWARDHDR, SPRITE_RENDERMODE_SLICED, SPRITE_RENDERMODE_TILED, SPECULAR_PHONG, FRESNEL_SCHLICK, BLEND_NONE, DITHER_NONE, DITHER_BAYER8 } from '../../constants.js';\nimport { ShaderPass } from '../../shader-pass.js';\nimport { LitShader } from './lit-shader.js';\nimport { ChunkBuilder } from '../chunk-builder.js';\nimport { ChunkUtils } from '../chunk-utils.js';\nimport { StandardMaterialOptions } from '../../materials/standard-material-options.js';\nimport { LitOptionsUtils } from './lit-options-utils.js';\nimport { ShaderGenerator } from './shader-generator.js';\n\nconst _matTex2D = [];\nconst buildPropertiesList = options => {\n\treturn Object.keys(options).filter(key => key !== 'litOptions').sort();\n};\nclass ShaderGeneratorStandard extends ShaderGenerator {\n\tconstructor(...args) {\n\t\tsuper(...args);\n\t\tthis.optionsContext = new StandardMaterialOptions();\n\t\tthis.optionsContextMin = new StandardMaterialOptions();\n\t}\n\tgenerateKey(options) {\n\t\tlet props;\n\t\tif (options === this.optionsContextMin) {\n\t\t\tif (!this.propsMin) this.propsMin = buildPropertiesList(options);\n\t\t\tprops = this.propsMin;\n\t\t} else if (options === this.optionsContext) {\n\t\t\tif (!this.props) this.props = buildPropertiesList(options);\n\t\t\tprops = this.props;\n\t\t} else {\n\t\t\tprops = buildPropertiesList(options);\n\t\t}\n\t\tconst key = `standard:\\n${props.map(prop => prop + options[prop]).join('\\n')}${LitOptionsUtils.generateKey(options.litOptions)}`;\n\t\treturn key;\n\t}\n\t_getUvSourceExpression(transformPropName, uVPropName, options) {\n\t\tconst transformId = options[transformPropName];\n\t\tconst uvChannel = options[uVPropName];\n\t\tconst isMainPass = options.litOptions.pass === SHADER_FORWARD || options.litOptions.pass === SHADER_FORWARDHDR;\n\t\tlet expression;\n\t\tif (isMainPass && options.litOptions.nineSlicedMode === SPRITE_RENDERMODE_SLICED) {\n\t\t\texpression = 'nineSlicedUv';\n\t\t} else if (isMainPass && options.litOptions.nineSlicedMode === SPRITE_RENDERMODE_TILED) {\n\t\t\texpression = 'nineSlicedUv';\n\t\t} else {\n\t\t\tif (transformId === 0) {\n\t\t\t\texpression = `vUv${uvChannel}`;\n\t\t\t} else {\n\t\t\t\texpression = `vUV${uvChannel}_${transformId}`;\n\t\t\t}\n\t\t\tif (options.heightMap && transformPropName !== 'heightMapTransform') {\n\t\t\t\texpression += ' + dUvOffset';\n\t\t\t}\n\t\t}\n\t\treturn expression;\n\t}\n\t_addMapDef(name, enabled) {\n\t\treturn enabled ? `#define ${name}\\n` : `#undef ${name}\\n`;\n\t}\n\t_addMapDefs(float, color, vertex, map, invert) {\n\t\treturn this._addMapDef('MAPFLOAT', float) + this._addMapDef('MAPCOLOR', color) + this._addMapDef('MAPVERTEX', vertex) + this._addMapDef('MAPTEXTURE', map) + this._addMapDef('MAPINVERT', invert);\n\t}\n\t_addMap(propName, chunkName, options, chunks, mapping, encoding = null) {\n\t\tconst mapPropName = `${propName}Map`;\n\t\tconst uVPropName = `${mapPropName}Uv`;\n\t\tconst identifierPropName = `${mapPropName}Identifier`;\n\t\tconst transformPropName = `${mapPropName}Transform`;\n\t\tconst channelPropName = `${mapPropName}Channel`;\n\t\tconst vertexColorChannelPropName = `${propName}VertexColorChannel`;\n\t\tconst tintPropName = `${propName}Tint`;\n\t\tconst vertexColorPropName = `${propName}VertexColor`;\n\t\tconst detailModePropName = `${propName}Mode`;\n\t\tconst invertName = `${propName}Invert`;\n\t\tconst tintOption = options[tintPropName];\n\t\tconst vertexColorOption = options[vertexColorPropName];\n\t\tconst textureOption = options[mapPropName];\n\t\tconst textureIdentifier = options[identifierPropName];\n\t\tconst detailModeOption = options[detailModePropName];\n\t\tlet subCode = chunks[chunkName];\n\t\tif (textureOption) {\n\t\t\tconst uv = this._getUvSourceExpression(transformPropName, uVPropName, options);\n\t\t\tsubCode = subCode.replace(/\\$UV/g, uv).replace(/\\$CH/g, options[channelPropName]);\n\t\t\tif (mapping && subCode.search(/\\$SAMPLER/g) !== -1) {\n\t\t\t\tlet samplerName = `texture_${mapPropName}`;\n\t\t\t\tconst alias = mapping[textureIdentifier];\n\t\t\t\tif (alias) {\n\t\t\t\t\tsamplerName = alias;\n\t\t\t\t} else {\n\t\t\t\t\tmapping[textureIdentifier] = samplerName;\n\t\t\t\t}\n\t\t\t\tsubCode = subCode.replace(/\\$SAMPLER/g, samplerName);\n\t\t\t}\n\t\t\tif (encoding) {\n\t\t\t\tif (options[channelPropName] === 'aaa') {\n\t\t\t\t\tsubCode = subCode.replace(/\\$DECODE/g, 'passThrough');\n\t\t\t\t} else {\n\t\t\t\t\tsubCode = subCode.replace(/\\$DECODE/g, ChunkUtils.decodeFunc(!options.litOptions.gamma && encoding === 'srgb' ? 'linear' : encoding));\n\t\t\t\t}\n\t\t\t\tif (subCode.indexOf('$texture2DSAMPLE')) {\n\t\t\t\t\tconst decodeTable = {\n\t\t\t\t\t\tlinear: 'texture2D',\n\t\t\t\t\t\tsrgb: 'texture2DSRGB',\n\t\t\t\t\t\trgbm: 'texture2DRGBM',\n\t\t\t\t\t\trgbe: 'texture2DRGBE'\n\t\t\t\t\t};\n\t\t\t\t\tsubCode = subCode.replace(/\\$texture2DSAMPLE/g, decodeTable[encoding] || 'texture2D');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (vertexColorOption) {\n\t\t\tsubCode = subCode.replace(/\\$VC/g, options[vertexColorChannelPropName]);\n\t\t}\n\t\tif (detailModeOption) {\n\t\t\tsubCode = subCode.replace(/\\$DETAILMODE/g, detailModeOption);\n\t\t}\n\t\tconst isFloatTint = !!(tintOption & 1);\n\t\tconst isVecTint = !!(tintOption & 2);\n\t\tconst invertOption = !!options[invertName];\n\t\tsubCode = this._addMapDefs(isFloatTint, isVecTint, vertexColorOption, textureOption, invertOption) + subCode;\n\t\treturn subCode.replace(/\\$/g, '');\n\t}\n\t_correctChannel(p, chan, _matTex2D) {\n\t\tif (_matTex2D[p] > 0) {\n\t\t\tif (_matTex2D[p] < chan.length) {\n\t\t\t\treturn chan.substring(0, _matTex2D[p]);\n\t\t\t} else if (_matTex2D[p] > chan.length) {\n\t\t\t\tlet str = chan;\n\t\t\t\tconst chr = str.charAt(str.length - 1);\n\t\t\t\tconst addLen = _matTex2D[p] - str.length;\n\t\t\t\tfor (let i = 0; i < addLen; i++) str += chr;\n\t\t\t\treturn str;\n\t\t\t}\n\t\t\treturn chan;\n\t\t}\n\t}\n\tcreateShaderDefinition(device, options) {\n\t\tconst shaderPassInfo = ShaderPass.get(device).getByIndex(options.litOptions.pass);\n\t\tconst isForwardPass = shaderPassInfo.isForward;\n\t\tconst litShader = new LitShader(device, options.litOptions);\n\t\tconst useUv = [];\n\t\tconst useUnmodifiedUv = [];\n\t\tconst mapTransforms = [];\n\t\tconst maxUvSets = 2;\n\t\tconst textureMapping = {};\n\t\tfor (const p in _matTex2D) {\n\t\t\tconst mname = `${p}Map`;\n\t\t\tif (options[`${p}VertexColor`]) {\n\t\t\t\tconst cname = `${p}VertexColorChannel`;\n\t\t\t\toptions[cname] = this._correctChannel(p, options[cname], _matTex2D);\n\t\t\t}\n\t\t\tif (options[mname]) {\n\t\t\t\tconst cname = `${mname}Channel`;\n\t\t\t\tconst tname = `${mname}Transform`;\n\t\t\t\tconst uname = `${mname}Uv`;\n\t\t\t\toptions[uname] = Math.min(options[uname], maxUvSets - 1);\n\t\t\t\toptions[cname] = this._correctChannel(p, options[cname], _matTex2D);\n\t\t\t\tconst uvSet = options[uname];\n\t\t\t\tuseUv[uvSet] = true;\n\t\t\t\tuseUnmodifiedUv[uvSet] = useUnmodifiedUv[uvSet] || options[mname] && !options[tname];\n\t\t\t\tif (options[tname]) {\n\t\t\t\t\tmapTransforms.push({\n\t\t\t\t\t\tname: p,\n\t\t\t\t\t\tid: options[tname],\n\t\t\t\t\t\tuv: options[uname]\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (options.forceUv1) {\n\t\t\tuseUv[1] = true;\n\t\t\tuseUnmodifiedUv[1] = useUnmodifiedUv[1] !== undefined ? useUnmodifiedUv[1] : true;\n\t\t}\n\t\tlitShader.generateVertexShader(useUv, useUnmodifiedUv, mapTransforms);\n\t\tif (options.litOptions.shadingModel === SPECULAR_PHONG) {\n\t\t\toptions.litOptions.fresnelModel = 0;\n\t\t\toptions.litOptions.ambientSH = false;\n\t\t} else {\n\t\t\toptions.litOptions.fresnelModel = options.litOptions.fresnelModel === 0 ? FRESNEL_SCHLICK : options.litOptions.fresnelModel;\n\t\t}\n\t\tconst decl = new ChunkBuilder();\n\t\tconst code = new ChunkBuilder();\n\t\tconst func = new ChunkBuilder();\n\t\tconst args = new ChunkBuilder();\n\t\tlet lightingUv = '';\n\t\tif (options.litOptions.nineSlicedMode === SPRITE_RENDERMODE_TILED) {\n\t\t\tdecl.append('const float textureBias = -1000.0;');\n\t\t} else {\n\t\t\tdecl.append('uniform float textureBias;');\n\t\t}\n\t\tif (isForwardPass) {\n\t\t\tif (options.heightMap) {\n\t\t\t\tdecl.append('vec2 dUvOffset;');\n\t\t\t\tcode.append(this._addMap('height', 'parallaxPS', options, litShader.chunks, textureMapping));\n\t\t\t\tfunc.append('getParallax();');\n\t\t\t}\n\t\t\tif (options.litOptions.blendType !== BLEND_NONE || options.litOptions.alphaTest || options.litOptions.alphaToCoverage || options.litOptions.opacityDither !== DITHER_NONE) {\n\t\t\t\tdecl.append('float dAlpha;');\n\t\t\t\tcode.append(this._addMap('opacity', 'opacityPS', options, litShader.chunks, textureMapping));\n\t\t\t\tfunc.append('getOpacity();');\n\t\t\t\targs.append('litArgs_opacity = dAlpha;');\n\t\t\t\tif (options.litOptions.alphaTest) {\n\t\t\t\t\tcode.append(litShader.chunks.alphaTestPS);\n\t\t\t\t\tfunc.append('alphaTest(dAlpha);');\n\t\t\t\t}\n\t\t\t\tconst opacityDither = options.litOptions.opacityDither;\n\t\t\t\tif (opacityDither !== DITHER_NONE) {\n\t\t\t\t\tif (opacityDither === DITHER_BAYER8) {\n\t\t\t\t\t\tdecl.append(litShader.chunks.bayerPS);\n\t\t\t\t\t}\n\t\t\t\t\tdecl.append(`#define DITHER_${opacityDither.toUpperCase()}\\n`);\n\t\t\t\t\tdecl.append(litShader.chunks.opacityDitherPS);\n\t\t\t\t\tfunc.append('opacityDither(dAlpha, 0.0);');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdecl.append('float dAlpha = 1.0;');\n\t\t\t}\n\t\t\tif (litShader.needsNormal) {\n\t\t\t\tif (options.normalMap || options.clearCoatNormalMap) {\n\t\t\t\t\tcode.append(options.packedNormal ? litShader.chunks.normalXYPS : litShader.chunks.normalXYZPS);\n\t\t\t\t\tif (!options.litOptions.hasTangents) {\n\t\t\t\t\t\tconst baseName = options.normalMap ? 'normalMap' : 'clearCoatNormalMap';\n\t\t\t\t\t\tlightingUv = this._getUvSourceExpression(`${baseName}Transform`, `${baseName}Uv`, options);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdecl.append('vec3 dNormalW;');\n\t\t\t\tcode.append(this._addMap('normalDetail', 'normalDetailMapPS', options, litShader.chunks, textureMapping));\n\t\t\t\tcode.append(this._addMap('normal', 'normalMapPS', options, litShader.chunks, textureMapping));\n\t\t\t\tfunc.append('getNormal();');\n\t\t\t\targs.append('litArgs_worldNormal = dNormalW;');\n\t\t\t}\n\t\t\tif (litShader.needsSceneColor) {\n\t\t\t\tdecl.append('uniform sampler2D uSceneColorMap;');\n\t\t\t}\n\t\t\tif (litShader.needsScreenSize) {\n\t\t\t\tdecl.append('uniform vec4 uScreenSize;');\n\t\t\t}\n\t\t\tif (litShader.needsTransforms) {\n\t\t\t\tdecl.append('uniform mat4 matrix_viewProjection;');\n\t\t\t\tdecl.append('uniform mat4 matrix_model;');\n\t\t\t}\n\t\t\tif (options.diffuseDetail || options.aoDetail) {\n\t\t\t\tcode.append(litShader.chunks.detailModesPS);\n\t\t\t}\n\t\t\tdecl.append('vec3 dAlbedo;');\n\t\t\tif (options.diffuseDetail) {\n\t\t\t\tcode.append(this._addMap('diffuseDetail', 'diffuseDetailMapPS', options, litShader.chunks, textureMapping, options.diffuseDetailEncoding));\n\t\t\t}\n\t\t\tcode.append(this._addMap('diffuse', 'diffusePS', options, litShader.chunks, textureMapping, options.diffuseEncoding));\n\t\t\tfunc.append('getAlbedo();');\n\t\t\targs.append('litArgs_albedo = dAlbedo;');\n\t\t\tif (options.litOptions.useRefraction) {\n\t\t\t\tdecl.append('float dTransmission;');\n\t\t\t\tcode.append(this._addMap('refraction', 'transmissionPS', options, litShader.chunks, textureMapping));\n\t\t\t\tfunc.append('getRefraction();');\n\t\t\t\targs.append('litArgs_transmission = dTransmission;');\n\t\t\t\tdecl.append('float dThickness;');\n\t\t\t\tcode.append(this._addMap('thickness', 'thicknessPS', options, litShader.chunks, textureMapping));\n\t\t\t\tfunc.append('getThickness();');\n\t\t\t\targs.append('litArgs_thickness = dThickness;');\n\t\t\t\tif (options.litOptions.dispersion) {\n\t\t\t\t\targs.append('litArgs_dispersion = material_dispersion;');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.litOptions.useIridescence) {\n\t\t\t\tdecl.append('float dIridescence;');\n\t\t\t\tcode.append(this._addMap('iridescence', 'iridescencePS', options, litShader.chunks, textureMapping));\n\t\t\t\tfunc.append('getIridescence();');\n\t\t\t\targs.append('litArgs_iridescence_intensity = dIridescence;');\n\t\t\t\tdecl.append('float dIridescenceThickness;');\n\t\t\t\tcode.append(this._addMap('iridescenceThickness', 'iridescenceThicknessPS', options, litShader.chunks, textureMapping));\n\t\t\t\tfunc.append('getIridescenceThickness();');\n\t\t\t\targs.append('litArgs_iridescence_thickness = dIridescenceThickness;');\n\t\t\t}\n\t\t\tif (litShader.lighting && options.litOptions.useSpecular || litShader.reflections) {\n\t\t\t\tdecl.append('vec3 dSpecularity;');\n\t\t\t\tdecl.append('float dGlossiness;');\n\t\t\t\tif (options.litOptions.useSheen) {\n\t\t\t\t\tdecl.append('vec3 sSpecularity;');\n\t\t\t\t\tcode.append(this._addMap('sheen', 'sheenPS', options, litShader.chunks, textureMapping, options.sheenEncoding));\n\t\t\t\t\tfunc.append('getSheen();');\n\t\t\t\t\targs.append('litArgs_sheen_specularity = sSpecularity;');\n\t\t\t\t\tdecl.append('float sGlossiness;');\n\t\t\t\t\tcode.append(this._addMap('sheenGloss', 'sheenGlossPS', options, litShader.chunks, textureMapping));\n\t\t\t\t\tfunc.append('getSheenGlossiness();');\n\t\t\t\t\targs.append('litArgs_sheen_gloss = sGlossiness;');\n\t\t\t\t}\n\t\t\t\tif (options.litOptions.useMetalness) {\n\t\t\t\t\tdecl.append('float dMetalness;');\n\t\t\t\t\tcode.append(this._addMap('metalness', 'metalnessPS', options, litShader.chunks, textureMapping));\n\t\t\t\t\tfunc.append('getMetalness();');\n\t\t\t\t\targs.append('litArgs_metalness = dMetalness;');\n\t\t\t\t\tdecl.append('float dIor;');\n\t\t\t\t\tcode.append(this._addMap('ior', 'iorPS', options, litShader.chunks, textureMapping));\n\t\t\t\t\tfunc.append('getIor();');\n\t\t\t\t\targs.append('litArgs_ior = dIor;');\n\t\t\t\t}\n\t\t\t\tif (options.litOptions.useSpecularityFactor) {\n\t\t\t\t\tdecl.append('float dSpecularityFactor;');\n\t\t\t\t\tcode.append(this._addMap('specularityFactor', 'specularityFactorPS', options, litShader.chunks, textureMapping));\n\t\t\t\t\tfunc.append('getSpecularityFactor();');\n\t\t\t\t\targs.append('litArgs_specularityFactor = dSpecularityFactor;');\n\t\t\t\t}\n\t\t\t\tif (options.useSpecularColor) {\n\t\t\t\t\tcode.append(this._addMap('specular', 'specularPS', options, litShader.chunks, textureMapping, options.specularEncoding));\n\t\t\t\t} else {\n\t\t\t\t\tcode.append('void getSpecularity() { dSpecularity = vec3(1); }');\n\t\t\t\t}\n\t\t\t\tcode.append(this._addMap('gloss', 'glossPS', options, litShader.chunks, textureMapping));\n\t\t\t\tfunc.append('getGlossiness();');\n\t\t\t\tfunc.append('getSpecularity();');\n\t\t\t\targs.append('litArgs_specularity = dSpecularity;');\n\t\t\t\targs.append('litArgs_gloss = dGlossiness;');\n\t\t\t} else {\n\t\t\t\tdecl.append('vec3 dSpecularity = vec3(0.0);');\n\t\t\t\tdecl.append('float dGlossiness = 0.0;');\n\t\t\t}\n\t\t\tif (options.aoDetail) {\n\t\t\t\tcode.append(this._addMap('aoDetail', 'aoDetailMapPS', options, litShader.chunks, textureMapping));\n\t\t\t}\n\t\t\tif (options.aoMap || options.aoVertexColor) {\n\t\t\t\tdecl.append('float dAo;');\n\t\t\t\tcode.append(this._addMap('ao', 'aoPS', options, litShader.chunks, textureMapping));\n\t\t\t\tfunc.append('getAO();');\n\t\t\t\targs.append('litArgs_ao = dAo;');\n\t\t\t}\n\t\t\tdecl.append('vec3 dEmission;');\n\t\t\tcode.append(this._addMap('emissive', 'emissivePS', options, litShader.chunks, textureMapping, options.emissiveEncoding));\n\t\t\tfunc.append('getEmission();');\n\t\t\targs.append('litArgs_emission = dEmission;');\n\t\t\tif (options.litOptions.useClearCoat) {\n\t\t\t\tdecl.append('float ccSpecularity;');\n\t\t\t\tdecl.append('float ccGlossiness;');\n\t\t\t\tdecl.append('vec3 ccNormalW;');\n\t\t\t\tcode.append(this._addMap('clearCoat', 'clearCoatPS', options, litShader.chunks, textureMapping));\n\t\t\t\tcode.append(this._addMap('clearCoatGloss', 'clearCoatGlossPS', options, litShader.chunks, textureMapping));\n\t\t\t\tcode.append(this._addMap('clearCoatNormal', 'clearCoatNormalPS', options, litShader.chunks, textureMapping));\n\t\t\t\tfunc.append('getClearCoat();');\n\t\t\t\tfunc.append('getClearCoatGlossiness();');\n\t\t\t\tfunc.append('getClearCoatNormal();');\n\t\t\t\targs.append('litArgs_clearcoat_specularity = ccSpecularity;');\n\t\t\t\targs.append('litArgs_clearcoat_gloss = ccGlossiness;');\n\t\t\t\targs.append('litArgs_clearcoat_worldNormal = ccNormalW;');\n\t\t\t}\n\t\t\tif (options.lightMap || options.lightVertexColor) {\n\t\t\t\tconst lightmapDir = options.dirLightMap && options.litOptions.useSpecular;\n\t\t\t\tconst lightmapChunkPropName = lightmapDir ? 'lightmapDirPS' : 'lightmapSinglePS';\n\t\t\t\tdecl.append('vec3 dLightmap;');\n\t\t\t\tif (lightmapDir) {\n\t\t\t\t\tdecl.append('vec3 dLightmapDir;');\n\t\t\t\t}\n\t\t\t\tcode.append(this._addMap('light', lightmapChunkPropName, options, litShader.chunks, textureMapping, options.lightMapEncoding));\n\t\t\t\tfunc.append('getLightMap();');\n\t\t\t\targs.append('litArgs_lightmap = dLightmap;');\n\t\t\t\tif (lightmapDir) {\n\t\t\t\t\targs.append('litArgs_lightmapDir = dLightmapDir;');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (code.code.indexOf('texture2DSRGB') !== -1 || code.code.indexOf('texture2DRGBM') !== -1 || code.code.indexOf('texture2DRGBE') !== -1) {\n\t\t\t\tcode.prepend(litShader.chunks.textureSamplePS);\n\t\t\t}\n\t\t} else {\n\t\t\tconst opacityShadowDither = options.litOptions.opacityShadowDither;\n\t\t\tif (options.litOptions.alphaTest || opacityShadowDither) {\n\t\t\t\tdecl.append('float dAlpha;');\n\t\t\t\tcode.append(this._addMap('opacity', 'opacityPS', options, litShader.chunks, textureMapping));\n\t\t\t\tfunc.append('getOpacity();');\n\t\t\t\targs.append('litArgs_opacity = dAlpha;');\n\t\t\t\tif (options.litOptions.alphaTest) {\n\t\t\t\t\tcode.append(litShader.chunks.alphaTestPS);\n\t\t\t\t\tfunc.append('alphaTest(dAlpha);');\n\t\t\t\t}\n\t\t\t\tif (opacityShadowDither !== DITHER_NONE) {\n\t\t\t\t\tif (opacityShadowDither === DITHER_BAYER8) {\n\t\t\t\t\t\tdecl.append(litShader.chunks.bayerPS);\n\t\t\t\t\t}\n\t\t\t\t\tdecl.append(`#define DITHER_${opacityShadowDither.toUpperCase()}\\n`);\n\t\t\t\t\tdecl.append(litShader.chunks.opacityDitherPS);\n\t\t\t\t\tfunc.append('opacityDither(dAlpha, 0.0);');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdecl.append(litShader.chunks.litShaderArgsPS);\n\t\tcode.append(`void evaluateFrontend() { \\n${func.code}\\n${args.code}\\n }\\n`);\n\t\tfunc.code = 'evaluateFrontend();';\n\t\tfor (const texture in textureMapping) {\n\t\t\tdecl.append(`uniform sampler2D ${textureMapping[texture]};`);\n\t\t}\n\t\tfunc.code = `\\n${func.code.split('\\n').map(l => `    ${l}`).join('\\n')}\\n\\n`;\n\t\tlitShader.generateFragmentShader(decl.code, code.code, func.code, lightingUv);\n\t\treturn litShader.getDefinition();\n\t}\n}\nconst standard = new ShaderGeneratorStandard();\n\nexport { _matTex2D, standard };\n","import { extends as _extends } from '../../../_virtual/_rollupPluginBabelHelpers.js';\nimport { Shader } from '../../platform/graphics/shader.js';\nimport { ShaderUtils } from '../../platform/graphics/shader-utils.js';\nimport { shaderChunks } from './chunks/chunks.js';\nimport { getProgramLibrary } from './get-program-library.js';\nimport { ShaderGenerator } from './programs/shader-generator.js';\nimport { SHADERLANGUAGE_WGSL } from '../../platform/graphics/constants.js';\n\nfunction createShader(device, vsName, fsName, useTransformFeedback = false, shaderDefinitionOptions = {}) {\n\tif (typeof useTransformFeedback === 'boolean') {\n\t\tshaderDefinitionOptions.useTransformFeedback = useTransformFeedback;\n\t} else if (typeof useTransformFeedback === 'object') {\n\t\tshaderDefinitionOptions = _extends({}, shaderDefinitionOptions, useTransformFeedback);\n\t}\n\treturn new Shader(device, ShaderUtils.createDefinition(device, _extends({}, shaderDefinitionOptions, {\n\t\tname: `${vsName}_${fsName}`,\n\t\tvertexCode: shaderChunks[vsName],\n\t\tfragmentCode: shaderChunks[fsName]\n\t})));\n}\nfunction createShaderFromCode(device, vsCode, fsCode, uniqueName, attributes, useTransformFeedback = false, shaderDefinitionOptions = {}) {\n\tif (typeof useTransformFeedback === 'boolean') {\n\t\tshaderDefinitionOptions.useTransformFeedback = useTransformFeedback;\n\t} else if (typeof useTransformFeedback === 'object') {\n\t\tshaderDefinitionOptions = _extends({}, shaderDefinitionOptions, useTransformFeedback);\n\t}\n\tconst programLibrary = getProgramLibrary(device);\n\tlet shader = programLibrary.getCachedShader(uniqueName);\n\tif (!shader) {\n\t\tshader = new Shader(device, ShaderUtils.createDefinition(device, _extends({}, shaderDefinitionOptions, {\n\t\t\tname: uniqueName,\n\t\t\tvertexCode: vsCode,\n\t\t\tfragmentCode: fsCode,\n\t\t\tattributes: attributes\n\t\t})));\n\t\tprogramLibrary.setCachedShader(uniqueName, shader);\n\t}\n\treturn shader;\n}\nclass ShaderGeneratorPassThrough extends ShaderGenerator {\n\tconstructor(key, shaderDefinition) {\n\t\tsuper();\n\t\tthis.key = key;\n\t\tthis.shaderDefinition = shaderDefinition;\n\t}\n\tgenerateKey(options) {\n\t\treturn this.key;\n\t}\n\tcreateShaderDefinition(device, options) {\n\t\treturn this.shaderDefinition;\n\t}\n}\nfunction processShader(shader, processingOptions) {\n\tvar _shaderDefinition$nam;\n\tconst shaderDefinition = shader.definition;\n\tconst name = (_shaderDefinition$nam = shaderDefinition.name) != null ? _shaderDefinition$nam : 'shader';\n\tconst key = `${name}-id-${shader.id}`;\n\tconst materialGenerator = new ShaderGeneratorPassThrough(key, shaderDefinition);\n\tconst libraryModuleName = 'shader';\n\tconst library = getProgramLibrary(shader.device);\n\tlibrary.register(libraryModuleName, materialGenerator);\n\tconst variant = library.getProgram(libraryModuleName, {}, processingOptions);\n\tif (shader.definition.shaderLanguage === SHADERLANGUAGE_WGSL) {\n\t\tvariant.meshUniformBufferFormat = shaderDefinition.meshUniformBufferFormat;\n\t\tvariant.meshBindGroupFormat = shaderDefinition.meshBindGroupFormat;\n\t}\n\tlibrary.unregister(libraryModuleName);\n\treturn variant;\n}\nshaderChunks.createShader = createShader;\nshaderChunks.createShaderFromCode = createShaderFromCode;\n\nexport { createShader, createShaderFromCode, processShader };\n","import { SHADER_DEPTH, SHADER_PICK, SHADER_FORWARD, SHADER_FORWARDHDR } from './constants.js';\nimport { DeviceCache } from '../platform/graphics/device-cache.js';\n\nconst shaderPassDeviceCache = new DeviceCache();\nclass ShaderPassInfo {\n\tconstructor(name, index, options = {}) {\n\t\tthis.index = void 0;\n\t\tthis.name = void 0;\n\t\tthis.shaderDefines = void 0;\n\t\tthis.name = name;\n\t\tthis.index = index;\n\t\tObject.assign(this, options);\n\t\tthis.shaderDefines = this.buildShaderDefines();\n\t}\n\tbuildShaderDefines() {\n\t\tlet keyword;\n\t\tif (this.isShadow) {\n\t\t\tkeyword = 'SHADOW';\n\t\t} else if (this.isForward) {\n\t\t\tkeyword = 'FORWARD';\n\t\t} else if (this.index === SHADER_DEPTH) {\n\t\t\tkeyword = 'DEPTH';\n\t\t} else if (this.index === SHADER_PICK) {\n\t\t\tkeyword = 'PICK';\n\t\t}\n\t\tconst define1 = keyword ? `#define ${keyword}_PASS\\n` : '';\n\t\tconst define2 = `#define ${this.name.toUpperCase()}_PASS\\n`;\n\t\treturn define1 + define2;\n\t}\n}\nclass ShaderPass {\n\tconstructor() {\n\t\tthis.passesNamed = new Map();\n\t\tthis.passesIndexed = [];\n\t\tthis.nextIndex = 0;\n\t\tconst add = (name, index, options) => {\n\t\t\tthis.allocate(name, options);\n\t\t};\n\t\tadd('forward', SHADER_FORWARD, {\n\t\t\tisForward: true\n\t\t});\n\t\tadd('forward_hdr', SHADER_FORWARDHDR, {\n\t\t\tisForward: true\n\t\t});\n\t\tadd('depth');\n\t\tadd('pick');\n\t\tadd('shadow');\n\t\tadd('prepass');\n\t}\n\tstatic get(device) {\n\t\treturn shaderPassDeviceCache.get(device, () => {\n\t\t\treturn new ShaderPass();\n\t\t});\n\t}\n\tallocate(name, options) {\n\t\tlet info = this.passesNamed.get(name);\n\t\tif (info === undefined) {\n\t\t\tinfo = new ShaderPassInfo(name, this.nextIndex, options);\n\t\t\tthis.passesNamed.set(info.name, info);\n\t\t\tthis.passesIndexed[info.index] = info;\n\t\t\tthis.nextIndex++;\n\t\t}\n\t\treturn info;\n\t}\n\tgetByIndex(index) {\n\t\tconst info = this.passesIndexed[index];\n\t\treturn info;\n\t}\n\tgetByName(name) {\n\t\treturn this.passesNamed.get(name);\n\t}\n}\n\nexport { ShaderPass, ShaderPassInfo };\n","import { RefCountedObject } from '../core/ref-counted-object.js';\nimport { SkinInstance } from './skin-instance.js';\n\nclass SkinInstanceCachedObject extends RefCountedObject {\n\tconstructor(skin, skinInstance) {\n\t\tsuper();\n\t\tthis.skin = skin;\n\t\tthis.skinInstance = skinInstance;\n\t}\n}\nclass SkinInstanceCache {\n\tstatic createCachedSkinInstance(skin, rootBone, entity) {\n\t\tlet skinInst = SkinInstanceCache.getCachedSkinInstance(skin, rootBone);\n\t\tif (!skinInst) {\n\t\t\tskinInst = new SkinInstance(skin);\n\t\t\tskinInst.resolve(rootBone, entity);\n\t\t\tSkinInstanceCache.addCachedSkinInstance(skin, rootBone, skinInst);\n\t\t}\n\t\treturn skinInst;\n\t}\n\tstatic getCachedSkinInstance(skin, rootBone) {\n\t\tlet skinInstance = null;\n\t\tconst cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);\n\t\tif (cachedObjArray) {\n\t\t\tconst cachedObj = cachedObjArray.find(element => element.skin === skin);\n\t\t\tif (cachedObj) {\n\t\t\t\tcachedObj.incRefCount();\n\t\t\t\tskinInstance = cachedObj.skinInstance;\n\t\t\t}\n\t\t}\n\t\treturn skinInstance;\n\t}\n\tstatic addCachedSkinInstance(skin, rootBone, skinInstance) {\n\t\tlet cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);\n\t\tif (!cachedObjArray) {\n\t\t\tcachedObjArray = [];\n\t\t\tSkinInstanceCache._skinInstanceCache.set(rootBone, cachedObjArray);\n\t\t}\n\t\tlet cachedObj = cachedObjArray.find(element => element.skin === skin);\n\t\tif (!cachedObj) {\n\t\t\tcachedObj = new SkinInstanceCachedObject(skin, skinInstance);\n\t\t\tcachedObjArray.push(cachedObj);\n\t\t}\n\t\tcachedObj.incRefCount();\n\t}\n\tstatic removeCachedSkinInstance(skinInstance) {\n\t\tif (skinInstance) {\n\t\t\tconst rootBone = skinInstance.rootBone;\n\t\t\tif (rootBone) {\n\t\t\t\tconst cachedObjArray = SkinInstanceCache._skinInstanceCache.get(rootBone);\n\t\t\t\tif (cachedObjArray) {\n\t\t\t\t\tconst cachedObjIndex = cachedObjArray.findIndex(element => element.skinInstance === skinInstance);\n\t\t\t\t\tif (cachedObjIndex >= 0) {\n\t\t\t\t\t\tconst cachedObj = cachedObjArray[cachedObjIndex];\n\t\t\t\t\t\tcachedObj.decRefCount();\n\t\t\t\t\t\tif (cachedObj.refCount === 0) {\n\t\t\t\t\t\t\tcachedObjArray.splice(cachedObjIndex, 1);\n\t\t\t\t\t\t\tif (!cachedObjArray.length) {\n\t\t\t\t\t\t\t\tSkinInstanceCache._skinInstanceCache.delete(rootBone);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (skinInstance) {\n\t\t\t\t\t\t\t\tskinInstance.destroy();\n\t\t\t\t\t\t\t\tcachedObj.skinInstance = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nSkinInstanceCache._skinInstanceCache = new Map();\n\nexport { SkinInstanceCache };\n","import { math } from '../core/math/math.js';\nimport { Mat4 } from '../core/math/mat4.js';\nimport { PIXELFORMAT_RGBA32F, FILTER_NEAREST, TEXTURELOCK_READ } from '../platform/graphics/constants.js';\nimport { Texture } from '../platform/graphics/texture.js';\n\nconst _invMatrix = new Mat4();\nclass SkinInstance {\n\tconstructor(skin) {\n\t\tthis.bones = void 0;\n\t\tthis.boneTextureSize = void 0;\n\t\tthis._dirty = true;\n\t\tthis._rootBone = null;\n\t\tthis._skinUpdateIndex = -1;\n\t\tthis._updateBeforeCull = true;\n\t\tif (skin) {\n\t\t\tthis.initSkin(skin);\n\t\t}\n\t}\n\tset rootBone(rootBone) {\n\t\tthis._rootBone = rootBone;\n\t}\n\tget rootBone() {\n\t\treturn this._rootBone;\n\t}\n\tinit(device, numBones) {\n\t\tif (device.supportsBoneTextures) {\n\t\t\tconst numPixels = numBones * 3;\n\t\t\tlet width = Math.ceil(Math.sqrt(numPixels));\n\t\t\twidth = math.roundUp(width, 3);\n\t\t\tconst height = Math.ceil(numPixels / width);\n\t\t\tthis.boneTexture = new Texture(device, {\n\t\t\t\twidth: width,\n\t\t\t\theight: height,\n\t\t\t\tformat: PIXELFORMAT_RGBA32F,\n\t\t\t\tmipmaps: false,\n\t\t\t\tminFilter: FILTER_NEAREST,\n\t\t\t\tmagFilter: FILTER_NEAREST,\n\t\t\t\tname: 'skin'\n\t\t\t});\n\t\t\tthis.boneTextureSize = [width, height, 1.0 / width, 1.0 / height];\n\t\t\tthis.matrixPalette = this.boneTexture.lock({\n\t\t\t\tmode: TEXTURELOCK_READ\n\t\t\t});\n\t\t\tthis.boneTexture.unlock();\n\t\t} else {\n\t\t\tthis.matrixPalette = new Float32Array(numBones * 12);\n\t\t}\n\t}\n\tdestroy() {\n\t\tif (this.boneTexture) {\n\t\t\tthis.boneTexture.destroy();\n\t\t\tthis.boneTexture = null;\n\t\t}\n\t}\n\tresolve(rootBone, entity) {\n\t\tthis.rootBone = rootBone;\n\t\tconst skin = this.skin;\n\t\tconst bones = [];\n\t\tfor (let j = 0; j < skin.boneNames.length; j++) {\n\t\t\tconst boneName = skin.boneNames[j];\n\t\t\tlet bone = rootBone.findByName(boneName);\n\t\t\tif (!bone) {\n\t\t\t\tbone = entity;\n\t\t\t}\n\t\t\tbones.push(bone);\n\t\t}\n\t\tthis.bones = bones;\n\t}\n\tinitSkin(skin) {\n\t\tthis.skin = skin;\n\t\tthis.bones = [];\n\t\tconst numBones = skin.inverseBindPose.length;\n\t\tthis.init(skin.device, numBones);\n\t\tthis.matrices = [];\n\t\tfor (let i = 0; i < numBones; i++) {\n\t\t\tthis.matrices[i] = new Mat4();\n\t\t}\n\t}\n\tuploadBones(device) {\n\t\tif (device.supportsBoneTextures) {\n\t\t\tthis.boneTexture.lock();\n\t\t\tthis.boneTexture.unlock();\n\t\t}\n\t}\n\t_updateMatrices(rootNode, skinUpdateIndex) {\n\t\tif (this._skinUpdateIndex !== skinUpdateIndex) {\n\t\t\tthis._skinUpdateIndex = skinUpdateIndex;\n\t\t\t_invMatrix.copy(rootNode.getWorldTransform()).invert();\n\t\t\tfor (let i = this.bones.length - 1; i >= 0; i--) {\n\t\t\t\tthis.matrices[i].mulAffine2(_invMatrix, this.bones[i].getWorldTransform());\n\t\t\t\tthis.matrices[i].mulAffine2(this.matrices[i], this.skin.inverseBindPose[i]);\n\t\t\t}\n\t\t}\n\t}\n\tupdateMatrices(rootNode, skinUpdateIndex) {\n\t\tif (this._updateBeforeCull) {\n\t\t\tthis._updateMatrices(rootNode, skinUpdateIndex);\n\t\t}\n\t}\n\tupdateMatrixPalette(rootNode, skinUpdateIndex) {\n\t\tthis._updateMatrices(rootNode, skinUpdateIndex);\n\t\tconst mp = this.matrixPalette;\n\t\tconst count = this.bones.length;\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst pe = this.matrices[i].data;\n\t\t\tconst base = i * 12;\n\t\t\tmp[base] = pe[0];\n\t\t\tmp[base + 1] = pe[4];\n\t\t\tmp[base + 2] = pe[8];\n\t\t\tmp[base + 3] = pe[12];\n\t\t\tmp[base + 4] = pe[1];\n\t\t\tmp[base + 5] = pe[5];\n\t\t\tmp[base + 6] = pe[9];\n\t\t\tmp[base + 7] = pe[13];\n\t\t\tmp[base + 8] = pe[2];\n\t\t\tmp[base + 9] = pe[6];\n\t\t\tmp[base + 10] = pe[10];\n\t\t\tmp[base + 11] = pe[14];\n\t\t}\n\t\tthis.uploadBones(this.skin.device);\n\t}\n}\n\nexport { SkinInstance };\n","class Skin {\n\tconstructor(graphicsDevice, ibp, boneNames) {\n\t\tthis.device = graphicsDevice;\n\t\tthis.inverseBindPose = ibp;\n\t\tthis.boneNames = boneNames;\n\t}\n}\n\nexport { Skin };\n","import { SKYTYPE_DOME, SKYTYPE_BOX } from '../constants.js';\nimport { Mesh } from '../mesh.js';\nimport { BoxGeometry } from '../geometry/box-geometry.js';\nimport { DomeGeometry } from '../geometry/dome-geometry.js';\n\nclass SkyGeometry {\n\tstatic create(device, type) {\n\t\tswitch (type) {\n\t\t\tcase SKYTYPE_BOX:\n\t\t\t\treturn SkyGeometry.box(device);\n\t\t\tcase SKYTYPE_DOME:\n\t\t\t\treturn SkyGeometry.dome(device);\n\t\t}\n\t\treturn SkyGeometry.infinite(device);\n\t}\n\tstatic infinite(device) {\n\t\treturn Mesh.fromGeometry(device, new BoxGeometry(device));\n\t}\n\tstatic box(device) {\n\t\treturn Mesh.fromGeometry(device, new BoxGeometry({\n\t\t\tyOffset: 0.5\n\t\t}));\n\t}\n\tstatic dome(device) {\n\t\tconst geom = new DomeGeometry({\n\t\t\tlatitudeBands: 50,\n\t\t\tlongitudeBands: 50\n\t\t});\n\t\tgeom.normals = undefined;\n\t\tgeom.uvs = undefined;\n\t\treturn Mesh.fromGeometry(device, geom);\n\t}\n}\n\nexport { SkyGeometry };\n","import { CULLFACE_FRONT } from '../../platform/graphics/constants.js';\nimport { ShaderProcessorOptions } from '../../platform/graphics/shader-processor-options.js';\nimport { SHADER_FORWARDHDR, GAMMA_SRGBHDR, GAMMA_NONE, TONEMAP_LINEAR, LAYERID_SKYBOX } from '../constants.js';\nimport { Material } from '../materials/material.js';\nimport { MeshInstance } from '../mesh-instance.js';\nimport { getProgramLibrary } from '../shader-lib/get-program-library.js';\nimport { skybox } from '../shader-lib/programs/skybox.js';\nimport { SkyGeometry } from './sky-geometry.js';\n\nclass SkyMesh {\n\tconstructor(device, scene, node, texture, type) {\n\t\tthis.meshInstance = null;\n\t\tconst material = new Material();\n\t\tmaterial.name = 'SkyMaterial';\n\t\tmaterial.getShaderVariant = function (dev, sc, defs, unused, pass, sortedLights, viewUniformFormat, viewBindGroupFormat) {\n\t\t\tconst options = {\n\t\t\t\tpass: pass,\n\t\t\t\tencoding: texture.encoding,\n\t\t\t\tgamma: pass === SHADER_FORWARDHDR ? scene.gammaCorrection ? GAMMA_SRGBHDR : GAMMA_NONE : scene.gammaCorrection,\n\t\t\t\ttoneMapping: pass === SHADER_FORWARDHDR ? TONEMAP_LINEAR : scene.toneMapping,\n\t\t\t\tskymesh: type\n\t\t\t};\n\t\t\tif (texture.cubemap) {\n\t\t\t\toptions.type = 'cubemap';\n\t\t\t\toptions.mip = texture.fixCubemapSeams ? scene.skyboxMip : 0;\n\t\t\t\toptions.fixSeams = texture.fixCubemapSeams;\n\t\t\t} else {\n\t\t\t\toptions.type = 'envAtlas';\n\t\t\t}\n\t\t\tconst processingOptions = new ShaderProcessorOptions(viewUniformFormat, viewBindGroupFormat);\n\t\t\tconst library = getProgramLibrary(device);\n\t\t\tlibrary.register('skybox', skybox);\n\t\t\treturn library.getProgram('skybox', options, processingOptions);\n\t\t};\n\t\tif (texture.cubemap) {\n\t\t\tmaterial.setParameter('texture_cubeMap', texture);\n\t\t} else {\n\t\t\tmaterial.setParameter('texture_envAtlas', texture);\n\t\t\tmaterial.setParameter('mipLevel', scene._skyboxMip);\n\t\t}\n\t\tmaterial.cull = CULLFACE_FRONT;\n\t\tmaterial.depthWrite = false;\n\t\tconst skyLayer = scene.layers.getLayerById(LAYERID_SKYBOX);\n\t\tif (skyLayer) {\n\t\t\tconst mesh = SkyGeometry.create(device, type);\n\t\t\tconst meshInstance = new MeshInstance(mesh, material, node);\n\t\t\tthis.meshInstance = meshInstance;\n\t\t\tmeshInstance.cull = false;\n\t\t\tmeshInstance.pick = false;\n\t\t\tskyLayer.addMeshInstances([meshInstance]);\n\t\t\tthis.skyLayer = skyLayer;\n\t\t}\n\t}\n\tdestroy() {\n\t\tif (this.meshInstance) {\n\t\t\tif (this.skyLayer) {\n\t\t\t\tthis.skyLayer.removeMeshInstances([this.meshInstance]);\n\t\t\t}\n\t\t\tthis.meshInstance.destroy();\n\t\t\tthis.meshInstance = null;\n\t\t}\n\t}\n}\n\nexport { SkyMesh };\n","import { Vec3 } from '../../core/math/vec3.js';\nimport { SKYTYPE_INFINITE } from '../constants.js';\nimport { GraphNode } from '../graph-node.js';\nimport { SkyMesh } from './sky-mesh.js';\n\nclass Sky {\n\tconstructor(scene) {\n\t\tthis._type = SKYTYPE_INFINITE;\n\t\tthis._center = new Vec3(0, 1, 0);\n\t\tthis.skyMesh = null;\n\t\tthis.node = new GraphNode('SkyMeshNode');\n\t\tthis.device = scene.device;\n\t\tthis.scene = scene;\n\t\tthis.center = new Vec3(0, 1, 0);\n\t\tthis.centerArray = new Float32Array(3);\n\t\tthis.projectedSkydomeCenterId = this.device.scope.resolve('projectedSkydomeCenter');\n\t}\n\tapplySettings(render) {\n\t\tvar _render$skyType, _render$skyMeshPositi, _render$skyMeshRotati, _render$skyMeshScale;\n\t\tthis.type = (_render$skyType = render.skyType) != null ? _render$skyType : SKYTYPE_INFINITE;\n\t\tthis.node.setLocalPosition(new Vec3((_render$skyMeshPositi = render.skyMeshPosition) != null ? _render$skyMeshPositi : [0, 0, 0]));\n\t\tthis.node.setLocalEulerAngles(new Vec3((_render$skyMeshRotati = render.skyMeshRotation) != null ? _render$skyMeshRotati : [0, 0, 0]));\n\t\tthis.node.setLocalScale(new Vec3((_render$skyMeshScale = render.skyMeshScale) != null ? _render$skyMeshScale : [1, 1, 1]));\n\t\tif (render.skyCenter) {\n\t\t\tthis._center = new Vec3(render.skyCenter);\n\t\t}\n\t}\n\tset type(value) {\n\t\tif (this._type !== value) {\n\t\t\tthis._type = value;\n\t\t\tthis.scene.updateShaders = true;\n\t\t\tthis.updateSkyMesh();\n\t\t}\n\t}\n\tget type() {\n\t\treturn this._type;\n\t}\n\tset center(value) {\n\t\tthis._center.copy(value);\n\t}\n\tget center() {\n\t\treturn this._center;\n\t}\n\tupdateSkyMesh() {\n\t\tconst texture = this.scene._getSkyboxTex();\n\t\tif (texture) {\n\t\t\tthis.resetSkyMesh();\n\t\t\tthis.skyMesh = new SkyMesh(this.device, this.scene, this.node, texture, this.type);\n\t\t\tthis.scene.fire('set:skybox', texture);\n\t\t}\n\t}\n\tresetSkyMesh() {\n\t\tvar _this$skyMesh;\n\t\t(_this$skyMesh = this.skyMesh) == null || _this$skyMesh.destroy();\n\t\tthis.skyMesh = null;\n\t}\n\tupdate() {\n\t\tif (this.type !== SKYTYPE_INFINITE) {\n\t\t\tconst {\n\t\t\t\tcenter,\n\t\t\t\tcenterArray\n\t\t\t} = this;\n\t\t\tconst temp = new Vec3();\n\t\t\tthis.node.getWorldTransform().transformPoint(center, temp);\n\t\t\tcenterArray[0] = temp.x;\n\t\t\tcenterArray[1] = temp.y;\n\t\t\tcenterArray[2] = temp.z;\n\t\t\tthis.projectedSkydomeCenterId.setValue(centerArray);\n\t\t}\n\t}\n}\n\nexport { Sky };\n","import { EventHandler } from '../core/event-handler.js';\nimport { Vec2 } from '../core/math/vec2.js';\nimport { SPRITE_RENDERMODE_SIMPLE, SPRITE_RENDERMODE_SLICED, SPRITE_RENDERMODE_TILED } from './constants.js';\nimport { Mesh } from './mesh.js';\nimport { Geometry } from './geometry/geometry.js';\n\nconst spriteNormals = [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1];\nconst spriteIndices = [0, 1, 3, 2, 3, 1];\nclass Sprite extends EventHandler {\n\tconstructor(device, options) {\n\t\tsuper();\n\t\tthis._device = device;\n\t\tthis._pixelsPerUnit = options && options.pixelsPerUnit !== undefined ? options.pixelsPerUnit : 1;\n\t\tthis._renderMode = options && options.renderMode !== undefined ? options.renderMode : SPRITE_RENDERMODE_SIMPLE;\n\t\tthis._atlas = options && options.atlas !== undefined ? options.atlas : null;\n\t\tthis._frameKeys = options && options.frameKeys !== undefined ? options.frameKeys : null;\n\t\tthis._meshes = [];\n\t\tthis._updatingProperties = false;\n\t\tthis._meshesDirty = false;\n\t\tif (this._atlas && this._frameKeys) {\n\t\t\tthis._createMeshes();\n\t\t}\n\t}\n\tset frameKeys(value) {\n\t\tthis._frameKeys = value;\n\t\tif (this._atlas && this._frameKeys) {\n\t\t\tif (this._updatingProperties) {\n\t\t\t\tthis._meshesDirty = true;\n\t\t\t} else {\n\t\t\t\tthis._createMeshes();\n\t\t\t}\n\t\t}\n\t\tthis.fire('set:frameKeys', value);\n\t}\n\tget frameKeys() {\n\t\treturn this._frameKeys;\n\t}\n\tset atlas(value) {\n\t\tif (value === this._atlas) return;\n\t\tif (this._atlas) {\n\t\t\tthis._atlas.off('set:frames', this._onSetFrames, this);\n\t\t\tthis._atlas.off('set:frame', this._onFrameChanged, this);\n\t\t\tthis._atlas.off('remove:frame', this._onFrameRemoved, this);\n\t\t}\n\t\tthis._atlas = value;\n\t\tif (this._atlas && this._frameKeys) {\n\t\t\tthis._atlas.on('set:frames', this._onSetFrames, this);\n\t\t\tthis._atlas.on('set:frame', this._onFrameChanged, this);\n\t\t\tthis._atlas.on('remove:frame', this._onFrameRemoved, this);\n\t\t\tif (this._updatingProperties) {\n\t\t\t\tthis._meshesDirty = true;\n\t\t\t} else {\n\t\t\t\tthis._createMeshes();\n\t\t\t}\n\t\t}\n\t\tthis.fire('set:atlas', value);\n\t}\n\tget atlas() {\n\t\treturn this._atlas;\n\t}\n\tset pixelsPerUnit(value) {\n\t\tif (this._pixelsPerUnit === value) return;\n\t\tthis._pixelsPerUnit = value;\n\t\tthis.fire('set:pixelsPerUnit', value);\n\t\tif (this._atlas && this._frameKeys && this.renderMode === SPRITE_RENDERMODE_SIMPLE) {\n\t\t\tif (this._updatingProperties) {\n\t\t\t\tthis._meshesDirty = true;\n\t\t\t} else {\n\t\t\t\tthis._createMeshes();\n\t\t\t}\n\t\t}\n\t}\n\tget pixelsPerUnit() {\n\t\treturn this._pixelsPerUnit;\n\t}\n\tset renderMode(value) {\n\t\tif (this._renderMode === value) {\n\t\t\treturn;\n\t\t}\n\t\tconst prev = this._renderMode;\n\t\tthis._renderMode = value;\n\t\tthis.fire('set:renderMode', value);\n\t\tif (prev === SPRITE_RENDERMODE_SIMPLE || value === SPRITE_RENDERMODE_SIMPLE) {\n\t\t\tif (this._atlas && this._frameKeys) {\n\t\t\t\tif (this._updatingProperties) {\n\t\t\t\t\tthis._meshesDirty = true;\n\t\t\t\t} else {\n\t\t\t\t\tthis._createMeshes();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tget renderMode() {\n\t\treturn this._renderMode;\n\t}\n\tget meshes() {\n\t\treturn this._meshes;\n\t}\n\t_createMeshes() {\n\t\tconst len = this._meshes.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst mesh = this._meshes[i];\n\t\t\tif (mesh) {\n\t\t\t\tmesh.destroy();\n\t\t\t}\n\t\t}\n\t\tconst count = this._frameKeys.length;\n\t\tthis._meshes = new Array(count);\n\t\tconst createMeshFunc = this.renderMode === SPRITE_RENDERMODE_SLICED || this._renderMode === SPRITE_RENDERMODE_TILED ? this._create9SliceMesh : this._createSimpleMesh;\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tconst frame = this._atlas.frames[this._frameKeys[i]];\n\t\t\tthis._meshes[i] = frame ? createMeshFunc.call(this, frame) : null;\n\t\t}\n\t\tthis.fire('set:meshes');\n\t}\n\t_createSimpleMesh(frame) {\n\t\tconst rect = frame.rect;\n\t\tconst texWidth = this._atlas.texture.width;\n\t\tconst texHeight = this._atlas.texture.height;\n\t\tconst w = rect.z / this._pixelsPerUnit;\n\t\tconst h = rect.w / this._pixelsPerUnit;\n\t\tconst hp = frame.pivot.x;\n\t\tconst vp = frame.pivot.y;\n\t\tconst positions = [-hp * w, -vp * h, 0, (1 - hp) * w, -vp * h, 0, (1 - hp) * w, (1 - vp) * h, 0, -hp * w, (1 - vp) * h, 0];\n\t\tconst lu = rect.x / texWidth;\n\t\tconst bv = 1.0 - rect.y / texHeight;\n\t\tconst ru = (rect.x + rect.z) / texWidth;\n\t\tconst tv = 1.0 - (rect.y + rect.w) / texHeight;\n\t\tconst uvs = [lu, bv, ru, bv, ru, tv, lu, tv];\n\t\tconst geom = new Geometry();\n\t\tgeom.positions = positions;\n\t\tgeom.normals = spriteNormals;\n\t\tgeom.uvs = uvs;\n\t\tgeom.indices = spriteIndices;\n\t\treturn Mesh.fromGeometry(this._device, geom);\n\t}\n\t_create9SliceMesh() {\n\t\tconst he = Vec2.ONE;\n\t\tconst ws = 3;\n\t\tconst ls = 3;\n\t\tconst positions = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\t\tconst indices = [];\n\t\tlet vcounter = 0;\n\t\tfor (let i = 0; i <= ws; i++) {\n\t\t\tconst u = i === 0 || i === ws ? 0 : 1;\n\t\t\tfor (let j = 0; j <= ls; j++) {\n\t\t\t\tconst x = -he.x + 2.0 * he.x * (i <= 1 ? 0 : 3) / ws;\n\t\t\t\tconst y = 0.0;\n\t\t\t\tconst z = -(-he.y + 2.0 * he.y * (j <= 1 ? 0 : 3) / ls);\n\t\t\t\tconst v = j === 0 || j === ls ? 0 : 1;\n\t\t\t\tpositions.push(-x, y, z);\n\t\t\t\tnormals.push(0.0, 1.0, 0.0);\n\t\t\t\tuvs.push(u, v);\n\t\t\t\tif (i < ws && j < ls) {\n\t\t\t\t\tindices.push(vcounter + ls + 1, vcounter + 1, vcounter);\n\t\t\t\t\tindices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);\n\t\t\t\t}\n\t\t\t\tvcounter++;\n\t\t\t}\n\t\t}\n\t\tconst geom = new Geometry();\n\t\tgeom.positions = positions;\n\t\tgeom.normals = normals;\n\t\tgeom.uvs = uvs;\n\t\tgeom.indices = indices;\n\t\treturn Mesh.fromGeometry(this._device, geom);\n\t}\n\t_onSetFrames(frames) {\n\t\tif (this._updatingProperties) {\n\t\t\tthis._meshesDirty = true;\n\t\t} else {\n\t\t\tthis._createMeshes();\n\t\t}\n\t}\n\t_onFrameChanged(frameKey, frame) {\n\t\tconst idx = this._frameKeys.indexOf(frameKey);\n\t\tif (idx < 0) return;\n\t\tif (frame) {\n\t\t\tif (this.renderMode === SPRITE_RENDERMODE_SIMPLE) {\n\t\t\t\tthis._meshes[idx] = this._createSimpleMesh(frame);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._meshes[idx] = null;\n\t\t}\n\t\tthis.fire('set:meshes');\n\t}\n\t_onFrameRemoved(frameKey) {\n\t\tconst idx = this._frameKeys.indexOf(frameKey);\n\t\tif (idx < 0) return;\n\t\tthis._meshes[idx] = null;\n\t\tthis.fire('set:meshes');\n\t}\n\tstartUpdate() {\n\t\tthis._updatingProperties = true;\n\t\tthis._meshesDirty = false;\n\t}\n\tendUpdate() {\n\t\tthis._updatingProperties = false;\n\t\tif (this._meshesDirty && this._atlas && this._frameKeys) {\n\t\t\tthis._createMeshes();\n\t\t}\n\t\tthis._meshesDirty = false;\n\t}\n\tdestroy() {\n\t\tfor (const mesh of this._meshes) {\n\t\t\tif (mesh) {\n\t\t\t\tmesh.destroy();\n\t\t\t}\n\t\t}\n\t\tthis._meshes.length = 0;\n\t}\n}\n\nexport { Sprite };\n","import { EventHandler } from '../core/event-handler.js';\n\nclass TextureAtlas extends EventHandler {\n\tconstructor() {\n\t\tsuper();\n\t\tthis._texture = null;\n\t\tthis._frames = null;\n\t}\n\tset texture(value) {\n\t\tthis._texture = value;\n\t\tthis.fire('set:texture', value);\n\t}\n\tget texture() {\n\t\treturn this._texture;\n\t}\n\tset frames(value) {\n\t\tthis._frames = value;\n\t\tthis.fire('set:frames', value);\n\t}\n\tget frames() {\n\t\treturn this._frames;\n\t}\n\tsetFrame(key, data) {\n\t\tlet frame = this._frames[key];\n\t\tif (!frame) {\n\t\t\tframe = {\n\t\t\t\trect: data.rect.clone(),\n\t\t\t\tpivot: data.pivot.clone(),\n\t\t\t\tborder: data.border.clone()\n\t\t\t};\n\t\t\tthis._frames[key] = frame;\n\t\t} else {\n\t\t\tframe.rect.copy(data.rect);\n\t\t\tframe.pivot.copy(data.pivot);\n\t\t\tframe.border.copy(data.border);\n\t\t}\n\t\tthis.fire('set:frame', key.toString(), frame);\n\t}\n\tremoveFrame(key) {\n\t\tconst frame = this._frames[key];\n\t\tif (frame) {\n\t\t\tdelete this._frames[key];\n\t\t\tthis.fire('remove:frame', key.toString(), frame);\n\t\t}\n\t}\n\tdestroy() {\n\t\tif (this._texture) {\n\t\t\tthis._texture.destroy();\n\t\t}\n\t}\n}\n\nexport { TextureAtlas };\n","import * as pc from 'playcanvas';\r\nimport { SceneView } from './SceneView';\r\nimport { MenuManager } from './MenuManager';\r\nimport { FileManager } from './FileManager';\r\nimport { EditorEntity, SceneData } from '../types';\r\n\r\nexport class Editor {\r\n  private sceneView: SceneView;\r\n  private menuManager: MenuManager;\r\n  private fileManager: FileManager;\r\n  private statusBar: HTMLElement;\r\n  private notification: HTMLElement;\r\n  private notificationTimeout: number | null = null;\r\n\r\n  constructor() {\r\n    this.statusBar = document.getElementById('status-bar') as HTMLElement;\r\n    this.notification = document.getElementById('notification') as HTMLElement;\r\n    \r\n    this.sceneView = new SceneView(this);\r\n    this.menuManager = new MenuManager(this);\r\n    this.fileManager = new FileManager(this);\r\n    \r\n    this.initialize();\r\n  }\r\n\r\n  initialize(): void {\r\n    this.sceneView.initialize();\r\n    this.menuManager.initialize();\r\n    this.fileManager.initialize();\r\n    \r\n    this.setStatus('Editor initialized');\r\n  }\r\n\r\n  setStatus(message: string): void {\r\n    if (this.statusBar) {\r\n      this.statusBar.textContent = message;\r\n    }\r\n  }\r\n\r\n  showNotification(message: string, duration = 3000): void {\r\n    if (this.notification) {\r\n      this.notification.textContent = message;\r\n      this.notification.classList.add('show');\r\n      \r\n      if (this.notificationTimeout) {\r\n        clearTimeout(this.notificationTimeout);\r\n      }\r\n      \r\n      this.notificationTimeout = window.setTimeout(() => {\r\n        this.notification.classList.remove('show');\r\n        this.notificationTimeout = null;\r\n      }, duration);\r\n    }\r\n  }\r\n\r\n  // Scene management methods\r\n  newScene(): void {\r\n    this.sceneView.resetScene();\r\n    this.setStatus('New scene created');\r\n    this.showNotification('New scene created');\r\n  }\r\n\r\n  addCube(): void {\r\n    const entity = this.sceneView.addCube();\r\n    this.setStatus(`Added cube: ${entity.name}`);\r\n    this.showNotification(`Added cube: ${entity.name}`);\r\n  }\r\n\r\n  loadScene(sceneData: string): void {\r\n    try {\r\n      const data = JSON.parse(sceneData) as SceneData;\r\n      this.sceneView.loadScene(data);\r\n      this.setStatus('Scene loaded');\r\n      this.showNotification('Scene loaded successfully');\r\n    } catch (error) {\r\n      this.setStatus('Error loading scene');\r\n      this.showNotification('Error loading scene: ' + String(error));\r\n      console.error('Error loading scene:', error);\r\n    }\r\n  }\r\n\r\n  saveScene(): void {\r\n    try {\r\n      const sceneData = this.sceneView.serializeScene();\r\n      this.fileManager.saveScene(sceneData);\r\n    } catch (error) {\r\n      this.setStatus('Error saving scene');\r\n      this.showNotification('Error saving scene: ' + String(error));\r\n      console.error('Error saving scene:', error);\r\n    }\r\n  }\r\n\r\n  onSceneSaved(filePath: string): void {\r\n    this.setStatus(`Scene saved to ${filePath}`);\r\n    this.showNotification(`Scene saved to ${filePath}`);\r\n  }\r\n\r\n  // Helper methods for accessing components\r\n  getSceneView(): SceneView {\r\n    return this.sceneView;\r\n  }\r\n}","import { Editor } from './Editor';\r\nimport { EditorComponent } from '../types';\r\n\r\nexport class FileManager implements EditorComponent {\r\n  private editor: Editor;\r\n\r\n  constructor(editor: Editor) {\r\n    this.editor = editor;\r\n  }\r\n\r\n  initialize(): void {\r\n    // Register event listeners for file operations\r\n    window.electronAPI.onSaveSceneComplete((event, filePath) => {\r\n      this.editor.onSceneSaved(filePath);\r\n    });\r\n\r\n    window.electronAPI.onSaveSceneError((event, error) => {\r\n      console.error('Error saving scene:', error);\r\n      this.editor.showNotification(`Error saving scene: ${error}`, 5000);\r\n    });\r\n  }\r\n\r\n  dispose(): void {\r\n    // Clean up (no-op for now as Electron IPC doesn't have removal methods)\r\n  }\r\n\r\n  // Send the serialized scene to the main process for saving\r\n  saveScene(sceneData: string): void {\r\n    window.electronAPI.saveScene(sceneData);\r\n  }\r\n}","import { Editor } from './Editor';\r\nimport { EditorComponent } from '../types';\r\n\r\nexport class MenuManager implements EditorComponent {\r\n  private editor: Editor;\r\n\r\n  constructor(editor: Editor) {\r\n    this.editor = editor;\r\n  }\r\n\r\n  initialize(): void {\r\n    // Register event listeners for menu actions\r\n    window.electronAPI.newScene(() => {\r\n      this.editor.newScene();\r\n    });\r\n\r\n    window.electronAPI.addCube(() => {\r\n      this.editor.addCube();\r\n    });\r\n\r\n    window.electronAPI.loadScene((event, data) => {\r\n      this.editor.loadScene(data);\r\n    });\r\n\r\n    window.electronAPI.requestSaveScene(() => {\r\n      this.editor.saveScene();\r\n    });\r\n  }\r\n\r\n  dispose(): void {\r\n    // Clean up (no-op for now as Electron IPC doesn't have removal methods)\r\n  }\r\n}","import * as pc from 'playcanvas';\nimport { Editor } from './Editor';\nimport { EditorComponent, EditorEntity, SceneData } from '../types';\nimport { Vec3 } from 'playcanvas';\nimport { OrbitCameraInput } from './orbit-camera-input';\nimport { createGridEntity } from './grid-factory';\n\nexport class SceneView implements EditorComponent {\n  private editor: Editor;\n  private app!: pc.Application;\n  private canvas: HTMLCanvasElement;\n  private camera!: pc.Entity;\n  private root!: pc.Entity;\n  private cubeCount: number = 0;\n  private orbitCameraInput!: OrbitCameraInput;\n  private onResizeCanvas!: () => void;\n\n  constructor(editor: Editor) {\n    this.editor = editor;\n    this.canvas = document.getElementById('scene-canvas') as HTMLCanvasElement;\n  }\n\n  initialize(): void {\n    this.app = new pc.Application(this.canvas);\n\n    this.onResizeCanvas = () => this.app.resizeCanvas();\n    window.addEventListener('resize', this.onResizeCanvas);\n\n    this.setupSceneCore();\n\n    this.app.start();\n  }\n\n  dispose(): void {\n    window.removeEventListener('resize', this.onResizeCanvas);\n    if (this.orbitCameraInput) {\n      this.orbitCameraInput.dispose();\n    }\n    \n    this.app.destroy();\n  }\n\n  setupSceneCore(): void {\n    this.root = new pc.Entity('Root');\n    this.app.root.addChild(this.root);\n\n    this.camera = new pc.Entity('Camera');\n    this.camera.addComponent('camera', {\n      clearColor: new pc.Color(0.4, 0.45, 0.5)\n    });\n    this.camera.setPosition(0, 2, 5);\n    this.camera.lookAt(0, 0, 0);\n    this.app.root.addChild(this.camera);\n\n    this.orbitCameraInput = new OrbitCameraInput(this.app, this.canvas, this.camera);\n\n    const light = new pc.Entity('Directional Light');\n    light.addComponent('light', {\n      type: 'directional',\n      color: new pc.Color(1, 1, 1),\n      castShadows: true,\n      intensity: 1.5,\n      shadowBias: 0.05,\n      shadowDistance: 30,\n      normalOffsetBias: 0.05\n    });\n    light.setLocalEulerAngles(45, 30, 0);\n    this.app.root.addChild(light);\n\n    createGridEntity(this.app, { color: new pc.Color(0.7, 0.7, 0.7) });\n  }\n\n  addCube(): pc.Entity {\n    this.cubeCount++;\n    const name = `Cube_${this.cubeCount}`;\n    \n    const cube = new pc.Entity(name);\n    \n    const material = new pc.StandardMaterial();\n    material.diffuse = new pc.Color(0.5 + Math.random() * 0.5, 0.5 + Math.random() * 0.5, 0.5 + Math.random() * 0.5);\n    material.update();\n    \n    cube.addComponent('render', {\n      type: 'box',\n      material: material\n    });\n    \n    cube.setPosition(\n      (Math.random() - 0.5) * 4,\n      0.5,\n      (Math.random() - 0.5) * 4\n    );\n    \n    this.root.addChild(cube);\n    return cube;\n  }\n\n  resetScene(): void {\n    while (this.root.children.length > 0) {\n      const child = this.root.children[0];\n      const gridEntity = this.app.root.findByName('Grid');\n      if (child !== this.camera && child !== gridEntity) { \n         child.destroy(); \n      } else {\n         this.root.removeChild(child); \n      }\n    }\n    this.cubeCount = 0;\n  }\n\n  serializeScene(): string {\n    const sceneData: SceneData = {\n      entities: [],\n      version: '0.1.0'\n    };\n\n    const serializeEntity = (entity: pc.Entity): EditorEntity | null => {\n      const gridEntity = this.app.root.findByName('Grid');\n      if (entity === this.camera || entity.name === 'Directional Light' || entity === gridEntity) { \n        return null;\n      }\n      \n      const position = entity.getPosition();\n      const rotation = entity.getEulerAngles();\n      const scale = entity.getLocalScale();\n\n      const data: EditorEntity = {\n        id: entity.getGuid(),\n        name: entity.name,\n        type: entity.name.toLowerCase().includes('cube') ? 'cube' : 'other',\n        position: [position.x, position.y, position.z],\n        rotation: [rotation.x, rotation.y, rotation.z],\n        scale: [scale.x, scale.y, scale.z],\n        components: {}\n      };\n\n      const renderComponent = entity.render;\n      if (renderComponent && renderComponent.material instanceof pc.StandardMaterial) {\n        const standardMaterial = renderComponent.material as pc.StandardMaterial;\n        data.components = {\n          render: {\n            type: renderComponent.type,\n            material: {\n              diffuse: standardMaterial.diffuse ? [\n                standardMaterial.diffuse.r,\n                standardMaterial.diffuse.g,\n                standardMaterial.diffuse.b\n              ] : [1, 1, 1]\n            }\n          }\n        };\n      } else if (renderComponent) {\n         data.components = {\n             render: { type: renderComponent.type }\n         };\n      }\n\n      return data;\n    };\n\n    this.root.children.forEach(entity => {\n      const serialized = serializeEntity(entity as pc.Entity);\n      if (serialized) {\n          sceneData.entities.push(serialized);\n      }\n    });\n\n    return JSON.stringify(sceneData, null, 2);\n  }\n\n  loadScene(sceneData: SceneData): void {\n    this.resetScene();\n    createGridEntity(this.app, { color: new pc.Color(0.7, 0.7, 0.7) });\n\n    sceneData.entities.forEach(entityData => {\n      if (entityData.type === 'cube') { \n        const cube = new pc.Entity(entityData.name);\n        cube.setGuid(entityData.id);\n\n        const renderData = entityData.components?.render;\n        if (renderData) {\n            const material = new pc.StandardMaterial();\n            if (renderData.material?.diffuse) {\n              const [r, g, b] = renderData.material.diffuse;\n              material.diffuse = new pc.Color(r, g, b);\n            } else {\n              material.diffuse = new pc.Color(1, 1, 1);\n            }\n            material.update();\n            \n            cube.addComponent('render', {\n              type: 'box',\n              material: material\n            });\n        }\n        \n        cube.setPosition(entityData.position[0], entityData.position[1], entityData.position[2]);\n        cube.setEulerAngles(entityData.rotation[0], entityData.rotation[1], entityData.rotation[2]);\n        cube.setLocalScale(entityData.scale[0], entityData.scale[1], entityData.scale[2]);\n\n        this.root.addChild(cube);\n\n        const match = entityData.name.match(/Cube_(\\d+)/);\n        if (match) {\n          const num = parseInt(match[1], 10);\n          this.cubeCount = Math.max(this.cubeCount, num);\n        }\n      } else {\n        console.warn(`Skipping load for unhandled entity type: ${entityData.type}`);\n      }\n    });\n  }\n}","import * as pc from 'playcanvas';\r\nimport { Vec3 } from 'playcanvas'; // Assuming Vec3 might be needed, if not, remove\r\n\r\n/**\r\n * Options for creating the grid.\r\n */\r\nexport interface GridOptions {\r\n  size?: number;\r\n  divisions?: number;\r\n  color?: pc.Color;\r\n  name?: string;\r\n}\r\n\r\n/**\r\n * Creates a grid entity with lines generated using a Mesh.\r\n * @param app - The PlayCanvas application instance.\r\n * @param options - Optional configuration for the grid.\r\n * @returns The created grid entity.\r\n */\r\nexport function createGridEntity(app: pc.Application, options?: GridOptions): pc.Entity {\r\n  const size = options?.size ?? 10;\r\n  const divisions = options?.divisions ?? 10;\r\n  const color = options?.color ?? new pc.Color(0.6, 0.6, 0.6);\r\n  const name = options?.name ?? 'Grid';\r\n\r\n  const step = size / divisions;\r\n  const halfSize = size / 2;\r\n\r\n  const positions: number[] = [];\r\n  const indices: number[] = [];\r\n  let index = 0;\r\n\r\n  // Generate vertices and indices\r\n  for (let i = -halfSize; i <= halfSize; i += step) {\r\n    positions.push(i, 0, -halfSize);\r\n    positions.push(i, 0, halfSize);\r\n    indices.push(index++, index++);\r\n\r\n    positions.push(-halfSize, 0, i);\r\n    positions.push(halfSize, 0, i);\r\n    indices.push(index++, index++);\r\n  }\r\n\r\n  // Create mesh\r\n  const mesh = new pc.Mesh(app.graphicsDevice);\r\n  mesh.setPositions(positions);\r\n  mesh.setIndices(indices);\r\n  mesh.update(pc.PRIMITIVE_LINES);\r\n\r\n  // Create material\r\n  const material = new pc.BasicMaterial();\r\n  material.color = color;\r\n  material.update();\r\n\r\n  // Find or create entity\r\n  let gridEntity = app.root.findByName(name) as pc.Entity;\r\n  if (!gridEntity) {\r\n    gridEntity = new pc.Entity(name);\r\n    app.root.addChild(gridEntity);\r\n  } else {\r\n    gridEntity.removeComponent('render');\r\n  }\r\n\r\n  // Add render component\r\n  gridEntity.addComponent('render', {\r\n    type: 'asset',\r\n    meshInstances: [new pc.MeshInstance(mesh, material)],\r\n  });\r\n\r\n  console.log(`Grid entity '${name}' created/updated.`);\r\n  return gridEntity;\r\n} ","import * as pc from 'playcanvas';\r\n\r\nexport class OrbitCameraInput {\r\n  private canvas: HTMLCanvasElement;\r\n  private camera: pc.Entity;\r\n  private app: pc.Application; // Needed for Vec3 potentially? Keep if needed, or remove.\r\n\r\n  private isDragging = false;\r\n  private lastX = 0;\r\n  private lastY = 0;\r\n  private cameraDistance = 5;\r\n  private cameraRotX = 0;\r\n  private cameraRotY = 30;\r\n\r\n  // Listener references for removal\r\n  private onMouseDownBound!: (e: MouseEvent) => void;\r\n  private onMouseUpBound!: () => void;\r\n  private onMouseMoveBound!: (e: MouseEvent) => void;\r\n  private onMouseWheelBound!: (e: WheelEvent) => void;\r\n\r\n  constructor(app: pc.Application, canvas: HTMLCanvasElement, camera: pc.Entity) {\r\n    this.app = app; // Store app if needed for utilities like Vec3\r\n    this.canvas = canvas;\r\n    this.camera = camera;\r\n\r\n    this.initialize();\r\n  }\r\n\r\n  private initialize(): void {\r\n    // Define bound listeners\r\n    this.onMouseDownBound = this.onMouseDown.bind(this);\r\n    this.onMouseUpBound = this.onMouseUp.bind(this);\r\n    this.onMouseMoveBound = this.onMouseMove.bind(this);\r\n    this.onMouseWheelBound = this.onMouseWheel.bind(this);\r\n\r\n    // Attach listeners\r\n    this.canvas.addEventListener('mousedown', this.onMouseDownBound);\r\n    window.addEventListener('mouseup', this.onMouseUpBound);\r\n    window.addEventListener('mousemove', this.onMouseMoveBound);\r\n    this.canvas.addEventListener('wheel', this.onMouseWheelBound, { passive: false });\r\n\r\n    // Set initial position\r\n    this.updateCameraPosition();\r\n  }\r\n\r\n  dispose(): void {\r\n    // Remove listeners\r\n    this.canvas.removeEventListener('mousedown', this.onMouseDownBound);\r\n    window.removeEventListener('mouseup', this.onMouseUpBound);\r\n    window.removeEventListener('mousemove', this.onMouseMoveBound);\r\n    this.canvas.removeEventListener('wheel', this.onMouseWheelBound);\r\n  }\r\n\r\n  private updateCameraPosition(): void {\r\n    const rad = Math.PI / 180;\r\n    const x = this.cameraDistance * Math.sin(this.cameraRotX * rad) * Math.cos(this.cameraRotY * rad);\r\n    const y = this.cameraDistance * Math.sin(this.cameraRotY * rad);\r\n    const z = this.cameraDistance * Math.cos(this.cameraRotX * rad) * Math.cos(this.cameraRotY * rad);\r\n\r\n    // Use pc.Vec3 if app reference is kept, or import Vec3 directly\r\n    this.camera.setPosition(x, y, z);\r\n    this.camera.lookAt(pc.Vec3.ZERO); // Use Vec3 directly if imported\r\n  }\r\n\r\n  private onMouseDown(e: MouseEvent): void {\r\n    this.isDragging = true;\r\n    this.lastX = e.clientX;\r\n    this.lastY = e.clientY;\r\n  }\r\n\r\n  private onMouseUp(): void {\r\n    this.isDragging = false;\r\n  }\r\n\r\n  private onMouseMove(e: MouseEvent): void {\r\n    if (this.isDragging) {\r\n      const deltaX = e.clientX - this.lastX;\r\n      const deltaY = e.clientY - this.lastY;\r\n\r\n      this.cameraRotX += deltaX * 0.2;\r\n      this.cameraRotY = Math.max(-90, Math.min(90, this.cameraRotY + deltaY * 0.2));\r\n\r\n      this.updateCameraPosition();\r\n\r\n      this.lastX = e.clientX;\r\n      this.lastY = e.clientY;\r\n    }\r\n  }\r\n\r\n  private onMouseWheel(e: WheelEvent): void {\r\n    this.cameraDistance = Math.max(1, this.cameraDistance + e.deltaY * 0.01);\r\n    this.updateCameraPosition();\r\n    e.preventDefault(); // Prevent page scroll\r\n  }\r\n} ","import { Editor } from './editor/Editor';\n\n// Wait for DOM to be ready\ndocument.addEventListener('DOMContentLoaded', () => {\n  // Create the editor instance\n  const editor = new Editor();\n  \n  // Store editor instance in window for debugging\n  (window as any).editor = editor;\n});","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\tif (cachedModule.error !== undefined) throw cachedModule.error;\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\ttry {\n\t\tvar execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };\n\t\t__webpack_require__.i.forEach(function(handler) { handler(execOptions); });\n\t\tmodule = execOptions.module;\n\t\texecOptions.factory.call(module.exports, module, module.exports, execOptions.require);\n\t} catch(e) {\n\t\tmodule.error = e;\n\t\tthrow e;\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// expose the module cache\n__webpack_require__.c = __webpack_module_cache__;\n\n// expose the module execution interceptor\n__webpack_require__.i = [];\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","// This function allow to reference all chunks\n__webpack_require__.hu = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".\" + __webpack_require__.h() + \".hot-update.js\";\n};","__webpack_require__.hmrF = () => (\"main.\" + __webpack_require__.h() + \".hot-update.json\");","__webpack_require__.h = () => (\"94efbe61f1b3c95fe921\")","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var inProgress = {};\nvar dataWebpackPrefix = \"BuilderBee:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t}\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var currentModuleData = {};\nvar installedModules = __webpack_require__.c;\n\n// module and require creation\nvar currentChildModule;\nvar currentParents = [];\n\n// status\nvar registeredStatusHandlers = [];\nvar currentStatus = \"idle\";\n\n// while downloading\nvar blockingPromises = 0;\nvar blockingPromisesWaiting = [];\n\n// The update info\nvar currentUpdateApplyHandlers;\nvar queuedInvalidatedModules;\n\n__webpack_require__.hmrD = currentModuleData;\n\n__webpack_require__.i.push(function (options) {\n\tvar module = options.module;\n\tvar require = createRequire(options.require, options.id);\n\tmodule.hot = createModuleHotObject(options.id, module);\n\tmodule.parents = currentParents;\n\tmodule.children = [];\n\tcurrentParents = [];\n\toptions.require = require;\n});\n\n__webpack_require__.hmrC = {};\n__webpack_require__.hmrI = {};\n\nfunction createRequire(require, moduleId) {\n\tvar me = installedModules[moduleId];\n\tif (!me) return require;\n\tvar fn = function (request) {\n\t\tif (me.hot.active) {\n\t\t\tif (installedModules[request]) {\n\t\t\t\tvar parents = installedModules[request].parents;\n\t\t\t\tif (parents.indexOf(moduleId) === -1) {\n\t\t\t\t\tparents.push(moduleId);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcurrentParents = [moduleId];\n\t\t\t\tcurrentChildModule = request;\n\t\t\t}\n\t\t\tif (me.children.indexOf(request) === -1) {\n\t\t\t\tme.children.push(request);\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.warn(\n\t\t\t\t\"[HMR] unexpected require(\" +\n\t\t\t\t\trequest +\n\t\t\t\t\t\") from disposed module \" +\n\t\t\t\t\tmoduleId\n\t\t\t);\n\t\t\tcurrentParents = [];\n\t\t}\n\t\treturn require(request);\n\t};\n\tvar createPropertyDescriptor = function (name) {\n\t\treturn {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn require[name];\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\trequire[name] = value;\n\t\t\t}\n\t\t};\n\t};\n\tfor (var name in require) {\n\t\tif (Object.prototype.hasOwnProperty.call(require, name) && name !== \"e\") {\n\t\t\tObject.defineProperty(fn, name, createPropertyDescriptor(name));\n\t\t}\n\t}\n\tfn.e = function (chunkId, fetchPriority) {\n\t\treturn trackBlockingPromise(require.e(chunkId, fetchPriority));\n\t};\n\treturn fn;\n}\n\nfunction createModuleHotObject(moduleId, me) {\n\tvar _main = currentChildModule !== moduleId;\n\tvar hot = {\n\t\t// private stuff\n\t\t_acceptedDependencies: {},\n\t\t_acceptedErrorHandlers: {},\n\t\t_declinedDependencies: {},\n\t\t_selfAccepted: false,\n\t\t_selfDeclined: false,\n\t\t_selfInvalidated: false,\n\t\t_disposeHandlers: [],\n\t\t_main: _main,\n\t\t_requireSelf: function () {\n\t\t\tcurrentParents = me.parents.slice();\n\t\t\tcurrentChildModule = _main ? undefined : moduleId;\n\t\t\t__webpack_require__(moduleId);\n\t\t},\n\n\t\t// Module API\n\t\tactive: true,\n\t\taccept: function (dep, callback, errorHandler) {\n\t\t\tif (dep === undefined) hot._selfAccepted = true;\n\t\t\telse if (typeof dep === \"function\") hot._selfAccepted = dep;\n\t\t\telse if (typeof dep === \"object\" && dep !== null) {\n\t\t\t\tfor (var i = 0; i < dep.length; i++) {\n\t\t\t\t\thot._acceptedDependencies[dep[i]] = callback || function () {};\n\t\t\t\t\thot._acceptedErrorHandlers[dep[i]] = errorHandler;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thot._acceptedDependencies[dep] = callback || function () {};\n\t\t\t\thot._acceptedErrorHandlers[dep] = errorHandler;\n\t\t\t}\n\t\t},\n\t\tdecline: function (dep) {\n\t\t\tif (dep === undefined) hot._selfDeclined = true;\n\t\t\telse if (typeof dep === \"object\" && dep !== null)\n\t\t\t\tfor (var i = 0; i < dep.length; i++)\n\t\t\t\t\thot._declinedDependencies[dep[i]] = true;\n\t\t\telse hot._declinedDependencies[dep] = true;\n\t\t},\n\t\tdispose: function (callback) {\n\t\t\thot._disposeHandlers.push(callback);\n\t\t},\n\t\taddDisposeHandler: function (callback) {\n\t\t\thot._disposeHandlers.push(callback);\n\t\t},\n\t\tremoveDisposeHandler: function (callback) {\n\t\t\tvar idx = hot._disposeHandlers.indexOf(callback);\n\t\t\tif (idx >= 0) hot._disposeHandlers.splice(idx, 1);\n\t\t},\n\t\tinvalidate: function () {\n\t\t\tthis._selfInvalidated = true;\n\t\t\tswitch (currentStatus) {\n\t\t\t\tcase \"idle\":\n\t\t\t\t\tcurrentUpdateApplyHandlers = [];\n\t\t\t\t\tObject.keys(__webpack_require__.hmrI).forEach(function (key) {\n\t\t\t\t\t\t__webpack_require__.hmrI[key](\n\t\t\t\t\t\t\tmoduleId,\n\t\t\t\t\t\t\tcurrentUpdateApplyHandlers\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\tsetStatus(\"ready\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ready\":\n\t\t\t\t\tObject.keys(__webpack_require__.hmrI).forEach(function (key) {\n\t\t\t\t\t\t__webpack_require__.hmrI[key](\n\t\t\t\t\t\t\tmoduleId,\n\t\t\t\t\t\t\tcurrentUpdateApplyHandlers\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"prepare\":\n\t\t\t\tcase \"check\":\n\t\t\t\tcase \"dispose\":\n\t\t\t\tcase \"apply\":\n\t\t\t\t\t(queuedInvalidatedModules = queuedInvalidatedModules || []).push(\n\t\t\t\t\t\tmoduleId\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// ignore requests in error states\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t},\n\n\t\t// Management API\n\t\tcheck: hotCheck,\n\t\tapply: hotApply,\n\t\tstatus: function (l) {\n\t\t\tif (!l) return currentStatus;\n\t\t\tregisteredStatusHandlers.push(l);\n\t\t},\n\t\taddStatusHandler: function (l) {\n\t\t\tregisteredStatusHandlers.push(l);\n\t\t},\n\t\tremoveStatusHandler: function (l) {\n\t\t\tvar idx = registeredStatusHandlers.indexOf(l);\n\t\t\tif (idx >= 0) registeredStatusHandlers.splice(idx, 1);\n\t\t},\n\n\t\t// inherit from previous dispose call\n\t\tdata: currentModuleData[moduleId]\n\t};\n\tcurrentChildModule = undefined;\n\treturn hot;\n}\n\nfunction setStatus(newStatus) {\n\tcurrentStatus = newStatus;\n\tvar results = [];\n\n\tfor (var i = 0; i < registeredStatusHandlers.length; i++)\n\t\tresults[i] = registeredStatusHandlers[i].call(null, newStatus);\n\n\treturn Promise.all(results).then(function () {});\n}\n\nfunction unblock() {\n\tif (--blockingPromises === 0) {\n\t\tsetStatus(\"ready\").then(function () {\n\t\t\tif (blockingPromises === 0) {\n\t\t\t\tvar list = blockingPromisesWaiting;\n\t\t\t\tblockingPromisesWaiting = [];\n\t\t\t\tfor (var i = 0; i < list.length; i++) {\n\t\t\t\t\tlist[i]();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n}\n\nfunction trackBlockingPromise(promise) {\n\tswitch (currentStatus) {\n\t\tcase \"ready\":\n\t\t\tsetStatus(\"prepare\");\n\t\t/* fallthrough */\n\t\tcase \"prepare\":\n\t\t\tblockingPromises++;\n\t\t\tpromise.then(unblock, unblock);\n\t\t\treturn promise;\n\t\tdefault:\n\t\t\treturn promise;\n\t}\n}\n\nfunction waitForBlockingPromises(fn) {\n\tif (blockingPromises === 0) return fn();\n\treturn new Promise(function (resolve) {\n\t\tblockingPromisesWaiting.push(function () {\n\t\t\tresolve(fn());\n\t\t});\n\t});\n}\n\nfunction hotCheck(applyOnUpdate) {\n\tif (currentStatus !== \"idle\") {\n\t\tthrow new Error(\"check() is only allowed in idle status\");\n\t}\n\treturn setStatus(\"check\")\n\t\t.then(__webpack_require__.hmrM)\n\t\t.then(function (update) {\n\t\t\tif (!update) {\n\t\t\t\treturn setStatus(applyInvalidatedModules() ? \"ready\" : \"idle\").then(\n\t\t\t\t\tfunction () {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn setStatus(\"prepare\").then(function () {\n\t\t\t\tvar updatedModules = [];\n\t\t\t\tcurrentUpdateApplyHandlers = [];\n\n\t\t\t\treturn Promise.all(\n\t\t\t\t\tObject.keys(__webpack_require__.hmrC).reduce(function (\n\t\t\t\t\t\tpromises,\n\t\t\t\t\t\tkey\n\t\t\t\t\t) {\n\t\t\t\t\t\t__webpack_require__.hmrC[key](\n\t\t\t\t\t\t\tupdate.c,\n\t\t\t\t\t\t\tupdate.r,\n\t\t\t\t\t\t\tupdate.m,\n\t\t\t\t\t\t\tpromises,\n\t\t\t\t\t\t\tcurrentUpdateApplyHandlers,\n\t\t\t\t\t\t\tupdatedModules\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn promises;\n\t\t\t\t\t}, [])\n\t\t\t\t).then(function () {\n\t\t\t\t\treturn waitForBlockingPromises(function () {\n\t\t\t\t\t\tif (applyOnUpdate) {\n\t\t\t\t\t\t\treturn internalApply(applyOnUpdate);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn setStatus(\"ready\").then(function () {\n\t\t\t\t\t\t\treturn updatedModules;\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n}\n\nfunction hotApply(options) {\n\tif (currentStatus !== \"ready\") {\n\t\treturn Promise.resolve().then(function () {\n\t\t\tthrow new Error(\n\t\t\t\t\"apply() is only allowed in ready status (state: \" +\n\t\t\t\t\tcurrentStatus +\n\t\t\t\t\t\")\"\n\t\t\t);\n\t\t});\n\t}\n\treturn internalApply(options);\n}\n\nfunction internalApply(options) {\n\toptions = options || {};\n\n\tapplyInvalidatedModules();\n\n\tvar results = currentUpdateApplyHandlers.map(function (handler) {\n\t\treturn handler(options);\n\t});\n\tcurrentUpdateApplyHandlers = undefined;\n\n\tvar errors = results\n\t\t.map(function (r) {\n\t\t\treturn r.error;\n\t\t})\n\t\t.filter(Boolean);\n\n\tif (errors.length > 0) {\n\t\treturn setStatus(\"abort\").then(function () {\n\t\t\tthrow errors[0];\n\t\t});\n\t}\n\n\t// Now in \"dispose\" phase\n\tvar disposePromise = setStatus(\"dispose\");\n\n\tresults.forEach(function (result) {\n\t\tif (result.dispose) result.dispose();\n\t});\n\n\t// Now in \"apply\" phase\n\tvar applyPromise = setStatus(\"apply\");\n\n\tvar error;\n\tvar reportError = function (err) {\n\t\tif (!error) error = err;\n\t};\n\n\tvar outdatedModules = [];\n\tresults.forEach(function (result) {\n\t\tif (result.apply) {\n\t\t\tvar modules = result.apply(reportError);\n\t\t\tif (modules) {\n\t\t\t\tfor (var i = 0; i < modules.length; i++) {\n\t\t\t\t\toutdatedModules.push(modules[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\treturn Promise.all([disposePromise, applyPromise]).then(function () {\n\t\t// handle errors in accept handlers and self accepted module load\n\t\tif (error) {\n\t\t\treturn setStatus(\"fail\").then(function () {\n\t\t\t\tthrow error;\n\t\t\t});\n\t\t}\n\n\t\tif (queuedInvalidatedModules) {\n\t\t\treturn internalApply(options).then(function (list) {\n\t\t\t\toutdatedModules.forEach(function (moduleId) {\n\t\t\t\t\tif (list.indexOf(moduleId) < 0) list.push(moduleId);\n\t\t\t\t});\n\t\t\t\treturn list;\n\t\t\t});\n\t\t}\n\n\t\treturn setStatus(\"idle\").then(function () {\n\t\t\treturn outdatedModules;\n\t\t});\n\t});\n}\n\nfunction applyInvalidatedModules() {\n\tif (queuedInvalidatedModules) {\n\t\tif (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];\n\t\tObject.keys(__webpack_require__.hmrI).forEach(function (key) {\n\t\t\tqueuedInvalidatedModules.forEach(function (moduleId) {\n\t\t\t\t__webpack_require__.hmrI[key](\n\t\t\t\t\tmoduleId,\n\t\t\t\t\tcurrentUpdateApplyHandlers\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\t\tqueuedInvalidatedModules = undefined;\n\t\treturn true;\n\t}\n}","__webpack_require__.p = \"/\";","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = __webpack_require__.hmrS_jsonp = __webpack_require__.hmrS_jsonp || {\n\t\"main\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\nvar currentUpdatedModulesList;\nvar waitingUpdateResolves = {};\nfunction loadUpdateChunk(chunkId, updatedModulesList) {\n\tcurrentUpdatedModulesList = updatedModulesList;\n\treturn new Promise((resolve, reject) => {\n\t\twaitingUpdateResolves[chunkId] = resolve;\n\t\t// start update chunk loading\n\t\tvar url = __webpack_require__.p + __webpack_require__.hu(chunkId);\n\t\t// create error before stack unwound to get useful stacktrace later\n\t\tvar error = new Error();\n\t\tvar loadingEnded = (event) => {\n\t\t\tif(waitingUpdateResolves[chunkId]) {\n\t\t\t\twaitingUpdateResolves[chunkId] = undefined\n\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\terror.message = 'Loading hot update chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\terror.type = errorType;\n\t\t\t\terror.request = realSrc;\n\t\t\t\treject(error);\n\t\t\t}\n\t\t};\n\t\t__webpack_require__.l(url, loadingEnded);\n\t});\n}\n\nself[\"webpackHotUpdateBuilderBee\"] = (chunkId, moreModules, runtime) => {\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\tcurrentUpdate[moduleId] = moreModules[moduleId];\n\t\t\tif(currentUpdatedModulesList) currentUpdatedModulesList.push(moduleId);\n\t\t}\n\t}\n\tif(runtime) currentUpdateRuntime.push(runtime);\n\tif(waitingUpdateResolves[chunkId]) {\n\t\twaitingUpdateResolves[chunkId]();\n\t\twaitingUpdateResolves[chunkId] = undefined;\n\t}\n};\n\nvar currentUpdateChunks;\nvar currentUpdate;\nvar currentUpdateRemovedChunks;\nvar currentUpdateRuntime;\nfunction applyHandler(options) {\n\tif (__webpack_require__.f) delete __webpack_require__.f.jsonpHmr;\n\tcurrentUpdateChunks = undefined;\n\tfunction getAffectedModuleEffects(updateModuleId) {\n\t\tvar outdatedModules = [updateModuleId];\n\t\tvar outdatedDependencies = {};\n\n\t\tvar queue = outdatedModules.map(function (id) {\n\t\t\treturn {\n\t\t\t\tchain: [id],\n\t\t\t\tid: id\n\t\t\t};\n\t\t});\n\t\twhile (queue.length > 0) {\n\t\t\tvar queueItem = queue.pop();\n\t\t\tvar moduleId = queueItem.id;\n\t\t\tvar chain = queueItem.chain;\n\t\t\tvar module = __webpack_require__.c[moduleId];\n\t\t\tif (\n\t\t\t\t!module ||\n\t\t\t\t(module.hot._selfAccepted && !module.hot._selfInvalidated)\n\t\t\t)\n\t\t\t\tcontinue;\n\t\t\tif (module.hot._selfDeclined) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"self-declined\",\n\t\t\t\t\tchain: chain,\n\t\t\t\t\tmoduleId: moduleId\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (module.hot._main) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"unaccepted\",\n\t\t\t\t\tchain: chain,\n\t\t\t\t\tmoduleId: moduleId\n\t\t\t\t};\n\t\t\t}\n\t\t\tfor (var i = 0; i < module.parents.length; i++) {\n\t\t\t\tvar parentId = module.parents[i];\n\t\t\t\tvar parent = __webpack_require__.c[parentId];\n\t\t\t\tif (!parent) continue;\n\t\t\t\tif (parent.hot._declinedDependencies[moduleId]) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"declined\",\n\t\t\t\t\t\tchain: chain.concat([parentId]),\n\t\t\t\t\t\tmoduleId: moduleId,\n\t\t\t\t\t\tparentId: parentId\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (outdatedModules.indexOf(parentId) !== -1) continue;\n\t\t\t\tif (parent.hot._acceptedDependencies[moduleId]) {\n\t\t\t\t\tif (!outdatedDependencies[parentId])\n\t\t\t\t\t\toutdatedDependencies[parentId] = [];\n\t\t\t\t\taddAllToSet(outdatedDependencies[parentId], [moduleId]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdelete outdatedDependencies[parentId];\n\t\t\t\toutdatedModules.push(parentId);\n\t\t\t\tqueue.push({\n\t\t\t\t\tchain: chain.concat([parentId]),\n\t\t\t\t\tid: parentId\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttype: \"accepted\",\n\t\t\tmoduleId: updateModuleId,\n\t\t\toutdatedModules: outdatedModules,\n\t\t\toutdatedDependencies: outdatedDependencies\n\t\t};\n\t}\n\n\tfunction addAllToSet(a, b) {\n\t\tfor (var i = 0; i < b.length; i++) {\n\t\t\tvar item = b[i];\n\t\t\tif (a.indexOf(item) === -1) a.push(item);\n\t\t}\n\t}\n\n\t// at begin all updates modules are outdated\n\t// the \"outdated\" status can propagate to parents if they don't accept the children\n\tvar outdatedDependencies = {};\n\tvar outdatedModules = [];\n\tvar appliedUpdate = {};\n\n\tvar warnUnexpectedRequire = function warnUnexpectedRequire(module) {\n\t\tconsole.warn(\n\t\t\t\"[HMR] unexpected require(\" + module.id + \") to disposed module\"\n\t\t);\n\t};\n\n\tfor (var moduleId in currentUpdate) {\n\t\tif (__webpack_require__.o(currentUpdate, moduleId)) {\n\t\t\tvar newModuleFactory = currentUpdate[moduleId];\n\t\t\t/** @type {TODO} */\n\t\t\tvar result = newModuleFactory\n\t\t\t\t? getAffectedModuleEffects(moduleId)\n\t\t\t\t: {\n\t\t\t\t\t\ttype: \"disposed\",\n\t\t\t\t\t\tmoduleId: moduleId\n\t\t\t\t\t};\n\t\t\t/** @type {Error|false} */\n\t\t\tvar abortError = false;\n\t\t\tvar doApply = false;\n\t\t\tvar doDispose = false;\n\t\t\tvar chainInfo = \"\";\n\t\t\tif (result.chain) {\n\t\t\t\tchainInfo = \"\\nUpdate propagation: \" + result.chain.join(\" -> \");\n\t\t\t}\n\t\t\tswitch (result.type) {\n\t\t\t\tcase \"self-declined\":\n\t\t\t\t\tif (options.onDeclined) options.onDeclined(result);\n\t\t\t\t\tif (!options.ignoreDeclined)\n\t\t\t\t\t\tabortError = new Error(\n\t\t\t\t\t\t\t\"Aborted because of self decline: \" +\n\t\t\t\t\t\t\t\tresult.moduleId +\n\t\t\t\t\t\t\t\tchainInfo\n\t\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"declined\":\n\t\t\t\t\tif (options.onDeclined) options.onDeclined(result);\n\t\t\t\t\tif (!options.ignoreDeclined)\n\t\t\t\t\t\tabortError = new Error(\n\t\t\t\t\t\t\t\"Aborted because of declined dependency: \" +\n\t\t\t\t\t\t\t\tresult.moduleId +\n\t\t\t\t\t\t\t\t\" in \" +\n\t\t\t\t\t\t\t\tresult.parentId +\n\t\t\t\t\t\t\t\tchainInfo\n\t\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"unaccepted\":\n\t\t\t\t\tif (options.onUnaccepted) options.onUnaccepted(result);\n\t\t\t\t\tif (!options.ignoreUnaccepted)\n\t\t\t\t\t\tabortError = new Error(\n\t\t\t\t\t\t\t\"Aborted because \" + moduleId + \" is not accepted\" + chainInfo\n\t\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"accepted\":\n\t\t\t\t\tif (options.onAccepted) options.onAccepted(result);\n\t\t\t\t\tdoApply = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"disposed\":\n\t\t\t\t\tif (options.onDisposed) options.onDisposed(result);\n\t\t\t\t\tdoDispose = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"Unexception type \" + result.type);\n\t\t\t}\n\t\t\tif (abortError) {\n\t\t\t\treturn {\n\t\t\t\t\terror: abortError\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (doApply) {\n\t\t\t\tappliedUpdate[moduleId] = newModuleFactory;\n\t\t\t\taddAllToSet(outdatedModules, result.outdatedModules);\n\t\t\t\tfor (moduleId in result.outdatedDependencies) {\n\t\t\t\t\tif (__webpack_require__.o(result.outdatedDependencies, moduleId)) {\n\t\t\t\t\t\tif (!outdatedDependencies[moduleId])\n\t\t\t\t\t\t\toutdatedDependencies[moduleId] = [];\n\t\t\t\t\t\taddAllToSet(\n\t\t\t\t\t\t\toutdatedDependencies[moduleId],\n\t\t\t\t\t\t\tresult.outdatedDependencies[moduleId]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (doDispose) {\n\t\t\t\taddAllToSet(outdatedModules, [result.moduleId]);\n\t\t\t\tappliedUpdate[moduleId] = warnUnexpectedRequire;\n\t\t\t}\n\t\t}\n\t}\n\tcurrentUpdate = undefined;\n\n\t// Store self accepted outdated modules to require them later by the module system\n\tvar outdatedSelfAcceptedModules = [];\n\tfor (var j = 0; j < outdatedModules.length; j++) {\n\t\tvar outdatedModuleId = outdatedModules[j];\n\t\tvar module = __webpack_require__.c[outdatedModuleId];\n\t\tif (\n\t\t\tmodule &&\n\t\t\t(module.hot._selfAccepted || module.hot._main) &&\n\t\t\t// removed self-accepted modules should not be required\n\t\t\tappliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&\n\t\t\t// when called invalidate self-accepting is not possible\n\t\t\t!module.hot._selfInvalidated\n\t\t) {\n\t\t\toutdatedSelfAcceptedModules.push({\n\t\t\t\tmodule: outdatedModuleId,\n\t\t\t\trequire: module.hot._requireSelf,\n\t\t\t\terrorHandler: module.hot._selfAccepted\n\t\t\t});\n\t\t}\n\t}\n\n\tvar moduleOutdatedDependencies;\n\n\treturn {\n\t\tdispose: function () {\n\t\t\tcurrentUpdateRemovedChunks.forEach(function (chunkId) {\n\t\t\t\tdelete installedChunks[chunkId];\n\t\t\t});\n\t\t\tcurrentUpdateRemovedChunks = undefined;\n\n\t\t\tvar idx;\n\t\t\tvar queue = outdatedModules.slice();\n\t\t\twhile (queue.length > 0) {\n\t\t\t\tvar moduleId = queue.pop();\n\t\t\t\tvar module = __webpack_require__.c[moduleId];\n\t\t\t\tif (!module) continue;\n\n\t\t\t\tvar data = {};\n\n\t\t\t\t// Call dispose handlers\n\t\t\t\tvar disposeHandlers = module.hot._disposeHandlers;\n\t\t\t\tfor (j = 0; j < disposeHandlers.length; j++) {\n\t\t\t\t\tdisposeHandlers[j].call(null, data);\n\t\t\t\t}\n\t\t\t\t__webpack_require__.hmrD[moduleId] = data;\n\n\t\t\t\t// disable module (this disables requires from this module)\n\t\t\t\tmodule.hot.active = false;\n\n\t\t\t\t// remove module from cache\n\t\t\t\tdelete __webpack_require__.c[moduleId];\n\n\t\t\t\t// when disposing there is no need to call dispose handler\n\t\t\t\tdelete outdatedDependencies[moduleId];\n\n\t\t\t\t// remove \"parents\" references from all children\n\t\t\t\tfor (j = 0; j < module.children.length; j++) {\n\t\t\t\t\tvar child = __webpack_require__.c[module.children[j]];\n\t\t\t\t\tif (!child) continue;\n\t\t\t\t\tidx = child.parents.indexOf(moduleId);\n\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\tchild.parents.splice(idx, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// remove outdated dependency from module children\n\t\t\tvar dependency;\n\t\t\tfor (var outdatedModuleId in outdatedDependencies) {\n\t\t\t\tif (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {\n\t\t\t\t\tmodule = __webpack_require__.c[outdatedModuleId];\n\t\t\t\t\tif (module) {\n\t\t\t\t\t\tmoduleOutdatedDependencies =\n\t\t\t\t\t\t\toutdatedDependencies[outdatedModuleId];\n\t\t\t\t\t\tfor (j = 0; j < moduleOutdatedDependencies.length; j++) {\n\t\t\t\t\t\t\tdependency = moduleOutdatedDependencies[j];\n\t\t\t\t\t\t\tidx = module.children.indexOf(dependency);\n\t\t\t\t\t\t\tif (idx >= 0) module.children.splice(idx, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tapply: function (reportError) {\n\t\t\t// insert new code\n\t\t\tfor (var updateModuleId in appliedUpdate) {\n\t\t\t\tif (__webpack_require__.o(appliedUpdate, updateModuleId)) {\n\t\t\t\t\t__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// run new runtime modules\n\t\t\tfor (var i = 0; i < currentUpdateRuntime.length; i++) {\n\t\t\t\tcurrentUpdateRuntime[i](__webpack_require__);\n\t\t\t}\n\n\t\t\t// call accept handlers\n\t\t\tfor (var outdatedModuleId in outdatedDependencies) {\n\t\t\t\tif (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {\n\t\t\t\t\tvar module = __webpack_require__.c[outdatedModuleId];\n\t\t\t\t\tif (module) {\n\t\t\t\t\t\tmoduleOutdatedDependencies =\n\t\t\t\t\t\t\toutdatedDependencies[outdatedModuleId];\n\t\t\t\t\t\tvar callbacks = [];\n\t\t\t\t\t\tvar errorHandlers = [];\n\t\t\t\t\t\tvar dependenciesForCallbacks = [];\n\t\t\t\t\t\tfor (var j = 0; j < moduleOutdatedDependencies.length; j++) {\n\t\t\t\t\t\t\tvar dependency = moduleOutdatedDependencies[j];\n\t\t\t\t\t\t\tvar acceptCallback =\n\t\t\t\t\t\t\t\tmodule.hot._acceptedDependencies[dependency];\n\t\t\t\t\t\t\tvar errorHandler =\n\t\t\t\t\t\t\t\tmodule.hot._acceptedErrorHandlers[dependency];\n\t\t\t\t\t\t\tif (acceptCallback) {\n\t\t\t\t\t\t\t\tif (callbacks.indexOf(acceptCallback) !== -1) continue;\n\t\t\t\t\t\t\t\tcallbacks.push(acceptCallback);\n\t\t\t\t\t\t\t\terrorHandlers.push(errorHandler);\n\t\t\t\t\t\t\t\tdependenciesForCallbacks.push(dependency);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (var k = 0; k < callbacks.length; k++) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tcallbacks[k].call(null, moduleOutdatedDependencies);\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\tif (typeof errorHandlers[k] === \"function\") {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\terrorHandlers[k](err, {\n\t\t\t\t\t\t\t\t\t\t\tmoduleId: outdatedModuleId,\n\t\t\t\t\t\t\t\t\t\t\tdependencyId: dependenciesForCallbacks[k]\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t} catch (err2) {\n\t\t\t\t\t\t\t\t\t\tif (options.onErrored) {\n\t\t\t\t\t\t\t\t\t\t\toptions.onErrored({\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"accept-error-handler-errored\",\n\t\t\t\t\t\t\t\t\t\t\t\tmoduleId: outdatedModuleId,\n\t\t\t\t\t\t\t\t\t\t\t\tdependencyId: dependenciesForCallbacks[k],\n\t\t\t\t\t\t\t\t\t\t\t\terror: err2,\n\t\t\t\t\t\t\t\t\t\t\t\toriginalError: err\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!options.ignoreErrored) {\n\t\t\t\t\t\t\t\t\t\t\treportError(err2);\n\t\t\t\t\t\t\t\t\t\t\treportError(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (options.onErrored) {\n\t\t\t\t\t\t\t\t\t\toptions.onErrored({\n\t\t\t\t\t\t\t\t\t\t\ttype: \"accept-errored\",\n\t\t\t\t\t\t\t\t\t\t\tmoduleId: outdatedModuleId,\n\t\t\t\t\t\t\t\t\t\t\tdependencyId: dependenciesForCallbacks[k],\n\t\t\t\t\t\t\t\t\t\t\terror: err\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!options.ignoreErrored) {\n\t\t\t\t\t\t\t\t\t\treportError(err);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Load self accepted modules\n\t\t\tfor (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {\n\t\t\t\tvar item = outdatedSelfAcceptedModules[o];\n\t\t\t\tvar moduleId = item.module;\n\t\t\t\ttry {\n\t\t\t\t\titem.require(moduleId);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (typeof item.errorHandler === \"function\") {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\titem.errorHandler(err, {\n\t\t\t\t\t\t\t\tmoduleId: moduleId,\n\t\t\t\t\t\t\t\tmodule: __webpack_require__.c[moduleId]\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} catch (err1) {\n\t\t\t\t\t\t\tif (options.onErrored) {\n\t\t\t\t\t\t\t\toptions.onErrored({\n\t\t\t\t\t\t\t\t\ttype: \"self-accept-error-handler-errored\",\n\t\t\t\t\t\t\t\t\tmoduleId: moduleId,\n\t\t\t\t\t\t\t\t\terror: err1,\n\t\t\t\t\t\t\t\t\toriginalError: err\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!options.ignoreErrored) {\n\t\t\t\t\t\t\t\treportError(err1);\n\t\t\t\t\t\t\t\treportError(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (options.onErrored) {\n\t\t\t\t\t\t\toptions.onErrored({\n\t\t\t\t\t\t\t\ttype: \"self-accept-errored\",\n\t\t\t\t\t\t\t\tmoduleId: moduleId,\n\t\t\t\t\t\t\t\terror: err\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!options.ignoreErrored) {\n\t\t\t\t\t\t\treportError(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn outdatedModules;\n\t\t}\n\t};\n}\n__webpack_require__.hmrI.jsonp = function (moduleId, applyHandlers) {\n\tif (!currentUpdate) {\n\t\tcurrentUpdate = {};\n\t\tcurrentUpdateRuntime = [];\n\t\tcurrentUpdateRemovedChunks = [];\n\t\tapplyHandlers.push(applyHandler);\n\t}\n\tif (!__webpack_require__.o(currentUpdate, moduleId)) {\n\t\tcurrentUpdate[moduleId] = __webpack_require__.m[moduleId];\n\t}\n};\n__webpack_require__.hmrC.jsonp = function (\n\tchunkIds,\n\tremovedChunks,\n\tremovedModules,\n\tpromises,\n\tapplyHandlers,\n\tupdatedModulesList\n) {\n\tapplyHandlers.push(applyHandler);\n\tcurrentUpdateChunks = {};\n\tcurrentUpdateRemovedChunks = removedChunks;\n\tcurrentUpdate = removedModules.reduce(function (obj, key) {\n\t\tobj[key] = false;\n\t\treturn obj;\n\t}, {});\n\tcurrentUpdateRuntime = [];\n\tchunkIds.forEach(function (chunkId) {\n\t\tif (\n\t\t\t__webpack_require__.o(installedChunks, chunkId) &&\n\t\t\tinstalledChunks[chunkId] !== undefined\n\t\t) {\n\t\t\tpromises.push(loadUpdateChunk(chunkId, updatedModulesList));\n\t\t\tcurrentUpdateChunks[chunkId] = true;\n\t\t} else {\n\t\t\tcurrentUpdateChunks[chunkId] = false;\n\t\t}\n\t});\n\tif (__webpack_require__.f) {\n\t\t__webpack_require__.f.jsonpHmr = function (chunkId, promises) {\n\t\t\tif (\n\t\t\t\tcurrentUpdateChunks &&\n\t\t\t\t__webpack_require__.o(currentUpdateChunks, chunkId) &&\n\t\t\t\t!currentUpdateChunks[chunkId]\n\t\t\t) {\n\t\t\t\tpromises.push(loadUpdateChunk(chunkId));\n\t\t\t\tcurrentUpdateChunks[chunkId] = true;\n\t\t\t}\n\t\t};\n\t}\n};\n\n__webpack_require__.hmrM = () => {\n\tif (typeof fetch === \"undefined\") throw new Error(\"No browser support: need fetch API\");\n\treturn fetch(__webpack_require__.p + __webpack_require__.hmrF()).then((response) => {\n\t\tif(response.status === 404) return; // no update available\n\t\tif(!response.ok) throw new Error(\"Failed to fetch update manifest \" + response.statusText);\n\t\treturn response.json();\n\t});\n};\n\n// no on chunks loaded\n\n// no jsonp function","","// module cache are used so entry inlining is disabled\n// startup\n// Load entry module and return exports\nvar __webpack_exports__ = __webpack_require__(\"./src/renderer/index.ts\");\n",""],"names":[],"sourceRoot":""}